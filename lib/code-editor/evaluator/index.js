"use client";
"use strict";
(function () {
  var $goVersion = "go1.18";
  Error.stackTraceLimit = Infinity;

  var $NaN = NaN;
  var $global, $module;
  if (typeof window !== "undefined") {
    /* web page */
    $global = window;
  } else if (typeof self !== "undefined") {
    /* web worker */
    $global = self;
  } else if (typeof global !== "undefined") {
    /* Node.js */
    $global = global;
    $global.require = require;
  } else {
    /* others (e.g. Nashorn) */
    $global = this;
  }

  if ($global === undefined || $global.Array === undefined) {
    throw new Error("no global object found");
  }
  if (typeof module !== "undefined") {
    $module = module;
  }

  if (!$global.fs && $global.require) {
    try {
      var fs = $global.require("fs");
      if (
        typeof fs === "object" &&
        fs !== null &&
        Object.keys(fs).length !== 0
      ) {
        $global.fs = fs;
      }
    } catch (e) {
      /* Ignore if the module couldn't be loaded. */
    }
  }

  if (!$global.fs) {
    var outputBuf = "";
    var decoder = new TextDecoder("utf-8");
    $global.fs = {
      constants: {
        O_WRONLY: -1,
        O_RDWR: -1,
        O_CREAT: -1,
        O_TRUNC: -1,
        O_APPEND: -1,
        O_EXCL: -1,
      }, // unused
      writeSync: function writeSync(fd, buf) {
        outputBuf += decoder.decode(buf);
        var nl = outputBuf.lastIndexOf("\n");
        if (nl != -1) {
          console.log(outputBuf.substr(0, nl));
          outputBuf = outputBuf.substr(nl + 1);
        }
        return buf.length;
      },
      write: function write(fd, buf, offset, length, position, callback) {
        if (offset !== 0 || length !== buf.length || position !== null) {
          callback(enosys());
          return;
        }
        var n = this.writeSync(fd, buf);
        callback(null, n);
      },
    };
  }

  var $linknames = {}; // Collection of functions referenced by a go:linkname directive.
  var $packages = {},
    $idCounter = 0;
  var $keys = function (m) {
    return m ? Object.keys(m) : [];
  };
  var $flushConsole = function () {};
  var $throwRuntimeError; /* set by package "runtime" */
  var $throwNilPointerError = function () {
    $throwRuntimeError("invalid memory address or nil pointer dereference");
  };
  var $call = function (fn, rcvr, args) {
    return fn.apply(rcvr, args);
  };
  var $makeFunc = function (fn) {
    return function () {
      return $externalize(
        fn(
          this,
          new ($sliceType($jsObjectPtr))(
            $global.Array.prototype.slice.call(arguments, [])
          )
        ),
        $emptyInterface
      );
    };
  };
  var $unused = function (v) {};
  var $print = console.log;
  // Under Node we can emulate print() more closely by avoiding a newline.
  if ($global.process !== undefined && $global.require) {
    try {
      var util = $global.require("util");
      $print = function () {
        $global.process.stderr.write(util.format.apply(this, arguments));
      };
    } catch (e) {
      // Failed to require util module, keep using console.log().
    }
  }
  var $println = console.log;

  var $initAllLinknames = function () {
    var names = $keys($packages);
    for (var i = 0; i < names.length; i++) {
      var f = $packages[names[i]]["$initLinknames"];
      if (typeof f == "function") {
        f();
      }
    }
  };

  var $mapArray = function (array, f) {
    var newArray = new array.constructor(array.length);
    for (var i = 0; i < array.length; i++) {
      newArray[i] = f(array[i]);
    }
    return newArray;
  };

  // $mapIndex returns the value of the given key in m, or undefined if m is nil/undefined or not a map
  var $mapIndex = function (m, key) {
    return typeof m.get === "function" ? m.get(key) : undefined;
  };
  // $mapDelete deletes the key and associated value from m.  If m is nil/undefined or not a map, $mapDelete is a no-op
  var $mapDelete = function (m, key) {
    typeof m.delete === "function" && m.delete(key);
  };
  // Returns a method bound to the receiver instance, safe to invoke as a
  // standalone function. Bound function is cached for later reuse.
  var $methodVal = function (recv, name) {
    var vals = recv.$methodVals || {};
    recv.$methodVals = vals; /* noop for primitives */
    var f = vals[name];
    if (f !== undefined) {
      return f;
    }
    var method = recv[name];
    f = method.bind(recv);
    vals[name] = f;
    return f;
  };

  var $methodExpr = function (typ, name) {
    var method = typ.prototype[name];
    if (method.$expr === undefined) {
      method.$expr = function () {
        $stackDepthOffset--;
        try {
          if (typ.wrapped) {
            arguments[0] = new typ(arguments[0]);
          }
          return Function.call.apply(method, arguments);
        } finally {
          $stackDepthOffset++;
        }
      };
    }
    return method.$expr;
  };

  var $ifaceMethodExprs = {};
  var $ifaceMethodExpr = function (name) {
    var expr = $ifaceMethodExprs["$" + name];
    if (expr === undefined) {
      expr = $ifaceMethodExprs["$" + name] = function () {
        $stackDepthOffset--;
        try {
          return Function.call.apply(arguments[0][name], arguments);
        } finally {
          $stackDepthOffset++;
        }
      };
    }
    return expr;
  };

  var $subslice = function (slice, low, high, max) {
    if (high === undefined) {
      high = slice.$length;
    }
    if (max === undefined) {
      max = slice.$capacity;
    }
    if (
      low < 0 ||
      high < low ||
      max < high ||
      high > slice.$capacity ||
      max > slice.$capacity
    ) {
      $throwRuntimeError("slice bounds out of range");
    }
    if (slice === slice.constructor.nil) {
      return slice;
    }
    var s = new slice.constructor(slice.$array);
    s.$offset = slice.$offset + low;
    s.$length = high - low;
    s.$capacity = max - low;
    return s;
  };

  var $substring = function (str, low, high) {
    if (low < 0 || high < low || high > str.length) {
      $throwRuntimeError("slice bounds out of range");
    }
    return str.substring(low, high);
  };

  // Convert Go slice to an equivalent JS array type.
  var $sliceToNativeArray = function (slice) {
    if (slice.$array.constructor !== Array) {
      return slice.$array.subarray(
        slice.$offset,
        slice.$offset + slice.$length
      );
    }
    return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
  };

  // Convert Go slice to a pointer to an underlying Go array.
  //
  // Note that an array pointer can be represented by an "unwrapped" native array
  // type, and it will be wrapped back into its Go type when necessary.
  var $sliceToGoArray = function (slice, arrayPtrType) {
    var arrayType = arrayPtrType.elem;
    if (arrayType !== undefined && slice.$length < arrayType.len) {
      $throwRuntimeError(
        "cannot convert slice with length " +
          slice.$length +
          " to pointer to array with length " +
          arrayType.len
      );
    }
    if (slice == slice.constructor.nil) {
      return arrayPtrType.nil; // Nil slice converts to nil array pointer.
    }
    if (slice.$array.constructor !== Array) {
      return slice.$array.subarray(
        slice.$offset,
        slice.$offset + arrayType.len
      );
    }
    if (
      slice.$offset == 0 &&
      slice.$length == slice.$capacity &&
      slice.$length == arrayType.len
    ) {
      return slice.$array;
    }
    if (arrayType.len == 0) {
      return new arrayType([]);
    }

    // Array.slice (unlike TypedArray.subarray) returns a copy of an array range,
    // which is not sharing memory with the original one, which violates the spec
    // for slice to array conversion. This is incompatible with the Go spec, in
    // particular that the assignments to the array elements would be visible in
    // the slice. Prefer to fail explicitly instead of creating subtle bugs.
    $throwRuntimeError(
      "gopherjs: non-numeric slice to underlying array conversion is not supported for subslices"
    );
  };

  // Convert between compatible slice types (e.g. native and names).
  var $convertSliceType = function (slice, desiredType) {
    if (slice == slice.constructor.nil) {
      return desiredType.nil; // Preserve nil value.
    }

    return $subslice(
      new desiredType(slice.$array),
      slice.$offset,
      slice.$offset + slice.$length
    );
  };

  var $decodeRune = function (str, pos) {
    var c0 = str.charCodeAt(pos);

    if (c0 < 0x80) {
      return [c0, 1];
    }

    if (c0 !== c0 || c0 < 0xc0) {
      return [0xfffd, 1];
    }

    var c1 = str.charCodeAt(pos + 1);
    if (c1 !== c1 || c1 < 0x80 || 0xc0 <= c1) {
      return [0xfffd, 1];
    }

    if (c0 < 0xe0) {
      var r = ((c0 & 0x1f) << 6) | (c1 & 0x3f);
      if (r <= 0x7f) {
        return [0xfffd, 1];
      }
      return [r, 2];
    }

    var c2 = str.charCodeAt(pos + 2);
    if (c2 !== c2 || c2 < 0x80 || 0xc0 <= c2) {
      return [0xfffd, 1];
    }

    if (c0 < 0xf0) {
      var r = ((c0 & 0x0f) << 12) | ((c1 & 0x3f) << 6) | (c2 & 0x3f);
      if (r <= 0x7ff) {
        return [0xfffd, 1];
      }
      if (0xd800 <= r && r <= 0xdfff) {
        return [0xfffd, 1];
      }
      return [r, 3];
    }

    var c3 = str.charCodeAt(pos + 3);
    if (c3 !== c3 || c3 < 0x80 || 0xc0 <= c3) {
      return [0xfffd, 1];
    }

    if (c0 < 0xf8) {
      var r =
        ((c0 & 0x07) << 18) |
        ((c1 & 0x3f) << 12) |
        ((c2 & 0x3f) << 6) |
        (c3 & 0x3f);
      if (r <= 0xffff || 0x10ffff < r) {
        return [0xfffd, 1];
      }
      return [r, 4];
    }

    return [0xfffd, 1];
  };

  var $encodeRune = function (r) {
    if (r < 0 || r > 0x10ffff || (0xd800 <= r && r <= 0xdfff)) {
      r = 0xfffd;
    }
    if (r <= 0x7f) {
      return String.fromCharCode(r);
    }
    if (r <= 0x7ff) {
      return String.fromCharCode(0xc0 | (r >> 6), 0x80 | (r & 0x3f));
    }
    if (r <= 0xffff) {
      return String.fromCharCode(
        0xe0 | (r >> 12),
        0x80 | ((r >> 6) & 0x3f),
        0x80 | (r & 0x3f)
      );
    }
    return String.fromCharCode(
      0xf0 | (r >> 18),
      0x80 | ((r >> 12) & 0x3f),
      0x80 | ((r >> 6) & 0x3f),
      0x80 | (r & 0x3f)
    );
  };

  var $stringToBytes = function (str) {
    var array = new Uint8Array(str.length);
    for (var i = 0; i < str.length; i++) {
      array[i] = str.charCodeAt(i);
    }
    return array;
  };

  var $bytesToString = function (slice) {
    if (slice.$length === 0) {
      return "";
    }
    var str = "";
    for (var i = 0; i < slice.$length; i += 10000) {
      str += String.fromCharCode.apply(
        undefined,
        slice.$array.subarray(
          slice.$offset + i,
          slice.$offset + Math.min(slice.$length, i + 10000)
        )
      );
    }
    return str;
  };

  var $stringToRunes = function (str) {
    var array = new Int32Array(str.length);
    var rune,
      j = 0;
    for (var i = 0; i < str.length; i += rune[1], j++) {
      rune = $decodeRune(str, i);
      array[j] = rune[0];
    }
    return array.subarray(0, j);
  };

  var $runesToString = function (slice) {
    if (slice.$length === 0) {
      return "";
    }
    var str = "";
    for (var i = 0; i < slice.$length; i++) {
      str += $encodeRune(slice.$array[slice.$offset + i]);
    }
    return str;
  };

  var $copyString = function (dst, src) {
    var n = Math.min(src.length, dst.$length);
    for (var i = 0; i < n; i++) {
      dst.$array[dst.$offset + i] = src.charCodeAt(i);
    }
    return n;
  };

  var $copySlice = function (dst, src) {
    var n = Math.min(src.$length, dst.$length);
    $copyArray(
      dst.$array,
      src.$array,
      dst.$offset,
      src.$offset,
      n,
      dst.constructor.elem
    );
    return n;
  };

  var $copyArray = function (dst, src, dstOffset, srcOffset, n, elem) {
    if (n === 0 || (dst === src && dstOffset === srcOffset)) {
      return;
    }

    if (src.subarray) {
      dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);
      return;
    }

    switch (elem.kind) {
      case $kindArray:
      case $kindStruct:
        if (dst === src && dstOffset > srcOffset) {
          for (var i = n - 1; i >= 0; i--) {
            elem.copy(dst[dstOffset + i], src[srcOffset + i]);
          }
          return;
        }
        for (var i = 0; i < n; i++) {
          elem.copy(dst[dstOffset + i], src[srcOffset + i]);
        }
        return;
    }

    if (dst === src && dstOffset > srcOffset) {
      for (var i = n - 1; i >= 0; i--) {
        dst[dstOffset + i] = src[srcOffset + i];
      }
      return;
    }
    for (var i = 0; i < n; i++) {
      dst[dstOffset + i] = src[srcOffset + i];
    }
  };

  var $clone = function (src, type) {
    var clone = type.zero();
    type.copy(clone, src);
    return clone;
  };

  var $pointerOfStructConversion = function (obj, type) {
    if (obj.$proxies === undefined) {
      obj.$proxies = {};
      obj.$proxies[obj.constructor.string] = obj;
    }
    var proxy = obj.$proxies[type.string];
    if (proxy === undefined) {
      var properties = {};
      for (var i = 0; i < type.elem.fields.length; i++) {
        (function (fieldProp) {
          properties[fieldProp] = {
            get: function () {
              return obj[fieldProp];
            },
            set: function (value) {
              obj[fieldProp] = value;
            },
          };
        })(type.elem.fields[i].prop);
      }
      proxy = Object.create(type.prototype, properties);
      proxy.$val = proxy;
      obj.$proxies[type.string] = proxy;
      proxy.$proxies = obj.$proxies;
    }
    return proxy;
  };

  var $append = function (slice) {
    return $internalAppend(slice, arguments, 1, arguments.length - 1);
  };

  var $appendSlice = function (slice, toAppend) {
    if (toAppend.constructor === String) {
      var bytes = $stringToBytes(toAppend);
      return $internalAppend(slice, bytes, 0, bytes.length);
    }
    return $internalAppend(
      slice,
      toAppend.$array,
      toAppend.$offset,
      toAppend.$length
    );
  };

  var $internalAppend = function (slice, array, offset, length) {
    if (length === 0) {
      return slice;
    }

    var newArray = slice.$array;
    var newOffset = slice.$offset;
    var newLength = slice.$length + length;
    var newCapacity = slice.$capacity;

    if (newLength > newCapacity) {
      newOffset = 0;
      newCapacity = Math.max(
        newLength,
        slice.$capacity < 1024
          ? slice.$capacity * 2
          : Math.floor((slice.$capacity * 5) / 4)
      );

      if (slice.$array.constructor === Array) {
        newArray = slice.$array.slice(
          slice.$offset,
          slice.$offset + slice.$length
        );
        newArray.length = newCapacity;
        var zero = slice.constructor.elem.zero;
        for (var i = slice.$length; i < newCapacity; i++) {
          newArray[i] = zero();
        }
      } else {
        newArray = new slice.$array.constructor(newCapacity);
        newArray.set(
          slice.$array.subarray(slice.$offset, slice.$offset + slice.$length)
        );
      }
    }

    $copyArray(
      newArray,
      array,
      newOffset + slice.$length,
      offset,
      length,
      slice.constructor.elem
    );

    var newSlice = new slice.constructor(newArray);
    newSlice.$offset = newOffset;
    newSlice.$length = newLength;
    newSlice.$capacity = newCapacity;
    return newSlice;
  };

  var $equal = function (a, b, type) {
    if (type === $jsObjectPtr) {
      return a === b;
    }
    switch (type.kind) {
      case $kindComplex64:
      case $kindComplex128:
        return a.$real === b.$real && a.$imag === b.$imag;
      case $kindInt64:
      case $kindUint64:
        return a.$high === b.$high && a.$low === b.$low;
      case $kindArray:
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!$equal(a[i], b[i], type.elem)) {
            return false;
          }
        }
        return true;
      case $kindStruct:
        for (var i = 0; i < type.fields.length; i++) {
          var f = type.fields[i];
          if (!$equal(a[f.prop], b[f.prop], f.typ)) {
            return false;
          }
        }
        return true;
      case $kindInterface:
        return $interfaceIsEqual(a, b);
      default:
        return a === b;
    }
  };

  var $interfaceIsEqual = function (a, b) {
    if (a === $ifaceNil || b === $ifaceNil) {
      return a === b;
    }
    if (a.constructor !== b.constructor) {
      return false;
    }
    if (a.constructor === $jsObjectPtr) {
      return a.object === b.object;
    }
    if (!a.constructor.comparable) {
      $throwRuntimeError("comparing uncomparable type " + a.constructor.string);
    }
    return $equal(a.$val, b.$val, a.constructor);
  };

  var $unsafeMethodToFunction = function (typ, name, isPtr) {
    if (isPtr) {
      return function (r, ...args) {
        var ptrType = $ptrType(typ);
        if (r.constructor != ptrType) {
          switch (typ.kind) {
            case $kindStruct:
              r = $pointerOfStructConversion(r, ptrType);
              break;
            case $kindArray:
              r = new ptrType(r);
              break;
            default:
              r = new ptrType(r.$get, r.$set, r.$target);
          }
        }
        return r[name](...args);
      };
    } else {
      return function (r, ...args) {
        var ptrType = $ptrType(typ);
        if (r.constructor != ptrType) {
          switch (typ.kind) {
            case $kindStruct:
              r = $clone(r, typ);
              break;
            case $kindSlice:
              r = $convertSliceType(r, typ);
              break;
            case $kindComplex64:
            case $kindComplex128:
              r = new typ(r.$real, r.$imag);
              break;
            default:
              r = new typ(r);
          }
        }
        return r[name](...args);
      };
    }
  };

  var $id = function (x) {
    return x;
  };

  var $instanceOf = function (x, y) {
    return x instanceof y;
  };

  var $typeOf = function (x) {
    return typeof x;
  };

  var $min = Math.min;
  var $mod = function (x, y) {
    return x % y;
  };
  var $parseInt = parseInt;
  var $parseFloat = function (f) {
    if (f !== undefined && f !== null && f.constructor === Number) {
      return f;
    }
    return parseFloat(f);
  };

  var $froundBuf = new Float32Array(1);
  var $fround =
    Math.fround ||
    function (f) {
      $froundBuf[0] = f;
      return $froundBuf[0];
    };

  var $imul =
    Math.imul ||
    function (a, b) {
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) >> 0;
    };

  var $floatKey = function (f) {
    if (f !== f) {
      $idCounter++;
      return "NaN$" + $idCounter;
    }
    return String(f);
  };

  var $flatten64 = function (x) {
    return x.$high * 4294967296 + x.$low;
  };

  var $shiftLeft64 = function (x, y) {
    if (y === 0) {
      return x;
    }
    if (y < 32) {
      return new x.constructor(
        (x.$high << y) | (x.$low >>> (32 - y)),
        (x.$low << y) >>> 0
      );
    }
    if (y < 64) {
      return new x.constructor(x.$low << (y - 32), 0);
    }
    return new x.constructor(0, 0);
  };

  var $shiftRightInt64 = function (x, y) {
    if (y === 0) {
      return x;
    }
    if (y < 32) {
      return new x.constructor(
        x.$high >> y,
        ((x.$low >>> y) | (x.$high << (32 - y))) >>> 0
      );
    }
    if (y < 64) {
      return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);
    }
    if (x.$high < 0) {
      return new x.constructor(-1, 4294967295);
    }
    return new x.constructor(0, 0);
  };

  var $shiftRightUint64 = function (x, y) {
    if (y === 0) {
      return x;
    }
    if (y < 32) {
      return new x.constructor(
        x.$high >>> y,
        ((x.$low >>> y) | (x.$high << (32 - y))) >>> 0
      );
    }
    if (y < 64) {
      return new x.constructor(0, x.$high >>> (y - 32));
    }
    return new x.constructor(0, 0);
  };

  var $mul64 = function (x, y) {
    var x48 = x.$high >>> 16;
    var x32 = x.$high & 0xffff;
    var x16 = x.$low >>> 16;
    var x00 = x.$low & 0xffff;

    var y48 = y.$high >>> 16;
    var y32 = y.$high & 0xffff;
    var y16 = y.$low >>> 16;
    var y00 = y.$low & 0xffff;

    var z48 = 0,
      z32 = 0,
      z16 = 0,
      z00 = 0;
    z00 += x00 * y00;
    z16 += z00 >>> 16;
    z00 &= 0xffff;
    z16 += x16 * y00;
    z32 += z16 >>> 16;
    z16 &= 0xffff;
    z16 += x00 * y16;
    z32 += z16 >>> 16;
    z16 &= 0xffff;
    z32 += x32 * y00;
    z48 += z32 >>> 16;
    z32 &= 0xffff;
    z32 += x16 * y16;
    z48 += z32 >>> 16;
    z32 &= 0xffff;
    z32 += x00 * y32;
    z48 += z32 >>> 16;
    z32 &= 0xffff;
    z48 += x48 * y00 + x32 * y16 + x16 * y32 + x00 * y48;
    z48 &= 0xffff;

    var hi = ((z48 << 16) | z32) >>> 0;
    var lo = ((z16 << 16) | z00) >>> 0;

    var r = new x.constructor(hi, lo);
    return r;
  };

  var $div64 = function (x, y, returnRemainder) {
    if (y.$high === 0 && y.$low === 0) {
      $throwRuntimeError("integer divide by zero");
    }

    var s = 1;
    var rs = 1;

    var xHigh = x.$high;
    var xLow = x.$low;
    if (xHigh < 0) {
      s = -1;
      rs = -1;
      xHigh = -xHigh;
      if (xLow !== 0) {
        xHigh--;
        xLow = 4294967296 - xLow;
      }
    }

    var yHigh = y.$high;
    var yLow = y.$low;
    if (y.$high < 0) {
      s *= -1;
      yHigh = -yHigh;
      if (yLow !== 0) {
        yHigh--;
        yLow = 4294967296 - yLow;
      }
    }

    var high = 0,
      low = 0,
      n = 0;
    while (
      yHigh < 2147483648 &&
      (xHigh > yHigh || (xHigh === yHigh && xLow > yLow))
    ) {
      yHigh = ((yHigh << 1) | (yLow >>> 31)) >>> 0;
      yLow = (yLow << 1) >>> 0;
      n++;
    }
    for (var i = 0; i <= n; i++) {
      high = (high << 1) | (low >>> 31);
      low = (low << 1) >>> 0;
      if (xHigh > yHigh || (xHigh === yHigh && xLow >= yLow)) {
        xHigh = xHigh - yHigh;
        xLow = xLow - yLow;
        if (xLow < 0) {
          xHigh--;
          xLow += 4294967296;
        }
        low++;
        if (low === 4294967296) {
          high++;
          low = 0;
        }
      }
      yLow = ((yLow >>> 1) | (yHigh << (32 - 1))) >>> 0;
      yHigh = yHigh >>> 1;
    }

    if (returnRemainder) {
      return new x.constructor(xHigh * rs, xLow * rs);
    }
    return new x.constructor(high * s, low * s);
  };

  var $divComplex = function (n, d) {
    var ninf =
      n.$real === Infinity ||
      n.$real === -Infinity ||
      n.$imag === Infinity ||
      n.$imag === -Infinity;
    var dinf =
      d.$real === Infinity ||
      d.$real === -Infinity ||
      d.$imag === Infinity ||
      d.$imag === -Infinity;
    var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);
    var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);
    if (nnan || dnan) {
      return new n.constructor(NaN, NaN);
    }
    if (ninf && !dinf) {
      return new n.constructor(Infinity, Infinity);
    }
    if (!ninf && dinf) {
      return new n.constructor(0, 0);
    }
    if (d.$real === 0 && d.$imag === 0) {
      if (n.$real === 0 && n.$imag === 0) {
        return new n.constructor(NaN, NaN);
      }
      return new n.constructor(Infinity, Infinity);
    }
    var a = Math.abs(d.$real);
    var b = Math.abs(d.$imag);
    if (a <= b) {
      var ratio = d.$real / d.$imag;
      var denom = d.$real * ratio + d.$imag;
      return new n.constructor(
        (n.$real * ratio + n.$imag) / denom,
        (n.$imag * ratio - n.$real) / denom
      );
    }
    var ratio = d.$imag / d.$real;
    var denom = d.$imag * ratio + d.$real;
    return new n.constructor(
      (n.$imag * ratio + n.$real) / denom,
      (n.$imag - n.$real * ratio) / denom
    );
  };

  var $kindBool = 1;
  var $kindInt = 2;
  var $kindInt8 = 3;
  var $kindInt16 = 4;
  var $kindInt32 = 5;
  var $kindInt64 = 6;
  var $kindUint = 7;
  var $kindUint8 = 8;
  var $kindUint16 = 9;
  var $kindUint32 = 10;
  var $kindUint64 = 11;
  var $kindUintptr = 12;
  var $kindFloat32 = 13;
  var $kindFloat64 = 14;
  var $kindComplex64 = 15;
  var $kindComplex128 = 16;
  var $kindArray = 17;
  var $kindChan = 18;
  var $kindFunc = 19;
  var $kindInterface = 20;
  var $kindMap = 21;
  var $kindPtr = 22;
  var $kindSlice = 23;
  var $kindString = 24;
  var $kindStruct = 25;
  var $kindUnsafePointer = 26;

  var $methodSynthesizers = [];
  var $addMethodSynthesizer = function (f) {
    if ($methodSynthesizers === null) {
      f();
      return;
    }
    $methodSynthesizers.push(f);
  };
  var $synthesizeMethods = function () {
    $methodSynthesizers.forEach(function (f) {
      f();
    });
    $methodSynthesizers = null;
  };

  var $ifaceKeyFor = function (x) {
    if (x === $ifaceNil) {
      return "nil";
    }
    var c = x.constructor;
    return c.string + "$" + c.keyFor(x.$val);
  };

  var $identity = function (x) {
    return x;
  };

  var $typeIDCounter = 0;

  var $idKey = function (x) {
    if (x.$id === undefined) {
      $idCounter++;
      x.$id = $idCounter;
    }
    return String(x.$id);
  };

  // Creates constructor functions for array pointer types. Returns a new function
  // instace each time to make sure each type is independent of the other.
  var $arrayPtrCtor = function () {
    return function (array) {
      this.$get = function () {
        return array;
      };
      this.$set = function (v) {
        typ.copy(this, v);
      };
      this.$val = array;
    };
  };

  var $newType = function (
    size,
    kind,
    string,
    named,
    pkg,
    exported,
    constructor
  ) {
    var typ;
    switch (kind) {
      case $kindBool:
      case $kindInt:
      case $kindInt8:
      case $kindInt16:
      case $kindInt32:
      case $kindUint:
      case $kindUint8:
      case $kindUint16:
      case $kindUint32:
      case $kindUintptr:
      case $kindUnsafePointer:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.keyFor = $identity;
        break;

      case $kindString:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.keyFor = function (x) {
          return "$" + x;
        };
        break;

      case $kindFloat32:
      case $kindFloat64:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.keyFor = function (x) {
          return $floatKey(x);
        };
        break;

      case $kindInt64:
        typ = function (high, low) {
          this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
          this.$low = low >>> 0;
          this.$val = this;
        };
        typ.keyFor = function (x) {
          return x.$high + "$" + x.$low;
        };
        break;

      case $kindUint64:
        typ = function (high, low) {
          this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
          this.$low = low >>> 0;
          this.$val = this;
        };
        typ.keyFor = function (x) {
          return x.$high + "$" + x.$low;
        };
        break;

      case $kindComplex64:
        typ = function (real, imag) {
          this.$real = $fround(real);
          this.$imag = $fround(imag);
          this.$val = this;
        };
        typ.keyFor = function (x) {
          return x.$real + "$" + x.$imag;
        };
        break;

      case $kindComplex128:
        typ = function (real, imag) {
          this.$real = real;
          this.$imag = imag;
          this.$val = this;
        };
        typ.keyFor = function (x) {
          return x.$real + "$" + x.$imag;
        };
        break;

      case $kindArray:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.ptr = $newType(
          4,
          $kindPtr,
          "*" + string,
          false,
          "",
          false,
          $arrayPtrCtor()
        );
        typ.init = function (elem, len) {
          typ.elem = elem;
          typ.len = len;
          typ.comparable = elem.comparable;
          typ.keyFor = function (x) {
            return Array.prototype.join.call(
              $mapArray(x, function (e) {
                return String(elem.keyFor(e))
                  .replace(/\\/g, "\\\\")
                  .replace(/\$/g, "\\$");
              }),
              "$"
            );
          };
          typ.copy = function (dst, src) {
            $copyArray(dst, src, 0, 0, src.length, elem);
          };
          typ.ptr.init(typ);
          Object.defineProperty(typ.ptr.nil, "nilCheck", {
            get: $throwNilPointerError,
          });
        };
        break;

      case $kindChan:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.keyFor = $idKey;
        typ.init = function (elem, sendOnly, recvOnly) {
          typ.elem = elem;
          typ.sendOnly = sendOnly;
          typ.recvOnly = recvOnly;
        };
        break;

      case $kindFunc:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.init = function (params, results, variadic) {
          typ.params = params;
          typ.results = results;
          typ.variadic = variadic;
          typ.comparable = false;
        };
        break;

      case $kindInterface:
        typ = { implementedBy: {}, missingMethodFor: {} };
        typ.keyFor = $ifaceKeyFor;
        typ.init = function (methods) {
          typ.methods = methods;
          methods.forEach(function (m) {
            $ifaceNil[m.prop] = $throwNilPointerError;
          });
        };
        break;

      case $kindMap:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.init = function (key, elem) {
          typ.key = key;
          typ.elem = elem;
          typ.comparable = false;
        };
        break;

      case $kindPtr:
        typ =
          constructor ||
          function (getter, setter, target) {
            this.$get = getter;
            this.$set = setter;
            this.$target = target;
            this.$val = this;
          };
        typ.keyFor = $idKey;
        typ.init = function (elem) {
          typ.elem = elem;
          typ.wrapped = elem.kind === $kindArray;
          typ.nil = new typ($throwNilPointerError, $throwNilPointerError);
        };
        break;

      case $kindSlice:
        typ = function (array) {
          if (array.constructor !== typ.nativeArray) {
            array = new typ.nativeArray(array);
          }
          this.$array = array;
          this.$offset = 0;
          this.$length = array.length;
          this.$capacity = array.length;
          this.$val = this;
        };
        typ.init = function (elem) {
          typ.elem = elem;
          typ.comparable = false;
          typ.nativeArray = $nativeArray(elem.kind);
          typ.nil = new typ([]);
        };
        break;

      case $kindStruct:
        typ = function (v) {
          this.$val = v;
        };
        typ.wrapped = true;
        typ.ptr = $newType(
          4,
          $kindPtr,
          "*" + string,
          false,
          pkg,
          exported,
          constructor
        );
        typ.ptr.elem = typ;
        typ.ptr.prototype.$get = function () {
          return this;
        };
        typ.ptr.prototype.$set = function (v) {
          typ.copy(this, v);
        };
        typ.init = function (pkgPath, fields) {
          typ.pkgPath = pkgPath;
          typ.fields = fields;
          fields.forEach(function (f) {
            if (!f.typ.comparable) {
              typ.comparable = false;
            }
          });
          typ.keyFor = function (x) {
            var val = x.$val;
            return $mapArray(fields, function (f) {
              return String(f.typ.keyFor(val[f.prop]))
                .replace(/\\/g, "\\\\")
                .replace(/\$/g, "\\$");
            }).join("$");
          };
          typ.copy = function (dst, src) {
            for (var i = 0; i < fields.length; i++) {
              var f = fields[i];
              switch (f.typ.kind) {
                case $kindArray:
                case $kindStruct:
                  f.typ.copy(dst[f.prop], src[f.prop]);
                  continue;
                default:
                  dst[f.prop] = src[f.prop];
                  continue;
              }
            }
          };
          /* nil value */
          var properties = {};
          fields.forEach(function (f) {
            properties[f.prop] = {
              get: $throwNilPointerError,
              set: $throwNilPointerError,
            };
          });
          typ.ptr.nil = Object.create(constructor.prototype, properties);
          typ.ptr.nil.$val = typ.ptr.nil;
          /* methods for embedded fields */
          $addMethodSynthesizer(function () {
            var synthesizeMethod = function (target, m, f) {
              if (target.prototype[m.prop] !== undefined) {
                return;
              }
              target.prototype[m.prop] = function () {
                var v = this.$val[f.prop];
                if (f.typ === $jsObjectPtr) {
                  v = new $jsObjectPtr(v);
                }
                if (v.$val === undefined) {
                  v = new f.typ(v);
                }
                return v[m.prop].apply(v, arguments);
              };
            };
            fields.forEach(function (f) {
              if (f.embedded) {
                $methodSet(f.typ).forEach(function (m) {
                  synthesizeMethod(typ, m, f);
                  synthesizeMethod(typ.ptr, m, f);
                });
                $methodSet($ptrType(f.typ)).forEach(function (m) {
                  synthesizeMethod(typ.ptr, m, f);
                });
              }
            });
          });
        };
        break;

      default:
        $panic(new $String("invalid kind: " + kind));
    }

    switch (kind) {
      case $kindBool:
      case $kindMap:
        typ.zero = function () {
          return false;
        };
        break;

      case $kindInt:
      case $kindInt8:
      case $kindInt16:
      case $kindInt32:
      case $kindUint:
      case $kindUint8:
      case $kindUint16:
      case $kindUint32:
      case $kindUintptr:
      case $kindUnsafePointer:
      case $kindFloat32:
      case $kindFloat64:
        typ.zero = function () {
          return 0;
        };
        break;

      case $kindString:
        typ.zero = function () {
          return "";
        };
        break;

      case $kindInt64:
      case $kindUint64:
      case $kindComplex64:
      case $kindComplex128:
        var zero = new typ(0, 0);
        typ.zero = function () {
          return zero;
        };
        break;

      case $kindPtr:
      case $kindSlice:
        typ.zero = function () {
          return typ.nil;
        };
        break;

      case $kindChan:
        typ.zero = function () {
          return $chanNil;
        };
        break;

      case $kindFunc:
        typ.zero = function () {
          return $throwNilPointerError;
        };
        break;

      case $kindInterface:
        typ.zero = function () {
          return $ifaceNil;
        };
        break;

      case $kindArray:
        typ.zero = function () {
          var arrayClass = $nativeArray(typ.elem.kind);
          if (arrayClass !== Array) {
            return new arrayClass(typ.len);
          }
          var array = new Array(typ.len);
          for (var i = 0; i < typ.len; i++) {
            array[i] = typ.elem.zero();
          }
          return array;
        };
        break;

      case $kindStruct:
        typ.zero = function () {
          return new typ.ptr();
        };
        break;

      default:
        $panic(new $String("invalid kind: " + kind));
    }

    typ.id = $typeIDCounter;
    $typeIDCounter++;
    typ.size = size;
    typ.kind = kind;
    typ.string = string;
    typ.named = named;
    typ.pkg = pkg;
    typ.exported = exported;
    typ.methods = [];
    typ.methodSetCache = null;
    typ.comparable = true;
    return typ;
  };

  var $methodSet = function (typ) {
    if (typ.methodSetCache !== null) {
      return typ.methodSetCache;
    }
    var base = {};

    var isPtr = typ.kind === $kindPtr;
    if (isPtr && typ.elem.kind === $kindInterface) {
      typ.methodSetCache = [];
      return [];
    }

    var current = [{ typ: isPtr ? typ.elem : typ, indirect: isPtr }];

    var seen = {};

    while (current.length > 0) {
      var next = [];
      var mset = [];

      current.forEach(function (e) {
        if (seen[e.typ.string]) {
          return;
        }
        seen[e.typ.string] = true;

        if (e.typ.named) {
          mset = mset.concat(e.typ.methods);
          if (e.indirect) {
            mset = mset.concat($ptrType(e.typ).methods);
          }
        }

        switch (e.typ.kind) {
          case $kindStruct:
            e.typ.fields.forEach(function (f) {
              if (f.embedded) {
                var fTyp = f.typ;
                var fIsPtr = fTyp.kind === $kindPtr;
                next.push({
                  typ: fIsPtr ? fTyp.elem : fTyp,
                  indirect: e.indirect || fIsPtr,
                });
              }
            });
            break;

          case $kindInterface:
            mset = mset.concat(e.typ.methods);
            break;
        }
      });

      mset.forEach(function (m) {
        if (base[m.name] === undefined) {
          base[m.name] = m;
        }
      });

      current = next;
    }

    typ.methodSetCache = [];
    Object.keys(base)
      .sort()
      .forEach(function (name) {
        typ.methodSetCache.push(base[name]);
      });
    return typ.methodSetCache;
  };

  var $Bool = $newType(1, $kindBool, "bool", true, "", false, null);
  var $Int = $newType(4, $kindInt, "int", true, "", false, null);
  var $Int8 = $newType(1, $kindInt8, "int8", true, "", false, null);
  var $Int16 = $newType(2, $kindInt16, "int16", true, "", false, null);
  var $Int32 = $newType(4, $kindInt32, "int32", true, "", false, null);
  var $Int64 = $newType(8, $kindInt64, "int64", true, "", false, null);
  var $Uint = $newType(4, $kindUint, "uint", true, "", false, null);
  var $Uint8 = $newType(1, $kindUint8, "uint8", true, "", false, null);
  var $Uint16 = $newType(2, $kindUint16, "uint16", true, "", false, null);
  var $Uint32 = $newType(4, $kindUint32, "uint32", true, "", false, null);
  var $Uint64 = $newType(8, $kindUint64, "uint64", true, "", false, null);
  var $Uintptr = $newType(4, $kindUintptr, "uintptr", true, "", false, null);
  var $Float32 = $newType(4, $kindFloat32, "float32", true, "", false, null);
  var $Float64 = $newType(8, $kindFloat64, "float64", true, "", false, null);
  var $Complex64 = $newType(
    8,
    $kindComplex64,
    "complex64",
    true,
    "",
    false,
    null
  );
  var $Complex128 = $newType(
    16,
    $kindComplex128,
    "complex128",
    true,
    "",
    false,
    null
  );
  var $String = $newType(8, $kindString, "string", true, "", false, null);
  var $UnsafePointer = $newType(
    4,
    $kindUnsafePointer,
    "unsafe.Pointer",
    true,
    "unsafe",
    false,
    null
  );

  var $nativeArray = function (elemKind) {
    switch (elemKind) {
      case $kindInt:
        return Int32Array;
      case $kindInt8:
        return Int8Array;
      case $kindInt16:
        return Int16Array;
      case $kindInt32:
        return Int32Array;
      case $kindUint:
        return Uint32Array;
      case $kindUint8:
        return Uint8Array;
      case $kindUint16:
        return Uint16Array;
      case $kindUint32:
        return Uint32Array;
      case $kindUintptr:
        return Uint32Array;
      case $kindFloat32:
        return Float32Array;
      case $kindFloat64:
        return Float64Array;
      default:
        return Array;
    }
  };
  var $toNativeArray = function (elemKind, array) {
    var nativeArray = $nativeArray(elemKind);
    if (nativeArray === Array) {
      return array;
    }
    return new nativeArray(array);
  };
  var $arrayTypes = {};
  var $arrayType = function (elem, len) {
    var typeKey = elem.id + "$" + len;
    var typ = $arrayTypes[typeKey];
    if (typ === undefined) {
      typ = $newType(
        elem.size * len,
        $kindArray,
        "[" + len + "]" + elem.string,
        false,
        "",
        false,
        null
      );
      $arrayTypes[typeKey] = typ;
      typ.init(elem, len);
    }
    return typ;
  };

  var $chanType = function (elem, sendOnly, recvOnly) {
    var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ");
    if (!sendOnly && !recvOnly && elem.string[0] == "<") {
      string += "(" + elem.string + ")";
    } else {
      string += elem.string;
    }
    var field = sendOnly ? "SendChan" : recvOnly ? "RecvChan" : "Chan";
    var typ = elem[field];
    if (typ === undefined) {
      typ = $newType(4, $kindChan, string, false, "", false, null);
      elem[field] = typ;
      typ.init(elem, sendOnly, recvOnly);
    }
    return typ;
  };
  var $Chan = function (elem, capacity) {
    if (capacity < 0 || capacity > 2147483647) {
      $throwRuntimeError("makechan: size out of range");
    }
    this.$elem = elem;
    this.$capacity = capacity;
    this.$buffer = [];
    this.$sendQueue = [];
    this.$recvQueue = [];
    this.$closed = false;
  };
  var $chanNil = new $Chan(null, 0);
  $chanNil.$sendQueue = $chanNil.$recvQueue = {
    length: 0,
    push: function () {},
    shift: function () {
      return undefined;
    },
    indexOf: function () {
      return -1;
    },
  };

  var $funcTypes = {};
  var $funcType = function (params, results, variadic) {
    var typeKey =
      $mapArray(params, function (p) {
        return p.id;
      }).join(",") +
      "$" +
      $mapArray(results, function (r) {
        return r.id;
      }).join(",") +
      "$" +
      variadic;
    var typ = $funcTypes[typeKey];
    if (typ === undefined) {
      var paramTypes = $mapArray(params, function (p) {
        return p.string;
      });
      if (variadic) {
        paramTypes[paramTypes.length - 1] =
          "..." + paramTypes[paramTypes.length - 1].substr(2);
      }
      var string = "func(" + paramTypes.join(", ") + ")";
      if (results.length === 1) {
        string += " " + results[0].string;
      } else if (results.length > 1) {
        string +=
          " (" +
          $mapArray(results, function (r) {
            return r.string;
          }).join(", ") +
          ")";
      }
      typ = $newType(4, $kindFunc, string, false, "", false, null);
      $funcTypes[typeKey] = typ;
      typ.init(params, results, variadic);
    }
    return typ;
  };

  var $interfaceTypes = {};
  var $interfaceType = function (methods) {
    var typeKey = $mapArray(methods, function (m) {
      return m.pkg + "," + m.name + "," + m.typ.id;
    }).join("$");
    var typ = $interfaceTypes[typeKey];
    if (typ === undefined) {
      var string = "interface {}";
      if (methods.length !== 0) {
        string =
          "interface { " +
          $mapArray(methods, function (m) {
            return (
              (m.pkg !== "" ? m.pkg + "." : "") +
              m.name +
              m.typ.string.substr(4)
            );
          }).join("; ") +
          " }";
      }
      typ = $newType(8, $kindInterface, string, false, "", false, null);
      $interfaceTypes[typeKey] = typ;
      typ.init(methods);
    }
    return typ;
  };
  var $emptyInterface = $interfaceType([]);
  var $ifaceNil = {};
  var $error = $newType(8, $kindInterface, "error", true, "", false, null);
  $error.init([
    {
      prop: "Error",
      name: "Error",
      pkg: "",
      typ: $funcType([], [$String], false),
    },
  ]);

  var $mapTypes = {};
  var $mapType = function (key, elem) {
    var typeKey = key.id + "$" + elem.id;
    var typ = $mapTypes[typeKey];
    if (typ === undefined) {
      typ = $newType(
        4,
        $kindMap,
        "map[" + key.string + "]" + elem.string,
        false,
        "",
        false,
        null
      );
      $mapTypes[typeKey] = typ;
      typ.init(key, elem);
    }
    return typ;
  };
  var $makeMap = function (keyForFunc, entries) {
    var m = new Map();
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      m.set(keyForFunc(e.k), e);
    }
    return m;
  };

  var $ptrType = function (elem) {
    var typ = elem.ptr;
    if (typ === undefined) {
      typ = $newType(
        4,
        $kindPtr,
        "*" + elem.string,
        false,
        "",
        elem.exported,
        null
      );
      elem.ptr = typ;
      typ.init(elem);
    }
    return typ;
  };

  var $newDataPointer = function (data, constructor) {
    if (constructor.elem.kind === $kindStruct) {
      return data;
    }
    return new constructor(
      function () {
        return data;
      },
      function (v) {
        data = v;
      }
    );
  };

  var $indexPtr = function (array, index, constructor) {
    if (array.buffer) {
      // Pointers to the same underlying ArrayBuffer share cache.
      var cache = (array.buffer.$ptr = array.buffer.$ptr || {});
      // Pointers of different primitive types are non-comparable and stored in different caches.
      var typeCache = (cache[array.name] = cache[array.name] || {});
      var cacheIdx = array.BYTES_PER_ELEMENT * index + array.byteOffset;
      return (
        typeCache[cacheIdx] ||
        (typeCache[cacheIdx] = new constructor(
          function () {
            return array[index];
          },
          function (v) {
            array[index] = v;
          }
        ))
      );
    } else {
      array.$ptr = array.$ptr || {};
      return (
        array.$ptr[index] ||
        (array.$ptr[index] = new constructor(
          function () {
            return array[index];
          },
          function (v) {
            array[index] = v;
          }
        ))
      );
    }
  };

  var $sliceType = function (elem) {
    var typ = elem.slice;
    if (typ === undefined) {
      typ = $newType(
        12,
        $kindSlice,
        "[]" + elem.string,
        false,
        "",
        false,
        null
      );
      elem.slice = typ;
      typ.init(elem);
    }
    return typ;
  };
  var $makeSlice = function (typ, length, capacity) {
    capacity = capacity || length;
    if (length < 0 || length > 2147483647) {
      $throwRuntimeError("makeslice: len out of range");
    }
    if (capacity < 0 || capacity < length || capacity > 2147483647) {
      $throwRuntimeError("makeslice: cap out of range");
    }
    var array = new typ.nativeArray(capacity);
    if (typ.nativeArray === Array) {
      for (var i = 0; i < capacity; i++) {
        array[i] = typ.elem.zero();
      }
    }
    var slice = new typ(array);
    slice.$length = length;
    return slice;
  };

  var $structTypes = {};
  var $structType = function (pkgPath, fields) {
    var typeKey = $mapArray(fields, function (f) {
      return f.name + "," + f.typ.id + "," + f.tag;
    }).join("$");
    var typ = $structTypes[typeKey];
    if (typ === undefined) {
      var string =
        "struct { " +
        $mapArray(fields, function (f) {
          var str =
            f.typ.string +
            (f.tag !== ""
              ? ' "' + f.tag.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
              : "");
          if (f.embedded) {
            return str;
          }
          return f.name + " " + str;
        }).join("; ") +
        " }";
      if (fields.length === 0) {
        string = "struct {}";
      }
      typ = $newType(0, $kindStruct, string, false, "", false, function () {
        this.$val = this;
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          if (f.name == "_") {
            continue;
          }
          var arg = arguments[i];
          this[f.prop] = arg !== undefined ? arg : f.typ.zero();
        }
      });
      $structTypes[typeKey] = typ;
      typ.init(pkgPath, fields);
    }
    return typ;
  };

  var $assertType = function (value, type, returnTuple) {
    var isInterface = type.kind === $kindInterface,
      ok,
      missingMethod = "";
    if (value === $ifaceNil) {
      ok = false;
    } else if (!isInterface) {
      ok = value.constructor === type;
    } else {
      var valueTypeString = value.constructor.string;
      ok = type.implementedBy[valueTypeString];
      if (ok === undefined) {
        ok = true;
        var valueMethodSet = $methodSet(value.constructor);
        var interfaceMethods = type.methods;
        for (var i = 0; i < interfaceMethods.length; i++) {
          var tm = interfaceMethods[i];
          var found = false;
          for (var j = 0; j < valueMethodSet.length; j++) {
            var vm = valueMethodSet[j];
            if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {
              found = true;
              break;
            }
          }
          if (!found) {
            ok = false;
            type.missingMethodFor[valueTypeString] = tm.name;
            break;
          }
        }
        type.implementedBy[valueTypeString] = ok;
      }
      if (!ok) {
        missingMethod = type.missingMethodFor[valueTypeString];
      }
    }

    if (!ok) {
      if (returnTuple) {
        return [type.zero(), false];
      }
      $panic(
        new $packages["runtime"].TypeAssertionError.ptr(
          $packages["runtime"]._type.ptr.nil,
          value === $ifaceNil
            ? $packages["runtime"]._type.ptr.nil
            : new $packages["runtime"]._type.ptr(value.constructor.string),
          new $packages["runtime"]._type.ptr(type.string),
          missingMethod
        )
      );
    }

    if (!isInterface) {
      value = value.$val;
    }
    if (type === $jsObjectPtr) {
      value = value.object;
    }
    return returnTuple ? [value, true] : value;
  };

  var $stackDepthOffset = 0;
  var $getStackDepth = function () {
    var err = new Error();
    if (err.stack === undefined) {
      return undefined;
    }
    return $stackDepthOffset + err.stack.split("\n").length;
  };

  var $panicStackDepth = null,
    $panicValue;
  var $callDeferred = function (deferred, jsErr, fromPanic) {
    if (
      !fromPanic &&
      deferred !== null &&
      $curGoroutine.deferStack.indexOf(deferred) == -1
    ) {
      throw jsErr;
    }
    if (jsErr !== null) {
      var newErr = null;
      try {
        $panic(new $jsErrorPtr(jsErr));
      } catch (err) {
        newErr = err;
      }
      $callDeferred(deferred, newErr);
      return;
    }
    if ($curGoroutine.asleep) {
      return;
    }

    $stackDepthOffset--;
    var outerPanicStackDepth = $panicStackDepth;
    var outerPanicValue = $panicValue;

    var localPanicValue = $curGoroutine.panicStack.pop();
    if (localPanicValue !== undefined) {
      $panicStackDepth = $getStackDepth();
      $panicValue = localPanicValue;
    }

    try {
      while (true) {
        if (deferred === null) {
          deferred =
            $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];
          if (deferred === undefined) {
            /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */
            $panicStackDepth = null;
            if (localPanicValue.Object instanceof Error) {
              throw localPanicValue.Object;
            }
            var msg;
            if (localPanicValue.constructor === $String) {
              msg = localPanicValue.$val;
            } else if (localPanicValue.Error !== undefined) {
              msg = localPanicValue.Error();
            } else if (localPanicValue.String !== undefined) {
              msg = localPanicValue.String();
            } else {
              msg = localPanicValue;
            }
            throw new Error(msg);
          }
        }
        var call = deferred.pop();
        if (call === undefined) {
          $curGoroutine.deferStack.pop();
          if (localPanicValue !== undefined) {
            deferred = null;
            continue;
          }
          return;
        }
        var r = call[0].apply(call[2], call[1]);
        if (r && r.$blk !== undefined) {
          deferred.push([r.$blk, [], r]);
          if (fromPanic) {
            throw null;
          }
          return;
        }

        if (localPanicValue !== undefined && $panicStackDepth === null) {
          /* error was recovered */
          if (fromPanic) {
            throw null;
          }
          return;
        }
      }
    } catch (e) {
      // Deferred function threw a JavaScript exception or tries to unwind stack
      // to the point where a panic was handled.
      if (fromPanic) {
        // Re-throw the exception to reach deferral execution call at the end
        // of the function.
        throw e;
      }
      // We are at the end of the function, handle the error or re-throw to
      // continue unwinding if necessary, or simply stop unwinding if we got far
      // enough.
      $callDeferred(deferred, e, fromPanic);
    } finally {
      if (localPanicValue !== undefined) {
        if ($panicStackDepth !== null) {
          $curGoroutine.panicStack.push(localPanicValue);
        }
        $panicStackDepth = outerPanicStackDepth;
        $panicValue = outerPanicValue;
      }
      $stackDepthOffset++;
    }
  };

  var $panic = function (value) {
    $curGoroutine.panicStack.push(value);
    $callDeferred(null, null, true);
  };
  var $recover = function () {
    if (
      $panicStackDepth === null ||
      ($panicStackDepth !== undefined &&
        $panicStackDepth !== $getStackDepth() - 2)
    ) {
      return $ifaceNil;
    }
    $panicStackDepth = null;
    return $panicValue;
  };
  var $throw = function (err) {
    throw err;
  };

  var $noGoroutine = {
    asleep: false,
    exit: false,
    deferStack: [],
    panicStack: [],
  };
  var $curGoroutine = $noGoroutine,
    $totalGoroutines = 0,
    $awakeGoroutines = 0,
    $checkForDeadlock = true,
    $exportedFunctions = 0;
  var $mainFinished = false;
  var $go = function (fun, args) {
    $totalGoroutines++;
    $awakeGoroutines++;
    var $goroutine = function () {
      try {
        $curGoroutine = $goroutine;
        var r = fun.apply(undefined, args);
        if (r && r.$blk !== undefined) {
          fun = function () {
            return r.$blk();
          };
          args = [];
          return;
        }
        $goroutine.exit = true;
      } catch (err) {
        if (!$goroutine.exit) {
          throw err;
        }
      } finally {
        $curGoroutine = $noGoroutine;
        if ($goroutine.exit) {
          /* also set by runtime.Goexit() */
          $totalGoroutines--;
          $goroutine.asleep = true;
        }
        if ($goroutine.asleep) {
          $awakeGoroutines--;
          if (
            !$mainFinished &&
            $awakeGoroutines === 0 &&
            $checkForDeadlock &&
            $exportedFunctions === 0
          ) {
            console.error("fatal error: all goroutines are asleep - deadlock!");
            if ($global.process !== undefined) {
              $global.process.exit(2);
            }
          }
        }
      }
    };
    $goroutine.asleep = false;
    $goroutine.exit = false;
    $goroutine.deferStack = [];
    $goroutine.panicStack = [];
    $schedule($goroutine);
  };

  var $scheduled = [];
  var $runScheduled = function () {
    // For nested setTimeout calls browsers enforce 4ms minimum delay. We minimize
    // the effect of this penalty by queueing the timer preemptively before we run
    // the goroutines, and later cancelling it if it turns out unneeded. See:
    // https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#nested_timeouts
    var nextRun = setTimeout($runScheduled);
    try {
      var start = Date.now();
      var r;
      while ((r = $scheduled.shift()) !== undefined) {
        r();
        // We need to interrupt this loop in order to allow the event loop to
        // process timers, IO, etc. However, invoking scheduling through
        // setTimeout is ~1000 times more expensive, so we amortize this cost by
        // looping until the 4ms minimal delay has elapsed (assuming there are
        // scheduled goroutines to run), and then yield to the event loop.
        var elapsed = Date.now() - start;
        if (elapsed > 4 || elapsed < 0) {
          break;
        }
      }
    } finally {
      if ($scheduled.length == 0) {
        // Cancel scheduling pass if there's nothing to run.
        clearTimeout(nextRun);
      }
    }
  };

  var $schedule = function (goroutine) {
    if (goroutine.asleep) {
      goroutine.asleep = false;
      $awakeGoroutines++;
    }
    $scheduled.push(goroutine);
    if ($curGoroutine === $noGoroutine) {
      $runScheduled();
    }
  };

  var $setTimeout = function (f, t) {
    $awakeGoroutines++;
    return setTimeout(function () {
      $awakeGoroutines--;
      f();
    }, t);
  };

  var $block = function () {
    if ($curGoroutine === $noGoroutine) {
      $throwRuntimeError(
        "cannot block in JavaScript callback, fix by wrapping code in goroutine"
      );
    }
    $curGoroutine.asleep = true;
  };

  var $restore = function (context, params) {
    if (context !== undefined && context.$blk !== undefined) {
      return context;
    }
    return params;
  };

  var $send = function (chan, value) {
    if (chan.$closed) {
      $throwRuntimeError("send on closed channel");
    }
    var queuedRecv = chan.$recvQueue.shift();
    if (queuedRecv !== undefined) {
      queuedRecv([value, true]);
      return;
    }
    if (chan.$buffer.length < chan.$capacity) {
      chan.$buffer.push(value);
      return;
    }

    var thisGoroutine = $curGoroutine;
    var closedDuringSend;
    chan.$sendQueue.push(function (closed) {
      closedDuringSend = closed;
      $schedule(thisGoroutine);
      return value;
    });
    $block();
    return {
      $blk: function () {
        if (closedDuringSend) {
          $throwRuntimeError("send on closed channel");
        }
      },
    };
  };
  var $recv = function (chan) {
    var queuedSend = chan.$sendQueue.shift();
    if (queuedSend !== undefined) {
      chan.$buffer.push(queuedSend(false));
    }
    var bufferedValue = chan.$buffer.shift();
    if (bufferedValue !== undefined) {
      return [bufferedValue, true];
    }
    if (chan.$closed) {
      return [chan.$elem.zero(), false];
    }

    var thisGoroutine = $curGoroutine;
    var f = {
      $blk: function () {
        return this.value;
      },
    };
    var queueEntry = function (v) {
      f.value = v;
      $schedule(thisGoroutine);
    };
    chan.$recvQueue.push(queueEntry);
    $block();
    return f;
  };
  var $close = function (chan) {
    if (chan.$closed) {
      $throwRuntimeError("close of closed channel");
    }
    chan.$closed = true;
    while (true) {
      var queuedSend = chan.$sendQueue.shift();
      if (queuedSend === undefined) {
        break;
      }
      queuedSend(true); /* will panic */
    }
    while (true) {
      var queuedRecv = chan.$recvQueue.shift();
      if (queuedRecv === undefined) {
        break;
      }
      queuedRecv([chan.$elem.zero(), false]);
    }
  };
  var $select = function (comms) {
    var ready = [];
    var selection = -1;
    for (var i = 0; i < comms.length; i++) {
      var comm = comms[i];
      var chan = comm[0];
      switch (comm.length) {
        case 0 /* default */:
          selection = i;
          break;
        case 1 /* recv */:
          if (
            chan.$sendQueue.length !== 0 ||
            chan.$buffer.length !== 0 ||
            chan.$closed
          ) {
            ready.push(i);
          }
          break;
        case 2 /* send */:
          if (chan.$closed) {
            $throwRuntimeError("send on closed channel");
          }
          if (
            chan.$recvQueue.length !== 0 ||
            chan.$buffer.length < chan.$capacity
          ) {
            ready.push(i);
          }
          break;
      }
    }

    if (ready.length !== 0) {
      selection = ready[Math.floor(Math.random() * ready.length)];
    }
    if (selection !== -1) {
      var comm = comms[selection];
      switch (comm.length) {
        case 0 /* default */:
          return [selection];
        case 1 /* recv */:
          return [selection, $recv(comm[0])];
        case 2 /* send */:
          $send(comm[0], comm[1]);
          return [selection];
      }
    }

    var entries = [];
    var thisGoroutine = $curGoroutine;
    var f = {
      $blk: function () {
        return this.selection;
      },
    };
    var removeFromQueues = function () {
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i];
        var queue = entry[0];
        var index = queue.indexOf(entry[1]);
        if (index !== -1) {
          queue.splice(index, 1);
        }
      }
    };
    for (var i = 0; i < comms.length; i++) {
      (function (i) {
        var comm = comms[i];
        switch (comm.length) {
          case 1 /* recv */:
            var queueEntry = function (value) {
              f.selection = [i, value];
              removeFromQueues();
              $schedule(thisGoroutine);
            };
            entries.push([comm[0].$recvQueue, queueEntry]);
            comm[0].$recvQueue.push(queueEntry);
            break;
          case 2 /* send */:
            var queueEntry = function () {
              if (comm[0].$closed) {
                $throwRuntimeError("send on closed channel");
              }
              f.selection = [i];
              removeFromQueues();
              $schedule(thisGoroutine);
              return comm[1];
            };
            entries.push([comm[0].$sendQueue, queueEntry]);
            comm[0].$sendQueue.push(queueEntry);
            break;
        }
      })(i);
    }
    $block();
    return f;
  };

  var $jsObjectPtr, $jsErrorPtr;

  var $needsExternalization = function (t) {
    switch (t.kind) {
      case $kindBool:
      case $kindInt:
      case $kindInt8:
      case $kindInt16:
      case $kindInt32:
      case $kindUint:
      case $kindUint8:
      case $kindUint16:
      case $kindUint32:
      case $kindUintptr:
      case $kindFloat32:
      case $kindFloat64:
        return false;
      default:
        return t !== $jsObjectPtr;
    }
  };

  var $externalize = function (v, t, makeWrapper) {
    if (t === $jsObjectPtr) {
      return v;
    }
    switch (t.kind) {
      case $kindBool:
      case $kindInt:
      case $kindInt8:
      case $kindInt16:
      case $kindInt32:
      case $kindUint:
      case $kindUint8:
      case $kindUint16:
      case $kindUint32:
      case $kindUintptr:
      case $kindFloat32:
      case $kindFloat64:
        return v;
      case $kindInt64:
      case $kindUint64:
        return $flatten64(v);
      case $kindArray:
        if ($needsExternalization(t.elem)) {
          return $mapArray(v, function (e) {
            return $externalize(e, t.elem, makeWrapper);
          });
        }
        return v;
      case $kindFunc:
        return $externalizeFunction(v, t, false, makeWrapper);
      case $kindInterface:
        if (v === $ifaceNil) {
          return null;
        }
        if (v.constructor === $jsObjectPtr) {
          return v.$val.object;
        }
        return $externalize(v.$val, v.constructor, makeWrapper);
      case $kindMap:
        var m = {};
        var keys = Array.from(v.keys());
        for (var i = 0; i < keys.length; i++) {
          var entry = v.get(keys[i]);
          m[$externalize(entry.k, t.key, makeWrapper)] = $externalize(
            entry.v,
            t.elem,
            makeWrapper
          );
        }
        return m;
      case $kindPtr:
        if (v === t.nil) {
          return null;
        }
        return $externalize(v.$get(), t.elem, makeWrapper);
      case $kindSlice:
        if ($needsExternalization(t.elem)) {
          return $mapArray($sliceToNativeArray(v), function (e) {
            return $externalize(e, t.elem, makeWrapper);
          });
        }
        return $sliceToNativeArray(v);
      case $kindString:
        if ($isASCII(v)) {
          return v;
        }
        var s = "",
          r;
        for (var i = 0; i < v.length; i += r[1]) {
          r = $decodeRune(v, i);
          var c = r[0];
          if (c > 0xffff) {
            var h = Math.floor((c - 0x10000) / 0x400) + 0xd800;
            var l = ((c - 0x10000) % 0x400) + 0xdc00;
            s += String.fromCharCode(h, l);
            continue;
          }
          s += String.fromCharCode(c);
        }
        return s;
      case $kindStruct:
        var timePkg = $packages["time"];
        if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {
          var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));
          return new Date($flatten64(milli));
        }

        var noJsObject = {};
        var searchJsObject = function (v, t) {
          if (t === $jsObjectPtr) {
            return v;
          }
          switch (t.kind) {
            case $kindPtr:
              if (v === t.nil) {
                return noJsObject;
              }
              return searchJsObject(v.$get(), t.elem);
            case $kindStruct:
              var f = t.fields[0];
              return searchJsObject(v[f.prop], f.typ);
            case $kindInterface:
              return searchJsObject(v.$val, v.constructor);
            default:
              return noJsObject;
          }
        };
        var o = searchJsObject(v, t);
        if (o !== noJsObject) {
          return o;
        }

        if (makeWrapper !== undefined) {
          return makeWrapper(v);
        }

        o = {};
        for (var i = 0; i < t.fields.length; i++) {
          var f = t.fields[i];
          if (!f.exported) {
            continue;
          }
          o[f.name] = $externalize(v[f.prop], f.typ, makeWrapper);
        }
        return o;
    }
    $throwRuntimeError("cannot externalize " + t.string);
  };

  var $externalizeFunction = function (v, t, passThis, makeWrapper) {
    if (v === $throwNilPointerError) {
      return null;
    }
    if (v.$externalizeWrapper === undefined) {
      $checkForDeadlock = false;
      v.$externalizeWrapper = function () {
        var args = [];
        for (var i = 0; i < t.params.length; i++) {
          if (t.variadic && i === t.params.length - 1) {
            var vt = t.params[i].elem,
              varargs = [];
            for (var j = i; j < arguments.length; j++) {
              varargs.push($internalize(arguments[j], vt, makeWrapper));
            }
            args.push(new t.params[i](varargs));
            break;
          }
          args.push($internalize(arguments[i], t.params[i], makeWrapper));
        }
        var result = v.apply(passThis ? this : undefined, args);
        switch (t.results.length) {
          case 0:
            return;
          case 1:
            return $externalize(
              $copyIfRequired(result, t.results[0]),
              t.results[0],
              makeWrapper
            );
          default:
            for (var i = 0; i < t.results.length; i++) {
              result[i] = $externalize(
                $copyIfRequired(result[i], t.results[i]),
                t.results[i],
                makeWrapper
              );
            }
            return result;
        }
      };
    }
    return v.$externalizeWrapper;
  };

  var $internalize = function (v, t, recv, seen, makeWrapper) {
    if (t === $jsObjectPtr) {
      return v;
    }
    if (t === $jsObjectPtr.elem) {
      $throwRuntimeError(
        "cannot internalize js.Object, use *js.Object instead"
      );
    }
    if (v && v.__internal_object__ !== undefined) {
      return $assertType(v.__internal_object__, t, false);
    }
    var timePkg = $packages["time"];
    if (timePkg !== undefined && t === timePkg.Time) {
      if (!(v !== null && v !== undefined && v.constructor === Date)) {
        $throwRuntimeError(
          "cannot internalize time.Time from " + typeof v + ", must be Date"
        );
      }
      return timePkg.Unix(
        new $Int64(0, 0),
        new $Int64(0, v.getTime() * 1000000)
      );
    }

    // Cache for values we've already internalized in order to deal with circular
    // references.
    if (seen === undefined) {
      seen = new Map();
    }
    if (!seen.has(t)) {
      seen.set(t, new Map());
    }
    if (seen.get(t).has(v)) {
      return seen.get(t).get(v);
    }

    switch (t.kind) {
      case $kindBool:
        return !!v;
      case $kindInt:
        return parseInt(v);
      case $kindInt8:
        return (parseInt(v) << 24) >> 24;
      case $kindInt16:
        return (parseInt(v) << 16) >> 16;
      case $kindInt32:
        return parseInt(v) >> 0;
      case $kindUint:
        return parseInt(v);
      case $kindUint8:
        return (parseInt(v) << 24) >>> 24;
      case $kindUint16:
        return (parseInt(v) << 16) >>> 16;
      case $kindUint32:
      case $kindUintptr:
        return parseInt(v) >>> 0;
      case $kindInt64:
      case $kindUint64:
        return new t(0, v);
      case $kindFloat32:
      case $kindFloat64:
        return parseFloat(v);
      case $kindArray:
        if (v.length !== t.len) {
          $throwRuntimeError(
            "got array with wrong size from JavaScript native"
          );
        }
        return $mapArray(v, function (e) {
          return $internalize(e, t.elem, makeWrapper);
        });
      case $kindFunc:
        return function () {
          var args = [];
          for (var i = 0; i < t.params.length; i++) {
            if (t.variadic && i === t.params.length - 1) {
              var vt = t.params[i].elem,
                varargs = arguments[i];
              for (var j = 0; j < varargs.$length; j++) {
                args.push(
                  $externalize(
                    varargs.$array[varargs.$offset + j],
                    vt,
                    makeWrapper
                  )
                );
              }
              break;
            }
            args.push($externalize(arguments[i], t.params[i], makeWrapper));
          }
          var result = v.apply(recv, args);
          switch (t.results.length) {
            case 0:
              return;
            case 1:
              return $internalize(result, t.results[0], makeWrapper);
            default:
              for (var i = 0; i < t.results.length; i++) {
                result[i] = $internalize(result[i], t.results[i], makeWrapper);
              }
              return result;
          }
        };
      case $kindInterface:
        if (t.methods.length !== 0) {
          $throwRuntimeError("cannot internalize " + t.string);
        }
        if (v === null) {
          return $ifaceNil;
        }
        if (v === undefined) {
          return new $jsObjectPtr(undefined);
        }
        switch (v.constructor) {
          case Int8Array:
            return new ($sliceType($Int8))(v);
          case Int16Array:
            return new ($sliceType($Int16))(v);
          case Int32Array:
            return new ($sliceType($Int))(v);
          case Uint8Array:
            return new ($sliceType($Uint8))(v);
          case Uint16Array:
            return new ($sliceType($Uint16))(v);
          case Uint32Array:
            return new ($sliceType($Uint))(v);
          case Float32Array:
            return new ($sliceType($Float32))(v);
          case Float64Array:
            return new ($sliceType($Float64))(v);
          case Array:
            return $internalize(v, $sliceType($emptyInterface), makeWrapper);
          case Boolean:
            return new $Bool(!!v);
          case Date:
            if (timePkg === undefined) {
              /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */
              return new $jsObjectPtr(v);
            }
            return new timePkg.Time($internalize(v, timePkg.Time, makeWrapper));
          case function () {}.constructor: // is usually Function, but in Chrome extensions it is something else
            var funcType = $funcType(
              [$sliceType($emptyInterface)],
              [$jsObjectPtr],
              true
            );
            return new funcType($internalize(v, funcType, makeWrapper));
          case Number:
            return new $Float64(parseFloat(v));
          case String:
            return new $String($internalize(v, $String, makeWrapper));
          default:
            if ($global.Node && v instanceof $global.Node) {
              return new $jsObjectPtr(v);
            }
            var mapType = $mapType($String, $emptyInterface);
            return new mapType(
              $internalize(v, mapType, recv, seen, makeWrapper)
            );
        }
      case $kindMap:
        var m = new Map();
        seen.get(t).set(v, m);
        var keys = $keys(v);
        for (var i = 0; i < keys.length; i++) {
          var k = $internalize(keys[i], t.key, recv, seen, makeWrapper);
          m.set(t.key.keyFor(k), {
            k: k,
            v: $internalize(v[keys[i]], t.elem, recv, seen, makeWrapper),
          });
        }
        return m;
      case $kindPtr:
        if (t.elem.kind === $kindStruct) {
          return $internalize(v, t.elem, makeWrapper);
        }
      case $kindSlice:
        return new t(
          $mapArray(v, function (e) {
            return $internalize(e, t.elem, makeWrapper);
          })
        );
      case $kindString:
        v = String(v);
        if ($isASCII(v)) {
          return v;
        }
        var s = "";
        var i = 0;
        while (i < v.length) {
          var h = v.charCodeAt(i);
          if (0xd800 <= h && h <= 0xdbff) {
            var l = v.charCodeAt(i + 1);
            var c = (h - 0xd800) * 0x400 + l - 0xdc00 + 0x10000;
            s += $encodeRune(c);
            i += 2;
            continue;
          }
          s += $encodeRune(h);
          i++;
        }
        return s;
      case $kindStruct:
        var noJsObject = {};
        var searchJsObject = function (t) {
          if (t === $jsObjectPtr) {
            return v;
          }
          if (t === $jsObjectPtr.elem) {
            $throwRuntimeError(
              "cannot internalize js.Object, use *js.Object instead"
            );
          }
          switch (t.kind) {
            case $kindPtr:
              return searchJsObject(t.elem);
            case $kindStruct:
              var f = t.fields[0];
              var o = searchJsObject(f.typ);
              if (o !== noJsObject) {
                var n = new t.ptr();
                n[f.prop] = o;
                return n;
              }
              return noJsObject;
            default:
              return noJsObject;
          }
        };
        var o = searchJsObject(t);
        if (o !== noJsObject) {
          return o;
        }
    }
    $throwRuntimeError("cannot internalize " + t.string);
  };

  var $copyIfRequired = function (v, typ) {
    // interface values
    if (v && v.constructor && v.constructor.copy) {
      return new v.constructor($clone(v.$val, v.constructor));
    }
    // array and struct values
    if (typ.copy) {
      var clone = typ.zero();
      typ.copy(clone, v);
      return clone;
    }
    return v;
  };

  /* $isASCII reports whether string s contains only ASCII characters. */
  var $isASCII = function (s) {
    for (var i = 0; i < s.length; i++) {
      if (s.charCodeAt(i) >= 128) {
        return false;
      }
    }
    return true;
  };

  $packages["github.com/gopherjs/gopherjs/js"] = (function () {
    var $pkg = {},
      $init,
      Object,
      Error,
      sliceType,
      ptrType,
      ptrType$1,
      MakeFunc,
      init;
    Object = $pkg.Object = $newType(
      0,
      $kindStruct,
      "js.Object",
      true,
      "github.com/gopherjs/gopherjs/js",
      true,
      function (object_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.object = null;
          return;
        }
        this.object = object_;
      }
    );
    Error = $pkg.Error = $newType(
      0,
      $kindStruct,
      "js.Error",
      true,
      "github.com/gopherjs/gopherjs/js",
      true,
      function (Object_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Object = null;
          return;
        }
        this.Object = Object_;
      }
    );
    sliceType = $sliceType($emptyInterface);
    ptrType = $ptrType(Object);
    ptrType$1 = $ptrType(Error);
    Object.ptr.prototype.Get = function (key) {
      var key, o;
      o = this;
      return o.object[$externalize(key, $String)];
    };
    Object.prototype.Get = function (key) {
      return this.$val.Get(key);
    };
    Object.ptr.prototype.Set = function (key, value) {
      var key, o, value;
      o = this;
      o.object[$externalize(key, $String)] = $externalize(
        value,
        $emptyInterface
      );
    };
    Object.prototype.Set = function (key, value) {
      return this.$val.Set(key, value);
    };
    Object.ptr.prototype.Delete = function (key) {
      var key, o;
      o = this;
      delete o.object[$externalize(key, $String)];
    };
    Object.prototype.Delete = function (key) {
      return this.$val.Delete(key);
    };
    Object.ptr.prototype.Length = function () {
      var o;
      o = this;
      return $parseInt(o.object.length);
    };
    Object.prototype.Length = function () {
      return this.$val.Length();
    };
    Object.ptr.prototype.Index = function (i) {
      var i, o;
      o = this;
      return o.object[i];
    };
    Object.prototype.Index = function (i) {
      return this.$val.Index(i);
    };
    Object.ptr.prototype.SetIndex = function (i, value) {
      var i, o, value;
      o = this;
      o.object[i] = $externalize(value, $emptyInterface);
    };
    Object.prototype.SetIndex = function (i, value) {
      return this.$val.SetIndex(i, value);
    };
    Object.ptr.prototype.Call = function (name, args) {
      var args, name, o, obj;
      o = this;
      return (
        (obj = o.object),
        obj[$externalize(name, $String)].apply(
          obj,
          $externalize(args, sliceType)
        )
      );
    };
    Object.prototype.Call = function (name, args) {
      return this.$val.Call(name, args);
    };
    Object.ptr.prototype.Invoke = function (args) {
      var args, o;
      o = this;
      return o.object.apply(undefined, $externalize(args, sliceType));
    };
    Object.prototype.Invoke = function (args) {
      return this.$val.Invoke(args);
    };
    Object.ptr.prototype.New = function (args) {
      var args, o;
      o = this;
      return new ($global.Function.prototype.bind.apply(
        o.object,
        [undefined].concat($externalize(args, sliceType))
      ))();
    };
    Object.prototype.New = function (args) {
      return this.$val.New(args);
    };
    Object.ptr.prototype.Bool = function () {
      var o;
      o = this;
      return !!o.object;
    };
    Object.prototype.Bool = function () {
      return this.$val.Bool();
    };
    Object.ptr.prototype.String = function () {
      var o;
      o = this;
      return $internalize(o.object, $String);
    };
    Object.prototype.String = function () {
      return this.$val.String();
    };
    Object.ptr.prototype.Int = function () {
      var o;
      o = this;
      return $parseInt(o.object) >> 0;
    };
    Object.prototype.Int = function () {
      return this.$val.Int();
    };
    Object.ptr.prototype.Int64 = function () {
      var o;
      o = this;
      return $internalize(o.object, $Int64);
    };
    Object.prototype.Int64 = function () {
      return this.$val.Int64();
    };
    Object.ptr.prototype.Uint64 = function () {
      var o;
      o = this;
      return $internalize(o.object, $Uint64);
    };
    Object.prototype.Uint64 = function () {
      return this.$val.Uint64();
    };
    Object.ptr.prototype.Float = function () {
      var o;
      o = this;
      return $parseFloat(o.object);
    };
    Object.prototype.Float = function () {
      return this.$val.Float();
    };
    Object.ptr.prototype.Interface = function () {
      var o;
      o = this;
      return $internalize(o.object, $emptyInterface);
    };
    Object.prototype.Interface = function () {
      return this.$val.Interface();
    };
    Object.ptr.prototype.Unsafe = function () {
      var o;
      o = this;
      return o.object;
    };
    Object.prototype.Unsafe = function () {
      return this.$val.Unsafe();
    };
    Error.ptr.prototype.Error = function () {
      var err;
      err = this;
      return "JavaScript error: " + $internalize(err.Object.message, $String);
    };
    Error.prototype.Error = function () {
      return this.$val.Error();
    };
    Error.ptr.prototype.Stack = function () {
      var err;
      err = this;
      return $internalize(err.Object.stack, $String);
    };
    Error.prototype.Stack = function () {
      return this.$val.Stack();
    };
    MakeFunc = function (fn) {
      var fn;
      return $makeFunc(fn);
    };
    $pkg.MakeFunc = MakeFunc;
    init = function () {
      var e;
      e = new Error.ptr(null);
      $unused(e);
    };
    ptrType.methods = [
      {
        prop: "Get",
        name: "Get",
        pkg: "",
        typ: $funcType([$String], [ptrType], false),
      },
      {
        prop: "Set",
        name: "Set",
        pkg: "",
        typ: $funcType([$String, $emptyInterface], [], false),
      },
      {
        prop: "Delete",
        name: "Delete",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Length",
        name: "Length",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Index",
        name: "Index",
        pkg: "",
        typ: $funcType([$Int], [ptrType], false),
      },
      {
        prop: "SetIndex",
        name: "SetIndex",
        pkg: "",
        typ: $funcType([$Int, $emptyInterface], [], false),
      },
      {
        prop: "Call",
        name: "Call",
        pkg: "",
        typ: $funcType([$String, sliceType], [ptrType], true),
      },
      {
        prop: "Invoke",
        name: "Invoke",
        pkg: "",
        typ: $funcType([sliceType], [ptrType], true),
      },
      {
        prop: "New",
        name: "New",
        pkg: "",
        typ: $funcType([sliceType], [ptrType], true),
      },
      {
        prop: "Bool",
        name: "Bool",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      { prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Int64",
        name: "Int64",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Uint64",
        name: "Uint64",
        pkg: "",
        typ: $funcType([], [$Uint64], false),
      },
      {
        prop: "Float",
        name: "Float",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "Interface",
        name: "Interface",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
      {
        prop: "Unsafe",
        name: "Unsafe",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Stack",
        name: "Stack",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Object.init("github.com/gopherjs/gopherjs/js", [
      {
        prop: "object",
        name: "object",
        embedded: false,
        exported: false,
        typ: ptrType,
        tag: "",
      },
    ]);
    Error.init("", [
      {
        prop: "Object",
        name: "Object",
        embedded: true,
        exported: true,
        typ: ptrType,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["runtime"] = (function () {
    var $pkg = {},
      $init,
      js,
      Error,
      _type,
      TypeAssertionError,
      basicFrame,
      Func,
      errorString,
      ptrType,
      sliceType,
      ptrType$1,
      structType,
      sliceType$1,
      ptrType$2,
      knownPositions,
      positionCounters,
      hiddenFrames,
      knownFrames,
      buildVersion,
      init,
      GOROOT,
      registerPosition,
      itoa,
      callstack,
      parseCallstack,
      ParseCallFrame,
      Caller,
      SetFinalizer,
      FuncForPC,
      KeepAlive,
      throw$1,
      nanotime,
      fastrand;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    Error = $pkg.Error = $newType(
      8,
      $kindInterface,
      "runtime.Error",
      true,
      "runtime",
      true,
      null
    );
    _type = $pkg._type = $newType(
      0,
      $kindStruct,
      "runtime._type",
      true,
      "runtime",
      false,
      function (str_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.str = "";
          return;
        }
        this.str = str_;
      }
    );
    TypeAssertionError = $pkg.TypeAssertionError = $newType(
      0,
      $kindStruct,
      "runtime.TypeAssertionError",
      true,
      "runtime",
      true,
      function (_interface_, concrete_, asserted_, missingMethod_) {
        this.$val = this;
        if (arguments.length === 0) {
          this._interface = ptrType$1.nil;
          this.concrete = ptrType$1.nil;
          this.asserted = ptrType$1.nil;
          this.missingMethod = "";
          return;
        }
        this._interface = _interface_;
        this.concrete = concrete_;
        this.asserted = asserted_;
        this.missingMethod = missingMethod_;
      }
    );
    basicFrame = $pkg.basicFrame = $newType(
      0,
      $kindStruct,
      "runtime.basicFrame",
      true,
      "runtime",
      false,
      function (FuncName_, File_, Line_, Col_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.FuncName = "";
          this.File = "";
          this.Line = 0;
          this.Col = 0;
          return;
        }
        this.FuncName = FuncName_;
        this.File = File_;
        this.Line = Line_;
        this.Col = Col_;
      }
    );
    Func = $pkg.Func = $newType(
      0,
      $kindStruct,
      "runtime.Func",
      true,
      "runtime",
      true,
      function (name_, file_, line_, opaque_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.file = "";
          this.line = 0;
          this.opaque = new structType.ptr();
          return;
        }
        this.name = name_;
        this.file = file_;
        this.line = line_;
        this.opaque = opaque_;
      }
    );
    errorString = $pkg.errorString = $newType(
      8,
      $kindString,
      "runtime.errorString",
      true,
      "runtime",
      false,
      null
    );
    ptrType = $ptrType(Func);
    sliceType = $sliceType(ptrType);
    ptrType$1 = $ptrType(_type);
    structType = $structType("", []);
    sliceType$1 = $sliceType(basicFrame);
    ptrType$2 = $ptrType(TypeAssertionError);
    _type.ptr.prototype.string = function () {
      var t;
      t = this;
      return t.str;
    };
    _type.prototype.string = function () {
      return this.$val.string();
    };
    _type.ptr.prototype.pkgpath = function () {
      var t;
      t = this;
      return "";
    };
    _type.prototype.pkgpath = function () {
      return this.$val.pkgpath();
    };
    TypeAssertionError.ptr.prototype.RuntimeError = function () {};
    TypeAssertionError.prototype.RuntimeError = function () {
      return this.$val.RuntimeError();
    };
    TypeAssertionError.ptr.prototype.Error = function () {
      var as, cs, e, inter, msg;
      e = this;
      inter = "interface";
      if (!(e._interface === ptrType$1.nil)) {
        inter = e._interface.string();
      }
      as = e.asserted.string();
      if (e.concrete === ptrType$1.nil) {
        return "interface conversion: " + inter + " is nil, not " + as;
      }
      cs = e.concrete.string();
      if (e.missingMethod === "") {
        msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
        if (cs === as) {
          if (!(e.concrete.pkgpath() === e.asserted.pkgpath())) {
            msg = msg + " (types from different packages)";
          } else {
            msg = msg + " (types from different scopes)";
          }
        }
        return msg;
      }
      return (
        "interface conversion: " +
        cs +
        " is not " +
        as +
        ": missing method " +
        e.missingMethod
      );
    };
    TypeAssertionError.prototype.Error = function () {
      return this.$val.Error();
    };
    init = function () {
      var e, jsPkg;
      jsPkg =
        $packages[$externalize("github.com/gopherjs/gopherjs/js", $String)];
      $jsObjectPtr = jsPkg.Object.ptr;
      $jsErrorPtr = jsPkg.Error.ptr;
      $throwRuntimeError = throw$1;
      buildVersion = $internalize($goVersion, $String);
      e = $ifaceNil;
      e = new TypeAssertionError.ptr(
        ptrType$1.nil,
        ptrType$1.nil,
        ptrType$1.nil,
        ""
      );
      $unused(e);
    };
    GOROOT = function () {
      var process, v, v$1;
      process = $global.process;
      if (process === undefined) {
        return "/";
      }
      v = process.env.GOPHERJS_GOROOT;
      if (!(v === undefined) && !($internalize(v, $String) === "")) {
        return $internalize(v, $String);
      } else {
        v$1 = process.env.GOROOT;
        if (!(v$1 === undefined) && !($internalize(v$1, $String) === "")) {
          return $internalize(v$1, $String);
        }
      }
      return "/usr/local/go";
    };
    $pkg.GOROOT = GOROOT;
    registerPosition = function (funcName, file, line, col) {
      var _entry,
        _key,
        _tuple,
        col,
        f,
        file,
        found,
        funcName,
        key,
        line,
        pc,
        pc$1;
      key = file + ":" + itoa(line) + ":" + itoa(col);
      _tuple =
        ((_entry = $mapIndex(knownPositions, $String.keyFor(key))),
        _entry !== undefined ? [_entry.v, true] : [0, false]);
      pc = _tuple[0];
      found = _tuple[1];
      if (found) {
        return pc;
      }
      f = new Func.ptr(funcName, file, line, new structType.ptr());
      pc$1 = positionCounters.$length >>> 0;
      positionCounters = $append(positionCounters, f);
      _key = key;
      (
        knownPositions || $throwRuntimeError("assignment to entry in nil map")
      ).set($String.keyFor(_key), { k: _key, v: pc$1 });
      return pc$1;
    };
    itoa = function (i) {
      var i;
      return $internalize(new $global.String(i), $String);
    };
    callstack = function (skip, limit) {
      var limit, lines, skip;
      skip = (((skip + 1) >> 0) + 1) >> 0;
      lines = new $global.Error().stack
        .split($externalize("\n", $String))
        .slice(skip, (skip + limit) >> 0);
      return parseCallstack(lines);
    };
    parseCallstack = function (lines) {
      var _entry, _entry$1, _tuple, alias, frame, frames, i, l, lines, ok;
      frames = new sliceType$1([]);
      l = $parseInt(lines.length);
      i = 0;
      while (true) {
        if (!(i < l)) {
          break;
        }
        frame = $clone(ParseCallFrame(lines[i]), basicFrame);
        if (
          ((_entry = $mapIndex(hiddenFrames, $String.keyFor(frame.FuncName))),
          _entry !== undefined ? _entry.v : false)
        ) {
          i = (i + 1) >> 0;
          continue;
        }
        _tuple =
          ((_entry$1 = $mapIndex(knownFrames, $String.keyFor(frame.FuncName))),
          _entry$1 !== undefined ? [_entry$1.v, true] : ["", false]);
        alias = _tuple[0];
        ok = _tuple[1];
        if (ok) {
          frame.FuncName = alias;
        }
        frames = $append(frames, frame);
        if (frame.FuncName === "runtime.goexit") {
          break;
        }
        i = (i + 1) >> 0;
      }
      return frames;
    };
    ParseCallFrame = function (info) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        col,
        file,
        fn,
        funcName,
        idx,
        info,
        line,
        openIdx,
        parts,
        parts$1,
        parts$2,
        pos,
        split;
      if ($parseInt(info.indexOf($externalize("@", $String))) >> 0 >= 0) {
        split = new $global.RegExp($externalize("[@:]", $String));
        parts = info.split(split);
        return new basicFrame.ptr(
          $internalize(parts[0], $String),
          $internalize(
            parts
              .slice(1, ($parseInt(parts.length) - 2) >> 0)
              .join($externalize(":", $String)),
            $String
          ),
          $parseInt(parts[($parseInt(parts.length) - 2) >> 0]) >> 0,
          $parseInt(parts[($parseInt(parts.length) - 1) >> 0]) >> 0
        );
      }
      openIdx = $parseInt(info.lastIndexOf($externalize("(", $String))) >> 0;
      if (openIdx === -1) {
        parts$1 = info.split($externalize(":", $String));
        return new basicFrame.ptr(
          "<none>",
          $internalize(
            parts$1
              .slice(0, ($parseInt(parts$1.length) - 2) >> 0)
              .join($externalize(":", $String))
              .replace(
                new $global.RegExp($externalize("^\\s*at ", $String)),
                $externalize("", $String)
              ),
            $String
          ),
          $parseInt(parts$1[($parseInt(parts$1.length) - 2) >> 0]) >> 0,
          $parseInt(parts$1[($parseInt(parts$1.length) - 1) >> 0]) >> 0
        );
      }
      _tmp = "";
      _tmp$1 = "";
      file = _tmp;
      funcName = _tmp$1;
      _tmp$2 = 0;
      _tmp$3 = 0;
      line = _tmp$2;
      col = _tmp$3;
      pos = info.substring(
        (openIdx + 1) >> 0,
        $parseInt(info.indexOf($externalize(")", $String))) >> 0
      );
      parts$2 = pos.split($externalize(":", $String));
      if ($internalize(pos, $String) === "<anonymous>") {
        file = "<anonymous>";
      } else {
        file = $internalize(
          parts$2
            .slice(0, ($parseInt(parts$2.length) - 2) >> 0)
            .join($externalize(":", $String)),
          $String
        );
        line = $parseInt(parts$2[($parseInt(parts$2.length) - 2) >> 0]) >> 0;
        col = $parseInt(parts$2[($parseInt(parts$2.length) - 1) >> 0]) >> 0;
      }
      fn = info.substring(
        (($parseInt(info.indexOf($externalize("at ", $String))) >> 0) + 3) >> 0,
        $parseInt(info.indexOf($externalize(" (", $String))) >> 0
      );
      idx = $parseInt(fn.indexOf($externalize("[as ", $String))) >> 0;
      if (idx > 0) {
        fn = fn.substring(
          (idx + 4) >> 0,
          fn.indexOf($externalize("]", $String))
        );
      }
      funcName = $internalize(fn, $String);
      return new basicFrame.ptr(funcName, file, line, col);
    };
    $pkg.ParseCallFrame = ParseCallFrame;
    Caller = function (skip) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        file,
        frames,
        line,
        ok,
        pc,
        skip;
      pc = 0;
      file = "";
      line = 0;
      ok = false;
      skip = (skip + 1) >> 0;
      frames = callstack(skip, 1);
      if (!(frames.$length === 1)) {
        _tmp = 0;
        _tmp$1 = "";
        _tmp$2 = 0;
        _tmp$3 = false;
        pc = _tmp;
        file = _tmp$1;
        line = _tmp$2;
        ok = _tmp$3;
        return [pc, file, line, ok];
      }
      pc = registerPosition(
        (0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
        ).FuncName,
        (0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
        ).File,
        (0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
        ).Line,
        (0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
        ).Col
      );
      _tmp$4 = pc;
      _tmp$5 = (
        0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
      ).File;
      _tmp$6 = (
        0 >= frames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : frames.$array[frames.$offset + 0]
      ).Line;
      _tmp$7 = true;
      pc = _tmp$4;
      file = _tmp$5;
      line = _tmp$6;
      ok = _tmp$7;
      return [pc, file, line, ok];
    };
    $pkg.Caller = Caller;
    SetFinalizer = function (x, f) {
      var f, x;
    };
    $pkg.SetFinalizer = SetFinalizer;
    Func.ptr.prototype.Entry = function () {
      return 0;
    };
    Func.prototype.Entry = function () {
      return this.$val.Entry();
    };
    Func.ptr.prototype.FileLine = function (pc) {
      var _tmp, _tmp$1, _tmp$2, _tmp$3, f, file, line, pc;
      file = "";
      line = 0;
      f = this;
      if (f === ptrType.nil) {
        _tmp = "";
        _tmp$1 = 0;
        file = _tmp;
        line = _tmp$1;
        return [file, line];
      }
      _tmp$2 = f.file;
      _tmp$3 = f.line;
      file = _tmp$2;
      line = _tmp$3;
      return [file, line];
    };
    Func.prototype.FileLine = function (pc) {
      return this.$val.FileLine(pc);
    };
    Func.ptr.prototype.Name = function () {
      var f;
      f = this;
      if (f === ptrType.nil || f.name === "") {
        return "<unknown>";
      }
      return f.name;
    };
    Func.prototype.Name = function () {
      return this.$val.Name();
    };
    FuncForPC = function (pc) {
      var ipc, pc;
      ipc = pc >> 0;
      if (ipc >= positionCounters.$length) {
        $panic(
          new $String(
            "GopherJS: pc=" +
              itoa(ipc) +
              " is out of range of known position counters"
          )
        );
      }
      return ipc < 0 || ipc >= positionCounters.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : positionCounters.$array[positionCounters.$offset + ipc];
    };
    $pkg.FuncForPC = FuncForPC;
    KeepAlive = function (param) {
      var param;
    };
    $pkg.KeepAlive = KeepAlive;
    errorString.prototype.RuntimeError = function () {
      var e;
      e = this.$val;
    };
    $ptrType(errorString).prototype.RuntimeError = function () {
      return new errorString(this.$get()).RuntimeError();
    };
    errorString.prototype.Error = function () {
      var e;
      e = this.$val;
      return "runtime error: " + e;
    };
    $ptrType(errorString).prototype.Error = function () {
      return new errorString(this.$get()).Error();
    };
    throw$1 = function (s) {
      var s;
      $panic(new errorString(s));
    };
    nanotime = function () {
      return $mul64(
        $internalize(new $global.Date().getTime(), $Int64),
        new $Int64(0, 1000000)
      );
    };
    $linknames["runtime.nanotime"] = nanotime;
    fastrand = function () {
      return ($parseFloat($global.Math.random()) * 4.294967295e9) >> 0;
    };
    $linknames["runtime.fastrand"] = fastrand;
    ptrType$1.methods = [
      {
        prop: "string",
        name: "string",
        pkg: "runtime",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "pkgpath",
        name: "pkgpath",
        pkg: "runtime",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$2.methods = [
      {
        prop: "RuntimeError",
        name: "RuntimeError",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType.methods = [
      {
        prop: "Entry",
        name: "Entry",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "FileLine",
        name: "FileLine",
        pkg: "",
        typ: $funcType([$Uintptr], [$String, $Int], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    errorString.methods = [
      {
        prop: "RuntimeError",
        name: "RuntimeError",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Error.init([
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "RuntimeError",
        name: "RuntimeError",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ]);
    _type.init("runtime", [
      {
        prop: "str",
        name: "str",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    TypeAssertionError.init("runtime", [
      {
        prop: "_interface",
        name: "_interface",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "concrete",
        name: "concrete",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "asserted",
        name: "asserted",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "missingMethod",
        name: "missingMethod",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    basicFrame.init("", [
      {
        prop: "FuncName",
        name: "FuncName",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "File",
        name: "File",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Line",
        name: "Line",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Col",
        name: "Col",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    Func.init("runtime", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "file",
        name: "file",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "line",
        name: "line",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "opaque",
        name: "opaque",
        embedded: false,
        exported: false,
        typ: structType,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            buildVersion = "";
            knownPositions = $makeMap($String.keyFor, []);
            positionCounters = new sliceType([]);
            hiddenFrames = $makeMap($String.keyFor, [
              { k: "$callDeferred", v: true },
            ]);
            knownFrames = $makeMap($String.keyFor, [
              { k: "$panic", v: "runtime.gopanic" },
              { k: "$goroutine", v: "runtime.goexit" },
            ]);
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/goarch"] = (function () {
    var $pkg = {},
      $init;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/unsafeheader"] = (function () {
    var $pkg = {},
      $init,
      Slice;
    Slice = $pkg.Slice = $newType(
      0,
      $kindStruct,
      "unsafeheader.Slice",
      true,
      "internal/unsafeheader",
      true,
      function (Data_, Len_, Cap_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Data = 0;
          this.Len = 0;
          this.Cap = 0;
          return;
        }
        this.Data = Data_;
        this.Len = Len_;
        this.Cap = Cap_;
      }
    );
    Slice.init("", [
      {
        prop: "Data",
        name: "Data",
        embedded: false,
        exported: true,
        typ: $UnsafePointer,
        tag: "",
      },
      {
        prop: "Len",
        name: "Len",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Cap",
        name: "Cap",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/reflectlite"] = (function () {
    var $pkg = {},
      $init,
      js,
      goarch,
      unsafeheader,
      runtime,
      Value,
      flag,
      ValueError,
      Type,
      Kind,
      tflag,
      rtype,
      method,
      chanDir,
      arrayType,
      chanType,
      imethod,
      interfaceType,
      mapType,
      ptrType,
      sliceType,
      structField,
      structType,
      nameOff,
      typeOff,
      textOff,
      errorString,
      Method,
      uncommonType,
      funcType,
      name,
      nameData,
      mapIter,
      TypeEx,
      ptrType$1,
      sliceType$1,
      sliceType$2,
      sliceType$3,
      sliceType$4,
      ptrType$2,
      funcType$1,
      ptrType$4,
      sliceType$5,
      ptrType$5,
      sliceType$6,
      ptrType$6,
      ptrType$7,
      sliceType$7,
      sliceType$8,
      sliceType$9,
      sliceType$10,
      ptrType$8,
      structType$2,
      ptrType$9,
      arrayType$2,
      sliceType$13,
      ptrType$10,
      funcType$2,
      ptrType$11,
      funcType$3,
      ptrType$12,
      ptrType$13,
      kindNames,
      callHelper,
      initialized,
      uint8Type,
      idJsType,
      idReflectType,
      idKindType,
      idRtype,
      uncommonTypeMap,
      nameMap,
      nameOffList,
      typeOffList,
      jsObjectPtr,
      selectHelper,
      implements$1,
      directlyAssignable,
      haveIdenticalType,
      haveIdenticalUnderlyingType,
      toType,
      ifaceIndir,
      unquote,
      init,
      jsType,
      reflectType,
      setKindType,
      newName,
      newNameOff,
      newTypeOff,
      internalStr,
      isWrapped,
      copyStruct,
      makeValue,
      TypeOf,
      ValueOf,
      FuncOf,
      SliceOf,
      unsafe_New,
      typedmemmove,
      keyFor,
      mapaccess,
      mapiterinit,
      mapiterkey,
      mapiternext,
      maplen,
      methodReceiver,
      valueInterface,
      ifaceE2I,
      methodName,
      makeMethodValue,
      wrapJsObject,
      unwrapJsObject,
      getJsTag,
      PtrTo,
      copyVal;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    goarch = $packages["internal/goarch"];
    unsafeheader = $packages["internal/unsafeheader"];
    runtime = $packages["runtime"];
    Value = $pkg.Value = $newType(
      0,
      $kindStruct,
      "reflectlite.Value",
      true,
      "internal/reflectlite",
      true,
      function (typ_, ptr_, flag_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.typ = ptrType$1.nil;
          this.ptr = 0;
          this.flag = 0;
          return;
        }
        this.typ = typ_;
        this.ptr = ptr_;
        this.flag = flag_;
      }
    );
    flag = $pkg.flag = $newType(
      4,
      $kindUintptr,
      "reflectlite.flag",
      true,
      "internal/reflectlite",
      false,
      null
    );
    ValueError = $pkg.ValueError = $newType(
      0,
      $kindStruct,
      "reflectlite.ValueError",
      true,
      "internal/reflectlite",
      true,
      function (Method_, Kind_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Method = "";
          this.Kind = 0;
          return;
        }
        this.Method = Method_;
        this.Kind = Kind_;
      }
    );
    Type = $pkg.Type = $newType(
      8,
      $kindInterface,
      "reflectlite.Type",
      true,
      "internal/reflectlite",
      true,
      null
    );
    Kind = $pkg.Kind = $newType(
      4,
      $kindUint,
      "reflectlite.Kind",
      true,
      "internal/reflectlite",
      true,
      null
    );
    tflag = $pkg.tflag = $newType(
      1,
      $kindUint8,
      "reflectlite.tflag",
      true,
      "internal/reflectlite",
      false,
      null
    );
    rtype = $pkg.rtype = $newType(
      0,
      $kindStruct,
      "reflectlite.rtype",
      true,
      "internal/reflectlite",
      false,
      function (
        size_,
        ptrdata_,
        hash_,
        tflag_,
        align_,
        fieldAlign_,
        kind_,
        equal_,
        gcdata_,
        str_,
        ptrToThis_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.size = 0;
          this.ptrdata = 0;
          this.hash = 0;
          this.tflag = 0;
          this.align = 0;
          this.fieldAlign = 0;
          this.kind = 0;
          this.equal = $throwNilPointerError;
          this.gcdata = ptrType$6.nil;
          this.str = 0;
          this.ptrToThis = 0;
          return;
        }
        this.size = size_;
        this.ptrdata = ptrdata_;
        this.hash = hash_;
        this.tflag = tflag_;
        this.align = align_;
        this.fieldAlign = fieldAlign_;
        this.kind = kind_;
        this.equal = equal_;
        this.gcdata = gcdata_;
        this.str = str_;
        this.ptrToThis = ptrToThis_;
      }
    );
    method = $pkg.method = $newType(
      0,
      $kindStruct,
      "reflectlite.method",
      true,
      "internal/reflectlite",
      false,
      function (name_, mtyp_, ifn_, tfn_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = 0;
          this.mtyp = 0;
          this.ifn = 0;
          this.tfn = 0;
          return;
        }
        this.name = name_;
        this.mtyp = mtyp_;
        this.ifn = ifn_;
        this.tfn = tfn_;
      }
    );
    chanDir = $pkg.chanDir = $newType(
      4,
      $kindInt,
      "reflectlite.chanDir",
      true,
      "internal/reflectlite",
      false,
      null
    );
    arrayType = $pkg.arrayType = $newType(
      0,
      $kindStruct,
      "reflectlite.arrayType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, elem_, slice_, len_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          this.slice = ptrType$1.nil;
          this.len = 0;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
        this.slice = slice_;
        this.len = len_;
      }
    );
    chanType = $pkg.chanType = $newType(
      0,
      $kindStruct,
      "reflectlite.chanType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, elem_, dir_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          this.dir = 0;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
        this.dir = dir_;
      }
    );
    imethod = $pkg.imethod = $newType(
      0,
      $kindStruct,
      "reflectlite.imethod",
      true,
      "internal/reflectlite",
      false,
      function (name_, typ_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = 0;
          this.typ = 0;
          return;
        }
        this.name = name_;
        this.typ = typ_;
      }
    );
    interfaceType = $pkg.interfaceType = $newType(
      0,
      $kindStruct,
      "reflectlite.interfaceType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, pkgPath_, methods_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.pkgPath = new name.ptr(ptrType$6.nil);
          this.methods = sliceType$9.nil;
          return;
        }
        this.rtype = rtype_;
        this.pkgPath = pkgPath_;
        this.methods = methods_;
      }
    );
    mapType = $pkg.mapType = $newType(
      0,
      $kindStruct,
      "reflectlite.mapType",
      true,
      "internal/reflectlite",
      false,
      function (
        rtype_,
        key_,
        elem_,
        bucket_,
        hasher_,
        keysize_,
        valuesize_,
        bucketsize_,
        flags_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.key = ptrType$1.nil;
          this.elem = ptrType$1.nil;
          this.bucket = ptrType$1.nil;
          this.hasher = $throwNilPointerError;
          this.keysize = 0;
          this.valuesize = 0;
          this.bucketsize = 0;
          this.flags = 0;
          return;
        }
        this.rtype = rtype_;
        this.key = key_;
        this.elem = elem_;
        this.bucket = bucket_;
        this.hasher = hasher_;
        this.keysize = keysize_;
        this.valuesize = valuesize_;
        this.bucketsize = bucketsize_;
        this.flags = flags_;
      }
    );
    ptrType = $pkg.ptrType = $newType(
      0,
      $kindStruct,
      "reflectlite.ptrType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, elem_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
      }
    );
    sliceType = $pkg.sliceType = $newType(
      0,
      $kindStruct,
      "reflectlite.sliceType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, elem_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
      }
    );
    structField = $pkg.structField = $newType(
      0,
      $kindStruct,
      "reflectlite.structField",
      true,
      "internal/reflectlite",
      false,
      function (name_, typ_, offsetEmbed_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = new name.ptr(ptrType$6.nil);
          this.typ = ptrType$1.nil;
          this.offsetEmbed = 0;
          return;
        }
        this.name = name_;
        this.typ = typ_;
        this.offsetEmbed = offsetEmbed_;
      }
    );
    structType = $pkg.structType = $newType(
      0,
      $kindStruct,
      "reflectlite.structType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, pkgPath_, fields_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.pkgPath = new name.ptr(ptrType$6.nil);
          this.fields = sliceType$10.nil;
          return;
        }
        this.rtype = rtype_;
        this.pkgPath = pkgPath_;
        this.fields = fields_;
      }
    );
    nameOff = $pkg.nameOff = $newType(
      4,
      $kindInt32,
      "reflectlite.nameOff",
      true,
      "internal/reflectlite",
      false,
      null
    );
    typeOff = $pkg.typeOff = $newType(
      4,
      $kindInt32,
      "reflectlite.typeOff",
      true,
      "internal/reflectlite",
      false,
      null
    );
    textOff = $pkg.textOff = $newType(
      4,
      $kindInt32,
      "reflectlite.textOff",
      true,
      "internal/reflectlite",
      false,
      null
    );
    errorString = $pkg.errorString = $newType(
      0,
      $kindStruct,
      "reflectlite.errorString",
      true,
      "internal/reflectlite",
      false,
      function (s_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.s = "";
          return;
        }
        this.s = s_;
      }
    );
    Method = $pkg.Method = $newType(
      0,
      $kindStruct,
      "reflectlite.Method",
      true,
      "internal/reflectlite",
      true,
      function (Name_, PkgPath_, Type_, Func_, Index_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Name = "";
          this.PkgPath = "";
          this.Type = $ifaceNil;
          this.Func = new Value.ptr(ptrType$1.nil, 0, 0);
          this.Index = 0;
          return;
        }
        this.Name = Name_;
        this.PkgPath = PkgPath_;
        this.Type = Type_;
        this.Func = Func_;
        this.Index = Index_;
      }
    );
    uncommonType = $pkg.uncommonType = $newType(
      0,
      $kindStruct,
      "reflectlite.uncommonType",
      true,
      "internal/reflectlite",
      false,
      function (pkgPath_, mcount_, xcount_, moff_, _methods_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.pkgPath = 0;
          this.mcount = 0;
          this.xcount = 0;
          this.moff = 0;
          this._methods = sliceType$5.nil;
          return;
        }
        this.pkgPath = pkgPath_;
        this.mcount = mcount_;
        this.xcount = xcount_;
        this.moff = moff_;
        this._methods = _methods_;
      }
    );
    funcType = $pkg.funcType = $newType(
      0,
      $kindStruct,
      "reflectlite.funcType",
      true,
      "internal/reflectlite",
      false,
      function (rtype_, inCount_, outCount_, _in_, _out_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$6.nil,
            0,
            0
          );
          this.inCount = 0;
          this.outCount = 0;
          this._in = sliceType$2.nil;
          this._out = sliceType$2.nil;
          return;
        }
        this.rtype = rtype_;
        this.inCount = inCount_;
        this.outCount = outCount_;
        this._in = _in_;
        this._out = _out_;
      }
    );
    name = $pkg.name = $newType(
      0,
      $kindStruct,
      "reflectlite.name",
      true,
      "internal/reflectlite",
      false,
      function (bytes_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.bytes = ptrType$6.nil;
          return;
        }
        this.bytes = bytes_;
      }
    );
    nameData = $pkg.nameData = $newType(
      0,
      $kindStruct,
      "reflectlite.nameData",
      true,
      "internal/reflectlite",
      false,
      function (name_, tag_, exported_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.tag = "";
          this.exported = false;
          return;
        }
        this.name = name_;
        this.tag = tag_;
        this.exported = exported_;
      }
    );
    mapIter = $pkg.mapIter = $newType(
      0,
      $kindStruct,
      "reflectlite.mapIter",
      true,
      "internal/reflectlite",
      false,
      function (t_, m_, keys_, i_, last_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.t = $ifaceNil;
          this.m = null;
          this.keys = null;
          this.i = 0;
          this.last = null;
          return;
        }
        this.t = t_;
        this.m = m_;
        this.keys = keys_;
        this.i = i_;
        this.last = last_;
      }
    );
    TypeEx = $pkg.TypeEx = $newType(
      8,
      $kindInterface,
      "reflectlite.TypeEx",
      true,
      "internal/reflectlite",
      true,
      null
    );
    ptrType$1 = $ptrType(rtype);
    sliceType$1 = $sliceType(name);
    sliceType$2 = $sliceType(ptrType$1);
    sliceType$3 = $sliceType($String);
    sliceType$4 = $sliceType($emptyInterface);
    ptrType$2 = $ptrType(js.Object);
    funcType$1 = $funcType([sliceType$4], [ptrType$2], true);
    ptrType$4 = $ptrType(uncommonType);
    sliceType$5 = $sliceType(method);
    ptrType$5 = $ptrType(funcType);
    sliceType$6 = $sliceType(Value);
    ptrType$6 = $ptrType($Uint8);
    ptrType$7 = $ptrType($UnsafePointer);
    sliceType$7 = $sliceType(Type);
    sliceType$8 = $sliceType(ptrType$2);
    sliceType$9 = $sliceType(imethod);
    sliceType$10 = $sliceType(structField);
    ptrType$8 = $ptrType(nameData);
    structType$2 = $structType("internal/reflectlite", [
      {
        prop: "str",
        name: "str",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    ptrType$9 = $ptrType(mapIter);
    arrayType$2 = $arrayType($Uintptr, 2);
    sliceType$13 = $sliceType($Uint8);
    ptrType$10 = $ptrType(ValueError);
    funcType$2 = $funcType([$UnsafePointer, $UnsafePointer], [$Bool], false);
    ptrType$11 = $ptrType(interfaceType);
    funcType$3 = $funcType([$UnsafePointer, $Uintptr], [$Uintptr], false);
    ptrType$12 = $ptrType(structField);
    ptrType$13 = $ptrType(errorString);
    flag.prototype.kind = function () {
      var f;
      f = this.$val;
      return ((f & 31) >>> 0) >>> 0;
    };
    $ptrType(flag).prototype.kind = function () {
      return new flag(this.$get()).kind();
    };
    flag.prototype.ro = function () {
      var f;
      f = this.$val;
      if (!((f & 96) >>> 0 === 0)) {
        return 32;
      }
      return 0;
    };
    $ptrType(flag).prototype.ro = function () {
      return new flag(this.$get()).ro();
    };
    Value.ptr.prototype.pointer = function () {
      var v;
      v = this;
      if (!(v.typ.size === 4) || !v.typ.pointers()) {
        $panic(new $String("can't call pointer on a non-pointer Value"));
      }
      if (!((v.flag & 128) >>> 0 === 0)) {
        return v.ptr.$get();
      }
      return v.ptr;
    };
    Value.prototype.pointer = function () {
      return this.$val.pointer();
    };
    ValueError.ptr.prototype.Error = function () {
      var e;
      e = this;
      if (e.Kind === 0) {
        return "reflect: call of " + e.Method + " on zero Value";
      }
      return (
        "reflect: call of " +
        e.Method +
        " on " +
        new Kind(e.Kind).String() +
        " Value"
      );
    };
    ValueError.prototype.Error = function () {
      return this.$val.Error();
    };
    flag.prototype.mustBeExported = function () {
      var f;
      f = this.$val;
      if (f === 0) {
        $panic(new ValueError.ptr(methodName(), 0));
      }
      if (!((f & 96) >>> 0 === 0)) {
        $panic(
          new $String(
            "reflect: " +
              methodName() +
              " using value obtained using unexported field"
          )
        );
      }
    };
    $ptrType(flag).prototype.mustBeExported = function () {
      return new flag(this.$get()).mustBeExported();
    };
    flag.prototype.mustBeAssignable = function () {
      var f;
      f = this.$val;
      if (f === 0) {
        $panic(new ValueError.ptr(methodName(), 0));
      }
      if (!((f & 96) >>> 0 === 0)) {
        $panic(
          new $String(
            "reflect: " +
              methodName() +
              " using value obtained using unexported field"
          )
        );
      }
      if ((f & 256) >>> 0 === 0) {
        $panic(
          new $String("reflect: " + methodName() + " using unaddressable value")
        );
      }
    };
    $ptrType(flag).prototype.mustBeAssignable = function () {
      return new flag(this.$get()).mustBeAssignable();
    };
    Value.ptr.prototype.CanSet = function () {
      var v;
      v = this;
      return (v.flag & 352) >>> 0 === 256;
    };
    Value.prototype.CanSet = function () {
      return this.$val.CanSet();
    };
    Value.ptr.prototype.IsValid = function () {
      var v;
      v = this;
      return !(v.flag === 0);
    };
    Value.prototype.IsValid = function () {
      return this.$val.IsValid();
    };
    Value.ptr.prototype.Kind = function () {
      var v;
      v = this;
      return new flag(v.flag).kind();
    };
    Value.prototype.Kind = function () {
      return this.$val.Kind();
    };
    Value.ptr.prototype.Type = function () {
      var f, v;
      v = this;
      f = v.flag;
      if (f === 0) {
        $panic(new ValueError.ptr("reflectlite.Value.Type", 0));
      }
      return v.typ;
    };
    Value.prototype.Type = function () {
      return this.$val.Type();
    };
    structField.ptr.prototype.embedded = function () {
      var f;
      f = this;
      return !((f.offsetEmbed & 1) >>> 0 === 0);
    };
    structField.prototype.embedded = function () {
      return this.$val.embedded();
    };
    Kind.prototype.String = function () {
      var k;
      k = this.$val;
      if (k >> 0 < kindNames.$length) {
        return k < 0 || k >= kindNames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : kindNames.$array[kindNames.$offset + k];
      }
      return 0 >= kindNames.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : kindNames.$array[kindNames.$offset + 0];
    };
    $ptrType(Kind).prototype.String = function () {
      return new Kind(this.$get()).String();
    };
    rtype.ptr.prototype.String = function () {
      var s, t;
      t = this;
      s = $clone(t.nameOff(t.str), name).name();
      if (!((t.tflag & 2) >>> 0 === 0)) {
        return $substring(s, 1);
      }
      return s;
    };
    rtype.prototype.String = function () {
      return this.$val.String();
    };
    rtype.ptr.prototype.Size = function () {
      var t;
      t = this;
      return t.size;
    };
    rtype.prototype.Size = function () {
      return this.$val.Size();
    };
    rtype.ptr.prototype.Kind = function () {
      var t;
      t = this;
      return ((t.kind & 31) >>> 0) >>> 0;
    };
    rtype.prototype.Kind = function () {
      return this.$val.Kind();
    };
    rtype.ptr.prototype.pointers = function () {
      var t;
      t = this;
      return !(t.ptrdata === 0);
    };
    rtype.prototype.pointers = function () {
      return this.$val.pointers();
    };
    rtype.ptr.prototype.common = function () {
      var t;
      t = this;
      return t;
    };
    rtype.prototype.common = function () {
      return this.$val.common();
    };
    rtype.ptr.prototype.exportedMethods = function () {
      var t, ut;
      t = this;
      ut = t.uncommon();
      if (ut === ptrType$4.nil) {
        return sliceType$5.nil;
      }
      return ut.exportedMethods();
    };
    rtype.prototype.exportedMethods = function () {
      return this.$val.exportedMethods();
    };
    rtype.ptr.prototype.NumMethod = function () {
      var t, tt;
      t = this;
      if (t.Kind() === 20) {
        tt = t.kindType;
        return tt.NumMethod();
      }
      return t.exportedMethods().$length;
    };
    rtype.prototype.NumMethod = function () {
      return this.$val.NumMethod();
    };
    rtype.ptr.prototype.PkgPath = function () {
      var t, ut;
      t = this;
      if ((t.tflag & 4) >>> 0 === 0) {
        return "";
      }
      ut = t.uncommon();
      if (ut === ptrType$4.nil) {
        return "";
      }
      return $clone(t.nameOff(ut.pkgPath), name).name();
    };
    rtype.prototype.PkgPath = function () {
      return this.$val.PkgPath();
    };
    rtype.ptr.prototype.hasName = function () {
      var t;
      t = this;
      return !((t.tflag & 4) >>> 0 === 0);
    };
    rtype.prototype.hasName = function () {
      return this.$val.hasName();
    };
    rtype.ptr.prototype.Name = function () {
      var i, s, t;
      t = this;
      if (!t.hasName()) {
        return "";
      }
      s = t.String();
      i = (s.length - 1) >> 0;
      while (true) {
        if (!(i >= 0 && !(s.charCodeAt(i) === 46))) {
          break;
        }
        i = (i - 1) >> 0;
      }
      return $substring(s, (i + 1) >> 0);
    };
    rtype.prototype.Name = function () {
      return this.$val.Name();
    };
    rtype.ptr.prototype.chanDir = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 18)) {
        $panic(new $String("reflect: chanDir of non-chan type"));
      }
      tt = t.kindType;
      return tt.dir >> 0;
    };
    rtype.prototype.chanDir = function () {
      return this.$val.chanDir();
    };
    rtype.ptr.prototype.Elem = function () {
      var _1, t, tt, tt$1, tt$2, tt$3, tt$4;
      t = this;
      _1 = t.Kind();
      if (_1 === 17) {
        tt = t.kindType;
        return toType(tt.elem);
      } else if (_1 === 18) {
        tt$1 = t.kindType;
        return toType(tt$1.elem);
      } else if (_1 === 21) {
        tt$2 = t.kindType;
        return toType(tt$2.elem);
      } else if (_1 === 22) {
        tt$3 = t.kindType;
        return toType(tt$3.elem);
      } else if (_1 === 23) {
        tt$4 = t.kindType;
        return toType(tt$4.elem);
      }
      $panic(new $String("reflect: Elem of invalid type"));
    };
    rtype.prototype.Elem = function () {
      return this.$val.Elem();
    };
    rtype.ptr.prototype.In = function (i) {
      var i, t, tt, x;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: In of non-func type"));
      }
      tt = t.kindType;
      return toType(
        ((x = tt.in$()),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i])
      );
    };
    rtype.prototype.In = function (i) {
      return this.$val.In(i);
    };
    rtype.ptr.prototype.Len = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 17)) {
        $panic(new $String("reflect: Len of non-array type"));
      }
      tt = t.kindType;
      return tt.len >> 0;
    };
    rtype.prototype.Len = function () {
      return this.$val.Len();
    };
    rtype.ptr.prototype.NumIn = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: NumIn of non-func type"));
      }
      tt = t.kindType;
      return tt.inCount >> 0;
    };
    rtype.prototype.NumIn = function () {
      return this.$val.NumIn();
    };
    rtype.ptr.prototype.NumOut = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: NumOut of non-func type"));
      }
      tt = t.kindType;
      return tt.out().$length;
    };
    rtype.prototype.NumOut = function () {
      return this.$val.NumOut();
    };
    rtype.ptr.prototype.Out = function (i) {
      var i, t, tt, x;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: Out of non-func type"));
      }
      tt = t.kindType;
      return toType(
        ((x = tt.out()),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i])
      );
    };
    rtype.prototype.Out = function (i) {
      return this.$val.Out(i);
    };
    interfaceType.ptr.prototype.NumMethod = function () {
      var t;
      t = this;
      return t.methods.$length;
    };
    interfaceType.prototype.NumMethod = function () {
      return this.$val.NumMethod();
    };
    rtype.ptr.prototype.Implements = function (u) {
      var { _r, t, u, $s, $r, $c } = $restore(this, { u });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($interfaceIsEqual(u, $ifaceNil)) {
              $panic(
                new $String("reflect: nil type passed to Type.Implements")
              );
            }
            _r = u.Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 20)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 20))) { */ case 1:
            $panic(
              new $String(
                "reflect: non-interface type passed to Type.Implements"
              )
            );
          /* } */ case 2:
            $s = -1;
            return implements$1($assertType(u, ptrType$1), t);
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Implements,
        $c: true,
        $r,
        _r,
        t,
        u,
        $s,
      };
      return $f;
    };
    rtype.prototype.Implements = function (u) {
      return this.$val.Implements(u);
    };
    rtype.ptr.prototype.AssignableTo = function (u) {
      var { $24r, _r, t, u, uu, $s, $r, $c } = $restore(this, { u });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($interfaceIsEqual(u, $ifaceNil)) {
              $panic(
                new $String("reflect: nil type passed to Type.AssignableTo")
              );
            }
            uu = $assertType(u, ptrType$1);
            _r = directlyAssignable(uu, t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r || implements$1(uu, t);
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.AssignableTo,
        $c: true,
        $r,
        $24r,
        _r,
        t,
        u,
        uu,
        $s,
      };
      return $f;
    };
    rtype.prototype.AssignableTo = function (u) {
      return this.$val.AssignableTo(u);
    };
    implements$1 = function (T, V) {
      var T,
        V,
        i,
        i$1,
        j,
        j$1,
        t,
        tm,
        tm$1,
        tmName,
        tmName$1,
        tmPkgPath,
        tmPkgPath$1,
        v,
        v$1,
        vm,
        vm$1,
        vmName,
        vmName$1,
        vmPkgPath,
        vmPkgPath$1,
        vmethods,
        x,
        x$1,
        x$2;
      if (!(T.Kind() === 20)) {
        return false;
      }
      t = T.kindType;
      if (t.methods.$length === 0) {
        return true;
      }
      if (V.Kind() === 20) {
        v = V.kindType;
        i = 0;
        j = 0;
        while (true) {
          if (!(j < v.methods.$length)) {
            break;
          }
          tm =
            ((x = t.methods),
            i < 0 || i >= x.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x.$array[x.$offset + i]);
          tmName = $clone(t.rtype.nameOff(tm.name), name);
          vm =
            ((x$1 = v.methods),
            j < 0 || j >= x$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$1.$array[x$1.$offset + j]);
          vmName = $clone(V.nameOff(vm.name), name);
          if (
            $clone(vmName, name).name() === $clone(tmName, name).name() &&
            V.typeOff(vm.typ) === t.rtype.typeOff(tm.typ)
          ) {
            if (!$clone(tmName, name).isExported()) {
              tmPkgPath = $clone(tmName, name).pkgPath();
              if (tmPkgPath === "") {
                tmPkgPath = $clone(t.pkgPath, name).name();
              }
              vmPkgPath = $clone(vmName, name).pkgPath();
              if (vmPkgPath === "") {
                vmPkgPath = $clone(v.pkgPath, name).name();
              }
              if (!(tmPkgPath === vmPkgPath)) {
                j = (j + 1) >> 0;
                continue;
              }
            }
            i = (i + 1) >> 0;
            if (i >= t.methods.$length) {
              return true;
            }
          }
          j = (j + 1) >> 0;
        }
        return false;
      }
      v$1 = V.uncommon();
      if (v$1 === ptrType$4.nil) {
        return false;
      }
      i$1 = 0;
      vmethods = v$1.methods();
      j$1 = 0;
      while (true) {
        if (!(j$1 < v$1.mcount >> 0)) {
          break;
        }
        tm$1 =
          ((x$2 = t.methods),
          i$1 < 0 || i$1 >= x$2.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x$2.$array[x$2.$offset + i$1]);
        tmName$1 = $clone(t.rtype.nameOff(tm$1.name), name);
        vm$1 = $clone(
          j$1 < 0 || j$1 >= vmethods.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : vmethods.$array[vmethods.$offset + j$1],
          method
        );
        vmName$1 = $clone(V.nameOff(vm$1.name), name);
        if (
          $clone(vmName$1, name).name() === $clone(tmName$1, name).name() &&
          V.typeOff(vm$1.mtyp) === t.rtype.typeOff(tm$1.typ)
        ) {
          if (!$clone(tmName$1, name).isExported()) {
            tmPkgPath$1 = $clone(tmName$1, name).pkgPath();
            if (tmPkgPath$1 === "") {
              tmPkgPath$1 = $clone(t.pkgPath, name).name();
            }
            vmPkgPath$1 = $clone(vmName$1, name).pkgPath();
            if (vmPkgPath$1 === "") {
              vmPkgPath$1 = $clone(V.nameOff(v$1.pkgPath), name).name();
            }
            if (!(tmPkgPath$1 === vmPkgPath$1)) {
              j$1 = (j$1 + 1) >> 0;
              continue;
            }
          }
          i$1 = (i$1 + 1) >> 0;
          if (i$1 >= t.methods.$length) {
            return true;
          }
        }
        j$1 = (j$1 + 1) >> 0;
      }
      return false;
    };
    directlyAssignable = function (T, V) {
      var { $24r, T, V, _r, $s, $r, $c } = $restore(this, { T, V });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (T === V) {
              $s = -1;
              return true;
            }
            if ((T.hasName() && V.hasName()) || !(T.Kind() === V.Kind())) {
              $s = -1;
              return false;
            }
            _r = haveIdenticalUnderlyingType(T, V, true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: directlyAssignable, $c: true, $r, $24r, T, V, _r, $s };
      return $f;
    };
    haveIdenticalType = function (T, V, cmpTags) {
      var {
        $24r,
        T,
        V,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _v,
        cmpTags,
        $s,
        $r,
        $c,
      } = $restore(this, { T, V, cmpTags });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (cmpTags) {
              $s = -1;
              return $interfaceIsEqual(T, V);
            }
            _r = T.Name();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = V.Name();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            if (!(_r === _r$1)) {
              _v = true;
              $s = 3;
              continue s;
            }
            _r$2 = T.Kind();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$3 = V.Kind();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _v = !(_r$2 === _r$3);
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            $s = -1;
            return false;
          /* } */ case 2:
            _r$4 = T.common();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _arg = _r$4;
            _r$5 = V.common();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r$5;
            _r$6 = haveIdenticalUnderlyingType(_arg, _arg$1, false);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            $24r = _r$6;
            $s = 11;
          case 11:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: haveIdenticalType,
        $c: true,
        $r,
        $24r,
        T,
        V,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _v,
        cmpTags,
        $s,
      };
      return $f;
    };
    haveIdenticalUnderlyingType = function (T, V, cmpTags) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        T,
        V,
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _ref,
        _v,
        _v$1,
        _v$2,
        _v$3,
        cmpTags,
        i,
        i$1,
        i$2,
        kind,
        t,
        t$1,
        t$2,
        tf,
        v,
        v$1,
        v$2,
        vf,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { T, V, cmpTags });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (T === V) {
              $s = -1;
              return true;
            }
            kind = T.Kind();
            if (!(kind === V.Kind())) {
              $s = -1;
              return false;
            }
            if ((1 <= kind && kind <= 16) || kind === 24 || kind === 26) {
              $s = -1;
              return true;
            }
            _1 = kind;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 18) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 19) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 21) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 22 || _1 === 23) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (_1 === (17)) { */ case 2:
            if (!(T.Len() === V.Len())) {
              _v = false;
              $s = 10;
              continue s;
            }
            _r = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 10:
            $24r = _v;
            $s = 12;
          case 12:
            return $24r;
          /* } else if (_1 === (18)) { */ case 3:
            if (!(V.chanDir() === 3)) {
              _v$1 = false;
              $s = 15;
              continue s;
            }
            _r$1 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$1;
          case 15:
            /* */ if (_v$1) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if (_v$1) { */ case 13:
            $s = -1;
            return true;
          /* } */ case 14:
            if (!(V.chanDir() === T.chanDir())) {
              _v$2 = false;
              $s = 17;
              continue s;
            }
            _r$2 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v$2 = _r$2;
          case 17:
            $24r$1 = _v$2;
            $s = 19;
          case 19:
            return $24r$1;
          /* } else if (_1 === (19)) { */ case 4:
            t = T.kindType;
            v = V.kindType;
            if (!(t.outCount === v.outCount) || !(t.inCount === v.inCount)) {
              $s = -1;
              return false;
            }
            i = 0;
          /* while (true) { */ case 20:
            /* if (!(i < t.rtype.NumIn())) { break; } */ if (
              !(i < t.rtype.NumIn())
            ) {
              $s = 21;
              continue;
            }
            _r$3 = haveIdenticalType(t.rtype.In(i), v.rtype.In(i), cmpTags);
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$3) {
              $s = 22;
              continue;
            }
            /* */ $s = 23;
            continue;
          /* if (!_r$3) { */ case 22:
            $s = -1;
            return false;
          /* } */ case 23:
            i = (i + 1) >> 0;
            $s = 20;
            continue;
          case 21:
            i$1 = 0;
          /* while (true) { */ case 25:
            /* if (!(i$1 < t.rtype.NumOut())) { break; } */ if (
              !(i$1 < t.rtype.NumOut())
            ) {
              $s = 26;
              continue;
            }
            _r$4 = haveIdenticalType(
              t.rtype.Out(i$1),
              v.rtype.Out(i$1),
              cmpTags
            );
            /* */ $s = 29;
          case 29:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$4) {
              $s = 27;
              continue;
            }
            /* */ $s = 28;
            continue;
          /* if (!_r$4) { */ case 27:
            $s = -1;
            return false;
          /* } */ case 28:
            i$1 = (i$1 + 1) >> 0;
            $s = 25;
            continue;
          case 26:
            $s = -1;
            return true;
          /* } else if (_1 === (20)) { */ case 5:
            t$1 = T.kindType;
            v$1 = V.kindType;
            if (t$1.methods.$length === 0 && v$1.methods.$length === 0) {
              $s = -1;
              return true;
            }
            $s = -1;
            return false;
          /* } else if (_1 === (21)) { */ case 6:
            _r$5 = haveIdenticalType(T.Key(), V.Key(), cmpTags);
            /* */ $s = 31;
          case 31:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            if (!_r$5) {
              _v$3 = false;
              $s = 30;
              continue s;
            }
            _r$6 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 32;
          case 32:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _v$3 = _r$6;
          case 30:
            $24r$2 = _v$3;
            $s = 33;
          case 33:
            return $24r$2;
          /* } else if ((_1 === (22)) || (_1 === (23))) { */ case 7:
            _r$7 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            $24r$3 = _r$7;
            $s = 35;
          case 35:
            return $24r$3;
          /* } else if (_1 === (25)) { */ case 8:
            t$2 = T.kindType;
            v$2 = V.kindType;
            if (!(t$2.fields.$length === v$2.fields.$length)) {
              $s = -1;
              return false;
            }
            if (
              !(
                $clone(t$2.pkgPath, name).name() ===
                $clone(v$2.pkgPath, name).name()
              )
            ) {
              $s = -1;
              return false;
            }
            _ref = t$2.fields;
            _i = 0;
          /* while (true) { */ case 36:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 37;
              continue;
            }
            i$2 = _i;
            tf =
              ((x = t$2.fields),
              i$2 < 0 || i$2 >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + i$2]);
            vf =
              ((x$1 = v$2.fields),
              i$2 < 0 || i$2 >= x$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1.$array[x$1.$offset + i$2]);
            if (
              !($clone(tf.name, name).name() === $clone(vf.name, name).name())
            ) {
              $s = -1;
              return false;
            }
            _r$8 = haveIdenticalType(tf.typ, vf.typ, cmpTags);
            /* */ $s = 40;
          case 40:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$8) {
              $s = 38;
              continue;
            }
            /* */ $s = 39;
            continue;
          /* if (!_r$8) { */ case 38:
            $s = -1;
            return false;
          /* } */ case 39:
            if (
              cmpTags &&
              !($clone(tf.name, name).tag() === $clone(vf.name, name).tag())
            ) {
              $s = -1;
              return false;
            }
            if (!(tf.offsetEmbed === vf.offsetEmbed)) {
              $s = -1;
              return false;
            }
            _i++;
            $s = 36;
            continue;
          case 37:
            $s = -1;
            return true;
          /* } */ case 9:
          case 1:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: haveIdenticalUnderlyingType,
        $c: true,
        $r,
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        T,
        V,
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _ref,
        _v,
        _v$1,
        _v$2,
        _v$3,
        cmpTags,
        i,
        i$1,
        i$2,
        kind,
        t,
        t$1,
        t$2,
        tf,
        v,
        v$1,
        v$2,
        vf,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    toType = function (t) {
      var t;
      if (t === ptrType$1.nil) {
        return $ifaceNil;
      }
      return t;
    };
    ifaceIndir = function (t) {
      var t;
      return (t.kind & 32) >>> 0 === 0;
    };
    Value.ptr.prototype.object = function () {
      var _1, newVal, v, val;
      v = this;
      if (v.typ.Kind() === 17 || v.typ.Kind() === 25) {
        return v.ptr;
      }
      if (!((v.flag & 128) >>> 0 === 0)) {
        val = v.ptr.$get();
        if (!(val === $ifaceNil) && !(val.constructor === jsType(v.typ))) {
          switch (0) {
            default:
              _1 = v.typ.Kind();
              if (_1 === 11 || _1 === 6) {
                val = new (jsType(v.typ))(val.$high, val.$low);
              } else if (_1 === 15 || _1 === 16) {
                val = new (jsType(v.typ))(val.$real, val.$imag);
              } else if (_1 === 23) {
                if (val === val.constructor.nil) {
                  val = jsType(v.typ).nil;
                  break;
                }
                newVal = new (jsType(v.typ))(val.$array);
                newVal.$offset = val.$offset;
                newVal.$length = val.$length;
                newVal.$capacity = val.$capacity;
                val = newVal;
              }
          }
        }
        return val;
      }
      return v.ptr;
    };
    Value.prototype.object = function () {
      return this.$val.object();
    };
    Value.ptr.prototype.assignTo = function (context, dst, target) {
      var { _r, _r$1, _r$2, context, dst, fl, target, v, x, $s, $r, $c } =
        $restore(this, { context, dst, target });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
            _r = makeMethodValue(context, $clone(v, Value));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Value.copy(v, _r);
          /* } */ case 2:
            _r$1 = directlyAssignable(dst, v.typ);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$1) {
              $s = 5;
              continue;
            }
            /* */ if (implements$1(dst, v.typ)) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (_r$1) { */ case 5:
            fl = (((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0;
            fl = (fl | (dst.Kind() >>> 0)) >>> 0;
            $s = -1;
            return new Value.ptr(dst, v.ptr, fl);
          /* } else if (implements$1(dst, v.typ)) { */ case 6:
            if (target === 0) {
              target = unsafe_New(dst);
            }
            _r$2 = valueInterface($clone(v, Value));
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            x = _r$2;
            if (dst.NumMethod() === 0) {
              target.$set(x);
            } else {
              ifaceE2I(dst, x, target);
            }
            $s = -1;
            return new Value.ptr(dst, target, 148);
          /* } */ case 7:
          case 4:
            $panic(
              new $String(
                context +
                  ": value of type " +
                  v.typ.String() +
                  " is not assignable to type " +
                  dst.String()
              )
            );
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.assignTo,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        context,
        dst,
        fl,
        target,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.assignTo = function (context, dst, target) {
      return this.$val.assignTo(context, dst, target);
    };
    Value.ptr.prototype.Cap = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 17) {
        return v.typ.Len();
      } else if (_1 === 18 || _1 === 23) {
        return $parseInt($clone(v, Value).object().$capacity) >> 0;
      }
      $panic(new ValueError.ptr("reflect.Value.Cap", k));
    };
    Value.prototype.Cap = function () {
      return this.$val.Cap();
    };
    Value.ptr.prototype.Index = function (i) {
      var {
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        a,
        a$1,
        c,
        fl,
        fl$1,
        fl$2,
        i,
        k,
        s,
        str,
        tt,
        tt$1,
        typ,
        typ$1,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            a = [a];
            a$1 = [a$1];
            c = [c];
            i = [i];
            typ = [typ];
            typ$1 = [typ$1];
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_1 === (17)) { */ case 2:
            tt = v.typ.kindType;
            if (i[0] < 0 || i[0] > tt.len >> 0) {
              $panic(new $String("reflect: array index out of range"));
            }
            typ[0] = tt.elem;
            fl =
              (((((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0) |
                (typ[0].Kind() >>> 0)) >>>
              0;
            a[0] = v.ptr;
            /* */ if (
              !((fl & 128) >>> 0 === 0) &&
              !(typ[0].Kind() === 17) &&
              !(typ[0].Kind() === 25)
            ) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 7:
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (a, a$1, c, i, typ, typ$1) {
                  return function () {
                    return wrapJsObject(typ[0], a[0][i[0]]);
                  };
                })(a, a$1, c, i, typ, typ$1),
                (function (a, a$1, c, i, typ, typ$1) {
                  return function (x) {
                    var x;
                    a[0][i[0]] = unwrapJsObject(typ[0], x);
                  };
                })(a, a$1, c, i, typ, typ$1)
              ),
              fl
            );
          /* } */ case 8:
            _r = makeValue(typ[0], wrapJsObject(typ[0], a[0][i[0]]), fl);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 10;
          case 10:
            return $24r;
          /* } else if (_1 === (23)) { */ case 3:
            s = $clone(v, Value).object();
            if (i[0] < 0 || i[0] >= $parseInt(s.$length) >> 0) {
              $panic(new $String("reflect: slice index out of range"));
            }
            tt$1 = v.typ.kindType;
            typ$1[0] = tt$1.elem;
            fl$1 =
              (((384 | new flag(v.flag).ro()) >>> 0) |
                (typ$1[0].Kind() >>> 0)) >>>
              0;
            i[0] = (i[0] + ($parseInt(s.$offset) >> 0)) >> 0;
            a$1[0] = s.$array;
            /* */ if (
              !((fl$1 & 128) >>> 0 === 0) &&
              !(typ$1[0].Kind() === 17) &&
              !(typ$1[0].Kind() === 25)
            ) {
              $s = 11;
              continue;
            }
            /* */ $s = 12;
            continue;
          /* if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { */ case 11:
            $s = -1;
            return new Value.ptr(
              typ$1[0],
              new (jsType(PtrTo(typ$1[0])))(
                (function (a, a$1, c, i, typ, typ$1) {
                  return function () {
                    return wrapJsObject(typ$1[0], a$1[0][i[0]]);
                  };
                })(a, a$1, c, i, typ, typ$1),
                (function (a, a$1, c, i, typ, typ$1) {
                  return function (x) {
                    var x;
                    a$1[0][i[0]] = unwrapJsObject(typ$1[0], x);
                  };
                })(a, a$1, c, i, typ, typ$1)
              ),
              fl$1
            );
          /* } */ case 12:
            _r$1 = makeValue(
              typ$1[0],
              wrapJsObject(typ$1[0], a$1[0][i[0]]),
              fl$1
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$1;
            $s = 14;
          case 14:
            return $24r$1;
          /* } else if (_1 === (24)) { */ case 4:
            str = v.ptr.$get();
            if (i[0] < 0 || i[0] >= str.length) {
              $panic(new $String("reflect: string index out of range"));
            }
            fl$2 = (((new flag(v.flag).ro() | 8) >>> 0) | 128) >>> 0;
            c[0] = str.charCodeAt(i[0]);
            $s = -1;
            return new Value.ptr(
              uint8Type,
              c.$ptr ||
                (c.$ptr = new ptrType$6(
                  function () {
                    return this.$target[0];
                  },
                  function ($v) {
                    this.$target[0] = $v;
                  },
                  c
                )),
              fl$2
            );
          /* } else { */ case 5:
            $panic(new ValueError.ptr("reflect.Value.Index", k));
          /* } */ case 6:
          case 1:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Index,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        a,
        a$1,
        c,
        fl,
        fl$1,
        fl$2,
        i,
        k,
        s,
        str,
        tt,
        tt$1,
        typ,
        typ$1,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Index = function (i) {
      return this.$val.Index(i);
    };
    Value.ptr.prototype.InterfaceData = function () {
      var v;
      v = this;
      $panic(new $String("InterfaceData is not supported by GopherJS"));
    };
    Value.prototype.InterfaceData = function () {
      return this.$val.InterfaceData();
    };
    Value.ptr.prototype.IsNil = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 22 || _1 === 23) {
        return $clone(v, Value).object() === jsType(v.typ).nil;
      } else if (_1 === 18) {
        return $clone(v, Value).object() === $chanNil;
      } else if (_1 === 19) {
        return $clone(v, Value).object() === $throwNilPointerError;
      } else if (_1 === 21) {
        return $clone(v, Value).object() === false;
      } else if (_1 === 20) {
        return $clone(v, Value).object() === $ifaceNil;
      } else if (_1 === 26) {
        return $clone(v, Value).object() === 0;
      } else {
        $panic(new ValueError.ptr("reflect.Value.IsNil", k));
      }
    };
    Value.prototype.IsNil = function () {
      return this.$val.IsNil();
    };
    Value.ptr.prototype.Len = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 17 || _1 === 24) {
        return $parseInt($clone(v, Value).object().length);
      } else if (_1 === 23) {
        return $parseInt($clone(v, Value).object().$length) >> 0;
      } else if (_1 === 18) {
        return $parseInt($clone(v, Value).object().$buffer.length) >> 0;
      } else if (_1 === 21) {
        return $parseInt($clone(v, Value).object().size) >> 0;
      } else {
        $panic(new ValueError.ptr("reflect.Value.Len", k));
      }
    };
    Value.prototype.Len = function () {
      return this.$val.Len();
    };
    Value.ptr.prototype.Pointer = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 18 || _1 === 21 || _1 === 22 || _1 === 26) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return $clone(v, Value).object();
      } else if (_1 === 19) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return 1;
      } else if (_1 === 23) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return $clone(v, Value).object().$array;
      } else {
        $panic(new ValueError.ptr("reflect.Value.Pointer", k));
      }
    };
    Value.prototype.Pointer = function () {
      return this.$val.Pointer();
    };
    Value.ptr.prototype.Set = function (x) {
      var { _1, _r, _r$1, v, x, $s, $r, $c } = $restore(this, { x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBeAssignable();
            new flag(x.flag).mustBeExported();
            _r = $clone(x, Value).assignTo("reflect.Set", v.typ, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Value.copy(x, _r);
            /* */ if (!((v.flag & 128) >>> 0 === 0)) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!((((v.flag & 128) >>> 0) === 0))) { */ case 2:
            _1 = v.typ.Kind();
            /* */ if (_1 === 17) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (_1 === (17)) { */ case 5:
            jsType(v.typ).copy(v.ptr, x.ptr);
            $s = 9;
            continue;
          /* } else if (_1 === (20)) { */ case 6:
            _r$1 = valueInterface($clone(x, Value));
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            v.ptr.$set(_r$1);
            $s = 9;
            continue;
          /* } else if (_1 === (25)) { */ case 7:
            copyStruct(v.ptr, x.ptr, v.typ);
            $s = 9;
            continue;
          /* } else { */ case 8:
            v.ptr.$set($clone(x, Value).object());
          /* } */ case 9:
          case 4:
            $s = -1;
            return;
          /* } */ case 3:
            v.ptr = x.ptr;
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Set,
        $c: true,
        $r,
        _1,
        _r,
        _r$1,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.Set = function (x) {
      return this.$val.Set(x);
    };
    Value.ptr.prototype.SetBytes = function (x) {
      var { _r, _r$1, _v, slice, typedSlice, v, x, $s, $r, $c } = $restore(
        this,
        { x }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBeAssignable();
            new flag(v.flag).mustBe(23);
            _r = v.typ.Elem().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 8)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 8))) { */ case 1:
            $panic(new $String("reflect.Value.SetBytes of non-byte slice"));
          /* } */ case 2:
            slice = x;
            if (!(v.typ.Name() === "")) {
              _v = true;
              $s = 6;
              continue s;
            }
            _r$1 = v.typ.Elem().Name();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = !(_r$1 === "");
          case 6:
            /* */ if (_v) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_v) { */ case 4:
            typedSlice = new (jsType(v.typ))(slice.$array);
            typedSlice.$offset = slice.$offset;
            typedSlice.$length = slice.$length;
            typedSlice.$capacity = slice.$capacity;
            slice = typedSlice;
          /* } */ case 5:
            v.ptr.$set(slice);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.SetBytes,
        $c: true,
        $r,
        _r,
        _r$1,
        _v,
        slice,
        typedSlice,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.SetBytes = function (x) {
      return this.$val.SetBytes(x);
    };
    Value.ptr.prototype.SetCap = function (n) {
      var n, newSlice, s, v;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(23);
      s = v.ptr.$get();
      if (n < $parseInt(s.$length) >> 0 || n > $parseInt(s.$capacity) >> 0) {
        $panic(new $String("reflect: slice capacity out of range in SetCap"));
      }
      newSlice = new (jsType(v.typ))(s.$array);
      newSlice.$offset = s.$offset;
      newSlice.$length = s.$length;
      newSlice.$capacity = n;
      v.ptr.$set(newSlice);
    };
    Value.prototype.SetCap = function (n) {
      return this.$val.SetCap(n);
    };
    Value.ptr.prototype.SetLen = function (n) {
      var n, newSlice, s, v;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(23);
      s = v.ptr.$get();
      if (n < 0 || n > $parseInt(s.$capacity) >> 0) {
        $panic(new $String("reflect: slice length out of range in SetLen"));
      }
      newSlice = new (jsType(v.typ))(s.$array);
      newSlice.$offset = s.$offset;
      newSlice.$length = n;
      newSlice.$capacity = s.$capacity;
      v.ptr.$set(newSlice);
    };
    Value.prototype.SetLen = function (n) {
      return this.$val.SetLen(n);
    };
    Value.ptr.prototype.Slice = function (i, j) {
      var {
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        cap,
        i,
        j,
        kind,
        s,
        str,
        tt,
        typ,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { i, j });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            cap = 0;
            typ = $ifaceNil;
            s = null;
            kind = new flag(v.flag).kind();
            _1 = kind;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_1 === (17)) { */ case 2:
            if ((v.flag & 256) >>> 0 === 0) {
              $panic(
                new $String("reflect.Value.Slice: slice of unaddressable array")
              );
            }
            tt = v.typ.kindType;
            cap = tt.len >> 0;
            typ = SliceOf(tt.elem);
            s = new (jsType(typ))($clone(v, Value).object());
            $s = 6;
            continue;
          /* } else if (_1 === (23)) { */ case 3:
            typ = v.typ;
            s = $clone(v, Value).object();
            cap = $parseInt(s.$capacity) >> 0;
            $s = 6;
            continue;
          /* } else if (_1 === (24)) { */ case 4:
            str = v.ptr.$get();
            if (i < 0 || j < i || j > str.length) {
              $panic(
                new $String(
                  "reflect.Value.Slice: string slice index out of bounds"
                )
              );
            }
            _r = ValueOf(new $String($substring(str, i, j)));
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 8;
          case 8:
            return $24r;
          /* } else { */ case 5:
            $panic(new ValueError.ptr("reflect.Value.Slice", kind));
          /* } */ case 6:
          case 1:
            if (i < 0 || j < i || j > cap) {
              $panic(
                new $String("reflect.Value.Slice: slice index out of bounds")
              );
            }
            _r$1 = makeValue(typ, $subslice(s, i, j), new flag(v.flag).ro());
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$1;
            $s = 10;
          case 10:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Slice,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        cap,
        i,
        j,
        kind,
        s,
        str,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Slice = function (i, j) {
      return this.$val.Slice(i, j);
    };
    Value.ptr.prototype.Slice3 = function (i, j, k) {
      var { $24r, _1, _r, cap, i, j, k, kind, s, tt, typ, v, $s, $r, $c } =
        $restore(this, { i, j, k });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            cap = 0;
            typ = $ifaceNil;
            s = null;
            kind = new flag(v.flag).kind();
            _1 = kind;
            if (_1 === 17) {
              if ((v.flag & 256) >>> 0 === 0) {
                $panic(
                  new $String(
                    "reflect.Value.Slice: slice of unaddressable array"
                  )
                );
              }
              tt = v.typ.kindType;
              cap = tt.len >> 0;
              typ = SliceOf(tt.elem);
              s = new (jsType(typ))($clone(v, Value).object());
            } else if (_1 === 23) {
              typ = v.typ;
              s = $clone(v, Value).object();
              cap = $parseInt(s.$capacity) >> 0;
            } else {
              $panic(new ValueError.ptr("reflect.Value.Slice3", kind));
            }
            if (i < 0 || j < i || k < j || k > cap) {
              $panic(
                new $String("reflect.Value.Slice3: slice index out of bounds")
              );
            }
            _r = makeValue(typ, $subslice(s, i, j, k), new flag(v.flag).ro());
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Slice3,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        cap,
        i,
        j,
        k,
        kind,
        s,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Slice3 = function (i, j, k) {
      return this.$val.Slice3(i, j, k);
    };
    Value.ptr.prototype.Close = function () {
      var v;
      v = this;
      new flag(v.flag).mustBe(18);
      new flag(v.flag).mustBeExported();
      $close($clone(v, Value).object());
    };
    Value.prototype.Close = function () {
      return this.$val.Close();
    };
    Value.ptr.prototype.Elem = function () {
      var { $24r, _1, _r, fl, k, tt, typ, v, val, val$1, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            /* */ if (_1 === 20) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 22) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (_1 === (20)) { */ case 2:
            val = $clone(v, Value).object();
            if (val === $ifaceNil) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            typ = reflectType(val.constructor);
            _r = makeValue(typ, val.$val, new flag(v.flag).ro());
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 7;
          case 7:
            return $24r;
          /* } else if (_1 === (22)) { */ case 3:
            if ($clone(v, Value).IsNil()) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            val$1 = $clone(v, Value).object();
            tt = v.typ.kindType;
            fl = (((((v.flag & 96) >>> 0) | 128) >>> 0) | 256) >>> 0;
            fl = (fl | (tt.elem.Kind() >>> 0)) >>> 0;
            $s = -1;
            return new Value.ptr(tt.elem, wrapJsObject(tt.elem, val$1), fl);
          /* } else { */ case 4:
            $panic(new ValueError.ptr("reflect.Value.Elem", k));
          /* } */ case 5:
          case 1:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Elem,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        fl,
        k,
        tt,
        typ,
        v,
        val,
        val$1,
        $s,
      };
      return $f;
    };
    Value.prototype.Elem = function () {
      return this.$val.Elem();
    };
    Value.ptr.prototype.NumField = function () {
      var tt, v;
      v = this;
      new flag(v.flag).mustBe(25);
      tt = v.typ.kindType;
      return tt.fields.$length;
    };
    Value.prototype.NumField = function () {
      return this.$val.NumField();
    };
    Value.ptr.prototype.MapKeys = function () {
      var { _r, a, fl, i, it, key, keyType, m, mlen, tt, v, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(21);
            tt = v.typ.kindType;
            keyType = tt.key;
            fl = (new flag(v.flag).ro() | (keyType.Kind() >>> 0)) >>> 0;
            m = $clone(v, Value).pointer();
            mlen = 0;
            if (!(m === 0)) {
              mlen = maplen(m);
            }
            it = mapiterinit(v.typ, m);
            a = $makeSlice(sliceType$6, mlen);
            i = 0;
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < a.$length)) { break; } */ if (!(i < a.$length)) {
              $s = 2;
              continue;
            }
            _r = mapiterkey(it);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            key = _r;
            if (key === 0) {
              /* break; */ $s = 2;
              continue;
            }
            Value.copy(
              i < 0 || i >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + i],
              copyVal(keyType, fl, key)
            );
            mapiternext(it);
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return $subslice(a, 0, i);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.MapKeys,
        $c: true,
        $r,
        _r,
        a,
        fl,
        i,
        it,
        key,
        keyType,
        m,
        mlen,
        tt,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.MapKeys = function () {
      return this.$val.MapKeys();
    };
    Value.ptr.prototype.MapIndex = function (key) {
      var { _r, e, fl, k, key, tt, typ, v, $s, $r, $c } = $restore(this, {
        key,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(21);
            tt = v.typ.kindType;
            _r = $clone(key, Value).assignTo(
              "reflect.Value.MapIndex",
              tt.key,
              0
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Value.copy(key, _r);
            k = 0;
            if (!((key.flag & 128) >>> 0 === 0)) {
              k = key.ptr;
            } else {
              k =
                key.$ptr_ptr ||
                (key.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  key
                ));
            }
            e = mapaccess(v.typ, $clone(v, Value).pointer(), k);
            if (e === 0) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            typ = tt.elem;
            fl = new flag((v.flag | key.flag) >>> 0).ro();
            fl = (fl | (typ.Kind() >>> 0)) >>> 0;
            $s = -1;
            return copyVal(typ, fl, e);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.MapIndex,
        $c: true,
        $r,
        _r,
        e,
        fl,
        k,
        key,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.MapIndex = function (key) {
      return this.$val.MapIndex(key);
    };
    Value.ptr.prototype.Field = function (i) {
      var {
        $24r,
        _r,
        _r$1,
        _r$2,
        field,
        fl,
        i,
        jsTag,
        o,
        prop,
        s,
        tag,
        tt,
        typ,
        v,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            jsTag = [jsTag];
            prop = [prop];
            s = [s];
            typ = [typ];
            v = this;
            if (!(new flag(v.flag).kind() === 25)) {
              $panic(
                new ValueError.ptr(
                  "reflect.Value.Field",
                  new flag(v.flag).kind()
                )
              );
            }
            tt = v.typ.kindType;
            if (i >>> 0 >= tt.fields.$length >>> 0) {
              $panic(new $String("reflect: Field index out of range"));
            }
            prop[0] = $internalize(jsType(v.typ).fields[i].prop, $String);
            field =
              ((x = tt.fields),
              i < 0 || i >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + i]);
            typ[0] = field.typ;
            fl = (((v.flag & 416) >>> 0) | (typ[0].Kind() >>> 0)) >>> 0;
            if (!$clone(field.name, name).isExported()) {
              if (field.embedded()) {
                fl = (fl | 64) >>> 0;
              } else {
                fl = (fl | 32) >>> 0;
              }
            }
            tag = $clone(
              ((x$1 = tt.fields),
              i < 0 || i >= x$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1.$array[x$1.$offset + i]).name,
              name
            ).tag();
            /* */ if (!(tag === "") && !(i === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!(tag === "") && !((i === 0))) { */ case 1:
            jsTag[0] = getJsTag(tag);
            /* */ if (!(jsTag[0] === "")) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!(jsTag[0] === "")) { */ case 3:
          /* while (true) { */ case 5:
            o = [o];
            _r = $clone(v, Value).Field(0);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Value.copy(v, _r);
            /* */ if (v.typ === jsObjectPtr) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (v.typ === jsObjectPtr) { */ case 8:
            o[0] = $clone(v, Value).object().object;
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (jsTag, o, prop, s, typ) {
                  return function () {
                    return $internalize(
                      o[0][$externalize(jsTag[0], $String)],
                      jsType(typ[0])
                    );
                  };
                })(jsTag, o, prop, s, typ),
                (function (jsTag, o, prop, s, typ) {
                  return function (x$2) {
                    var x$2;
                    o[0][$externalize(jsTag[0], $String)] = $externalize(
                      x$2,
                      jsType(typ[0])
                    );
                  };
                })(jsTag, o, prop, s, typ)
              ),
              fl
            );
          /* } */ case 9:
            /* */ if (v.typ.Kind() === 22) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (v.typ.Kind() === 22) { */ case 10:
            _r$1 = $clone(v, Value).Elem();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            Value.copy(v, _r$1);
          /* } */ case 11:
            $s = 5;
            continue;
          case 6:
          /* } */ case 4:
          /* } */ case 2:
            s[0] = v.ptr;
            /* */ if (
              !((fl & 128) >>> 0 === 0) &&
              !(typ[0].Kind() === 17) &&
              !(typ[0].Kind() === 25)
            ) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 13:
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (jsTag, prop, s, typ) {
                  return function () {
                    return wrapJsObject(
                      typ[0],
                      s[0][$externalize(prop[0], $String)]
                    );
                  };
                })(jsTag, prop, s, typ),
                (function (jsTag, prop, s, typ) {
                  return function (x$2) {
                    var x$2;
                    s[0][$externalize(prop[0], $String)] = unwrapJsObject(
                      typ[0],
                      x$2
                    );
                  };
                })(jsTag, prop, s, typ)
              ),
              fl
            );
          /* } */ case 14:
            _r$2 = makeValue(
              typ[0],
              wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]),
              fl
            );
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 16;
          case 16:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Field,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        field,
        fl,
        i,
        jsTag,
        o,
        prop,
        s,
        tag,
        tt,
        typ,
        v,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    Value.prototype.Field = function (i) {
      return this.$val.Field(i);
    };
    errorString.ptr.prototype.Error = function () {
      var e;
      e = this;
      return e.s;
    };
    errorString.prototype.Error = function () {
      return this.$val.Error();
    };
    unquote = function (s) {
      var s;
      if (s.length < 2) {
        return [s, $ifaceNil];
      }
      if (s.charCodeAt(0) === 39 || s.charCodeAt(0) === 34) {
        if (s.charCodeAt((s.length - 1) >> 0) === s.charCodeAt(0)) {
          return [$substring(s, 1, (s.length - 1) >> 0), $ifaceNil];
        }
        return ["", $pkg.ErrSyntax];
      }
      return [s, $ifaceNil];
    };
    flag.prototype.mustBe = function (expected) {
      var expected, f;
      f = this.$val;
      if (!(((f & 31) >>> 0) >>> 0 === expected)) {
        $panic(new ValueError.ptr(methodName(), new flag(f).kind()));
      }
    };
    $ptrType(flag).prototype.mustBe = function (expected) {
      return new flag(this.$get()).mustBe(expected);
    };
    rtype.ptr.prototype.Comparable = function () {
      var { $24r, _1, _r, _r$1, ft, i, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _1 = t.Kind();
            /* */ if (_1 === 19 || _1 === 23 || _1 === 21) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 17) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { */ case 2:
            $s = -1;
            return false;
          /* } else if (_1 === (17)) { */ case 3:
            _r = t.Elem().Comparable();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 7;
          case 7:
            return $24r;
          /* } else if (_1 === (25)) { */ case 4:
            i = 0;
          /* while (true) { */ case 8:
            /* if (!(i < t.NumField())) { break; } */ if (!(i < t.NumField())) {
              $s = 9;
              continue;
            }
            ft = $clone(t.Field(i), structField);
            _r$1 = ft.typ.Comparable();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$1) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (!_r$1) { */ case 10:
            $s = -1;
            return false;
          /* } */ case 11:
            i = (i + 1) >> 0;
            $s = 8;
            continue;
          case 9:
          /* } */ case 5:
          case 1:
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Comparable,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        _r$1,
        ft,
        i,
        t,
        $s,
      };
      return $f;
    };
    rtype.prototype.Comparable = function () {
      return this.$val.Comparable();
    };
    rtype.ptr.prototype.IsVariadic = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: IsVariadic of non-func type"));
      }
      tt = t.kindType;
      return !((tt.outCount & 32768) >>> 0 === 0);
    };
    rtype.prototype.IsVariadic = function () {
      return this.$val.IsVariadic();
    };
    rtype.ptr.prototype.Field = function (i) {
      var i, t, tt, x;
      t = this;
      if (!(t.Kind() === 25)) {
        $panic(new $String("reflect: Field of non-struct type"));
      }
      tt = t.kindType;
      if (i < 0 || i >= tt.fields.$length) {
        $panic(new $String("reflect: Field index out of bounds"));
      }
      return (
        (x = tt.fields),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i]
      );
    };
    rtype.prototype.Field = function (i) {
      return this.$val.Field(i);
    };
    rtype.ptr.prototype.Key = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 21)) {
        $panic(new $String("reflect: Key of non-map type"));
      }
      tt = t.kindType;
      return toType(tt.key);
    };
    rtype.prototype.Key = function () {
      return this.$val.Key();
    };
    rtype.ptr.prototype.NumField = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 25)) {
        $panic(new $String("reflect: NumField of non-struct type"));
      }
      tt = t.kindType;
      return tt.fields.$length;
    };
    rtype.prototype.NumField = function () {
      return this.$val.NumField();
    };
    rtype.ptr.prototype.Method = function (i) {
      var {
        $24r,
        _i,
        _i$1,
        _r,
        _r$1,
        _ref,
        _ref$1,
        arg,
        fl,
        fn,
        ft,
        i,
        in$1,
        m,
        methods,
        mt,
        mtyp,
        out,
        p,
        pname,
        prop,
        ret,
        t,
        tt,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            prop = [prop];
            m = new Method.ptr(
              "",
              "",
              $ifaceNil,
              new Value.ptr(ptrType$1.nil, 0, 0),
              0
            );
            t = this;
            /* */ if (t.Kind() === 20) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (t.Kind() === 20) { */ case 1:
            tt = t.kindType;
            _r = tt.rtype.Method(i);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Method.copy(m, _r);
            $24r = m;
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            methods = t.exportedMethods();
            if (i < 0 || i >= methods.$length) {
              $panic(new $String("reflect: Method index out of range"));
            }
            p = $clone(
              i < 0 || i >= methods.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : methods.$array[methods.$offset + i],
              method
            );
            pname = $clone(t.nameOff(p.name), name);
            m.Name = $clone(pname, name).name();
            fl = 19;
            mtyp = t.typeOff(p.mtyp);
            ft = mtyp.kindType;
            in$1 = $makeSlice(sliceType$7, 0, (1 + ft.in$().$length) >> 0);
            in$1 = $append(in$1, t);
            _ref = ft.in$();
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              arg =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              in$1 = $append(in$1, arg);
              _i++;
            }
            out = $makeSlice(sliceType$7, 0, ft.out().$length);
            _ref$1 = ft.out();
            _i$1 = 0;
            while (true) {
              if (!(_i$1 < _ref$1.$length)) {
                break;
              }
              ret =
                _i$1 < 0 || _i$1 >= _ref$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref$1.$array[_ref$1.$offset + _i$1];
              out = $append(out, ret);
              _i$1++;
            }
            _r$1 = FuncOf(in$1, out, ft.rtype.IsVariadic());
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            mt = _r$1;
            m.Type = mt;
            prop[0] = $internalize(
              $methodSet(t[$externalize(idJsType, $String)])[i].prop,
              $String
            );
            fn = js.MakeFunc(
              (function (prop) {
                return function (this$1, arguments$1) {
                  var arguments$1, rcvr, this$1;
                  rcvr =
                    0 >= arguments$1.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : arguments$1.$array[arguments$1.$offset + 0];
                  return new $jsObjectPtr(
                    rcvr[$externalize(prop[0], $String)].apply(
                      rcvr,
                      $externalize($subslice(arguments$1, 1), sliceType$8)
                    )
                  );
                };
              })(prop)
            );
            Value.copy(
              m.Func,
              new Value.ptr($assertType(mt, ptrType$1), fn, fl)
            );
            m.Index = i;
            Method.copy(m, m);
            $s = -1;
            return m;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Method,
        $c: true,
        $r,
        $24r,
        _i,
        _i$1,
        _r,
        _r$1,
        _ref,
        _ref$1,
        arg,
        fl,
        fn,
        ft,
        i,
        in$1,
        m,
        methods,
        mt,
        mtyp,
        out,
        p,
        pname,
        prop,
        ret,
        t,
        tt,
        $s,
      };
      return $f;
    };
    rtype.prototype.Method = function (i) {
      return this.$val.Method(i);
    };
    init = function () {
      var {
        used,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            used = function (i) {
              var i;
            };
            $r = used(
              ((x = new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              )),
              new x.constructor.elem(x))
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$1 = new uncommonType.ptr(0, 0, 0, 0, sliceType$5.nil)),
              new x$1.constructor.elem(x$1))
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$2 = new method.ptr(0, 0, 0, 0)),
              new x$2.constructor.elem(x$2))
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$3 = new arrayType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                ptrType$1.nil,
                0
              )),
              new x$3.constructor.elem(x$3))
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$4 = new chanType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                0
              )),
              new x$4.constructor.elem(x$4))
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$5 = new funcType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                0,
                0,
                sliceType$2.nil,
                sliceType$2.nil
              )),
              new x$5.constructor.elem(x$5))
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$6 = new interfaceType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                new name.ptr(ptrType$6.nil),
                sliceType$9.nil
              )),
              new x$6.constructor.elem(x$6))
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$7 = new mapType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                ptrType$1.nil,
                ptrType$1.nil,
                $throwNilPointerError,
                0,
                0,
                0,
                0
              )),
              new x$7.constructor.elem(x$7))
            );
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$8 = new ptrType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                ptrType$1.nil
              )),
              new x$8.constructor.elem(x$8))
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$9 = new sliceType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                ptrType$1.nil
              )),
              new x$9.constructor.elem(x$9))
            );
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$10 = new structType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$6.nil,
                  0,
                  0
                ),
                new name.ptr(ptrType$6.nil),
                sliceType$10.nil
              )),
              new x$10.constructor.elem(x$10))
            );
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$11 = new imethod.ptr(0, 0)), new x$11.constructor.elem(x$11))
            );
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$12 = new structField.ptr(
                new name.ptr(ptrType$6.nil),
                ptrType$1.nil,
                0
              )),
              new x$12.constructor.elem(x$12))
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            initialized = true;
            uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: init,
        $c: true,
        $r,
        used,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
      };
      return $f;
    };
    jsType = function (typ) {
      var typ;
      return typ[$externalize(idJsType, $String)];
    };
    reflectType = function (typ) {
      var _1,
        _i,
        _i$1,
        _i$2,
        _i$3,
        _key,
        _ref,
        _ref$1,
        _ref$2,
        _ref$3,
        dir,
        exported,
        exported$1,
        f,
        fields,
        i,
        i$1,
        i$2,
        i$3,
        i$4,
        i$5,
        imethods,
        in$1,
        m,
        m$1,
        m$2,
        methodSet,
        methods,
        offsetEmbed,
        out,
        outCount,
        params,
        reflectFields,
        reflectMethods,
        results,
        rt,
        typ,
        ut,
        xcount;
      if (typ[$externalize(idReflectType, $String)] === undefined) {
        rt = new rtype.ptr(
          ($parseInt(typ.size) >> 0) >>> 0,
          0,
          0,
          0,
          0,
          0,
          (($parseInt(typ.kind) >> 0) << 24) >>> 24,
          $throwNilPointerError,
          ptrType$6.nil,
          newNameOff(
            $clone(newName(internalStr(typ.string), "", !!typ.exported), name)
          ),
          0
        );
        rt[$externalize(idJsType, $String)] = typ;
        typ[$externalize(idReflectType, $String)] = rt;
        methodSet = $methodSet(typ);
        if (!($parseInt(methodSet.length) === 0) || !!typ.named) {
          rt.tflag = (rt.tflag | 1) >>> 0;
          if (!!typ.named) {
            rt.tflag = (rt.tflag | 4) >>> 0;
          }
          reflectMethods = sliceType$5.nil;
          i = 0;
          while (true) {
            if (!(i < $parseInt(methodSet.length))) {
              break;
            }
            m = methodSet[i];
            exported = internalStr(m.pkg) === "";
            if (!exported) {
              i = (i + 1) >> 0;
              continue;
            }
            reflectMethods = $append(
              reflectMethods,
              new method.ptr(
                newNameOff(
                  $clone(newName(internalStr(m.name), "", exported), name)
                ),
                newTypeOff(reflectType(m.typ)),
                0,
                0
              )
            );
            i = (i + 1) >> 0;
          }
          xcount = (reflectMethods.$length << 16) >>> 16;
          i$1 = 0;
          while (true) {
            if (!(i$1 < $parseInt(methodSet.length))) {
              break;
            }
            m$1 = methodSet[i$1];
            exported$1 = internalStr(m$1.pkg) === "";
            if (exported$1) {
              i$1 = (i$1 + 1) >> 0;
              continue;
            }
            reflectMethods = $append(
              reflectMethods,
              new method.ptr(
                newNameOff(
                  $clone(newName(internalStr(m$1.name), "", exported$1), name)
                ),
                newTypeOff(reflectType(m$1.typ)),
                0,
                0
              )
            );
            i$1 = (i$1 + 1) >> 0;
          }
          ut = new uncommonType.ptr(
            newNameOff($clone(newName(internalStr(typ.pkg), "", false), name)),
            ($parseInt(methodSet.length) << 16) >>> 16,
            xcount,
            0,
            reflectMethods
          );
          _key = rt;
          (
            uncommonTypeMap ||
            $throwRuntimeError("assignment to entry in nil map")
          ).set(ptrType$1.keyFor(_key), { k: _key, v: ut });
          ut[$externalize(idJsType, $String)] = typ;
        }
        _1 = rt.Kind();
        if (_1 === 17) {
          setKindType(
            rt,
            new arrayType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              ),
              reflectType(typ.elem),
              ptrType$1.nil,
              ($parseInt(typ.len) >> 0) >>> 0
            )
          );
        } else if (_1 === 18) {
          dir = 3;
          if (!!typ.sendOnly) {
            dir = 2;
          }
          if (!!typ.recvOnly) {
            dir = 1;
          }
          setKindType(
            rt,
            new chanType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              ),
              reflectType(typ.elem),
              dir >>> 0
            )
          );
        } else if (_1 === 19) {
          params = typ.params;
          in$1 = $makeSlice(sliceType$2, $parseInt(params.length));
          _ref = in$1;
          _i = 0;
          while (true) {
            if (!(_i < _ref.$length)) {
              break;
            }
            i$2 = _i;
            i$2 < 0 || i$2 >= in$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (in$1.$array[in$1.$offset + i$2] = reflectType(params[i$2]));
            _i++;
          }
          results = typ.results;
          out = $makeSlice(sliceType$2, $parseInt(results.length));
          _ref$1 = out;
          _i$1 = 0;
          while (true) {
            if (!(_i$1 < _ref$1.$length)) {
              break;
            }
            i$3 = _i$1;
            i$3 < 0 || i$3 >= out.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (out.$array[out.$offset + i$3] = reflectType(results[i$3]));
            _i$1++;
          }
          outCount = ($parseInt(results.length) << 16) >>> 16;
          if (!!typ.variadic) {
            outCount = (outCount | 32768) >>> 0;
          }
          setKindType(
            rt,
            new funcType.ptr(
              $clone(rt, rtype),
              ($parseInt(params.length) << 16) >>> 16,
              outCount,
              in$1,
              out
            )
          );
        } else if (_1 === 20) {
          methods = typ.methods;
          imethods = $makeSlice(sliceType$9, $parseInt(methods.length));
          _ref$2 = imethods;
          _i$2 = 0;
          while (true) {
            if (!(_i$2 < _ref$2.$length)) {
              break;
            }
            i$4 = _i$2;
            m$2 = methods[i$4];
            imethod.copy(
              i$4 < 0 || i$4 >= imethods.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : imethods.$array[imethods.$offset + i$4],
              new imethod.ptr(
                newNameOff(
                  $clone(
                    newName(
                      internalStr(m$2.name),
                      "",
                      internalStr(m$2.pkg) === ""
                    ),
                    name
                  )
                ),
                newTypeOff(reflectType(m$2.typ))
              )
            );
            _i$2++;
          }
          setKindType(
            rt,
            new interfaceType.ptr(
              $clone(rt, rtype),
              $clone(newName(internalStr(typ.pkg), "", false), name),
              imethods
            )
          );
        } else if (_1 === 21) {
          setKindType(
            rt,
            new mapType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              ),
              reflectType(typ.key),
              reflectType(typ.elem),
              ptrType$1.nil,
              $throwNilPointerError,
              0,
              0,
              0,
              0
            )
          );
        } else if (_1 === 22) {
          setKindType(
            rt,
            new ptrType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              ),
              reflectType(typ.elem)
            )
          );
        } else if (_1 === 23) {
          setKindType(
            rt,
            new sliceType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$6.nil,
                0,
                0
              ),
              reflectType(typ.elem)
            )
          );
        } else if (_1 === 25) {
          fields = typ.fields;
          reflectFields = $makeSlice(sliceType$10, $parseInt(fields.length));
          _ref$3 = reflectFields;
          _i$3 = 0;
          while (true) {
            if (!(_i$3 < _ref$3.$length)) {
              break;
            }
            i$5 = _i$3;
            f = fields[i$5];
            offsetEmbed = ((i$5 >>> 0) << 1) >>> 0;
            if (!!f.embedded) {
              offsetEmbed = (offsetEmbed | 1) >>> 0;
            }
            structField.copy(
              i$5 < 0 || i$5 >= reflectFields.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : reflectFields.$array[reflectFields.$offset + i$5],
              new structField.ptr(
                $clone(
                  newName(
                    internalStr(f.name),
                    internalStr(f.tag),
                    !!f.exported
                  ),
                  name
                ),
                reflectType(f.typ),
                offsetEmbed
              )
            );
            _i$3++;
          }
          setKindType(
            rt,
            new structType.ptr(
              $clone(rt, rtype),
              $clone(newName(internalStr(typ.pkgPath), "", false), name),
              reflectFields
            )
          );
        }
      }
      return typ[$externalize(idReflectType, $String)];
    };
    setKindType = function (rt, kindType) {
      var kindType, rt;
      rt[$externalize(idKindType, $String)] = kindType;
      kindType[$externalize(idRtype, $String)] = rt;
    };
    uncommonType.ptr.prototype.methods = function () {
      var t;
      t = this;
      return t._methods;
    };
    uncommonType.prototype.methods = function () {
      return this.$val.methods();
    };
    uncommonType.ptr.prototype.exportedMethods = function () {
      var t;
      t = this;
      return $subslice(t._methods, 0, t.xcount, t.xcount);
    };
    uncommonType.prototype.exportedMethods = function () {
      return this.$val.exportedMethods();
    };
    rtype.ptr.prototype.uncommon = function () {
      var _entry, t;
      t = this;
      return (
        (_entry = $mapIndex(uncommonTypeMap, ptrType$1.keyFor(t))),
        _entry !== undefined ? _entry.v : ptrType$4.nil
      );
    };
    rtype.prototype.uncommon = function () {
      return this.$val.uncommon();
    };
    funcType.ptr.prototype.in$ = function () {
      var t;
      t = this;
      return t._in;
    };
    funcType.prototype.in$ = function () {
      return this.$val.in$();
    };
    funcType.ptr.prototype.out = function () {
      var t;
      t = this;
      return t._out;
    };
    funcType.prototype.out = function () {
      return this.$val.out();
    };
    name.ptr.prototype.name = function () {
      var _entry, n, s;
      s = "";
      n = this;
      s = ((_entry = $mapIndex(nameMap, ptrType$6.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$8.nil).name;
      return s;
    };
    name.prototype.name = function () {
      return this.$val.name();
    };
    name.ptr.prototype.tag = function () {
      var _entry, n, s;
      s = "";
      n = this;
      s = ((_entry = $mapIndex(nameMap, ptrType$6.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$8.nil).tag;
      return s;
    };
    name.prototype.tag = function () {
      return this.$val.tag();
    };
    name.ptr.prototype.pkgPath = function () {
      var n;
      n = this;
      return "";
    };
    name.prototype.pkgPath = function () {
      return this.$val.pkgPath();
    };
    name.ptr.prototype.isExported = function () {
      var _entry, n;
      n = this;
      return ((_entry = $mapIndex(nameMap, ptrType$6.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$8.nil).exported;
    };
    name.prototype.isExported = function () {
      return this.$val.isExported();
    };
    newName = function (n, tag, exported) {
      var _key, b, exported, n, tag;
      b = $newDataPointer(0, ptrType$6);
      _key = b;
      (nameMap || $throwRuntimeError("assignment to entry in nil map")).set(
        ptrType$6.keyFor(_key),
        { k: _key, v: new nameData.ptr(n, tag, exported) }
      );
      return new name.ptr(b);
    };
    rtype.ptr.prototype.nameOff = function (off) {
      var off, t, x;
      t = this;
      return (
        (x = off >> 0),
        x < 0 || x >= nameOffList.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : nameOffList.$array[nameOffList.$offset + x]
      );
    };
    rtype.prototype.nameOff = function (off) {
      return this.$val.nameOff(off);
    };
    newNameOff = function (n) {
      var i, n;
      i = nameOffList.$length;
      nameOffList = $append(nameOffList, n);
      return i >> 0;
    };
    rtype.ptr.prototype.typeOff = function (off) {
      var off, t, x;
      t = this;
      return (
        (x = off >> 0),
        x < 0 || x >= typeOffList.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : typeOffList.$array[typeOffList.$offset + x]
      );
    };
    rtype.prototype.typeOff = function (off) {
      return this.$val.typeOff(off);
    };
    newTypeOff = function (t) {
      var i, t;
      i = typeOffList.$length;
      typeOffList = $append(typeOffList, t);
      return i >> 0;
    };
    internalStr = function (strObj) {
      var c, strObj;
      c = new structType$2.ptr("");
      c.str = strObj;
      return c.str;
    };
    isWrapped = function (typ) {
      var typ;
      return !!jsType(typ).wrapped;
    };
    copyStruct = function (dst, src, typ) {
      var dst, fields, i, prop, src, typ;
      fields = jsType(typ).fields;
      i = 0;
      while (true) {
        if (!(i < $parseInt(fields.length))) {
          break;
        }
        prop = $internalize(fields[i].prop, $String);
        dst[$externalize(prop, $String)] = src[$externalize(prop, $String)];
        i = (i + 1) >> 0;
      }
    };
    makeValue = function (t, v, fl) {
      var {
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _v,
        _v$1,
        fl,
        rt,
        t,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { t, v, fl });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            rt = _r;
            _r$1 = t.Kind();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            if (_r$1 === 17) {
              _v$1 = true;
              $s = 5;
              continue s;
            }
            _r$2 = t.Kind();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$2 === 25;
          case 5:
            if (_v$1) {
              _v = true;
              $s = 4;
              continue s;
            }
            _r$3 = t.Kind();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _v = _r$3 === 22;
          case 4:
            /* */ if (_v) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (_v) { */ case 2:
            _r$4 = t.Kind();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(rt, v, (fl | (_r$4 >>> 0)) >>> 0);
            $s = 10;
          case 10:
            return $24r;
          /* } */ case 3:
            _r$5 = t.Kind();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $24r$1 = new Value.ptr(
              rt,
              $newDataPointer(v, jsType(rt.ptrTo())),
              (((fl | (_r$5 >>> 0)) >>> 0) | 128) >>> 0
            );
            $s = 12;
          case 12:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeValue,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _v,
        _v$1,
        fl,
        rt,
        t,
        v,
        $s,
      };
      return $f;
    };
    TypeOf = function (i) {
      var i;
      if (!initialized) {
        return new rtype.ptr(
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          $throwNilPointerError,
          ptrType$6.nil,
          0,
          0
        );
      }
      if ($interfaceIsEqual(i, $ifaceNil)) {
        return $ifaceNil;
      }
      return reflectType(i.constructor);
    };
    $pkg.TypeOf = TypeOf;
    ValueOf = function (i) {
      var { $24r, _r, i, $s, $r, $c } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if ($interfaceIsEqual(i, $ifaceNil)) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            _r = makeValue(reflectType(i.constructor), i.$val, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: ValueOf, $c: true, $r, $24r, _r, i, $s };
      return $f;
    };
    $pkg.ValueOf = ValueOf;
    FuncOf = function (in$1, out, variadic) {
      var {
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        _v,
        _v$1,
        i,
        i$1,
        in$1,
        jsIn,
        jsOut,
        out,
        v,
        v$1,
        variadic,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { in$1, out, variadic });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (!variadic) {
              _v = false;
              $s = 3;
              continue s;
            }
            if (in$1.$length === 0) {
              _v$1 = true;
              $s = 4;
              continue s;
            }
            _r = ((x = (in$1.$length - 1) >> 0),
            x < 0 || x >= in$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : in$1.$array[in$1.$offset + x]).Kind();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v$1 = !(_r === 23);
          case 4:
            _v = _v$1;
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            $panic(
              new $String(
                "reflect.FuncOf: last arg of variadic func must be slice"
              )
            );
          /* } */ case 2:
            jsIn = $makeSlice(sliceType$8, in$1.$length);
            _ref = in$1;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              i = _i;
              v =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              i < 0 || i >= jsIn.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (jsIn.$array[jsIn.$offset + i] = jsType(v));
              _i++;
            }
            jsOut = $makeSlice(sliceType$8, out.$length);
            _ref$1 = out;
            _i$1 = 0;
            while (true) {
              if (!(_i$1 < _ref$1.$length)) {
                break;
              }
              i$1 = _i$1;
              v$1 =
                _i$1 < 0 || _i$1 >= _ref$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref$1.$array[_ref$1.$offset + _i$1];
              i$1 < 0 || i$1 >= jsOut.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (jsOut.$array[jsOut.$offset + i$1] = jsType(v$1));
              _i$1++;
            }
            $s = -1;
            return reflectType(
              $funcType(
                $externalize(jsIn, sliceType$8),
                $externalize(jsOut, sliceType$8),
                $externalize(variadic, $Bool)
              )
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: FuncOf,
        $c: true,
        $r,
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        _v,
        _v$1,
        i,
        i$1,
        in$1,
        jsIn,
        jsOut,
        out,
        v,
        v$1,
        variadic,
        x,
        $s,
      };
      return $f;
    };
    $pkg.FuncOf = FuncOf;
    rtype.ptr.prototype.ptrTo = function () {
      var t;
      t = this;
      return reflectType($ptrType(jsType(t)));
    };
    rtype.prototype.ptrTo = function () {
      return this.$val.ptrTo();
    };
    SliceOf = function (t) {
      var t;
      return reflectType($sliceType(jsType(t)));
    };
    $pkg.SliceOf = SliceOf;
    unsafe_New = function (typ) {
      var _1, typ;
      _1 = typ.Kind();
      if (_1 === 25) {
        return new (jsType(typ).ptr)();
      } else if (_1 === 17) {
        return jsType(typ).zero();
      } else {
        return $newDataPointer(jsType(typ).zero(), jsType(typ.ptrTo()));
      }
    };
    typedmemmove = function (t, dst, src) {
      var dst, src, t;
      dst.$set(src.$get());
    };
    keyFor = function (t, key) {
      var k, key, kv, t;
      kv = key;
      if (!(kv.$get === undefined)) {
        kv = kv.$get();
      }
      k = $internalize(jsType(t.Key()).keyFor(kv), $String);
      return [kv, k];
    };
    mapaccess = function (t, m, key) {
      var _tuple, entry, k, key, m, t;
      _tuple = keyFor(t, key);
      k = _tuple[1];
      entry = m.get($externalize(k, $String));
      if (entry === undefined) {
        return 0;
      }
      return $newDataPointer(entry.v, jsType(PtrTo(t.Elem())));
    };
    mapIter.ptr.prototype.skipUntilValidKey = function () {
      var iter, k;
      iter = this;
      while (true) {
        if (!(iter.i < $parseInt(iter.keys.length))) {
          break;
        }
        k = iter.keys[iter.i];
        if (!(iter.m.get(k) === undefined)) {
          break;
        }
        iter.i = (iter.i + 1) >> 0;
      }
    };
    mapIter.prototype.skipUntilValidKey = function () {
      return this.$val.skipUntilValidKey();
    };
    mapiterinit = function (t, m) {
      var m, t;
      return new mapIter.ptr(t, m, $global.Array.from(m.keys()), 0, null);
    };
    mapiterkey = function (it) {
      var { $24r, _r, _r$1, _r$2, it, iter, k, kv, $s, $r, $c } = $restore(
        this,
        { it }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            iter = $pointerOfStructConversion(it, ptrType$9);
            kv = null;
            if (!(iter.last === null)) {
              kv = iter.last;
            } else {
              iter.skipUntilValidKey();
              if (iter.i === $parseInt(iter.keys.length)) {
                $s = -1;
                return 0;
              }
              k = iter.keys[iter.i];
              kv = iter.m.get(k);
              iter.last = kv;
            }
            _r = $assertType(iter.t, TypeEx).Key();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = PtrTo(_r);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = jsType(_r$1);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = $newDataPointer(kv.k, _r$2);
            $s = 4;
          case 4:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mapiterkey,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        it,
        iter,
        k,
        kv,
        $s,
      };
      return $f;
    };
    mapiternext = function (it) {
      var it, iter;
      iter = $pointerOfStructConversion(it, ptrType$9);
      iter.last = null;
      iter.i = (iter.i + 1) >> 0;
    };
    maplen = function (m) {
      var m;
      return $parseInt(m.size) >> 0;
    };
    methodReceiver = function (op, v, i) {
      var _$12, fn, i, m, m$1, ms, op, prop, rcvr, t, tt, v, x;
      _$12 = ptrType$1.nil;
      t = ptrType$5.nil;
      fn = 0;
      prop = "";
      if (v.typ.Kind() === 20) {
        tt = v.typ.kindType;
        if (i < 0 || i >= tt.methods.$length) {
          $panic(new $String("reflect: internal error: invalid method index"));
        }
        m =
          ((x = tt.methods),
          i < 0 || i >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + i]);
        if (!$clone(tt.rtype.nameOff(m.name), name).isExported()) {
          $panic(new $String("reflect: " + op + " of unexported method"));
        }
        t = tt.rtype.typeOff(m.typ).kindType;
        prop = $clone(tt.rtype.nameOff(m.name), name).name();
      } else {
        ms = v.typ.exportedMethods();
        if (i >>> 0 >= ms.$length >>> 0) {
          $panic(new $String("reflect: internal error: invalid method index"));
        }
        m$1 = $clone(
          i < 0 || i >= ms.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : ms.$array[ms.$offset + i],
          method
        );
        if (!$clone(v.typ.nameOff(m$1.name), name).isExported()) {
          $panic(new $String("reflect: " + op + " of unexported method"));
        }
        t = v.typ.typeOff(m$1.mtyp).kindType;
        prop = $internalize($methodSet(jsType(v.typ))[i].prop, $String);
      }
      rcvr = $clone(v, Value).object();
      if (isWrapped(v.typ)) {
        rcvr = new (jsType(v.typ))(rcvr);
      }
      fn = rcvr[$externalize(prop, $String)];
      return [_$12, t, fn];
    };
    valueInterface = function (v) {
      var { _r, cv, v, $s, $r, $c } = $restore(this, { v });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (v.flag === 0) {
              $panic(new ValueError.ptr("reflect.Value.Interface", 0));
            }
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
            _r = makeMethodValue("Interface", $clone(v, Value));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Value.copy(v, _r);
          /* } */ case 2:
            if (isWrapped(v.typ)) {
              if (
                !((v.flag & 128) >>> 0 === 0) &&
                $clone(v, Value).Kind() === 25
              ) {
                cv = jsType(v.typ).zero();
                copyStruct(cv, $clone(v, Value).object(), v.typ);
                $s = -1;
                return new (jsType(v.typ))(cv);
              }
              $s = -1;
              return new (jsType(v.typ))($clone(v, Value).object());
            }
            $s = -1;
            return $clone(v, Value).object();
          /* */
        }
        return;
      }
      var $f = { $blk: valueInterface, $c: true, $r, _r, cv, v, $s };
      return $f;
    };
    ifaceE2I = function (t, src, dst) {
      var dst, src, t;
      dst.$set(src);
    };
    methodName = function () {
      return "?FIXME?";
    };
    makeMethodValue = function (op, v) {
      var { $24r, _r, _tuple, fn, fv, op, rcvr, v, $s, $r, $c } = $restore(
        this,
        { op, v }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fn = [fn];
            rcvr = [rcvr];
            if ((v.flag & 512) >>> 0 === 0) {
              $panic(
                new $String(
                  "reflect: internal error: invalid use of makePartialFunc"
                )
              );
            }
            _tuple = methodReceiver(
              op,
              $clone(v, Value),
              ((v.flag >> 0) >> 10) >> 0
            );
            fn[0] = _tuple[2];
            rcvr[0] = $clone(v, Value).object();
            if (isWrapped(v.typ)) {
              rcvr[0] = new (jsType(v.typ))(rcvr[0]);
            }
            fv = js.MakeFunc(
              (function (fn, rcvr) {
                return function (this$1, arguments$1) {
                  var arguments$1, this$1;
                  return new $jsObjectPtr(
                    fn[0].apply(rcvr[0], $externalize(arguments$1, sliceType$8))
                  );
                };
              })(fn, rcvr)
            );
            _r = $clone(v, Value).Type().common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(_r, fv, (new flag(v.flag).ro() | 19) >>> 0);
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeMethodValue,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        fn,
        fv,
        op,
        rcvr,
        v,
        $s,
      };
      return $f;
    };
    wrapJsObject = function (typ, val) {
      var typ, val;
      if ($interfaceIsEqual(typ, jsObjectPtr)) {
        return new (jsType(jsObjectPtr))(val);
      }
      return val;
    };
    unwrapJsObject = function (typ, val) {
      var typ, val;
      if ($interfaceIsEqual(typ, jsObjectPtr)) {
        return val.object;
      }
      return val;
    };
    getJsTag = function (tag) {
      var _tuple, i, name$1, qvalue, tag, value;
      while (true) {
        if (!!(tag === "")) {
          break;
        }
        i = 0;
        while (true) {
          if (!(i < tag.length && tag.charCodeAt(i) === 32)) {
            break;
          }
          i = (i + 1) >> 0;
        }
        tag = $substring(tag, i);
        if (tag === "") {
          break;
        }
        i = 0;
        while (true) {
          if (
            !(
              i < tag.length &&
              !(tag.charCodeAt(i) === 32) &&
              !(tag.charCodeAt(i) === 58) &&
              !(tag.charCodeAt(i) === 34)
            )
          ) {
            break;
          }
          i = (i + 1) >> 0;
        }
        if (
          (i + 1) >> 0 >= tag.length ||
          !(tag.charCodeAt(i) === 58) ||
          !(tag.charCodeAt((i + 1) >> 0) === 34)
        ) {
          break;
        }
        name$1 = $substring(tag, 0, i);
        tag = $substring(tag, (i + 1) >> 0);
        i = 1;
        while (true) {
          if (!(i < tag.length && !(tag.charCodeAt(i) === 34))) {
            break;
          }
          if (tag.charCodeAt(i) === 92) {
            i = (i + 1) >> 0;
          }
          i = (i + 1) >> 0;
        }
        if (i >= tag.length) {
          break;
        }
        qvalue = $substring(tag, 0, (i + 1) >> 0);
        tag = $substring(tag, (i + 1) >> 0);
        if (name$1 === "js") {
          _tuple = unquote(qvalue);
          value = _tuple[0];
          return value;
        }
      }
      return "";
    };
    PtrTo = function (t) {
      var t;
      return $assertType(t, ptrType$1).ptrTo();
    };
    $pkg.PtrTo = PtrTo;
    copyVal = function (typ, fl, ptr) {
      var c, fl, ptr, typ;
      if (ifaceIndir(typ)) {
        c = unsafe_New(typ);
        typedmemmove(typ, c, ptr);
        return new Value.ptr(typ, c, (fl | 128) >>> 0);
      }
      return new Value.ptr(typ, ptr.$get(), fl);
    };
    Value.methods = [
      {
        prop: "pointer",
        name: "pointer",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$UnsafePointer], false),
      },
      {
        prop: "CanSet",
        name: "CanSet",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsValid",
        name: "IsValid",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "numMethod",
        name: "numMethod",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "object",
        name: "object",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$2], false),
      },
      {
        prop: "assignTo",
        name: "assignTo",
        pkg: "internal/reflectlite",
        typ: $funcType([$String, ptrType$1, $UnsafePointer], [Value], false),
      },
      {
        prop: "call",
        name: "call",
        pkg: "internal/reflectlite",
        typ: $funcType([$String, sliceType$6], [sliceType$6], false),
      },
      { prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Index",
        name: "Index",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
      {
        prop: "InterfaceData",
        name: "InterfaceData",
        pkg: "",
        typ: $funcType([], [arrayType$2], false),
      },
      {
        prop: "IsNil",
        name: "IsNil",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Pointer",
        name: "Pointer",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      { prop: "Set", name: "Set", pkg: "", typ: $funcType([Value], [], false) },
      {
        prop: "SetBytes",
        name: "SetBytes",
        pkg: "",
        typ: $funcType([sliceType$13], [], false),
      },
      {
        prop: "SetCap",
        name: "SetCap",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "SetLen",
        name: "SetLen",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "Slice",
        name: "Slice",
        pkg: "",
        typ: $funcType([$Int, $Int], [Value], false),
      },
      {
        prop: "Slice3",
        name: "Slice3",
        pkg: "",
        typ: $funcType([$Int, $Int, $Int], [Value], false),
      },
      { prop: "Close", name: "Close", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Value], false),
      },
      {
        prop: "NumField",
        name: "NumField",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "MapKeys",
        name: "MapKeys",
        pkg: "",
        typ: $funcType([], [sliceType$6], false),
      },
      {
        prop: "MapIndex",
        name: "MapIndex",
        pkg: "",
        typ: $funcType([Value], [Value], false),
      },
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
    ];
    flag.methods = [
      {
        prop: "kind",
        name: "kind",
        pkg: "internal/reflectlite",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "ro",
        name: "ro",
        pkg: "internal/reflectlite",
        typ: $funcType([], [flag], false),
      },
      {
        prop: "mustBeExported",
        name: "mustBeExported",
        pkg: "internal/reflectlite",
        typ: $funcType([], [], false),
      },
      {
        prop: "mustBeAssignable",
        name: "mustBeAssignable",
        pkg: "internal/reflectlite",
        typ: $funcType([], [], false),
      },
      {
        prop: "mustBe",
        name: "mustBe",
        pkg: "internal/reflectlite",
        typ: $funcType([Kind], [], false),
      },
    ];
    ptrType$10.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Kind.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "pointers",
        name: "pointers",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "common",
        name: "common",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "exportedMethods",
        name: "exportedMethods",
        pkg: "internal/reflectlite",
        typ: $funcType([], [sliceType$5], false),
      },
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "hasName",
        name: "hasName",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "chanDir",
        name: "chanDir",
        pkg: "internal/reflectlite",
        typ: $funcType([], [chanDir], false),
      },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "In",
        name: "In",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "NumIn",
        name: "NumIn",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumOut",
        name: "NumOut",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Out",
        name: "Out",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      {
        prop: "Implements",
        name: "Implements",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "AssignableTo",
        name: "AssignableTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Comparable",
        name: "Comparable",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsVariadic",
        name: "IsVariadic",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "kindType",
        name: "kindType",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [structField], false),
      },
      { prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false) },
      {
        prop: "NumField",
        name: "NumField",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Method",
        name: "Method",
        pkg: "",
        typ: $funcType([$Int], [Method], false),
      },
      {
        prop: "uncommon",
        name: "uncommon",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$4], false),
      },
      {
        prop: "nameOff",
        name: "nameOff",
        pkg: "internal/reflectlite",
        typ: $funcType([nameOff], [name], false),
      },
      {
        prop: "typeOff",
        name: "typeOff",
        pkg: "internal/reflectlite",
        typ: $funcType([typeOff], [ptrType$1], false),
      },
      {
        prop: "ptrTo",
        name: "ptrTo",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$1], false),
      },
    ];
    ptrType$11.methods = [
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
    ];
    ptrType$12.methods = [
      {
        prop: "offset",
        name: "offset",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "embedded",
        name: "embedded",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$13.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$4.methods = [
      {
        prop: "methods",
        name: "methods",
        pkg: "internal/reflectlite",
        typ: $funcType([], [sliceType$5], false),
      },
      {
        prop: "exportedMethods",
        name: "exportedMethods",
        pkg: "internal/reflectlite",
        typ: $funcType([], [sliceType$5], false),
      },
    ];
    ptrType$5.methods = [
      {
        prop: "in$",
        name: "in",
        pkg: "internal/reflectlite",
        typ: $funcType([], [sliceType$2], false),
      },
      {
        prop: "out",
        name: "out",
        pkg: "internal/reflectlite",
        typ: $funcType([], [sliceType$2], false),
      },
    ];
    name.methods = [
      {
        prop: "data",
        name: "data",
        pkg: "internal/reflectlite",
        typ: $funcType([$Int, $String], [ptrType$6], false),
      },
      {
        prop: "hasTag",
        name: "hasTag",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "readVarint",
        name: "readVarint",
        pkg: "internal/reflectlite",
        typ: $funcType([$Int], [$Int, $Int], false),
      },
      {
        prop: "name",
        name: "name",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "tag",
        name: "tag",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "isExported",
        name: "isExported",
        pkg: "internal/reflectlite",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$9.methods = [
      {
        prop: "skipUntilValidKey",
        name: "skipUntilValidKey",
        pkg: "internal/reflectlite",
        typ: $funcType([], [], false),
      },
    ];
    Value.init("internal/reflectlite", [
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "ptr",
        name: "ptr",
        embedded: false,
        exported: false,
        typ: $UnsafePointer,
        tag: "",
      },
      {
        prop: "flag",
        name: "flag",
        embedded: true,
        exported: false,
        typ: flag,
        tag: "",
      },
    ]);
    ValueError.init("", [
      {
        prop: "Method",
        name: "Method",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Kind",
        name: "Kind",
        embedded: false,
        exported: true,
        typ: Kind,
        tag: "",
      },
    ]);
    Type.init([
      {
        prop: "AssignableTo",
        name: "AssignableTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Comparable",
        name: "Comparable",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "Implements",
        name: "Implements",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "common",
        name: "common",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "uncommon",
        name: "uncommon",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$4], false),
      },
    ]);
    rtype.init("internal/reflectlite", [
      {
        prop: "size",
        name: "size",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "ptrdata",
        name: "ptrdata",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "hash",
        name: "hash",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "tflag",
        name: "tflag",
        embedded: false,
        exported: false,
        typ: tflag,
        tag: "",
      },
      {
        prop: "align",
        name: "align",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "fieldAlign",
        name: "fieldAlign",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "kind",
        name: "kind",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "equal",
        name: "equal",
        embedded: false,
        exported: false,
        typ: funcType$2,
        tag: "",
      },
      {
        prop: "gcdata",
        name: "gcdata",
        embedded: false,
        exported: false,
        typ: ptrType$6,
        tag: "",
      },
      {
        prop: "str",
        name: "str",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "ptrToThis",
        name: "ptrToThis",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
    ]);
    method.init("internal/reflectlite", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "mtyp",
        name: "mtyp",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
      {
        prop: "ifn",
        name: "ifn",
        embedded: false,
        exported: false,
        typ: textOff,
        tag: "",
      },
      {
        prop: "tfn",
        name: "tfn",
        embedded: false,
        exported: false,
        typ: textOff,
        tag: "",
      },
    ]);
    arrayType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "slice",
        name: "slice",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "len",
        name: "len",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    chanType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "dir",
        name: "dir",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    imethod.init("internal/reflectlite", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
    ]);
    interfaceType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "methods",
        name: "methods",
        embedded: false,
        exported: false,
        typ: sliceType$9,
        tag: "",
      },
    ]);
    mapType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "key",
        name: "key",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "bucket",
        name: "bucket",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "hasher",
        name: "hasher",
        embedded: false,
        exported: false,
        typ: funcType$3,
        tag: "",
      },
      {
        prop: "keysize",
        name: "keysize",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "valuesize",
        name: "valuesize",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "bucketsize",
        name: "bucketsize",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "flags",
        name: "flags",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
    ]);
    ptrType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
    ]);
    sliceType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
    ]);
    structField.init("internal/reflectlite", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "offsetEmbed",
        name: "offsetEmbed",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    structType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "fields",
        name: "fields",
        embedded: false,
        exported: false,
        typ: sliceType$10,
        tag: "",
      },
    ]);
    errorString.init("internal/reflectlite", [
      {
        prop: "s",
        name: "s",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    Method.init("", [
      {
        prop: "Name",
        name: "Name",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Type",
        name: "Type",
        embedded: false,
        exported: true,
        typ: Type,
        tag: "",
      },
      {
        prop: "Func",
        name: "Func",
        embedded: false,
        exported: true,
        typ: Value,
        tag: "",
      },
      {
        prop: "Index",
        name: "Index",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    uncommonType.init("internal/reflectlite", [
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "mcount",
        name: "mcount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "xcount",
        name: "xcount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "moff",
        name: "moff",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "_methods",
        name: "_methods",
        embedded: false,
        exported: false,
        typ: sliceType$5,
        tag: "",
      },
    ]);
    funcType.init("internal/reflectlite", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: 'reflect:"func"',
      },
      {
        prop: "inCount",
        name: "inCount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "outCount",
        name: "outCount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "_in",
        name: "_in",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
      {
        prop: "_out",
        name: "_out",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
    ]);
    name.init("internal/reflectlite", [
      {
        prop: "bytes",
        name: "bytes",
        embedded: false,
        exported: false,
        typ: ptrType$6,
        tag: "",
      },
    ]);
    nameData.init("internal/reflectlite", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "tag",
        name: "tag",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "exported",
        name: "exported",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    mapIter.init("internal/reflectlite", [
      {
        prop: "t",
        name: "t",
        embedded: false,
        exported: false,
        typ: Type,
        tag: "",
      },
      {
        prop: "m",
        name: "m",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
      {
        prop: "keys",
        name: "keys",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
      {
        prop: "i",
        name: "i",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "last",
        name: "last",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
    ]);
    TypeEx.init([
      {
        prop: "AssignableTo",
        name: "AssignableTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Comparable",
        name: "Comparable",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "Implements",
        name: "Implements",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      { prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false) },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "common",
        name: "common",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "uncommon",
        name: "uncommon",
        pkg: "internal/reflectlite",
        typ: $funcType([], [ptrType$4], false),
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = goarch.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unsafeheader.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            uint8Type = ptrType$1.nil;
            nameOffList = sliceType$1.nil;
            typeOffList = sliceType$2.nil;
            kindNames = new sliceType$3([
              "invalid",
              "bool",
              "int",
              "int8",
              "int16",
              "int32",
              "int64",
              "uint",
              "uint8",
              "uint16",
              "uint32",
              "uint64",
              "uintptr",
              "float32",
              "float64",
              "complex64",
              "complex128",
              "array",
              "chan",
              "func",
              "interface",
              "map",
              "ptr",
              "slice",
              "string",
              "struct",
              "unsafe.Pointer",
            ]);
            callHelper = $assertType(
              $internalize($call, $emptyInterface),
              funcType$1
            );
            $pkg.ErrSyntax = new errorString.ptr("invalid syntax");
            initialized = false;
            idJsType = "_jsType";
            idReflectType = "_reflectType";
            idKindType = "kindType";
            idRtype = "_rtype";
            uncommonTypeMap = new $global.Map();
            nameMap = new $global.Map();
            jsObjectPtr = reflectType($jsObjectPtr);
            selectHelper = $assertType(
              $internalize($select, $emptyInterface),
              funcType$1
            );
            $r = init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["errors"] = (function () {
    var $pkg = {},
      $init,
      reflectlite,
      errorString,
      ptrType,
      ptrType$1,
      errorType,
      _r,
      New;
    reflectlite = $packages["internal/reflectlite"];
    errorString = $pkg.errorString = $newType(
      0,
      $kindStruct,
      "errors.errorString",
      true,
      "errors",
      false,
      function (s_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.s = "";
          return;
        }
        this.s = s_;
      }
    );
    ptrType = $ptrType($error);
    ptrType$1 = $ptrType(errorString);
    New = function (text) {
      var text;
      return new errorString.ptr(text);
    };
    $pkg.New = New;
    errorString.ptr.prototype.Error = function () {
      var e;
      e = this;
      return e.s;
    };
    errorString.prototype.Error = function () {
      return this.$val.Error();
    };
    ptrType$1.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    errorString.init("errors", [
      {
        prop: "s",
        name: "s",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = reflectlite.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r = reflectlite.TypeOf(ptrType.nil).Elem();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            errorType = _r;
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/abi"] = (function () {
    var $pkg = {},
      $init,
      goarch,
      FuncPCABI0;
    goarch = $packages["internal/goarch"];
    FuncPCABI0 = function () {
      $throwRuntimeError(
        "native function not implemented: internal/abi.FuncPCABI0"
      );
    };
    $pkg.FuncPCABI0 = FuncPCABI0;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = goarch.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/cpu"] = (function () {
    var $pkg = {},
      $init;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/bytealg"] = (function () {
    var $pkg = {},
      $init,
      cpu,
      IndexByteString;
    cpu = $packages["internal/cpu"];
    IndexByteString = function (s, c) {
      var c, i, s;
      i = 0;
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        if (s.charCodeAt(i) === c) {
          return i;
        }
        i = (i + 1) >> 0;
      }
      return -1;
    };
    $pkg.IndexByteString = IndexByteString;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = cpu.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/goexperiment"] = (function () {
    var $pkg = {},
      $init;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/itoa"] = (function () {
    var $pkg = {},
      $init,
      arrayType,
      sliceType,
      Itoa,
      Uitoa;
    arrayType = $arrayType($Uint8, 20);
    sliceType = $sliceType($Uint8);
    Itoa = function (val) {
      var val;
      if (val < 0) {
        return "-" + Uitoa(-val >>> 0);
      }
      return Uitoa(val >>> 0);
    };
    $pkg.Itoa = Itoa;
    Uitoa = function (val) {
      var _q, buf, i, q, val;
      if (val === 0) {
        return "0";
      }
      buf = arrayType.zero();
      i = 19;
      while (true) {
        if (!(val >= 10)) {
          break;
        }
        q =
          ((_q = val / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >>> 0
            : $throwRuntimeError("integer divide by zero"));
        i < 0 || i >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[i] =
              (((((48 + val) >>> 0) - ((q * 10) >>> 0)) >>> 0) << 24) >>> 24);
        i = (i - 1) >> 0;
        val = q;
      }
      i < 0 || i >= buf.length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf[i] = (((48 + val) >>> 0) << 24) >>> 24);
      return $bytesToString($subslice(new sliceType(buf), i));
    };
    $pkg.Uitoa = Uitoa;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["math/bits"] = (function () {
    var $pkg = {},
      $init,
      deBruijn32tab,
      deBruijn64tab,
      LeadingZeros64,
      TrailingZeros,
      TrailingZeros32,
      TrailingZeros64,
      Len32,
      Len64,
      Add64,
      Mul64;
    LeadingZeros64 = function (x) {
      var x;
      return (64 - Len64(x)) >> 0;
    };
    $pkg.LeadingZeros64 = LeadingZeros64;
    TrailingZeros = function (x) {
      var x;
      if (true) {
        return TrailingZeros32(x >>> 0);
      }
      return TrailingZeros64(new $Uint64(0, x));
    };
    $pkg.TrailingZeros = TrailingZeros;
    TrailingZeros32 = function (x) {
      var x, x$1;
      if (x === 0) {
        return 32;
      }
      return (
        ((x$1 =
          (($imul((x & (-x >>> 0)) >>> 0, 125613361) >>> 0) >>> 27) >>> 0),
        x$1 < 0 || x$1 >= deBruijn32tab.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : deBruijn32tab[x$1]) >> 0
      );
    };
    $pkg.TrailingZeros32 = TrailingZeros32;
    TrailingZeros64 = function (x) {
      var x, x$1, x$2;
      if (x.$high === 0 && x.$low === 0) {
        return 64;
      }
      return (
        ((x$1 = $shiftRightUint64(
          $mul64(
            ((x$2 = new $Uint64(-x.$high, -x.$low)),
            new $Uint64(x.$high & x$2.$high, (x.$low & x$2.$low) >>> 0)),
            new $Uint64(66559345, 3033172745)
          ),
          58
        )),
        $flatten64(x$1) < 0 || $flatten64(x$1) >= deBruijn64tab.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : deBruijn64tab[$flatten64(x$1)]) >> 0
      );
    };
    $pkg.TrailingZeros64 = TrailingZeros64;
    Len32 = function (x) {
      var n, x, y, y$1;
      n = 0;
      if (x >= 65536) {
        x = ((y = 16), y < 32 ? x >>> y : 0) >>> 0;
        n = 16;
      }
      if (x >= 256) {
        x = ((y$1 = 8), y$1 < 32 ? x >>> y$1 : 0) >>> 0;
        n = (n + 8) >> 0;
      }
      n =
        (n +
          ("\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b".charCodeAt(
            x
          ) >>
            0)) >>
        0;
      return n;
    };
    $pkg.Len32 = Len32;
    Len64 = function (x) {
      var n, x;
      n = 0;
      if (x.$high > 1 || (x.$high === 1 && x.$low >= 0)) {
        x = $shiftRightUint64(x, 32);
        n = 32;
      }
      if (x.$high > 0 || (x.$high === 0 && x.$low >= 65536)) {
        x = $shiftRightUint64(x, 16);
        n = (n + 16) >> 0;
      }
      if (x.$high > 0 || (x.$high === 0 && x.$low >= 256)) {
        x = $shiftRightUint64(x, 8);
        n = (n + 8) >> 0;
      }
      n =
        (n +
          ("\x00\x01\x02\x02\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x06\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\x07\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b".charCodeAt(
            $flatten64(x)
          ) >>
            0)) >>
        0;
      return n;
    };
    $pkg.Len64 = Len64;
    Add64 = function (x, y, carry) {
      var carry, carryOut, sum, x, x$1, x$2, x$3, x$4, y;
      sum = new $Uint64(0, 0);
      carryOut = new $Uint64(0, 0);
      sum =
        ((x$1 = new $Uint64(x.$high + y.$high, x.$low + y.$low)),
        new $Uint64(x$1.$high + carry.$high, x$1.$low + carry.$low));
      carryOut = $shiftRightUint64(
        ((x$2 = new $Uint64(x.$high & y.$high, (x.$low & y.$low) >>> 0)),
        (x$3 =
          ((x$4 = new $Uint64(x.$high | y.$high, (x.$low | y.$low) >>> 0)),
          new $Uint64(x$4.$high & ~sum.$high, (x$4.$low & ~sum.$low) >>> 0))),
        new $Uint64(x$2.$high | x$3.$high, (x$2.$low | x$3.$low) >>> 0)),
        63
      );
      return [sum, carryOut];
    };
    $pkg.Add64 = Add64;
    Mul64 = function (x, y) {
      var hi,
        lo,
        t,
        w0,
        w1,
        w2,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x0,
        x1,
        y,
        y0,
        y1;
      hi = new $Uint64(0, 0);
      lo = new $Uint64(0, 0);
      x0 = new $Uint64(x.$high & 0, (x.$low & 4294967295) >>> 0);
      x1 = $shiftRightUint64(x, 32);
      y0 = new $Uint64(y.$high & 0, (y.$low & 4294967295) >>> 0);
      y1 = $shiftRightUint64(y, 32);
      w0 = $mul64(x0, y0);
      t =
        ((x$1 = $mul64(x1, y0)),
        (x$2 = $shiftRightUint64(w0, 32)),
        new $Uint64(x$1.$high + x$2.$high, x$1.$low + x$2.$low));
      w1 = new $Uint64(t.$high & 0, (t.$low & 4294967295) >>> 0);
      w2 = $shiftRightUint64(t, 32);
      w1 =
        ((x$3 = $mul64(x0, y1)),
        new $Uint64(w1.$high + x$3.$high, w1.$low + x$3.$low));
      hi =
        ((x$4 =
          ((x$5 = $mul64(x1, y1)),
          new $Uint64(x$5.$high + w2.$high, x$5.$low + w2.$low))),
        (x$6 = $shiftRightUint64(w1, 32)),
        new $Uint64(x$4.$high + x$6.$high, x$4.$low + x$6.$low));
      lo = $mul64(x, y);
      return [hi, lo];
    };
    $pkg.Mul64 = Mul64;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            deBruijn32tab = $toNativeArray(
              $kindUint8,
              [
                0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31,
                27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,
              ]
            );
            deBruijn64tab = $toNativeArray(
              $kindUint8,
              [
                0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62,
                47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63,
                55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54,
                26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,
              ]
            );
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["math"] = (function () {
    var $pkg = {},
      $init,
      js,
      bits,
      arrayType,
      arrayType$1,
      arrayType$2,
      structType,
      math,
      _zero,
      posInf,
      negInf,
      nan,
      buf,
      Inf,
      Mod,
      NaN,
      init,
      Float32bits,
      Float32frombits,
      Float64bits,
      Float64frombits;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    bits = $packages["math/bits"];
    arrayType = $arrayType($Uint32, 2);
    arrayType$1 = $arrayType($Float32, 2);
    arrayType$2 = $arrayType($Float64, 1);
    structType = $structType("math", [
      {
        prop: "uint32array",
        name: "uint32array",
        embedded: false,
        exported: false,
        typ: arrayType,
        tag: "",
      },
      {
        prop: "float32array",
        name: "float32array",
        embedded: false,
        exported: false,
        typ: arrayType$1,
        tag: "",
      },
      {
        prop: "float64array",
        name: "float64array",
        embedded: false,
        exported: false,
        typ: arrayType$2,
        tag: "",
      },
    ]);
    Inf = function (sign) {
      var sign;
      if (sign >= 0) {
        return posInf;
      } else {
        return negInf;
      }
    };
    $pkg.Inf = Inf;
    Mod = function (x, y) {
      var x, y;
      return $parseFloat($mod(x, y));
    };
    $pkg.Mod = Mod;
    $pkg.NaN = function () {
      return nan;
    };
    init = function () {
      var ab;
      ab = new $global.ArrayBuffer(8);
      buf.uint32array = new $global.Uint32Array(ab);
      buf.float32array = new $global.Float32Array(ab);
      buf.float64array = new $global.Float64Array(ab);
    };
    Float32bits = function (f) {
      var f;
      buf.float32array[0] = f;
      return buf.uint32array[0];
    };
    $pkg.Float32bits = Float32bits;
    Float32frombits = function (b) {
      var b;
      buf.uint32array[0] = b;
      return buf.float32array[0];
    };
    $pkg.Float32frombits = Float32frombits;
    Float64bits = function (f) {
      var f, x, x$1;
      buf.float64array[0] = f;
      return (
        (x = $shiftLeft64(new $Uint64(0, buf.uint32array[1]), 32)),
        (x$1 = new $Uint64(0, buf.uint32array[0])),
        new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low)
      );
    };
    $pkg.Float64bits = Float64bits;
    Float64frombits = function (b) {
      var b;
      buf.uint32array[0] = b.$low >>> 0;
      buf.uint32array[1] = $shiftRightUint64(b, 32).$low >>> 0;
      return buf.float64array[0];
    };
    $pkg.Float64frombits = Float64frombits;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bits.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            buf = new structType.ptr(
              arrayType.zero(),
              arrayType$1.zero(),
              arrayType$2.zero()
            );
            math = $global.Math;
            _zero = 0;
            posInf = 1 / _zero;
            negInf = -1 / _zero;
            nan = $parseFloat($NaN);
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["unicode/utf8"] = (function () {
    var $pkg = {},
      $init,
      acceptRange,
      first,
      acceptRanges,
      DecodeRune,
      DecodeRuneInString,
      RuneLen,
      EncodeRune,
      RuneCount,
      RuneCountInString,
      ValidString,
      ValidRune;
    acceptRange = $pkg.acceptRange = $newType(
      0,
      $kindStruct,
      "utf8.acceptRange",
      true,
      "unicode/utf8",
      false,
      function (lo_, hi_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.lo = 0;
          this.hi = 0;
          return;
        }
        this.lo = lo_;
        this.hi = hi_;
      }
    );
    DecodeRune = function (p) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        accept,
        b1,
        b2,
        b3,
        mask,
        n,
        p,
        p0,
        r,
        size,
        sz,
        x,
        x$1;
      r = 0;
      size = 0;
      n = p.$length;
      if (n < 1) {
        _tmp = 65533;
        _tmp$1 = 0;
        r = _tmp;
        size = _tmp$1;
        return [r, size];
      }
      p0 =
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : p.$array[p.$offset + 0];
      x =
        p0 < 0 || p0 >= first.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : first[p0];
      if (x >= 240) {
        mask = ((((x >> 0) << 31) >> 0) >> 31) >> 0;
        _tmp$2 =
          ((((0 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + 0]) >>
            0) &
            ~mask) >>
            0) |
          (65533 & mask);
        _tmp$3 = 1;
        r = _tmp$2;
        size = _tmp$3;
        return [r, size];
      }
      sz = ((x & 7) >>> 0) >> 0;
      accept = $clone(
        ((x$1 = ((x >>> 4) << 24) >>> 24),
        x$1 < 0 || x$1 >= acceptRanges.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : acceptRanges[x$1]),
        acceptRange
      );
      if (n < sz) {
        _tmp$4 = 65533;
        _tmp$5 = 1;
        r = _tmp$4;
        size = _tmp$5;
        return [r, size];
      }
      b1 =
        1 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : p.$array[p.$offset + 1];
      if (b1 < accept.lo || accept.hi < b1) {
        _tmp$6 = 65533;
        _tmp$7 = 1;
        r = _tmp$6;
        size = _tmp$7;
        return [r, size];
      }
      if (sz <= 2) {
        _tmp$8 =
          (((((p0 & 31) >>> 0) >> 0) << 6) >> 0) | (((b1 & 63) >>> 0) >> 0);
        _tmp$9 = 2;
        r = _tmp$8;
        size = _tmp$9;
        return [r, size];
      }
      b2 =
        2 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : p.$array[p.$offset + 2];
      if (b2 < 128 || 191 < b2) {
        _tmp$10 = 65533;
        _tmp$11 = 1;
        r = _tmp$10;
        size = _tmp$11;
        return [r, size];
      }
      if (sz <= 3) {
        _tmp$12 =
          (((((p0 & 15) >>> 0) >> 0) << 12) >> 0) |
          (((((b1 & 63) >>> 0) >> 0) << 6) >> 0) |
          (((b2 & 63) >>> 0) >> 0);
        _tmp$13 = 3;
        r = _tmp$12;
        size = _tmp$13;
        return [r, size];
      }
      b3 =
        3 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : p.$array[p.$offset + 3];
      if (b3 < 128 || 191 < b3) {
        _tmp$14 = 65533;
        _tmp$15 = 1;
        r = _tmp$14;
        size = _tmp$15;
        return [r, size];
      }
      _tmp$16 =
        (((((p0 & 7) >>> 0) >> 0) << 18) >> 0) |
        (((((b1 & 63) >>> 0) >> 0) << 12) >> 0) |
        (((((b2 & 63) >>> 0) >> 0) << 6) >> 0) |
        (((b3 & 63) >>> 0) >> 0);
      _tmp$17 = 4;
      r = _tmp$16;
      size = _tmp$17;
      return [r, size];
    };
    $pkg.DecodeRune = DecodeRune;
    DecodeRuneInString = function (s) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        accept,
        mask,
        n,
        r,
        s,
        s0,
        s1,
        s2,
        s3,
        size,
        sz,
        x,
        x$1;
      r = 0;
      size = 0;
      n = s.length;
      if (n < 1) {
        _tmp = 65533;
        _tmp$1 = 0;
        r = _tmp;
        size = _tmp$1;
        return [r, size];
      }
      s0 = s.charCodeAt(0);
      x =
        s0 < 0 || s0 >= first.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : first[s0];
      if (x >= 240) {
        mask = ((((x >> 0) << 31) >> 0) >> 31) >> 0;
        _tmp$2 = (((s.charCodeAt(0) >> 0) & ~mask) >> 0) | (65533 & mask);
        _tmp$3 = 1;
        r = _tmp$2;
        size = _tmp$3;
        return [r, size];
      }
      sz = ((x & 7) >>> 0) >> 0;
      accept = $clone(
        ((x$1 = ((x >>> 4) << 24) >>> 24),
        x$1 < 0 || x$1 >= acceptRanges.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : acceptRanges[x$1]),
        acceptRange
      );
      if (n < sz) {
        _tmp$4 = 65533;
        _tmp$5 = 1;
        r = _tmp$4;
        size = _tmp$5;
        return [r, size];
      }
      s1 = s.charCodeAt(1);
      if (s1 < accept.lo || accept.hi < s1) {
        _tmp$6 = 65533;
        _tmp$7 = 1;
        r = _tmp$6;
        size = _tmp$7;
        return [r, size];
      }
      if (sz <= 2) {
        _tmp$8 =
          (((((s0 & 31) >>> 0) >> 0) << 6) >> 0) | (((s1 & 63) >>> 0) >> 0);
        _tmp$9 = 2;
        r = _tmp$8;
        size = _tmp$9;
        return [r, size];
      }
      s2 = s.charCodeAt(2);
      if (s2 < 128 || 191 < s2) {
        _tmp$10 = 65533;
        _tmp$11 = 1;
        r = _tmp$10;
        size = _tmp$11;
        return [r, size];
      }
      if (sz <= 3) {
        _tmp$12 =
          (((((s0 & 15) >>> 0) >> 0) << 12) >> 0) |
          (((((s1 & 63) >>> 0) >> 0) << 6) >> 0) |
          (((s2 & 63) >>> 0) >> 0);
        _tmp$13 = 3;
        r = _tmp$12;
        size = _tmp$13;
        return [r, size];
      }
      s3 = s.charCodeAt(3);
      if (s3 < 128 || 191 < s3) {
        _tmp$14 = 65533;
        _tmp$15 = 1;
        r = _tmp$14;
        size = _tmp$15;
        return [r, size];
      }
      _tmp$16 =
        (((((s0 & 7) >>> 0) >> 0) << 18) >> 0) |
        (((((s1 & 63) >>> 0) >> 0) << 12) >> 0) |
        (((((s2 & 63) >>> 0) >> 0) << 6) >> 0) |
        (((s3 & 63) >>> 0) >> 0);
      _tmp$17 = 4;
      r = _tmp$16;
      size = _tmp$17;
      return [r, size];
    };
    $pkg.DecodeRuneInString = DecodeRuneInString;
    RuneLen = function (r) {
      var r;
      if (r < 0) {
        return -1;
      } else if (r <= 127) {
        return 1;
      } else if (r <= 2047) {
        return 2;
      } else if (55296 <= r && r <= 57343) {
        return -1;
      } else if (r <= 65535) {
        return 3;
      } else if (r <= 1114111) {
        return 4;
      }
      return -1;
    };
    $pkg.RuneLen = RuneLen;
    EncodeRune = function (p, r) {
      var i, p, r;
      i = r >>> 0;
      if (i <= 127) {
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 0] = (r << 24) >>> 24);
        return 1;
      } else if (i <= 2047) {
        $unused(
          1 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + 1]
        );
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 0] =
              (192 | ((((r >> 6) >> 0) << 24) >>> 24)) >>> 0);
        1 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 1] =
              (128 | ((((r << 24) >>> 24) & 63) >>> 0)) >>> 0);
        return 2;
      } else if (i > 1114111 || (55296 <= i && i <= 57343)) {
        r = 65533;
        $unused(
          2 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + 2]
        );
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 0] =
              (224 | ((((r >> 12) >> 0) << 24) >>> 24)) >>> 0);
        1 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 1] =
              (128 | ((((((r >> 6) >> 0) << 24) >>> 24) & 63) >>> 0)) >>> 0);
        2 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 2] =
              (128 | ((((r << 24) >>> 24) & 63) >>> 0)) >>> 0);
        return 3;
      } else if (i <= 65535) {
        $unused(
          2 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + 2]
        );
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 0] =
              (224 | ((((r >> 12) >> 0) << 24) >>> 24)) >>> 0);
        1 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 1] =
              (128 | ((((((r >> 6) >> 0) << 24) >>> 24) & 63) >>> 0)) >>> 0);
        2 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 2] =
              (128 | ((((r << 24) >>> 24) & 63) >>> 0)) >>> 0);
        return 3;
      } else {
        $unused(
          3 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + 3]
        );
        0 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 0] =
              (240 | ((((r >> 18) >> 0) << 24) >>> 24)) >>> 0);
        1 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 1] =
              (128 | ((((((r >> 12) >> 0) << 24) >>> 24) & 63) >>> 0)) >>> 0);
        2 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 2] =
              (128 | ((((((r >> 6) >> 0) << 24) >>> 24) & 63) >>> 0)) >>> 0);
        3 >= p.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (p.$array[p.$offset + 3] =
              (128 | ((((r << 24) >>> 24) & 63) >>> 0)) >>> 0);
        return 4;
      }
    };
    $pkg.EncodeRune = EncodeRune;
    RuneCount = function (p) {
      var accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;
      np = p.$length;
      n = 0;
      i = 0;
      while (true) {
        if (!(i < np)) {
          break;
        }
        n = (n + 1) >> 0;
        c =
          i < 0 || i >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + i];
        if (c < 128) {
          i = (i + 1) >> 0;
          continue;
        }
        x =
          c < 0 || c >= first.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : first[c];
        if (x === 241) {
          i = (i + 1) >> 0;
          continue;
        }
        size = ((x & 7) >>> 0) >> 0;
        if ((i + size) >> 0 > np) {
          i = (i + 1) >> 0;
          continue;
        }
        accept = $clone(
          ((x$1 = ((x >>> 4) << 24) >>> 24),
          x$1 < 0 || x$1 >= acceptRanges.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : acceptRanges[x$1]),
          acceptRange
        );
        c$1 =
          ((x$2 = (i + 1) >> 0),
          x$2 < 0 || x$2 >= p.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : p.$array[p.$offset + x$2]);
        if (c$1 < accept.lo || accept.hi < c$1) {
          size = 1;
        } else if (size === 2) {
        } else {
          c$2 =
            ((x$3 = (i + 2) >> 0),
            x$3 < 0 || x$3 >= p.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : p.$array[p.$offset + x$3]);
          if (c$2 < 128 || 191 < c$2) {
            size = 1;
          } else if (size === 3) {
          } else {
            c$3 =
              ((x$4 = (i + 3) >> 0),
              x$4 < 0 || x$4 >= p.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : p.$array[p.$offset + x$4]);
            if (c$3 < 128 || 191 < c$3) {
              size = 1;
            }
          }
        }
        i = (i + size) >> 0;
      }
      return n;
    };
    $pkg.RuneCount = RuneCount;
    RuneCountInString = function (s) {
      var accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;
      n = 0;
      ns = s.length;
      i = 0;
      while (true) {
        if (!(i < ns)) {
          break;
        }
        c = s.charCodeAt(i);
        if (c < 128) {
          i = (i + 1) >> 0;
          n = (n + 1) >> 0;
          continue;
        }
        x =
          c < 0 || c >= first.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : first[c];
        if (x === 241) {
          i = (i + 1) >> 0;
          n = (n + 1) >> 0;
          continue;
        }
        size = ((x & 7) >>> 0) >> 0;
        if ((i + size) >> 0 > ns) {
          i = (i + 1) >> 0;
          n = (n + 1) >> 0;
          continue;
        }
        accept = $clone(
          ((x$1 = ((x >>> 4) << 24) >>> 24),
          x$1 < 0 || x$1 >= acceptRanges.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : acceptRanges[x$1]),
          acceptRange
        );
        c$1 = s.charCodeAt((i + 1) >> 0);
        if (c$1 < accept.lo || accept.hi < c$1) {
          size = 1;
        } else if (size === 2) {
        } else {
          c$2 = s.charCodeAt((i + 2) >> 0);
          if (c$2 < 128 || 191 < c$2) {
            size = 1;
          } else if (size === 3) {
          } else {
            c$3 = s.charCodeAt((i + 3) >> 0);
            if (c$3 < 128 || 191 < c$3) {
              size = 1;
            }
          }
        }
        i = (i + size) >> 0;
        n = (n + 1) >> 0;
      }
      n = n;
      return n;
    };
    $pkg.RuneCountInString = RuneCountInString;
    ValidString = function (s) {
      var accept, c, c$1, c$2, first32, i, n, s, second32, si, size, x, x$1;
      while (true) {
        if (!(s.length >= 8)) {
          break;
        }
        first32 =
          ((((((s.charCodeAt(0) >>> 0) |
            (((s.charCodeAt(1) >>> 0) << 8) >>> 0)) >>>
            0) |
            (((s.charCodeAt(2) >>> 0) << 16) >>> 0)) >>>
            0) |
            (((s.charCodeAt(3) >>> 0) << 24) >>> 0)) >>>
          0;
        second32 =
          ((((((s.charCodeAt(4) >>> 0) |
            (((s.charCodeAt(5) >>> 0) << 8) >>> 0)) >>>
            0) |
            (((s.charCodeAt(6) >>> 0) << 16) >>> 0)) >>>
            0) |
            (((s.charCodeAt(7) >>> 0) << 24) >>> 0)) >>>
          0;
        if (!((((first32 | second32) >>> 0) & 2155905152) >>> 0 === 0)) {
          break;
        }
        s = $substring(s, 8);
      }
      n = s.length;
      i = 0;
      while (true) {
        if (!(i < n)) {
          break;
        }
        si = s.charCodeAt(i);
        if (si < 128) {
          i = (i + 1) >> 0;
          continue;
        }
        x =
          si < 0 || si >= first.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : first[si];
        if (x === 241) {
          return false;
        }
        size = ((x & 7) >>> 0) >> 0;
        if ((i + size) >> 0 > n) {
          return false;
        }
        accept = $clone(
          ((x$1 = ((x >>> 4) << 24) >>> 24),
          x$1 < 0 || x$1 >= acceptRanges.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : acceptRanges[x$1]),
          acceptRange
        );
        c = s.charCodeAt((i + 1) >> 0);
        if (c < accept.lo || accept.hi < c) {
          return false;
        } else if (size === 2) {
        } else {
          c$1 = s.charCodeAt((i + 2) >> 0);
          if (c$1 < 128 || 191 < c$1) {
            return false;
          } else if (size === 3) {
          } else {
            c$2 = s.charCodeAt((i + 3) >> 0);
            if (c$2 < 128 || 191 < c$2) {
              return false;
            }
          }
        }
        i = (i + size) >> 0;
      }
      return true;
    };
    $pkg.ValidString = ValidString;
    ValidRune = function (r) {
      var r;
      if (0 <= r && r < 55296) {
        return true;
      } else if (57343 < r && r <= 1114111) {
        return true;
      }
      return false;
    };
    $pkg.ValidRune = ValidRune;
    acceptRange.init("unicode/utf8", [
      {
        prop: "lo",
        name: "lo",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "hi",
        name: "hi",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            first = $toNativeArray(
              $kindUint8,
              [
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
                240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241,
                241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,
                241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,
                241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,
                241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241,
                241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2,
                2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
                2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241,
                241, 241, 241, 241,
              ]
            );
            acceptRanges = $toNativeArray($kindStruct, [
              new acceptRange.ptr(128, 191),
              new acceptRange.ptr(160, 191),
              new acceptRange.ptr(128, 159),
              new acceptRange.ptr(144, 191),
              new acceptRange.ptr(128, 143),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
              new acceptRange.ptr(0, 0),
            ]);
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["strconv"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js,
      bytealg,
      math,
      bits,
      utf8,
      floatInfo,
      decimalSlice,
      decimal,
      leftCheat,
      NumError,
      sliceType,
      sliceType$1,
      arrayType,
      sliceType$2,
      sliceType$3,
      sliceType$4,
      sliceType$5,
      sliceType$6,
      arrayType$1,
      arrayType$2,
      ptrType,
      arrayType$3,
      arrayType$4,
      arrayType$5,
      ptrType$1,
      ptrType$2,
      isPrint16,
      isNotPrint16,
      isPrint32,
      isNotPrint32,
      isGraphic,
      uint64pow10,
      float32info,
      float32info$24ptr,
      float64info,
      float64info$24ptr,
      detailedPowersOfTen,
      leftcheats,
      optimize,
      powtab,
      float64pow10,
      float32pow10,
      contains,
      quoteWith,
      appendQuotedWith,
      appendQuotedRuneWith,
      appendEscapedRune,
      Quote,
      AppendQuote,
      AppendQuoteToASCII,
      AppendQuoteRune,
      AppendQuoteRuneToASCII,
      CanBackquote,
      unhex,
      UnquoteChar,
      Unquote,
      unquote,
      bsearch16,
      bsearch32,
      IsPrint,
      isInGraphicList,
      formatBits,
      isPowerOfTwo,
      Itoa,
      Atoi,
      ryuFtoaFixed32,
      ryuFtoaFixed64,
      formatDecimal,
      ryuFtoaShortest,
      mulByLog2Log10,
      mulByLog10Log2,
      computeBounds,
      ryuDigits,
      ryuDigits32,
      mult64bitPow10,
      mult128bitPow10,
      divisibleByPower5,
      divmod1e9,
      FormatFloat,
      AppendFloat,
      genericFtoa,
      bigFtoa,
      formatDigits,
      roundShortest,
      fmtE,
      fmtF,
      fmtB,
      fmtX,
      min,
      max,
      eiselLemire64,
      eiselLemire32,
      digitZero,
      trim,
      rightShift,
      prefixIsLessThan,
      leftShift,
      shouldRoundUp,
      index,
      lower,
      syntaxError,
      rangeError,
      baseError,
      bitSizeError,
      ParseUint,
      underscoreOK,
      commonPrefixLenIgnoreCase,
      special,
      readFloat,
      atof64exact,
      atof32exact,
      atofHex,
      atof32,
      atof64,
      ParseFloat,
      parseFloatPrefix,
      FormatBool;
    errors = $packages["errors"];
    js = $packages["github.com/gopherjs/gopherjs/js"];
    bytealg = $packages["internal/bytealg"];
    math = $packages["math"];
    bits = $packages["math/bits"];
    utf8 = $packages["unicode/utf8"];
    floatInfo = $pkg.floatInfo = $newType(
      0,
      $kindStruct,
      "strconv.floatInfo",
      true,
      "strconv",
      false,
      function (mantbits_, expbits_, bias_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.mantbits = 0;
          this.expbits = 0;
          this.bias = 0;
          return;
        }
        this.mantbits = mantbits_;
        this.expbits = expbits_;
        this.bias = bias_;
      }
    );
    decimalSlice = $pkg.decimalSlice = $newType(
      0,
      $kindStruct,
      "strconv.decimalSlice",
      true,
      "strconv",
      false,
      function (d_, nd_, dp_, neg_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.d = sliceType$6.nil;
          this.nd = 0;
          this.dp = 0;
          this.neg = false;
          return;
        }
        this.d = d_;
        this.nd = nd_;
        this.dp = dp_;
        this.neg = neg_;
      }
    );
    decimal = $pkg.decimal = $newType(
      0,
      $kindStruct,
      "strconv.decimal",
      true,
      "strconv",
      false,
      function (d_, nd_, dp_, neg_, trunc_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.d = arrayType$5.zero();
          this.nd = 0;
          this.dp = 0;
          this.neg = false;
          this.trunc = false;
          return;
        }
        this.d = d_;
        this.nd = nd_;
        this.dp = dp_;
        this.neg = neg_;
        this.trunc = trunc_;
      }
    );
    leftCheat = $pkg.leftCheat = $newType(
      0,
      $kindStruct,
      "strconv.leftCheat",
      true,
      "strconv",
      false,
      function (delta_, cutoff_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.delta = 0;
          this.cutoff = "";
          return;
        }
        this.delta = delta_;
        this.cutoff = cutoff_;
      }
    );
    NumError = $pkg.NumError = $newType(
      0,
      $kindStruct,
      "strconv.NumError",
      true,
      "strconv",
      true,
      function (Func_, Num_, Err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Func = "";
          this.Num = "";
          this.Err = $ifaceNil;
          return;
        }
        this.Func = Func_;
        this.Num = Num_;
        this.Err = Err_;
      }
    );
    sliceType = $sliceType($Uint16);
    sliceType$1 = $sliceType($Uint32);
    arrayType = $arrayType($Uint64, 2);
    sliceType$2 = $sliceType(leftCheat);
    sliceType$3 = $sliceType($Int);
    sliceType$4 = $sliceType($Float64);
    sliceType$5 = $sliceType($Float32);
    sliceType$6 = $sliceType($Uint8);
    arrayType$1 = $arrayType($Uint8, 4);
    arrayType$2 = $arrayType($Uint8, 65);
    ptrType = $ptrType(floatInfo);
    arrayType$3 = $arrayType($Uint8, 32);
    arrayType$4 = $arrayType($Uint8, 24);
    arrayType$5 = $arrayType($Uint8, 800);
    ptrType$1 = $ptrType(NumError);
    ptrType$2 = $ptrType(decimal);
    contains = function (s, c) {
      var c, s;
      return !(index(s, c) === -1);
    };
    quoteWith = function (s, quote, ASCIIonly, graphicOnly) {
      var ASCIIonly, _q, graphicOnly, quote, s;
      return $bytesToString(
        appendQuotedWith(
          $makeSlice(
            sliceType$6,
            0,
            ((_q = $imul(3, s.length) / 2),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >> 0
              : $throwRuntimeError("integer divide by zero"))
          ),
          s,
          quote,
          ASCIIonly,
          graphicOnly
        )
      );
    };
    appendQuotedWith = function (buf, s, quote, ASCIIonly, graphicOnly) {
      var ASCIIonly, _tuple, buf, graphicOnly, nBuf, quote, r, s, width;
      if ((buf.$capacity - buf.$length) >> 0 < s.length) {
        nBuf = $makeSlice(
          sliceType$6,
          buf.$length,
          (((((buf.$length + 1) >> 0) + s.length) >> 0) + 1) >> 0
        );
        $copySlice(nBuf, buf);
        buf = nBuf;
      }
      buf = $append(buf, quote);
      width = 0;
      while (true) {
        if (!(s.length > 0)) {
          break;
        }
        r = s.charCodeAt(0) >> 0;
        width = 1;
        if (r >= 128) {
          _tuple = utf8.DecodeRuneInString(s);
          r = _tuple[0];
          width = _tuple[1];
        }
        if (width === 1 && r === 65533) {
          buf = $appendSlice(buf, "\\x");
          buf = $append(
            buf,
            "0123456789abcdef".charCodeAt(
              ((s.charCodeAt(0) >>> 4) << 24) >>> 24
            )
          );
          buf = $append(
            buf,
            "0123456789abcdef".charCodeAt((s.charCodeAt(0) & 15) >>> 0)
          );
          s = $substring(s, width);
          continue;
        }
        buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
        s = $substring(s, width);
      }
      buf = $append(buf, quote);
      return buf;
    };
    appendQuotedRuneWith = function (buf, r, quote, ASCIIonly, graphicOnly) {
      var ASCIIonly, buf, graphicOnly, quote, r;
      buf = $append(buf, quote);
      if (!utf8.ValidRune(r)) {
        r = 65533;
      }
      buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
      buf = $append(buf, quote);
      return buf;
    };
    appendEscapedRune = function (buf, r, quote, ASCIIonly, graphicOnly) {
      var ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1;
      runeTmp = arrayType$1.zero();
      if (r === quote >> 0 || r === 92) {
        buf = $append(buf, 92);
        buf = $append(buf, (r << 24) >>> 24);
        return buf;
      }
      if (ASCIIonly) {
        if (r < 128 && IsPrint(r)) {
          buf = $append(buf, (r << 24) >>> 24);
          return buf;
        }
      } else if (IsPrint(r) || (graphicOnly && isInGraphicList(r))) {
        n = utf8.EncodeRune(new sliceType$6(runeTmp), r);
        buf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));
        return buf;
      }
      _1 = r;
      if (_1 === 7) {
        buf = $appendSlice(buf, "\\a");
      } else if (_1 === 8) {
        buf = $appendSlice(buf, "\\b");
      } else if (_1 === 12) {
        buf = $appendSlice(buf, "\\f");
      } else if (_1 === 10) {
        buf = $appendSlice(buf, "\\n");
      } else if (_1 === 13) {
        buf = $appendSlice(buf, "\\r");
      } else if (_1 === 9) {
        buf = $appendSlice(buf, "\\t");
      } else if (_1 === 11) {
        buf = $appendSlice(buf, "\\v");
      } else {
        if (r < 32) {
          buf = $appendSlice(buf, "\\x");
          buf = $append(
            buf,
            "0123456789abcdef".charCodeAt(
              ((((r << 24) >>> 24) >>> 4) << 24) >>> 24
            )
          );
          buf = $append(
            buf,
            "0123456789abcdef".charCodeAt((((r << 24) >>> 24) & 15) >>> 0)
          );
        } else if (!utf8.ValidRune(r)) {
          r = 65533;
          buf = $appendSlice(buf, "\\u");
          s = 12;
          while (true) {
            if (!(s >= 0)) {
              break;
            }
            buf = $append(
              buf,
              "0123456789abcdef".charCodeAt(
                ((r >> $min(s >>> 0, 31)) >> 0) & 15
              )
            );
            s = (s - 4) >> 0;
          }
        } else if (r < 65536) {
          buf = $appendSlice(buf, "\\u");
          s = 12;
          while (true) {
            if (!(s >= 0)) {
              break;
            }
            buf = $append(
              buf,
              "0123456789abcdef".charCodeAt(
                ((r >> $min(s >>> 0, 31)) >> 0) & 15
              )
            );
            s = (s - 4) >> 0;
          }
        } else {
          buf = $appendSlice(buf, "\\U");
          s$1 = 28;
          while (true) {
            if (!(s$1 >= 0)) {
              break;
            }
            buf = $append(
              buf,
              "0123456789abcdef".charCodeAt(
                ((r >> $min(s$1 >>> 0, 31)) >> 0) & 15
              )
            );
            s$1 = (s$1 - 4) >> 0;
          }
        }
      }
      return buf;
    };
    Quote = function (s) {
      var s;
      return quoteWith(s, 34, false, false);
    };
    $pkg.Quote = Quote;
    AppendQuote = function (dst, s) {
      var dst, s;
      return appendQuotedWith(dst, s, 34, false, false);
    };
    $pkg.AppendQuote = AppendQuote;
    AppendQuoteToASCII = function (dst, s) {
      var dst, s;
      return appendQuotedWith(dst, s, 34, true, false);
    };
    $pkg.AppendQuoteToASCII = AppendQuoteToASCII;
    AppendQuoteRune = function (dst, r) {
      var dst, r;
      return appendQuotedRuneWith(dst, r, 39, false, false);
    };
    $pkg.AppendQuoteRune = AppendQuoteRune;
    AppendQuoteRuneToASCII = function (dst, r) {
      var dst, r;
      return appendQuotedRuneWith(dst, r, 39, true, false);
    };
    $pkg.AppendQuoteRuneToASCII = AppendQuoteRuneToASCII;
    CanBackquote = function (s) {
      var _tuple, r, s, wid;
      while (true) {
        if (!(s.length > 0)) {
          break;
        }
        _tuple = utf8.DecodeRuneInString(s);
        r = _tuple[0];
        wid = _tuple[1];
        s = $substring(s, wid);
        if (wid > 1) {
          if (r === 65279) {
            return false;
          }
          continue;
        }
        if (r === 65533) {
          return false;
        }
        if ((r < 32 && !(r === 9)) || r === 96 || r === 127) {
          return false;
        }
      }
      return true;
    };
    $pkg.CanBackquote = CanBackquote;
    unhex = function (b) {
      var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, c, ok, v;
      v = 0;
      ok = false;
      c = b >> 0;
      if (48 <= c && c <= 57) {
        _tmp = (c - 48) >> 0;
        _tmp$1 = true;
        v = _tmp;
        ok = _tmp$1;
        return [v, ok];
      } else if (97 <= c && c <= 102) {
        _tmp$2 = (((c - 97) >> 0) + 10) >> 0;
        _tmp$3 = true;
        v = _tmp$2;
        ok = _tmp$3;
        return [v, ok];
      } else if (65 <= c && c <= 70) {
        _tmp$4 = (((c - 65) >> 0) + 10) >> 0;
        _tmp$5 = true;
        v = _tmp$4;
        ok = _tmp$5;
        return [v, ok];
      }
      return [v, ok];
    };
    UnquoteChar = function (s, quote) {
      var _1,
        _2,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tuple,
        _tuple$1,
        c,
        c$1,
        err,
        j,
        j$1,
        multibyte,
        n,
        ok,
        quote,
        r,
        s,
        size,
        tail,
        v,
        v$1,
        value,
        x,
        x$1;
      value = 0;
      multibyte = false;
      tail = "";
      err = $ifaceNil;
      if (s.length === 0) {
        err = $pkg.ErrSyntax;
        return [value, multibyte, tail, err];
      }
      c = s.charCodeAt(0);
      if (c === quote && (quote === 39 || quote === 34)) {
        err = $pkg.ErrSyntax;
        return [value, multibyte, tail, err];
      } else if (c >= 128) {
        _tuple = utf8.DecodeRuneInString(s);
        r = _tuple[0];
        size = _tuple[1];
        _tmp = r;
        _tmp$1 = true;
        _tmp$2 = $substring(s, size);
        _tmp$3 = $ifaceNil;
        value = _tmp;
        multibyte = _tmp$1;
        tail = _tmp$2;
        err = _tmp$3;
        return [value, multibyte, tail, err];
      } else if (!(c === 92)) {
        _tmp$4 = s.charCodeAt(0) >> 0;
        _tmp$5 = false;
        _tmp$6 = $substring(s, 1);
        _tmp$7 = $ifaceNil;
        value = _tmp$4;
        multibyte = _tmp$5;
        tail = _tmp$6;
        err = _tmp$7;
        return [value, multibyte, tail, err];
      }
      if (s.length <= 1) {
        err = $pkg.ErrSyntax;
        return [value, multibyte, tail, err];
      }
      c$1 = s.charCodeAt(1);
      s = $substring(s, 2);
      switch (0) {
        default:
          _1 = c$1;
          if (_1 === 97) {
            value = 7;
          } else if (_1 === 98) {
            value = 8;
          } else if (_1 === 102) {
            value = 12;
          } else if (_1 === 110) {
            value = 10;
          } else if (_1 === 114) {
            value = 13;
          } else if (_1 === 116) {
            value = 9;
          } else if (_1 === 118) {
            value = 11;
          } else if (_1 === 120 || _1 === 117 || _1 === 85) {
            n = 0;
            _2 = c$1;
            if (_2 === 120) {
              n = 2;
            } else if (_2 === 117) {
              n = 4;
            } else if (_2 === 85) {
              n = 8;
            }
            v = 0;
            if (s.length < n) {
              err = $pkg.ErrSyntax;
              return [value, multibyte, tail, err];
            }
            j = 0;
            while (true) {
              if (!(j < n)) {
                break;
              }
              _tuple$1 = unhex(s.charCodeAt(j));
              x = _tuple$1[0];
              ok = _tuple$1[1];
              if (!ok) {
                err = $pkg.ErrSyntax;
                return [value, multibyte, tail, err];
              }
              v = ((v << 4) >> 0) | x;
              j = (j + 1) >> 0;
            }
            s = $substring(s, n);
            if (c$1 === 120) {
              value = v;
              break;
            }
            if (!utf8.ValidRune(v)) {
              err = $pkg.ErrSyntax;
              return [value, multibyte, tail, err];
            }
            value = v;
            multibyte = true;
          } else if (
            _1 === 48 ||
            _1 === 49 ||
            _1 === 50 ||
            _1 === 51 ||
            _1 === 52 ||
            _1 === 53 ||
            _1 === 54 ||
            _1 === 55
          ) {
            v$1 = ((c$1 >> 0) - 48) >> 0;
            if (s.length < 2) {
              err = $pkg.ErrSyntax;
              return [value, multibyte, tail, err];
            }
            j$1 = 0;
            while (true) {
              if (!(j$1 < 2)) {
                break;
              }
              x$1 = ((s.charCodeAt(j$1) >> 0) - 48) >> 0;
              if (x$1 < 0 || x$1 > 7) {
                err = $pkg.ErrSyntax;
                return [value, multibyte, tail, err];
              }
              v$1 = ((v$1 << 3) >> 0) | x$1;
              j$1 = (j$1 + 1) >> 0;
            }
            s = $substring(s, 2);
            if (v$1 > 255) {
              err = $pkg.ErrSyntax;
              return [value, multibyte, tail, err];
            }
            value = v$1;
          } else if (_1 === 92) {
            value = 92;
          } else if (_1 === 39 || _1 === 34) {
            if (!(c$1 === quote)) {
              err = $pkg.ErrSyntax;
              return [value, multibyte, tail, err];
            }
            value = c$1 >> 0;
          } else {
            err = $pkg.ErrSyntax;
            return [value, multibyte, tail, err];
          }
      }
      tail = s;
      return [value, multibyte, tail, err];
    };
    $pkg.UnquoteChar = UnquoteChar;
    Unquote = function (s) {
      var _tuple, err, out, rem, s;
      _tuple = unquote(s, true);
      out = _tuple[0];
      rem = _tuple[1];
      err = _tuple[2];
      if (rem.length > 0) {
        return ["", $pkg.ErrSyntax];
      }
      return [out, err];
    };
    $pkg.Unquote = Unquote;
    unquote = function (in$1, unescape) {
      var _1,
        _2,
        _q,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$24,
        _tmp$25,
        _tmp$26,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        arr,
        buf,
        buf$1,
        end,
        err,
        err$1,
        i,
        in$1,
        in0,
        multibyte,
        n,
        n$1,
        out,
        quote,
        r,
        r$1,
        rem,
        rem$1,
        unescape,
        valid;
      out = "";
      rem = "";
      err = $ifaceNil;
      if (in$1.length < 2) {
        _tmp = "";
        _tmp$1 = in$1;
        _tmp$2 = $pkg.ErrSyntax;
        out = _tmp;
        rem = _tmp$1;
        err = _tmp$2;
        return [out, rem, err];
      }
      quote = in$1.charCodeAt(0);
      end = index($substring(in$1, 1), quote);
      if (end < 0) {
        _tmp$3 = "";
        _tmp$4 = in$1;
        _tmp$5 = $pkg.ErrSyntax;
        out = _tmp$3;
        rem = _tmp$4;
        err = _tmp$5;
        return [out, rem, err];
      }
      end = (end + 2) >> 0;
      _1 = quote;
      if (_1 === 96) {
        if (!unescape) {
          out = $substring(in$1, 0, end);
        } else if (!contains($substring(in$1, 0, end), 13)) {
          out = $substring(in$1, 1, (end - 1) >> 0);
        } else {
          buf = $makeSlice(
            sliceType$6,
            0,
            (((((end - 1) >> 0) - 1) >> 0) - 1) >> 0
          );
          i = 1;
          while (true) {
            if (!(i < (end - 1) >> 0)) {
              break;
            }
            if (!(in$1.charCodeAt(i) === 13)) {
              buf = $append(buf, in$1.charCodeAt(i));
            }
            i = (i + 1) >> 0;
          }
          out = $bytesToString(buf);
        }
        _tmp$6 = out;
        _tmp$7 = $substring(in$1, end);
        _tmp$8 = $ifaceNil;
        out = _tmp$6;
        rem = _tmp$7;
        err = _tmp$8;
        return [out, rem, err];
      } else if (_1 === 34 || _1 === 39) {
        if (
          !contains($substring(in$1, 0, end), 92) &&
          !contains($substring(in$1, 0, end), 10)
        ) {
          valid = false;
          _2 = quote;
          if (_2 === 34) {
            valid = utf8.ValidString($substring(in$1, 1, (end - 1) >> 0));
          } else if (_2 === 39) {
            _tuple = utf8.DecodeRuneInString(
              $substring(in$1, 1, (end - 1) >> 0)
            );
            r = _tuple[0];
            n = _tuple[1];
            valid =
              (((1 + n) >> 0) + 1) >> 0 === end &&
              (!(r === 65533) || !(n === 1));
          }
          if (valid) {
            out = $substring(in$1, 0, end);
            if (unescape) {
              out = $substring(out, 1, (end - 1) >> 0);
            }
            _tmp$9 = out;
            _tmp$10 = $substring(in$1, end);
            _tmp$11 = $ifaceNil;
            out = _tmp$9;
            rem = _tmp$10;
            err = _tmp$11;
            return [out, rem, err];
          }
        }
        buf$1 = sliceType$6.nil;
        in0 = in$1;
        in$1 = $substring(in$1, 1);
        if (unescape) {
          buf$1 = $makeSlice(
            sliceType$6,
            0,
            ((_q = $imul(3, end) / 2),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >> 0
              : $throwRuntimeError("integer divide by zero"))
          );
        }
        while (true) {
          if (!(in$1.length > 0 && !(in$1.charCodeAt(0) === quote))) {
            break;
          }
          _tuple$1 = UnquoteChar(in$1, quote);
          r$1 = _tuple$1[0];
          multibyte = _tuple$1[1];
          rem$1 = _tuple$1[2];
          err$1 = _tuple$1[3];
          if (
            in$1.charCodeAt(0) === 10 ||
            !$interfaceIsEqual(err$1, $ifaceNil)
          ) {
            _tmp$12 = "";
            _tmp$13 = in0;
            _tmp$14 = $pkg.ErrSyntax;
            out = _tmp$12;
            rem = _tmp$13;
            err = _tmp$14;
            return [out, rem, err];
          }
          in$1 = rem$1;
          if (unescape) {
            if (r$1 < 128 || !multibyte) {
              buf$1 = $append(buf$1, (r$1 << 24) >>> 24);
            } else {
              arr = arrayType$1.zero();
              n$1 = utf8.EncodeRune(new sliceType$6(arr), r$1);
              buf$1 = $appendSlice(
                buf$1,
                $subslice(new sliceType$6(arr), 0, n$1)
              );
            }
          }
          if (quote === 39) {
            break;
          }
        }
        if (!(in$1.length > 0 && in$1.charCodeAt(0) === quote)) {
          _tmp$15 = "";
          _tmp$16 = in0;
          _tmp$17 = $pkg.ErrSyntax;
          out = _tmp$15;
          rem = _tmp$16;
          err = _tmp$17;
          return [out, rem, err];
        }
        in$1 = $substring(in$1, 1);
        if (unescape) {
          _tmp$18 = $bytesToString(buf$1);
          _tmp$19 = in$1;
          _tmp$20 = $ifaceNil;
          out = _tmp$18;
          rem = _tmp$19;
          err = _tmp$20;
          return [out, rem, err];
        }
        _tmp$21 = $substring(in0, 0, (in0.length - in$1.length) >> 0);
        _tmp$22 = in$1;
        _tmp$23 = $ifaceNil;
        out = _tmp$21;
        rem = _tmp$22;
        err = _tmp$23;
        return [out, rem, err];
      } else {
        _tmp$24 = "";
        _tmp$25 = in$1;
        _tmp$26 = $pkg.ErrSyntax;
        out = _tmp$24;
        rem = _tmp$25;
        err = _tmp$26;
        return [out, rem, err];
      }
    };
    bsearch16 = function (a, x) {
      var _tmp, _tmp$1, a, h, i, j, x;
      _tmp = 0;
      _tmp$1 = a.$length;
      i = _tmp;
      j = _tmp$1;
      while (true) {
        if (!(i < j)) {
          break;
        }
        h = (i + ((((j - i) >> 0) >> 1) >> 0)) >> 0;
        if (
          (h < 0 || h >= a.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : a.$array[a.$offset + h]) < x
        ) {
          i = (h + 1) >> 0;
        } else {
          j = h;
        }
      }
      return i;
    };
    bsearch32 = function (a, x) {
      var _tmp, _tmp$1, a, h, i, j, x;
      _tmp = 0;
      _tmp$1 = a.$length;
      i = _tmp;
      j = _tmp$1;
      while (true) {
        if (!(i < j)) {
          break;
        }
        h = (i + ((((j - i) >> 0) >> 1) >> 0)) >> 0;
        if (
          (h < 0 || h >= a.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : a.$array[a.$offset + h]) < x
        ) {
          i = (h + 1) >> 0;
        } else {
          j = h;
        }
      }
      return i;
    };
    IsPrint = function (r) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        i,
        i$1,
        isNotPrint,
        isNotPrint$1,
        isPrint,
        isPrint$1,
        j,
        j$1,
        r,
        rr,
        rr$1,
        x,
        x$1,
        x$2,
        x$3;
      if (r <= 255) {
        if (32 <= r && r <= 126) {
          return true;
        }
        if (161 <= r && r <= 255) {
          return !(r === 173);
        }
        return false;
      }
      if (0 <= r && r < 65536) {
        _tmp = (r << 16) >>> 16;
        _tmp$1 = isPrint16;
        _tmp$2 = isNotPrint16;
        rr = _tmp;
        isPrint = _tmp$1;
        isNotPrint = _tmp$2;
        i = bsearch16(isPrint, rr);
        if (
          i >= isPrint.$length ||
          rr <
            ((x = (i & ~1) >> 0),
            x < 0 || x >= isPrint.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : isPrint.$array[isPrint.$offset + x]) ||
          ((x$1 = i | 1),
          x$1 < 0 || x$1 >= isPrint.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : isPrint.$array[isPrint.$offset + x$1]) < rr
        ) {
          return false;
        }
        j = bsearch16(isNotPrint, rr);
        return (
          j >= isNotPrint.$length ||
          !(
            (j < 0 || j >= isNotPrint.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : isNotPrint.$array[isNotPrint.$offset + j]) === rr
          )
        );
      }
      _tmp$3 = r >>> 0;
      _tmp$4 = isPrint32;
      _tmp$5 = isNotPrint32;
      rr$1 = _tmp$3;
      isPrint$1 = _tmp$4;
      isNotPrint$1 = _tmp$5;
      i$1 = bsearch32(isPrint$1, rr$1);
      if (
        i$1 >= isPrint$1.$length ||
        rr$1 <
          ((x$2 = (i$1 & ~1) >> 0),
          x$2 < 0 || x$2 >= isPrint$1.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : isPrint$1.$array[isPrint$1.$offset + x$2]) ||
        ((x$3 = i$1 | 1),
        x$3 < 0 || x$3 >= isPrint$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : isPrint$1.$array[isPrint$1.$offset + x$3]) < rr$1
      ) {
        return false;
      }
      if (r >= 131072) {
        return true;
      }
      r = (r - 65536) >> 0;
      j$1 = bsearch16(isNotPrint$1, (r << 16) >>> 16);
      return (
        j$1 >= isNotPrint$1.$length ||
        !(
          (j$1 < 0 || j$1 >= isNotPrint$1.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) ===
          (r << 16) >>> 16
        )
      );
    };
    $pkg.IsPrint = IsPrint;
    isInGraphicList = function (r) {
      var i, r, rr;
      if (r > 65535) {
        return false;
      }
      rr = (r << 16) >>> 16;
      i = bsearch16(isGraphic, rr);
      return (
        i < isGraphic.$length &&
        rr ===
          (i < 0 || i >= isGraphic.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : isGraphic.$array[isGraphic.$offset + i])
      );
    };
    formatBits = function (dst, u, base, neg, append_) {
      var _q,
        _q$1,
        _r,
        _r$1,
        a,
        append_,
        b,
        b$1,
        base,
        d,
        dst,
        i,
        is,
        is$1,
        is$2,
        j,
        m,
        neg,
        q,
        q$1,
        s,
        shift,
        u,
        us,
        us$1,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5;
      d = sliceType$6.nil;
      s = "";
      if (base < 2 || base > 36) {
        $panic(new $String("strconv: illegal AppendInt/FormatInt base"));
      }
      a = arrayType$2.zero();
      i = 65;
      if (neg) {
        u = new $Uint64(-u.$high, -u.$low);
      }
      if (base === 10) {
        if (true) {
          while (true) {
            if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 1000000000))) {
              break;
            }
            q = $div64(u, new $Uint64(0, 1000000000), false);
            us =
              ((x = $mul64(q, new $Uint64(0, 1000000000))),
              new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0;
            j = 4;
            while (true) {
              if (!(j > 0)) {
                break;
              }
              is =
                (((_r = us % 100),
                _r === _r ? _r : $throwRuntimeError("integer divide by zero")) *
                  2) >>>
                0;
              us =
                ((_q = us / 100),
                _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                  ? _q >>> 0
                  : $throwRuntimeError("integer divide by zero"));
              i = (i - 2) >> 0;
              (x$1 = (i + 1) >> 0),
                x$1 < 0 || x$1 >= a.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : (a[x$1] =
                      "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                        (is + 1) >>> 0
                      ));
              (x$2 = (i + 0) >> 0),
                x$2 < 0 || x$2 >= a.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : (a[x$2] =
                      "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                        (is + 0) >>> 0
                      ));
              j = (j - 1) >> 0;
            }
            i = (i - 1) >> 0;
            i < 0 || i >= a.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (a[i] =
                  "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                    (((us * 2) >>> 0) + 1) >>> 0
                  ));
            u = q;
          }
        }
        us$1 = u.$low >>> 0;
        while (true) {
          if (!(us$1 >= 100)) {
            break;
          }
          is$1 =
            (((_r$1 = us$1 % 100),
            _r$1 === _r$1
              ? _r$1
              : $throwRuntimeError("integer divide by zero")) *
              2) >>>
            0;
          us$1 =
            ((_q$1 = us$1 / 100),
            _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
              ? _q$1 >>> 0
              : $throwRuntimeError("integer divide by zero"));
          i = (i - 2) >> 0;
          (x$3 = (i + 1) >> 0),
            x$3 < 0 || x$3 >= a.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (a[x$3] =
                  "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                    (is$1 + 1) >>> 0
                  ));
          (x$4 = (i + 0) >> 0),
            x$4 < 0 || x$4 >= a.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (a[x$4] =
                  "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                    (is$1 + 0) >>> 0
                  ));
        }
        is$2 = (us$1 * 2) >>> 0;
        i = (i - 1) >> 0;
        i < 0 || i >= a.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (a[i] =
              "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                (is$2 + 1) >>> 0
              ));
        if (us$1 >= 10) {
          i = (i - 1) >> 0;
          i < 0 || i >= a.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (a[i] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  is$2
                ));
        }
      } else if (isPowerOfTwo(base)) {
        shift = ((bits.TrailingZeros(base >>> 0) >>> 0) & 7) >>> 0;
        b = new $Uint64(0, base);
        m = ((base >>> 0) - 1) >>> 0;
        while (true) {
          if (
            !(u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low))
          ) {
            break;
          }
          i = (i - 1) >> 0;
          i < 0 || i >= a.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(
                ((u.$low >>> 0) & m) >>> 0
              ));
          u = $shiftRightUint64(u, shift);
        }
        i = (i - 1) >> 0;
        i < 0 || i >= a.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(
              u.$low >>> 0
            ));
      } else {
        b$1 = new $Uint64(0, base);
        while (true) {
          if (
            !(
              u.$high > b$1.$high ||
              (u.$high === b$1.$high && u.$low >= b$1.$low)
            )
          ) {
            break;
          }
          i = (i - 1) >> 0;
          q$1 = $div64(u, b$1, false);
          i < 0 || i >= a.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(
                ((x$5 = $mul64(q$1, b$1)),
                new $Uint64(u.$high - x$5.$high, u.$low - x$5.$low)).$low >>> 0
              ));
          u = q$1;
        }
        i = (i - 1) >> 0;
        i < 0 || i >= a.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(
              u.$low >>> 0
            ));
      }
      if (neg) {
        i = (i - 1) >> 0;
        i < 0 || i >= a.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (a[i] = 45);
      }
      if (append_) {
        d = $appendSlice(dst, $subslice(new sliceType$6(a), i));
        return [d, s];
      }
      s = $bytesToString($subslice(new sliceType$6(a), i));
      return [d, s];
    };
    isPowerOfTwo = function (x) {
      var x;
      return (x & ((x - 1) >> 0)) === 0;
    };
    Itoa = function (i) {
      var i;
      return $internalize(i.toString(), $String);
    };
    $pkg.Itoa = Itoa;
    Atoi = function (s) {
      var floatval, i, jsValue, s, v;
      if (s.length === 0) {
        return [0, syntaxError("Atoi", s)];
      }
      i = 0;
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        v = s.charCodeAt(i);
        if (v < 48 || v > 57) {
          if (!(v === 43) && !(v === 45)) {
            return [0, syntaxError("Atoi", s)];
          }
        }
        i = (i + 1) >> 0;
      }
      jsValue = $global.Number($externalize(s, $String), 10);
      if (!!!$global.isFinite(jsValue)) {
        return [0, syntaxError("Atoi", s)];
      }
      floatval = $parseFloat(jsValue);
      if (floatval > 2.147483647e9) {
        return [2147483647, rangeError("Atoi", s)];
      } else if (floatval < -2.147483648e9) {
        return [-2147483648, rangeError("Atoi", s)];
      }
      return [$parseInt(jsValue) >> 0, $ifaceNil];
    };
    $pkg.Atoi = Atoi;
    ryuFtoaFixed32 = function (d, mant, exp, prec) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        d,
        d0,
        dexp2,
        dfrac,
        di,
        e2,
        exact,
        exp,
        extra,
        extraMask,
        mant,
        prec,
        q,
        roundUp,
        y,
        y$1,
        y$2,
        y$3,
        y$4,
        y$5,
        y$6;
      if (prec < 0) {
        $panic(new $String("ryuFtoaFixed32 called with negative prec"));
      }
      if (prec > 9) {
        $panic(new $String("ryuFtoaFixed32 called with prec > 9"));
      }
      if (mant === 0) {
        _tmp = 0;
        _tmp$1 = 0;
        d.nd = _tmp;
        d.dp = _tmp$1;
        return;
      }
      e2 = exp;
      b = bits.Len32(mant);
      if (b < 25) {
        mant = ((y = ((25 - b) >> 0) >>> 0), y < 32 ? mant << y : 0) >>> 0;
        e2 = (e2 + ((b - 25) >> 0)) >> 0;
      }
      q = (((-mulByLog2Log10((e2 + 24) >> 0) + prec) >> 0) - 1) >> 0;
      exact = q <= 27 && q >= 0;
      _tuple = mult64bitPow10(mant, e2, q);
      di = _tuple[0];
      dexp2 = _tuple[1];
      d0 = _tuple[2];
      if (dexp2 >= 0) {
        $panic(new $String("not enough significant bits after mult64bitPow10"));
      }
      if (q < 0 && q >= -10 && divisibleByPower5(new $Uint64(0, mant), -q)) {
        exact = true;
        d0 = true;
      }
      extra = -dexp2 >>> 0;
      extraMask = ((((y$1 = extra), y$1 < 32 ? 1 << y$1 : 0) >>> 0) - 1) >>> 0;
      _tmp$2 = ((y$2 = extra), y$2 < 32 ? di >>> y$2 : 0) >>> 0;
      _tmp$3 = (di & extraMask) >>> 0;
      di = _tmp$2;
      dfrac = _tmp$3;
      roundUp = false;
      if (exact) {
        roundUp =
          dfrac > ((y$3 = (extra - 1) >>> 0), y$3 < 32 ? 1 << y$3 : 0) >>> 0 ||
          (dfrac ===
            ((y$4 = (extra - 1) >>> 0), y$4 < 32 ? 1 << y$4 : 0) >>> 0 &&
            !d0) ||
          (dfrac ===
            ((y$5 = (extra - 1) >>> 0), y$5 < 32 ? 1 << y$5 : 0) >>> 0 &&
            d0 &&
            (di & 1) >>> 0 === 1);
      } else {
        roundUp =
          ((y$6 = (extra - 1) >>> 0), y$6 < 32 ? dfrac >>> y$6 : 0) >>> 0 === 1;
      }
      if (!(dfrac === 0)) {
        d0 = false;
      }
      formatDecimal(d, new $Uint64(0, di), !d0, roundUp, prec);
      d.dp = (d.dp - q) >> 0;
    };
    ryuFtoaFixed64 = function (d, mant, exp, prec) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        d,
        d0,
        dexp2,
        dfrac,
        di,
        e2,
        exact,
        exp,
        extra,
        extraMask,
        mant,
        prec,
        q,
        roundUp,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5;
      if (prec > 18) {
        $panic(new $String("ryuFtoaFixed64 called with prec > 18"));
      }
      if (mant.$high === 0 && mant.$low === 0) {
        _tmp = 0;
        _tmp$1 = 0;
        d.nd = _tmp;
        d.dp = _tmp$1;
        return;
      }
      e2 = exp;
      b = bits.Len64(mant);
      if (b < 55) {
        mant = $shiftLeft64(mant, ((55 - b) >> 0) >>> 0);
        e2 = (e2 + ((b - 55) >> 0)) >> 0;
      }
      q = (((-mulByLog2Log10((e2 + 54) >> 0) + prec) >> 0) - 1) >> 0;
      exact = q <= 55 && q >= 0;
      _tuple = mult128bitPow10(mant, e2, q);
      di = _tuple[0];
      dexp2 = _tuple[1];
      d0 = _tuple[2];
      if (dexp2 >= 0) {
        $panic(
          new $String("not enough significant bits after mult128bitPow10")
        );
      }
      if (q < 0 && q >= -22 && divisibleByPower5(mant, -q)) {
        exact = true;
        d0 = true;
      }
      extra = -dexp2 >>> 0;
      extraMask =
        ((x = $shiftLeft64(new $Uint64(0, 1), extra)),
        new $Uint64(x.$high - 0, x.$low - 1));
      _tmp$2 = $shiftRightUint64(di, extra);
      _tmp$3 = new $Uint64(
        di.$high & extraMask.$high,
        (di.$low & extraMask.$low) >>> 0
      );
      di = _tmp$2;
      dfrac = _tmp$3;
      roundUp = false;
      if (exact) {
        roundUp =
          ((x$1 = $shiftLeft64(new $Uint64(0, 1), (extra - 1) >>> 0)),
          dfrac.$high > x$1.$high ||
            (dfrac.$high === x$1.$high && dfrac.$low > x$1.$low)) ||
          (((x$2 = $shiftLeft64(new $Uint64(0, 1), (extra - 1) >>> 0)),
          dfrac.$high === x$2.$high && dfrac.$low === x$2.$low) &&
            !d0) ||
          (((x$3 = $shiftLeft64(new $Uint64(0, 1), (extra - 1) >>> 0)),
          dfrac.$high === x$3.$high && dfrac.$low === x$3.$low) &&
            d0 &&
            ((x$4 = new $Uint64(di.$high & 0, (di.$low & 1) >>> 0)),
            x$4.$high === 0 && x$4.$low === 1));
      } else {
        roundUp =
          ((x$5 = $shiftRightUint64(dfrac, (extra - 1) >>> 0)),
          x$5.$high === 0 && x$5.$low === 1);
      }
      if (!(dfrac.$high === 0 && dfrac.$low === 0)) {
        d0 = false;
      }
      formatDecimal(d, di, !d0, roundUp, prec);
      d.dp = (d.dp - q) >> 0;
    };
    formatDecimal = function (d, m, trunc, roundUp, prec) {
      var _q,
        _r,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        a,
        b,
        d,
        m,
        max$1,
        n,
        prec,
        roundUp,
        trimmed,
        trunc,
        v,
        v1,
        v2,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      max$1 =
        prec < 0 || prec >= uint64pow10.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : uint64pow10[prec];
      trimmed = 0;
      while (true) {
        if (
          !(
            m.$high > max$1.$high ||
            (m.$high === max$1.$high && m.$low >= max$1.$low)
          )
        ) {
          break;
        }
        _tmp = $div64(m, new $Uint64(0, 10), false);
        _tmp$1 = $div64(m, new $Uint64(0, 10), true);
        a = _tmp;
        b = _tmp$1;
        m = a;
        trimmed = (trimmed + 1) >> 0;
        if (b.$high > 0 || (b.$high === 0 && b.$low > 5)) {
          roundUp = true;
        } else if (b.$high < 0 || (b.$high === 0 && b.$low < 5)) {
          roundUp = false;
        } else {
          roundUp =
            trunc ||
            ((x = new $Uint64(m.$high & 0, (m.$low & 1) >>> 0)),
            x.$high === 0 && x.$low === 1);
        }
        if (!(b.$high === 0 && b.$low === 0)) {
          trunc = true;
        }
      }
      if (roundUp) {
        m =
          ((x$1 = new $Uint64(0, 1)),
          new $Uint64(m.$high + x$1.$high, m.$low + x$1.$low));
      }
      if (
        m.$high > max$1.$high ||
        (m.$high === max$1.$high && m.$low >= max$1.$low)
      ) {
        m = $div64(m, new $Uint64(0, 10), false);
        trimmed = (trimmed + 1) >> 0;
      }
      n = prec >>> 0;
      d.nd = prec;
      v = m;
      while (true) {
        if (!(v.$high > 0 || (v.$high === 0 && v.$low >= 100))) {
          break;
        }
        _tmp$2 = new $Uint64(0, 0);
        _tmp$3 = new $Uint64(0, 0);
        v1 = _tmp$2;
        v2 = _tmp$3;
        if (
          ((x$2 = $shiftRightUint64(v, 32)), x$2.$high === 0 && x$2.$low === 0)
        ) {
          _tmp$4 = new $Uint64(
            0,
            ((_q = (v.$low >>> 0) / 100),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >>> 0
              : $throwRuntimeError("integer divide by zero"))
          );
          _tmp$5 = new $Uint64(
            0,
            ((_r = (v.$low >>> 0) % 100),
            _r === _r ? _r : $throwRuntimeError("integer divide by zero"))
          );
          v1 = _tmp$4;
          v2 = _tmp$5;
        } else {
          _tmp$6 = $div64(v, new $Uint64(0, 100), false);
          _tmp$7 = $div64(v, new $Uint64(0, 100), true);
          v1 = _tmp$6;
          v2 = _tmp$7;
        }
        n = (n - 2) >>> 0;
        (x$4 = d.d),
          (x$5 = (n + 1) >>> 0),
          x$5 < 0 || x$5 >= x$4.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$4.$array[x$4.$offset + x$5] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  $flatten64(
                    ((x$3 = $mul64(new $Uint64(0, 2), v2)),
                    new $Uint64(x$3.$high + 0, x$3.$low + 1))
                  )
                ));
        (x$7 = d.d),
          (x$8 = (n + 0) >>> 0),
          x$8 < 0 || x$8 >= x$7.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$7.$array[x$7.$offset + x$8] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  $flatten64(
                    ((x$6 = $mul64(new $Uint64(0, 2), v2)),
                    new $Uint64(x$6.$high + 0, x$6.$low + 0))
                  )
                ));
        v = v1;
      }
      if (v.$high > 0 || (v.$high === 0 && v.$low > 0)) {
        n = (n - 1) >>> 0;
        (x$10 = d.d),
          n < 0 || n >= x$10.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$10.$array[x$10.$offset + n] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  $flatten64(
                    ((x$9 = $mul64(new $Uint64(0, 2), v)),
                    new $Uint64(x$9.$high + 0, x$9.$low + 1))
                  )
                ));
      }
      if (v.$high > 0 || (v.$high === 0 && v.$low >= 10)) {
        n = (n - 1) >>> 0;
        (x$11 = d.d),
          n < 0 || n >= x$11.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$11.$array[x$11.$offset + n] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  $flatten64($mul64(new $Uint64(0, 2), v))
                ));
      }
      while (true) {
        if (
          !(
            ((x$12 = d.d),
            (x$13 = (d.nd - 1) >> 0),
            x$13 < 0 || x$13 >= x$12.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$12.$array[x$12.$offset + x$13]) === 48
          )
        ) {
          break;
        }
        d.nd = (d.nd - 1) >> 0;
        trimmed = (trimmed + 1) >> 0;
      }
      d.dp = (d.nd + trimmed) >> 0;
    };
    ryuFtoaShortest = function (d, mant, exp, flt) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        c0,
        cup,
        d,
        dc,
        dc0,
        dc32,
        dl,
        dl0,
        dl32,
        du,
        du0,
        du32,
        e2,
        exp,
        extra,
        extraMask,
        flt,
        fracc,
        fracl,
        fracu,
        lok,
        mant,
        mc,
        ml,
        mu,
        q,
        uok,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8;
      if (mant.$high === 0 && mant.$low === 0) {
        _tmp = 0;
        _tmp$1 = 0;
        d.nd = _tmp;
        d.dp = _tmp$1;
        return;
      }
      if (exp <= 0 && bits.TrailingZeros64(mant) >= -exp) {
        mant = $shiftRightUint64(mant, -exp >>> 0);
        ryuDigits(d, mant, mant, mant, true, false);
        return;
      }
      _tuple = computeBounds(mant, exp, flt);
      ml = _tuple[0];
      mc = _tuple[1];
      mu = _tuple[2];
      e2 = _tuple[3];
      if (e2 === 0) {
        ryuDigits(d, ml, mc, mu, true, false);
        return;
      }
      q = (mulByLog2Log10(-e2) + 1) >> 0;
      _tmp$2 = new $Uint64(0, 0);
      _tmp$3 = new $Uint64(0, 0);
      _tmp$4 = new $Uint64(0, 0);
      dl = _tmp$2;
      dc = _tmp$3;
      du = _tmp$4;
      _tmp$5 = false;
      _tmp$6 = false;
      _tmp$7 = false;
      dl0 = _tmp$5;
      dc0 = _tmp$6;
      du0 = _tmp$7;
      if (flt === float32info) {
        _tmp$8 = 0;
        _tmp$9 = 0;
        _tmp$10 = 0;
        dl32 = _tmp$8;
        dc32 = _tmp$9;
        du32 = _tmp$10;
        _tuple$1 = mult64bitPow10(ml.$low >>> 0, e2, q);
        dl32 = _tuple$1[0];
        dl0 = _tuple$1[2];
        _tuple$2 = mult64bitPow10(mc.$low >>> 0, e2, q);
        dc32 = _tuple$2[0];
        dc0 = _tuple$2[2];
        _tuple$3 = mult64bitPow10(mu.$low >>> 0, e2, q);
        du32 = _tuple$3[0];
        e2 = _tuple$3[1];
        du0 = _tuple$3[2];
        _tmp$11 = new $Uint64(0, dl32);
        _tmp$12 = new $Uint64(0, dc32);
        _tmp$13 = new $Uint64(0, du32);
        dl = _tmp$11;
        dc = _tmp$12;
        du = _tmp$13;
      } else {
        _tuple$4 = mult128bitPow10(ml, e2, q);
        dl = _tuple$4[0];
        dl0 = _tuple$4[2];
        _tuple$5 = mult128bitPow10(mc, e2, q);
        dc = _tuple$5[0];
        dc0 = _tuple$5[2];
        _tuple$6 = mult128bitPow10(mu, e2, q);
        du = _tuple$6[0];
        e2 = _tuple$6[1];
        du0 = _tuple$6[2];
      }
      if (e2 >= 0) {
        $panic(
          new $String("not enough significant bits after mult128bitPow10")
        );
      }
      if (q > 55) {
        _tmp$14 = false;
        _tmp$15 = false;
        _tmp$16 = false;
        dl0 = _tmp$14;
        dc0 = _tmp$15;
        du0 = _tmp$16;
      }
      if (q < 0 && q >= -24) {
        if (divisibleByPower5(ml, -q)) {
          dl0 = true;
        }
        if (divisibleByPower5(mc, -q)) {
          dc0 = true;
        }
        if (divisibleByPower5(mu, -q)) {
          du0 = true;
        }
      }
      extra = -e2 >>> 0;
      extraMask =
        ((x = $shiftLeft64(new $Uint64(0, 1), extra)),
        new $Uint64(x.$high - 0, x.$low - 1));
      _tmp$17 = $shiftRightUint64(dl, extra);
      _tmp$18 = new $Uint64(
        dl.$high & extraMask.$high,
        (dl.$low & extraMask.$low) >>> 0
      );
      dl = _tmp$17;
      fracl = _tmp$18;
      _tmp$19 = $shiftRightUint64(dc, extra);
      _tmp$20 = new $Uint64(
        dc.$high & extraMask.$high,
        (dc.$low & extraMask.$low) >>> 0
      );
      dc = _tmp$19;
      fracc = _tmp$20;
      _tmp$21 = $shiftRightUint64(du, extra);
      _tmp$22 = new $Uint64(
        du.$high & extraMask.$high,
        (du.$low & extraMask.$low) >>> 0
      );
      du = _tmp$21;
      fracu = _tmp$22;
      uok = !du0 || fracu.$high > 0 || (fracu.$high === 0 && fracu.$low > 0);
      if (du0 && fracu.$high === 0 && fracu.$low === 0) {
        uok =
          ((x$1 = new $Uint64(mant.$high & 0, (mant.$low & 1) >>> 0)),
          x$1.$high === 0 && x$1.$low === 0);
      }
      if (!uok) {
        du =
          ((x$2 = new $Uint64(0, 1)),
          new $Uint64(du.$high - x$2.$high, du.$low - x$2.$low));
      }
      cup = false;
      if (dc0) {
        cup =
          ((x$3 = $shiftLeft64(new $Uint64(0, 1), (extra - 1) >>> 0)),
          fracc.$high > x$3.$high ||
            (fracc.$high === x$3.$high && fracc.$low > x$3.$low)) ||
          (((x$4 = $shiftLeft64(new $Uint64(0, 1), (extra - 1) >>> 0)),
          fracc.$high === x$4.$high && fracc.$low === x$4.$low) &&
            ((x$5 = new $Uint64(dc.$high & 0, (dc.$low & 1) >>> 0)),
            x$5.$high === 0 && x$5.$low === 1));
      } else {
        cup =
          ((x$6 = $shiftRightUint64(fracc, (extra - 1) >>> 0)),
          x$6.$high === 0 && x$6.$low === 1);
      }
      lok =
        dl0 &&
        fracl.$high === 0 &&
        fracl.$low === 0 &&
        ((x$7 = new $Uint64(mant.$high & 0, (mant.$low & 1) >>> 0)),
        x$7.$high === 0 && x$7.$low === 0);
      if (!lok) {
        dl =
          ((x$8 = new $Uint64(0, 1)),
          new $Uint64(dl.$high + x$8.$high, dl.$low + x$8.$low));
      }
      c0 = dc0 && fracc.$high === 0 && fracc.$low === 0;
      ryuDigits(d, dl, dc, du, c0, cup);
      d.dp = (d.dp - q) >> 0;
    };
    mulByLog2Log10 = function (x) {
      var x;
      return ($imul(x, 78913) >> 18) >> 0;
    };
    mulByLog10Log2 = function (x) {
      var x;
      return ($imul(x, 108853) >> 15) >> 0;
    };
    computeBounds = function (mant, exp, flt) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        central,
        e2,
        exp,
        flt,
        lower$1,
        mant,
        upper,
        x,
        x$1,
        x$2,
        x$3,
        x$4;
      lower$1 = new $Uint64(0, 0);
      central = new $Uint64(0, 0);
      upper = new $Uint64(0, 0);
      e2 = 0;
      if (
        !((x = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
        mant.$high === x.$high && mant.$low === x.$low) ||
        exp === (((flt.bias + 1) >> 0) - (flt.mantbits >> 0)) >> 0
      ) {
        _tmp =
          ((x$1 = $mul64(new $Uint64(0, 2), mant)),
          new $Uint64(x$1.$high - 0, x$1.$low - 1));
        _tmp$1 = $mul64(new $Uint64(0, 2), mant);
        _tmp$2 =
          ((x$2 = $mul64(new $Uint64(0, 2), mant)),
          new $Uint64(x$2.$high + 0, x$2.$low + 1));
        lower$1 = _tmp;
        central = _tmp$1;
        upper = _tmp$2;
        e2 = (exp - 1) >> 0;
        return [lower$1, central, upper, e2];
      } else {
        _tmp$3 =
          ((x$3 = $mul64(new $Uint64(0, 4), mant)),
          new $Uint64(x$3.$high - 0, x$3.$low - 1));
        _tmp$4 = $mul64(new $Uint64(0, 4), mant);
        _tmp$5 =
          ((x$4 = $mul64(new $Uint64(0, 4), mant)),
          new $Uint64(x$4.$high + 0, x$4.$low + 2));
        lower$1 = _tmp$3;
        central = _tmp$4;
        upper = _tmp$5;
        e2 = (exp - 2) >> 0;
        return [lower$1, central, upper, e2];
      }
    };
    ryuDigits = function (d, lower$1, central, upper, c0, cup) {
      var _q,
        _r,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        _tuple$2,
        c0,
        central,
        chi,
        clo,
        cup,
        d,
        lhi,
        llo,
        lower$1,
        n,
        uhi,
        ulo,
        upper,
        v,
        v1,
        v2,
        x,
        x$1,
        x$2,
        x$3;
      _tuple = divmod1e9(lower$1);
      lhi = _tuple[0];
      llo = _tuple[1];
      _tuple$1 = divmod1e9(central);
      chi = _tuple$1[0];
      clo = _tuple$1[1];
      _tuple$2 = divmod1e9(upper);
      uhi = _tuple$2[0];
      ulo = _tuple$2[1];
      if (uhi === 0) {
        ryuDigits32(d, llo, clo, ulo, c0, cup, 8);
      } else if (lhi < uhi) {
        if (!(llo === 0)) {
          lhi = (lhi + 1) >>> 0;
        }
        c0 = c0 && clo === 0;
        cup = clo > 500000000 || (clo === 500000000 && cup);
        ryuDigits32(d, lhi, chi, uhi, c0, cup, 8);
        d.dp = (d.dp + 9) >> 0;
      } else {
        d.nd = 0;
        n = 9;
        v = chi;
        while (true) {
          if (!(v > 0)) {
            break;
          }
          _tmp =
            ((_q = v / 10),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >>> 0
              : $throwRuntimeError("integer divide by zero"));
          _tmp$1 =
            ((_r = v % 10),
            _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
          v1 = _tmp;
          v2 = _tmp$1;
          v = v1;
          n = (n - 1) >>> 0;
          (x = d.d),
            n < 0 || n >= x.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (x.$array[x.$offset + n] = (((v2 + 48) >>> 0) << 24) >>> 24);
        }
        d.d = $subslice(d.d, n);
        d.nd = ((9 - n) >>> 0) >> 0;
        ryuDigits32(d, llo, clo, ulo, c0, cup, (d.nd + 8) >> 0);
      }
      while (true) {
        if (
          !(
            d.nd > 0 &&
            ((x$1 = d.d),
            (x$2 = (d.nd - 1) >> 0),
            x$2 < 0 || x$2 >= x$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$1.$array[x$1.$offset + x$2]) === 48
          )
        ) {
          break;
        }
        d.nd = (d.nd - 1) >> 0;
      }
      while (true) {
        if (
          !(
            d.nd > 0 &&
            ((x$3 = d.d),
            0 >= x$3.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$3.$array[x$3.$offset + 0]) === 48
          )
        ) {
          break;
        }
        d.nd = (d.nd - 1) >> 0;
        d.dp = (d.dp - 1) >> 0;
        d.d = $subslice(d.d, 1);
      }
    };
    ryuDigits32 = function (d, lower$1, central, upper, c0, cup, endindex) {
      var _q,
        _q$1,
        _q$2,
        _q$3,
        _r,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        c,
        c0,
        cNextDigit,
        cdigit,
        central,
        cup,
        d,
        endindex,
        l,
        lower$1,
        n,
        trimmed,
        u,
        upper,
        v,
        v1,
        v2,
        x,
        x$1,
        x$2,
        x$3;
      if (upper === 0) {
        d.dp = (endindex + 1) >> 0;
        return;
      }
      trimmed = 0;
      cNextDigit = 0;
      while (true) {
        if (!(upper > 0)) {
          break;
        }
        l =
          ((_q = ((lower$1 + 9) >>> 0) / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >>> 0
            : $throwRuntimeError("integer divide by zero"));
        _tmp =
          ((_q$1 = central / 10),
          _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
            ? _q$1 >>> 0
            : $throwRuntimeError("integer divide by zero"));
        _tmp$1 =
          ((_r = central % 10),
          _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
        c = _tmp;
        cdigit = _tmp$1;
        u =
          ((_q$2 = upper / 10),
          _q$2 === _q$2 && _q$2 !== 1 / 0 && _q$2 !== -1 / 0
            ? _q$2 >>> 0
            : $throwRuntimeError("integer divide by zero"));
        if (l > u) {
          break;
        }
        if (l === (c + 1) >>> 0 && c < u) {
          c = (c + 1) >>> 0;
          cdigit = 0;
          cup = false;
        }
        trimmed = (trimmed + 1) >> 0;
        c0 = c0 && cNextDigit === 0;
        cNextDigit = cdigit >> 0;
        _tmp$2 = l;
        _tmp$3 = c;
        _tmp$4 = u;
        lower$1 = _tmp$2;
        central = _tmp$3;
        upper = _tmp$4;
      }
      if (trimmed > 0) {
        cup =
          cNextDigit > 5 ||
          (cNextDigit === 5 && !c0) ||
          (cNextDigit === 5 && c0 && (central & 1) >>> 0 === 1);
      }
      if (central < upper && cup) {
        central = (central + 1) >>> 0;
      }
      endindex = (endindex - trimmed) >> 0;
      v = central;
      n = endindex;
      while (true) {
        if (!(n > d.nd)) {
          break;
        }
        _tmp$5 =
          ((_q$3 = v / 100),
          _q$3 === _q$3 && _q$3 !== 1 / 0 && _q$3 !== -1 / 0
            ? _q$3 >>> 0
            : $throwRuntimeError("integer divide by zero"));
        _tmp$6 =
          ((_r$1 = v % 100),
          _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
        v1 = _tmp$5;
        v2 = _tmp$6;
        (x = d.d),
          n < 0 || n >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x.$array[x.$offset + n] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  (($imul(2, v2) >>> 0) + 1) >>> 0
                ));
        (x$1 = d.d),
          (x$2 = (n - 1) >> 0),
          x$2 < 0 || x$2 >= x$1.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$1.$array[x$1.$offset + x$2] =
                "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(
                  (($imul(2, v2) >>> 0) + 0) >>> 0
                ));
        n = (n - 2) >> 0;
        v = v1;
      }
      if (n === d.nd) {
        (x$3 = d.d),
          n < 0 || n >= x$3.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$3.$array[x$3.$offset + n] = (((v + 48) >>> 0) << 24) >>> 24);
      }
      d.nd = (endindex + 1) >> 0;
      d.dp = (d.nd + trimmed) >> 0;
    };
    mult64bitPow10 = function (m, e2, q) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        e2,
        exact,
        hi,
        lo,
        m,
        pow,
        q,
        resE,
        resM,
        x,
        x$1,
        x$2,
        x$3,
        x$4;
      resM = 0;
      resE = 0;
      exact = false;
      if (q === 0) {
        _tmp = (m << 6) >>> 0;
        _tmp$1 = (e2 - 6) >> 0;
        _tmp$2 = true;
        resM = _tmp;
        resE = _tmp$1;
        exact = _tmp$2;
        return [resM, resE, exact];
      }
      if (q < -348 || 347 < q) {
        $panic(new $String("mult64bitPow10: power of 10 is out of range"));
      }
      pow = ((x = (q - -348) >> 0),
      x < 0 || x >= detailedPowersOfTen.length
        ? ($throwRuntimeError("index out of range"), undefined)
        : detailedPowersOfTen[x])[1];
      if (q < 0) {
        pow =
          ((x$1 = new $Uint64(0, 1)),
          new $Uint64(pow.$high + x$1.$high, pow.$low + x$1.$low));
      }
      _tuple = bits.Mul64(new $Uint64(0, m), pow);
      hi = _tuple[0];
      lo = _tuple[1];
      e2 = (e2 + ((((mulByLog10Log2(q) - 63) >> 0) + 57) >> 0)) >> 0;
      _tmp$3 =
        ((x$2 = $shiftLeft64(hi, 7)),
        (x$3 = $shiftRightUint64(lo, 57)),
        new $Uint64(x$2.$high | x$3.$high, (x$2.$low | x$3.$low) >>> 0))
          .$low >>> 0;
      _tmp$4 = e2;
      _tmp$5 = ((x$4 = $shiftLeft64(lo, 7)), x$4.$high === 0 && x$4.$low === 0);
      resM = _tmp$3;
      resE = _tmp$4;
      exact = _tmp$5;
      return [resM, resE, exact];
    };
    mult128bitPow10 = function (m, e2, q) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        _tuple$1,
        _tuple$2,
        carry,
        e2,
        exact,
        h0,
        h1,
        l0,
        l1,
        m,
        mid,
        pow,
        q,
        resE,
        resM,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6;
      resM = new $Uint64(0, 0);
      resE = 0;
      exact = false;
      if (q === 0) {
        _tmp = $shiftLeft64(m, 8);
        _tmp$1 = (e2 - 8) >> 0;
        _tmp$2 = true;
        resM = _tmp;
        resE = _tmp$1;
        exact = _tmp$2;
        return [resM, resE, exact];
      }
      if (q < -348 || 347 < q) {
        $panic(new $String("mult128bitPow10: power of 10 is out of range"));
      }
      pow = $clone(
        ((x = (q - -348) >> 0),
        x < 0 || x >= detailedPowersOfTen.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : detailedPowersOfTen[x]),
        arrayType
      );
      if (q < 0) {
        pow[0] =
          ((x$1 = pow[0]),
          (x$2 = new $Uint64(0, 1)),
          new $Uint64(x$1.$high + x$2.$high, x$1.$low + x$2.$low));
      }
      e2 = (e2 + ((((mulByLog10Log2(q) - 127) >> 0) + 119) >> 0)) >> 0;
      _tuple = bits.Mul64(m, pow[0]);
      l1 = _tuple[0];
      l0 = _tuple[1];
      _tuple$1 = bits.Mul64(m, pow[1]);
      h1 = _tuple$1[0];
      h0 = _tuple$1[1];
      _tuple$2 = bits.Add64(l1, h0, new $Uint64(0, 0));
      mid = _tuple$2[0];
      carry = _tuple$2[1];
      h1 =
        ((x$3 = carry), new $Uint64(h1.$high + x$3.$high, h1.$low + x$3.$low));
      _tmp$3 =
        ((x$4 = $shiftLeft64(h1, 9)),
        (x$5 = $shiftRightUint64(mid, 55)),
        new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0));
      _tmp$4 = e2;
      _tmp$5 =
        ((x$6 = $shiftLeft64(mid, 9)), x$6.$high === 0 && x$6.$low === 0) &&
        l0.$high === 0 &&
        l0.$low === 0;
      resM = _tmp$3;
      resE = _tmp$4;
      exact = _tmp$5;
      return [resM, resE, exact];
    };
    divisibleByPower5 = function (m, k) {
      var i, k, m, x;
      if (m.$high === 0 && m.$low === 0) {
        return true;
      }
      i = 0;
      while (true) {
        if (!(i < k)) {
          break;
        }
        if (
          !((x = $div64(m, new $Uint64(0, 5), true)),
          x.$high === 0 && x.$low === 0)
        ) {
          return false;
        }
        m = $div64(m, new $Uint64(0, 5), false);
        i = (i + 1) >> 0;
      }
      return true;
    };
    divmod1e9 = function (x) {
      var _tuple, hi, q, x, x$1;
      if (false) {
        return [
          $div64(x, new $Uint64(0, 1000000000), false).$low >>> 0,
          $div64(x, new $Uint64(0, 1000000000), true).$low >>> 0,
        ];
      }
      _tuple = bits.Mul64(
        $shiftRightUint64(x, 1),
        new $Uint64(2305843009, 917808536)
      );
      hi = _tuple[0];
      q = $shiftRightUint64(hi, 28);
      return [
        q.$low >>> 0,
        ((x$1 = $mul64(q, new $Uint64(0, 1000000000))),
        new $Uint64(x.$high - x$1.$high, x.$low - x$1.$low)).$low >>> 0,
      ];
    };
    FormatFloat = function (f, fmt, prec, bitSize) {
      var bitSize, f, fmt, prec;
      return $bytesToString(
        genericFtoa(
          $makeSlice(sliceType$6, 0, max((prec + 4) >> 0, 24)),
          f,
          fmt,
          prec,
          bitSize
        )
      );
    };
    $pkg.FormatFloat = FormatFloat;
    AppendFloat = function (dst, f, fmt, prec, bitSize) {
      var bitSize, dst, f, fmt, prec;
      return genericFtoa(dst, f, fmt, prec, bitSize);
    };
    $pkg.AppendFloat = AppendFloat;
    genericFtoa = function (dst, val, fmt, prec, bitSize) {
      var _1,
        _2,
        _3,
        _4,
        bitSize,
        bits$1,
        buf,
        buf$1,
        digits,
        digs,
        dst,
        exp,
        flt,
        fmt,
        mant,
        neg,
        ok,
        prec,
        s,
        shortest,
        val,
        x,
        x$1,
        x$2,
        x$3,
        y,
        y$1;
      bits$1 = new $Uint64(0, 0);
      flt = ptrType.nil;
      _1 = bitSize;
      if (_1 === 32) {
        bits$1 = new $Uint64(0, math.Float32bits($fround(val)));
        flt = float32info;
      } else if (_1 === 64) {
        bits$1 = math.Float64bits(val);
        flt = float64info;
      } else {
        $panic(new $String("strconv: illegal AppendFloat/FormatFloat bitSize"));
      }
      neg = !((x = $shiftRightUint64(
        bits$1,
        (flt.expbits + flt.mantbits) >>> 0
      )),
      x.$high === 0 && x.$low === 0);
      exp =
        ($shiftRightUint64(bits$1, flt.mantbits).$low >> 0) &
        (((((y = flt.expbits), y < 32 ? 1 << y : 0) >> 0) - 1) >> 0);
      mant =
        ((x$1 =
          ((x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
          new $Uint64(x$2.$high - 0, x$2.$low - 1))),
        new $Uint64(bits$1.$high & x$1.$high, (bits$1.$low & x$1.$low) >>> 0));
      _2 = exp;
      if (
        _2 ===
        ((((y$1 = flt.expbits), y$1 < 32 ? 1 << y$1 : 0) >> 0) - 1) >> 0
      ) {
        s = "";
        if (!(mant.$high === 0 && mant.$low === 0)) {
          s = "NaN";
        } else if (neg) {
          s = "-Inf";
        } else {
          s = "+Inf";
        }
        return $appendSlice(dst, s);
      } else if (_2 === 0) {
        exp = (exp + 1) >> 0;
      } else {
        mant =
          ((x$3 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
          new $Uint64(mant.$high | x$3.$high, (mant.$low | x$3.$low) >>> 0));
      }
      exp = (exp + flt.bias) >> 0;
      if (fmt === 98) {
        return fmtB(dst, neg, mant, exp, flt);
      }
      if (fmt === 120 || fmt === 88) {
        return fmtX(dst, prec, fmt, neg, mant, exp, flt);
      }
      if (!optimize) {
        return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
      }
      digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
      ok = false;
      shortest = prec < 0;
      if (shortest) {
        buf = arrayType$3.zero();
        digs.d = new sliceType$6(buf);
        ryuFtoaShortest(digs, mant, (exp - (flt.mantbits >> 0)) >> 0, flt);
        ok = true;
        _3 = fmt;
        if (_3 === 101 || _3 === 69) {
          prec = max((digs.nd - 1) >> 0, 0);
        } else if (_3 === 102) {
          prec = max((digs.nd - digs.dp) >> 0, 0);
        } else if (_3 === 103 || _3 === 71) {
          prec = digs.nd;
        }
      } else if (!(fmt === 102)) {
        digits = prec;
        _4 = fmt;
        if (_4 === 101 || _4 === 69) {
          digits = (digits + 1) >> 0;
        } else if (_4 === 103 || _4 === 71) {
          if (prec === 0) {
            prec = 1;
          }
          digits = prec;
        }
        buf$1 = arrayType$4.zero();
        if (bitSize === 32 && digits <= 9) {
          digs.d = new sliceType$6(buf$1);
          ryuFtoaFixed32(
            digs,
            mant.$low >>> 0,
            (exp - (flt.mantbits >> 0)) >> 0,
            digits
          );
          ok = true;
        } else if (digits <= 18) {
          digs.d = new sliceType$6(buf$1);
          ryuFtoaFixed64(digs, mant, (exp - (flt.mantbits >> 0)) >> 0, digits);
          ok = true;
        }
      }
      if (!ok) {
        return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
      }
      return formatDigits(
        dst,
        shortest,
        neg,
        $clone(digs, decimalSlice),
        prec,
        fmt
      );
    };
    bigFtoa = function (dst, prec, fmt, neg, mant, exp, flt) {
      var _1, _2, d, digs, dst, exp, flt, fmt, mant, neg, prec, shortest;
      d = new decimal.ptr(arrayType$5.zero(), 0, 0, false, false);
      d.Assign(mant);
      d.Shift((exp - (flt.mantbits >> 0)) >> 0);
      digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
      shortest = prec < 0;
      if (shortest) {
        roundShortest(d, mant, exp, flt);
        decimalSlice.copy(
          digs,
          new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false)
        );
        _1 = fmt;
        if (_1 === 101 || _1 === 69) {
          prec = (digs.nd - 1) >> 0;
        } else if (_1 === 102) {
          prec = max((digs.nd - digs.dp) >> 0, 0);
        } else if (_1 === 103 || _1 === 71) {
          prec = digs.nd;
        }
      } else {
        _2 = fmt;
        if (_2 === 101 || _2 === 69) {
          d.Round((prec + 1) >> 0);
        } else if (_2 === 102) {
          d.Round((d.dp + prec) >> 0);
        } else if (_2 === 103 || _2 === 71) {
          if (prec === 0) {
            prec = 1;
          }
          d.Round(prec);
        }
        decimalSlice.copy(
          digs,
          new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false)
        );
      }
      return formatDigits(
        dst,
        shortest,
        neg,
        $clone(digs, decimalSlice),
        prec,
        fmt
      );
    };
    formatDigits = function (dst, shortest, neg, digs, prec, fmt) {
      var _1, digs, dst, eprec, exp, fmt, neg, prec, shortest;
      _1 = fmt;
      if (_1 === 101 || _1 === 69) {
        return fmtE(dst, neg, $clone(digs, decimalSlice), prec, fmt);
      } else if (_1 === 102) {
        return fmtF(dst, neg, $clone(digs, decimalSlice), prec);
      } else if (_1 === 103 || _1 === 71) {
        eprec = prec;
        if (eprec > digs.nd && digs.nd >= digs.dp) {
          eprec = digs.nd;
        }
        if (shortest) {
          eprec = 6;
        }
        exp = (digs.dp - 1) >> 0;
        if (exp < -4 || exp >= eprec) {
          if (prec > digs.nd) {
            prec = digs.nd;
          }
          return fmtE(
            dst,
            neg,
            $clone(digs, decimalSlice),
            (prec - 1) >> 0,
            (((((fmt + 101) << 24) >>> 24) - 103) << 24) >>> 24
          );
        }
        if (prec > digs.dp) {
          prec = digs.nd;
        }
        return fmtF(
          dst,
          neg,
          $clone(digs, decimalSlice),
          max((prec - digs.dp) >> 0, 0)
        );
      }
      return $append(dst, 37, fmt);
    };
    roundShortest = function (d, mant, exp, flt) {
      var d,
        exp,
        explo,
        flt,
        inclusive,
        l,
        li,
        lower$1,
        m,
        mant,
        mantlo,
        mi,
        minexp,
        okdown,
        okup,
        u,
        ui,
        upper,
        upperdelta,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7;
      if (mant.$high === 0 && mant.$low === 0) {
        d.nd = 0;
        return;
      }
      minexp = (flt.bias + 1) >> 0;
      if (
        exp > minexp &&
        $imul(332, (d.dp - d.nd) >> 0) >=
          $imul(100, (exp - (flt.mantbits >> 0)) >> 0)
      ) {
        return;
      }
      upper = new decimal.ptr(arrayType$5.zero(), 0, 0, false, false);
      upper.Assign(
        ((x = $mul64(mant, new $Uint64(0, 2))),
        new $Uint64(x.$high + 0, x.$low + 1))
      );
      upper.Shift((((exp - (flt.mantbits >> 0)) >> 0) - 1) >> 0);
      mantlo = new $Uint64(0, 0);
      explo = 0;
      if (
        ((x$1 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
        mant.$high > x$1.$high ||
          (mant.$high === x$1.$high && mant.$low > x$1.$low)) ||
        exp === minexp
      ) {
        mantlo = new $Uint64(mant.$high - 0, mant.$low - 1);
        explo = exp;
      } else {
        mantlo =
          ((x$2 = $mul64(mant, new $Uint64(0, 2))),
          new $Uint64(x$2.$high - 0, x$2.$low - 1));
        explo = (exp - 1) >> 0;
      }
      lower$1 = new decimal.ptr(arrayType$5.zero(), 0, 0, false, false);
      lower$1.Assign(
        ((x$3 = $mul64(mantlo, new $Uint64(0, 2))),
        new $Uint64(x$3.$high + 0, x$3.$low + 1))
      );
      lower$1.Shift((((explo - (flt.mantbits >> 0)) >> 0) - 1) >> 0);
      inclusive =
        ((x$4 = $div64(mant, new $Uint64(0, 2), true)),
        x$4.$high === 0 && x$4.$low === 0);
      upperdelta = 0;
      ui = 0;
      while (true) {
        mi = (((ui - upper.dp) >> 0) + d.dp) >> 0;
        if (mi >= d.nd) {
          break;
        }
        li = (((ui - upper.dp) >> 0) + lower$1.dp) >> 0;
        l = 48;
        if (li >= 0 && li < lower$1.nd) {
          l =
            ((x$5 = lower$1.d),
            li < 0 || li >= x$5.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$5[li]);
        }
        m = 48;
        if (mi >= 0) {
          m =
            ((x$6 = d.d),
            mi < 0 || mi >= x$6.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$6[mi]);
        }
        u = 48;
        if (ui < upper.nd) {
          u =
            ((x$7 = upper.d),
            ui < 0 || ui >= x$7.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$7[ui]);
        }
        okdown = !(l === m) || (inclusive && (li + 1) >> 0 === lower$1.nd);
        if (upperdelta === 0 && ((m + 1) << 24) >>> 24 < u) {
          upperdelta = 2;
        } else if (upperdelta === 0 && !(m === u)) {
          upperdelta = 1;
        } else if (upperdelta === 1 && (!(m === 57) || !(u === 48))) {
          upperdelta = 2;
        }
        okup =
          upperdelta > 0 &&
          (inclusive || upperdelta > 1 || (ui + 1) >> 0 < upper.nd);
        if (okdown && okup) {
          d.Round((mi + 1) >> 0);
          return;
        } else if (okdown) {
          d.RoundDown((mi + 1) >> 0);
          return;
        } else if (okup) {
          d.RoundUp((mi + 1) >> 0);
          return;
        }
        ui = (ui + 1) >> 0;
      }
    };
    fmtE = function (dst, neg, d, prec, fmt) {
      var _q,
        _q$1,
        _q$2,
        _r,
        _r$1,
        _r$2,
        ch,
        d,
        dst,
        exp,
        fmt,
        i,
        m,
        neg,
        prec,
        x;
      if (neg) {
        dst = $append(dst, 45);
      }
      ch = 48;
      if (!(d.nd === 0)) {
        ch =
          ((x = d.d),
          0 >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + 0]);
      }
      dst = $append(dst, ch);
      if (prec > 0) {
        dst = $append(dst, 46);
        i = 1;
        m = min(d.nd, (prec + 1) >> 0);
        if (i < m) {
          dst = $appendSlice(dst, $subslice(d.d, i, m));
          i = m;
        }
        while (true) {
          if (!(i <= prec)) {
            break;
          }
          dst = $append(dst, 48);
          i = (i + 1) >> 0;
        }
      }
      dst = $append(dst, fmt);
      exp = (d.dp - 1) >> 0;
      if (d.nd === 0) {
        exp = 0;
      }
      if (exp < 0) {
        ch = 45;
        exp = -exp;
      } else {
        ch = 43;
      }
      dst = $append(dst, ch);
      if (exp < 10) {
        dst = $append(dst, 48, ((((exp << 24) >>> 24) + 48) << 24) >>> 24);
      } else if (exp < 100) {
        dst = $append(
          dst,
          ((((((_q = exp / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((((_r = exp % 10),
          _r === _r ? _r : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24
        );
      } else {
        dst = $append(
          dst,
          ((((((_q$1 = exp / 100),
          _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
            ? _q$1 >> 0
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((_r$1 =
            ((((_q$2 = exp / 10),
            _q$2 === _q$2 && _q$2 !== 1 / 0 && _q$2 !== -1 / 0
              ? _q$2 >> 0
              : $throwRuntimeError("integer divide by zero")) <<
              24) >>>
              24) %
            10),
          _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) +
            48) <<
            24) >>>
            24,
          ((((((_r$2 = exp % 10),
          _r$2 === _r$2
            ? _r$2
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24
        );
      }
      return dst;
    };
    fmtF = function (dst, neg, d, prec) {
      var ch, d, dst, i, j, m, neg, prec, x;
      if (neg) {
        dst = $append(dst, 45);
      }
      if (d.dp > 0) {
        m = min(d.nd, d.dp);
        dst = $appendSlice(dst, $subslice(d.d, 0, m));
        while (true) {
          if (!(m < d.dp)) {
            break;
          }
          dst = $append(dst, 48);
          m = (m + 1) >> 0;
        }
      } else {
        dst = $append(dst, 48);
      }
      if (prec > 0) {
        dst = $append(dst, 46);
        i = 0;
        while (true) {
          if (!(i < prec)) {
            break;
          }
          ch = 48;
          j = (d.dp + i) >> 0;
          if (0 <= j && j < d.nd) {
            ch =
              ((x = d.d),
              j < 0 || j >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + j]);
          }
          dst = $append(dst, ch);
          i = (i + 1) >> 0;
        }
      }
      return dst;
    };
    fmtB = function (dst, neg, mant, exp, flt) {
      var _tuple, _tuple$1, dst, exp, flt, mant, neg;
      if (neg) {
        dst = $append(dst, 45);
      }
      _tuple = formatBits(dst, mant, 10, false, true);
      dst = _tuple[0];
      dst = $append(dst, 112);
      exp = (exp - (flt.mantbits >> 0)) >> 0;
      if (exp >= 0) {
        dst = $append(dst, 43);
      }
      _tuple$1 = formatBits(dst, new $Uint64(0, exp), 10, exp < 0, true);
      dst = _tuple$1[0];
      return dst;
    };
    fmtX = function (dst, prec, fmt, neg, mant, exp, flt) {
      var _q,
        _q$1,
        _q$2,
        _q$3,
        _q$4,
        _q$5,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        ch,
        dst,
        exp,
        extra,
        flt,
        fmt,
        hex,
        i,
        mant,
        neg,
        prec,
        shift,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8;
      if (mant.$high === 0 && mant.$low === 0) {
        exp = 0;
      }
      mant = $shiftLeft64(mant, (60 - flt.mantbits) >>> 0);
      while (true) {
        if (
          !(
            !(mant.$high === 0 && mant.$low === 0) &&
            ((x = new $Uint64(mant.$high & 268435456, (mant.$low & 0) >>> 0)),
            x.$high === 0 && x.$low === 0)
          )
        ) {
          break;
        }
        mant = $shiftLeft64(mant, 1);
        exp = (exp - 1) >> 0;
      }
      if (prec >= 0 && prec < 15) {
        shift = $imul(prec, 4) >>> 0;
        extra =
          ((x$1 = $shiftLeft64(mant, shift)),
          new $Uint64(x$1.$high & 268435455, (x$1.$low & 4294967295) >>> 0));
        mant = $shiftRightUint64(mant, (60 - shift) >>> 0);
        if (
          ((x$2 =
            ((x$3 = new $Uint64(mant.$high & 0, (mant.$low & 1) >>> 0)),
            new $Uint64(
              extra.$high | x$3.$high,
              (extra.$low | x$3.$low) >>> 0
            ))),
          x$2.$high > 134217728 || (x$2.$high === 134217728 && x$2.$low > 0))
        ) {
          mant =
            ((x$4 = new $Uint64(0, 1)),
            new $Uint64(mant.$high + x$4.$high, mant.$low + x$4.$low));
        }
        mant = $shiftLeft64(mant, (60 - shift) >>> 0);
        if (
          !((x$5 = new $Uint64(mant.$high & 536870912, (mant.$low & 0) >>> 0)),
          x$5.$high === 0 && x$5.$low === 0)
        ) {
          mant = $shiftRightUint64(mant, 1);
          exp = (exp + 1) >> 0;
        }
      }
      hex = "0123456789abcdef";
      if (fmt === 88) {
        hex = "0123456789ABCDEF";
      }
      if (neg) {
        dst = $append(dst, 45);
      }
      dst = $append(
        dst,
        48,
        fmt,
        ((48 +
          ((((x$6 = $shiftRightUint64(mant, 60)),
          new $Uint64(x$6.$high & 0, (x$6.$low & 1) >>> 0)).$low <<
            24) >>>
            24)) <<
          24) >>>
          24
      );
      mant = $shiftLeft64(mant, 4);
      if (prec < 0 && !(mant.$high === 0 && mant.$low === 0)) {
        dst = $append(dst, 46);
        while (true) {
          if (!!(mant.$high === 0 && mant.$low === 0)) {
            break;
          }
          dst = $append(
            dst,
            hex.charCodeAt(
              $flatten64(
                ((x$7 = $shiftRightUint64(mant, 60)),
                new $Uint64(x$7.$high & 0, (x$7.$low & 15) >>> 0))
              )
            )
          );
          mant = $shiftLeft64(mant, 4);
        }
      } else if (prec > 0) {
        dst = $append(dst, 46);
        i = 0;
        while (true) {
          if (!(i < prec)) {
            break;
          }
          dst = $append(
            dst,
            hex.charCodeAt(
              $flatten64(
                ((x$8 = $shiftRightUint64(mant, 60)),
                new $Uint64(x$8.$high & 0, (x$8.$low & 15) >>> 0))
              )
            )
          );
          mant = $shiftLeft64(mant, 4);
          i = (i + 1) >> 0;
        }
      }
      ch = 80;
      if (fmt === lower(fmt)) {
        ch = 112;
      }
      dst = $append(dst, ch);
      if (exp < 0) {
        ch = 45;
        exp = -exp;
      } else {
        ch = 43;
      }
      dst = $append(dst, ch);
      if (exp < 100) {
        dst = $append(
          dst,
          ((((((_q = exp / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((((_r = exp % 10),
          _r === _r ? _r : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24
        );
      } else if (exp < 1000) {
        dst = $append(
          dst,
          ((((((_q$1 = exp / 100),
          _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
            ? _q$1 >> 0
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((((_r$1 =
            ((_q$2 = exp / 10),
            _q$2 === _q$2 && _q$2 !== 1 / 0 && _q$2 !== -1 / 0
              ? _q$2 >> 0
              : $throwRuntimeError("integer divide by zero")) % 10),
          _r$1 === _r$1
            ? _r$1
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((((_r$2 = exp % 10),
          _r$2 === _r$2
            ? _r$2
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24
        );
      } else {
        dst = $append(
          dst,
          ((((((_q$3 = exp / 1000),
          _q$3 === _q$3 && _q$3 !== 1 / 0 && _q$3 !== -1 / 0
            ? _q$3 >> 0
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((_r$3 =
            ((((_q$4 = exp / 100),
            _q$4 === _q$4 && _q$4 !== 1 / 0 && _q$4 !== -1 / 0
              ? _q$4 >> 0
              : $throwRuntimeError("integer divide by zero")) <<
              24) >>>
              24) %
            10),
          _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero")) +
            48) <<
            24) >>>
            24,
          ((((((_r$4 =
            ((_q$5 = exp / 10),
            _q$5 === _q$5 && _q$5 !== 1 / 0 && _q$5 !== -1 / 0
              ? _q$5 >> 0
              : $throwRuntimeError("integer divide by zero")) % 10),
          _r$4 === _r$4
            ? _r$4
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24,
          ((((((_r$5 = exp % 10),
          _r$5 === _r$5
            ? _r$5
            : $throwRuntimeError("integer divide by zero")) <<
            24) >>>
            24) +
            48) <<
            24) >>>
            24
        );
      }
      return dst;
    };
    min = function (a, b) {
      var a, b;
      if (a < b) {
        return a;
      }
      return b;
    };
    max = function (a, b) {
      var a, b;
      if (a > b) {
        return a;
      }
      return b;
    };
    eiselLemire64 = function (man, exp10, neg) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        clz,
        exp10,
        f,
        man,
        mergedHi,
        mergedLo,
        msb,
        neg,
        ok,
        retBits,
        retExp2,
        retMantissa,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$15,
        x$16,
        x$17,
        x$18,
        x$19,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        xHi,
        xLo,
        yHi,
        yLo;
      f = 0;
      ok = false;
      if (man.$high === 0 && man.$low === 0) {
        if (neg) {
          f = math.Float64frombits(new $Uint64(2147483648, 0));
        }
        _tmp = f;
        _tmp$1 = true;
        f = _tmp;
        ok = _tmp$1;
        return [f, ok];
      }
      if (exp10 < -348 || 347 < exp10) {
        _tmp$2 = 0;
        _tmp$3 = false;
        f = _tmp$2;
        ok = _tmp$3;
        return [f, ok];
      }
      clz = bits.LeadingZeros64(man);
      man = $shiftLeft64(man, clz >>> 0);
      retExp2 =
        ((x = new $Uint64(
          0,
          ((((($imul(217706, exp10) >> 16) >> 0) + 64) >> 0) + 1023) >> 0
        )),
        (x$1 = new $Uint64(0, clz)),
        new $Uint64(x.$high - x$1.$high, x.$low - x$1.$low));
      _tuple = bits.Mul64(
        man,
        ((x$2 = (exp10 - -348) >> 0),
        x$2 < 0 || x$2 >= detailedPowersOfTen.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : detailedPowersOfTen[x$2])[1]
      );
      xHi = _tuple[0];
      xLo = _tuple[1];
      if (
        ((x$3 = new $Uint64(xHi.$high & 0, (xHi.$low & 511) >>> 0)),
        x$3.$high === 0 && x$3.$low === 511) &&
        ((x$4 = new $Uint64(xLo.$high + man.$high, xLo.$low + man.$low)),
        x$4.$high < man.$high ||
          (x$4.$high === man.$high && x$4.$low < man.$low))
      ) {
        _tuple$1 = bits.Mul64(
          man,
          ((x$5 = (exp10 - -348) >> 0),
          x$5 < 0 || x$5 >= detailedPowersOfTen.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : detailedPowersOfTen[x$5])[0]
        );
        yHi = _tuple$1[0];
        yLo = _tuple$1[1];
        _tmp$4 = xHi;
        _tmp$5 = new $Uint64(xLo.$high + yHi.$high, xLo.$low + yHi.$low);
        mergedHi = _tmp$4;
        mergedLo = _tmp$5;
        if (
          mergedLo.$high < xLo.$high ||
          (mergedLo.$high === xLo.$high && mergedLo.$low < xLo.$low)
        ) {
          mergedHi =
            ((x$6 = new $Uint64(0, 1)),
            new $Uint64(mergedHi.$high + x$6.$high, mergedHi.$low + x$6.$low));
        }
        if (
          ((x$7 = new $Uint64(mergedHi.$high & 0, (mergedHi.$low & 511) >>> 0)),
          x$7.$high === 0 && x$7.$low === 511) &&
          ((x$8 = new $Uint64(mergedLo.$high + 0, mergedLo.$low + 1)),
          x$8.$high === 0 && x$8.$low === 0) &&
          ((x$9 = new $Uint64(yLo.$high + man.$high, yLo.$low + man.$low)),
          x$9.$high < man.$high ||
            (x$9.$high === man.$high && x$9.$low < man.$low))
        ) {
          _tmp$6 = 0;
          _tmp$7 = false;
          f = _tmp$6;
          ok = _tmp$7;
          return [f, ok];
        }
        _tmp$8 = mergedHi;
        _tmp$9 = mergedLo;
        xHi = _tmp$8;
        xLo = _tmp$9;
      }
      msb = $shiftRightUint64(xHi, 63);
      retMantissa = $shiftRightUint64(
        xHi,
        $flatten64(new $Uint64(msb.$high + 0, msb.$low + 9))
      );
      retExp2 =
        ((x$10 = new $Uint64(0 ^ msb.$high, (1 ^ msb.$low) >>> 0)),
        new $Uint64(retExp2.$high - x$10.$high, retExp2.$low - x$10.$low));
      if (
        xLo.$high === 0 &&
        xLo.$low === 0 &&
        ((x$11 = new $Uint64(xHi.$high & 0, (xHi.$low & 511) >>> 0)),
        x$11.$high === 0 && x$11.$low === 0) &&
        ((x$12 = new $Uint64(
          retMantissa.$high & 0,
          (retMantissa.$low & 3) >>> 0
        )),
        x$12.$high === 0 && x$12.$low === 1)
      ) {
        _tmp$10 = 0;
        _tmp$11 = false;
        f = _tmp$10;
        ok = _tmp$11;
        return [f, ok];
      }
      retMantissa =
        ((x$13 = new $Uint64(
          retMantissa.$high & 0,
          (retMantissa.$low & 1) >>> 0
        )),
        new $Uint64(
          retMantissa.$high + x$13.$high,
          retMantissa.$low + x$13.$low
        ));
      retMantissa = $shiftRightUint64(retMantissa, 1);
      if (
        ((x$14 = $shiftRightUint64(retMantissa, 53)),
        x$14.$high > 0 || (x$14.$high === 0 && x$14.$low > 0))
      ) {
        retMantissa = $shiftRightUint64(retMantissa, 1);
        retExp2 =
          ((x$15 = new $Uint64(0, 1)),
          new $Uint64(retExp2.$high + x$15.$high, retExp2.$low + x$15.$low));
      }
      if (
        ((x$16 = new $Uint64(retExp2.$high - 0, retExp2.$low - 1)),
        x$16.$high > 0 || (x$16.$high === 0 && x$16.$low >= 2046))
      ) {
        _tmp$12 = 0;
        _tmp$13 = false;
        f = _tmp$12;
        ok = _tmp$13;
        return [f, ok];
      }
      retBits =
        ((x$17 = $shiftLeft64(retExp2, 52)),
        (x$18 = new $Uint64(
          retMantissa.$high & 1048575,
          (retMantissa.$low & 4294967295) >>> 0
        )),
        new $Uint64(x$17.$high | x$18.$high, (x$17.$low | x$18.$low) >>> 0));
      if (neg) {
        retBits =
          ((x$19 = new $Uint64(2147483648, 0)),
          new $Uint64(
            retBits.$high | x$19.$high,
            (retBits.$low | x$19.$low) >>> 0
          ));
      }
      _tmp$14 = math.Float64frombits(retBits);
      _tmp$15 = true;
      f = _tmp$14;
      ok = _tmp$15;
      return [f, ok];
    };
    eiselLemire32 = function (man, exp10, neg) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        clz,
        exp10,
        f,
        man,
        mergedHi,
        mergedLo,
        msb,
        neg,
        ok,
        retBits,
        retExp2,
        retMantissa,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$15,
        x$16,
        x$17,
        x$18,
        x$19,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        xHi,
        xLo,
        yHi,
        yLo;
      f = 0;
      ok = false;
      if (man.$high === 0 && man.$low === 0) {
        if (neg) {
          f = math.Float32frombits(2147483648);
        }
        _tmp = f;
        _tmp$1 = true;
        f = _tmp;
        ok = _tmp$1;
        return [f, ok];
      }
      if (exp10 < -348 || 347 < exp10) {
        _tmp$2 = 0;
        _tmp$3 = false;
        f = _tmp$2;
        ok = _tmp$3;
        return [f, ok];
      }
      clz = bits.LeadingZeros64(man);
      man = $shiftLeft64(man, clz >>> 0);
      retExp2 =
        ((x = new $Uint64(
          0,
          ((((($imul(217706, exp10) >> 16) >> 0) + 64) >> 0) + 127) >> 0
        )),
        (x$1 = new $Uint64(0, clz)),
        new $Uint64(x.$high - x$1.$high, x.$low - x$1.$low));
      _tuple = bits.Mul64(
        man,
        ((x$2 = (exp10 - -348) >> 0),
        x$2 < 0 || x$2 >= detailedPowersOfTen.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : detailedPowersOfTen[x$2])[1]
      );
      xHi = _tuple[0];
      xLo = _tuple[1];
      if (
        ((x$3 = new $Uint64(xHi.$high & 63, (xHi.$low & 4294967295) >>> 0)),
        x$3.$high === 63 && x$3.$low === 4294967295) &&
        ((x$4 = new $Uint64(xLo.$high + man.$high, xLo.$low + man.$low)),
        x$4.$high < man.$high ||
          (x$4.$high === man.$high && x$4.$low < man.$low))
      ) {
        _tuple$1 = bits.Mul64(
          man,
          ((x$5 = (exp10 - -348) >> 0),
          x$5 < 0 || x$5 >= detailedPowersOfTen.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : detailedPowersOfTen[x$5])[0]
        );
        yHi = _tuple$1[0];
        yLo = _tuple$1[1];
        _tmp$4 = xHi;
        _tmp$5 = new $Uint64(xLo.$high + yHi.$high, xLo.$low + yHi.$low);
        mergedHi = _tmp$4;
        mergedLo = _tmp$5;
        if (
          mergedLo.$high < xLo.$high ||
          (mergedLo.$high === xLo.$high && mergedLo.$low < xLo.$low)
        ) {
          mergedHi =
            ((x$6 = new $Uint64(0, 1)),
            new $Uint64(mergedHi.$high + x$6.$high, mergedHi.$low + x$6.$low));
        }
        if (
          ((x$7 = new $Uint64(
            mergedHi.$high & 63,
            (mergedHi.$low & 4294967295) >>> 0
          )),
          x$7.$high === 63 && x$7.$low === 4294967295) &&
          ((x$8 = new $Uint64(mergedLo.$high + 0, mergedLo.$low + 1)),
          x$8.$high === 0 && x$8.$low === 0) &&
          ((x$9 = new $Uint64(yLo.$high + man.$high, yLo.$low + man.$low)),
          x$9.$high < man.$high ||
            (x$9.$high === man.$high && x$9.$low < man.$low))
        ) {
          _tmp$6 = 0;
          _tmp$7 = false;
          f = _tmp$6;
          ok = _tmp$7;
          return [f, ok];
        }
        _tmp$8 = mergedHi;
        _tmp$9 = mergedLo;
        xHi = _tmp$8;
        xLo = _tmp$9;
      }
      msb = $shiftRightUint64(xHi, 63);
      retMantissa = $shiftRightUint64(
        xHi,
        $flatten64(new $Uint64(msb.$high + 0, msb.$low + 38))
      );
      retExp2 =
        ((x$10 = new $Uint64(0 ^ msb.$high, (1 ^ msb.$low) >>> 0)),
        new $Uint64(retExp2.$high - x$10.$high, retExp2.$low - x$10.$low));
      if (
        xLo.$high === 0 &&
        xLo.$low === 0 &&
        ((x$11 = new $Uint64(xHi.$high & 63, (xHi.$low & 4294967295) >>> 0)),
        x$11.$high === 0 && x$11.$low === 0) &&
        ((x$12 = new $Uint64(
          retMantissa.$high & 0,
          (retMantissa.$low & 3) >>> 0
        )),
        x$12.$high === 0 && x$12.$low === 1)
      ) {
        _tmp$10 = 0;
        _tmp$11 = false;
        f = _tmp$10;
        ok = _tmp$11;
        return [f, ok];
      }
      retMantissa =
        ((x$13 = new $Uint64(
          retMantissa.$high & 0,
          (retMantissa.$low & 1) >>> 0
        )),
        new $Uint64(
          retMantissa.$high + x$13.$high,
          retMantissa.$low + x$13.$low
        ));
      retMantissa = $shiftRightUint64(retMantissa, 1);
      if (
        ((x$14 = $shiftRightUint64(retMantissa, 24)),
        x$14.$high > 0 || (x$14.$high === 0 && x$14.$low > 0))
      ) {
        retMantissa = $shiftRightUint64(retMantissa, 1);
        retExp2 =
          ((x$15 = new $Uint64(0, 1)),
          new $Uint64(retExp2.$high + x$15.$high, retExp2.$low + x$15.$low));
      }
      if (
        ((x$16 = new $Uint64(retExp2.$high - 0, retExp2.$low - 1)),
        x$16.$high > 0 || (x$16.$high === 0 && x$16.$low >= 254))
      ) {
        _tmp$12 = 0;
        _tmp$13 = false;
        f = _tmp$12;
        ok = _tmp$13;
        return [f, ok];
      }
      retBits =
        ((x$17 = $shiftLeft64(retExp2, 23)),
        (x$18 = new $Uint64(
          retMantissa.$high & 0,
          (retMantissa.$low & 8388607) >>> 0
        )),
        new $Uint64(x$17.$high | x$18.$high, (x$17.$low | x$18.$low) >>> 0));
      if (neg) {
        retBits =
          ((x$19 = new $Uint64(0, 2147483648)),
          new $Uint64(
            retBits.$high | x$19.$high,
            (retBits.$low | x$19.$low) >>> 0
          ));
      }
      _tmp$14 = math.Float32frombits(retBits.$low >>> 0);
      _tmp$15 = true;
      f = _tmp$14;
      ok = _tmp$15;
      return [f, ok];
    };
    decimal.ptr.prototype.String = function () {
      var a, buf, n, w;
      a = this;
      n = (10 + a.nd) >> 0;
      if (a.dp > 0) {
        n = (n + a.dp) >> 0;
      }
      if (a.dp < 0) {
        n = (n + -a.dp) >> 0;
      }
      buf = $makeSlice(sliceType$6, n);
      w = 0;
      if (a.nd === 0) {
        return "0";
      } else if (a.dp <= 0) {
        w < 0 || w >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + w] = 48);
        w = (w + 1) >> 0;
        w < 0 || w >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + w] = 46);
        w = (w + 1) >> 0;
        w = (w + digitZero($subslice(buf, w, (w + -a.dp) >> 0))) >> 0;
        w =
          (w +
            $copySlice(
              $subslice(buf, w),
              $subslice(new sliceType$6(a.d), 0, a.nd)
            )) >>
          0;
      } else if (a.dp < a.nd) {
        w =
          (w +
            $copySlice(
              $subslice(buf, w),
              $subslice(new sliceType$6(a.d), 0, a.dp)
            )) >>
          0;
        w < 0 || w >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + w] = 46);
        w = (w + 1) >> 0;
        w =
          (w +
            $copySlice(
              $subslice(buf, w),
              $subslice(new sliceType$6(a.d), a.dp, a.nd)
            )) >>
          0;
      } else {
        w =
          (w +
            $copySlice(
              $subslice(buf, w),
              $subslice(new sliceType$6(a.d), 0, a.nd)
            )) >>
          0;
        w =
          (w + digitZero($subslice(buf, w, (((w + a.dp) >> 0) - a.nd) >> 0))) >>
          0;
      }
      return $bytesToString($subslice(buf, 0, w));
    };
    decimal.prototype.String = function () {
      return this.$val.String();
    };
    digitZero = function (dst) {
      var _i, _ref, dst, i;
      _ref = dst;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        i < 0 || i >= dst.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (dst.$array[dst.$offset + i] = 48);
        _i++;
      }
      return dst.$length;
    };
    trim = function (a) {
      var a, x, x$1;
      while (true) {
        if (
          !(
            a.nd > 0 &&
            ((x = a.d),
            (x$1 = (a.nd - 1) >> 0),
            x$1 < 0 || x$1 >= x.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x[x$1]) === 48
          )
        ) {
          break;
        }
        a.nd = (a.nd - 1) >> 0;
      }
      if (a.nd === 0) {
        a.dp = 0;
      }
    };
    decimal.ptr.prototype.Assign = function (v) {
      var a, buf, n, v, v1, x, x$1, x$2;
      a = this;
      buf = arrayType$4.zero();
      n = 0;
      while (true) {
        if (!(v.$high > 0 || (v.$high === 0 && v.$low > 0))) {
          break;
        }
        v1 = $div64(v, new $Uint64(0, 10), false);
        v =
          ((x = $mul64(new $Uint64(0, 10), v1)),
          new $Uint64(v.$high - x.$high, v.$low - x.$low));
        n < 0 || n >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[n] =
              (new $Uint64(v.$high + 0, v.$low + 48).$low << 24) >>> 24);
        n = (n + 1) >> 0;
        v = v1;
      }
      a.nd = 0;
      n = (n - 1) >> 0;
      while (true) {
        if (!(n >= 0)) {
          break;
        }
        (x$1 = a.d),
          (x$2 = a.nd),
          x$2 < 0 || x$2 >= x$1.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$1[x$2] =
                n < 0 || n >= buf.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : buf[n]);
        a.nd = (a.nd + 1) >> 0;
        n = (n - 1) >> 0;
      }
      a.dp = a.nd;
      trim(a);
    };
    decimal.prototype.Assign = function (v) {
      return this.$val.Assign(v);
    };
    rightShift = function (a, k) {
      var a,
        c,
        c$1,
        dig,
        dig$1,
        k,
        mask,
        n,
        r,
        w,
        x,
        x$1,
        x$2,
        x$3,
        y,
        y$1,
        y$2,
        y$3,
        y$4;
      r = 0;
      w = 0;
      n = 0;
      while (true) {
        if (!(((y = k), y < 32 ? n >>> y : 0) >>> 0 === 0)) {
          break;
        }
        if (r >= a.nd) {
          if (n === 0) {
            a.nd = 0;
            return;
          }
          while (true) {
            if (!(((y$1 = k), y$1 < 32 ? n >>> y$1 : 0) >>> 0 === 0)) {
              break;
            }
            n = (n * 10) >>> 0;
            r = (r + 1) >> 0;
          }
          break;
        }
        c =
          ((x = a.d),
          r < 0 || r >= x.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x[r]) >>> 0;
        n = (((((n * 10) >>> 0) + c) >>> 0) - 48) >>> 0;
        r = (r + 1) >> 0;
      }
      a.dp = (a.dp - ((r - 1) >> 0)) >> 0;
      mask = ((((y$2 = k), y$2 < 32 ? 1 << y$2 : 0) >>> 0) - 1) >>> 0;
      while (true) {
        if (!(r < a.nd)) {
          break;
        }
        c$1 =
          ((x$1 = a.d),
          r < 0 || r >= x$1.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x$1[r]) >>> 0;
        dig = ((y$3 = k), y$3 < 32 ? n >>> y$3 : 0) >>> 0;
        n = (n & mask) >>> 0;
        (x$2 = a.d),
          w < 0 || w >= x$2.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (x$2[w] = (((dig + 48) >>> 0) << 24) >>> 24);
        w = (w + 1) >> 0;
        n = (((((n * 10) >>> 0) + c$1) >>> 0) - 48) >>> 0;
        r = (r + 1) >> 0;
      }
      while (true) {
        if (!(n > 0)) {
          break;
        }
        dig$1 = ((y$4 = k), y$4 < 32 ? n >>> y$4 : 0) >>> 0;
        n = (n & mask) >>> 0;
        if (w < 800) {
          (x$3 = a.d),
            w < 0 || w >= x$3.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (x$3[w] = (((dig$1 + 48) >>> 0) << 24) >>> 24);
          w = (w + 1) >> 0;
        } else if (dig$1 > 0) {
          a.trunc = true;
        }
        n = (n * 10) >>> 0;
      }
      a.nd = w;
      trim(a);
    };
    prefixIsLessThan = function (b, s) {
      var b, i, s;
      i = 0;
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        if (i >= b.$length) {
          return true;
        }
        if (
          !(
            (i < 0 || i >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + i]) === s.charCodeAt(i)
          )
        ) {
          return (
            (i < 0 || i >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + i]) < s.charCodeAt(i)
          );
        }
        i = (i + 1) >> 0;
      }
      return false;
    };
    leftShift = function (a, k) {
      var _q,
        _q$1,
        a,
        delta,
        k,
        n,
        quo,
        quo$1,
        r,
        rem,
        rem$1,
        w,
        x,
        x$1,
        x$2,
        y;
      delta = (
        k < 0 || k >= leftcheats.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : leftcheats.$array[leftcheats.$offset + k]
      ).delta;
      if (
        prefixIsLessThan(
          $subslice(new sliceType$6(a.d), 0, a.nd),
          (k < 0 || k >= leftcheats.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : leftcheats.$array[leftcheats.$offset + k]
          ).cutoff
        )
      ) {
        delta = (delta - 1) >> 0;
      }
      r = a.nd;
      w = (a.nd + delta) >> 0;
      n = 0;
      r = (r - 1) >> 0;
      while (true) {
        if (!(r >= 0)) {
          break;
        }
        n =
          (n +
            (((y = k),
            y < 32
              ? (((((x = a.d),
                r < 0 || r >= x.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x[r]) >>>
                  0) -
                  48) >>>
                  0) <<
                y
              : 0) >>>
              0)) >>>
          0;
        quo =
          ((_q = n / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >>> 0
            : $throwRuntimeError("integer divide by zero"));
        rem = (n - ((10 * quo) >>> 0)) >>> 0;
        w = (w - 1) >> 0;
        if (w < 800) {
          (x$1 = a.d),
            w < 0 || w >= x$1.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (x$1[w] = (((rem + 48) >>> 0) << 24) >>> 24);
        } else if (!(rem === 0)) {
          a.trunc = true;
        }
        n = quo;
        r = (r - 1) >> 0;
      }
      while (true) {
        if (!(n > 0)) {
          break;
        }
        quo$1 =
          ((_q$1 = n / 10),
          _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
            ? _q$1 >>> 0
            : $throwRuntimeError("integer divide by zero"));
        rem$1 = (n - ((10 * quo$1) >>> 0)) >>> 0;
        w = (w - 1) >> 0;
        if (w < 800) {
          (x$2 = a.d),
            w < 0 || w >= x$2.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (x$2[w] = (((rem$1 + 48) >>> 0) << 24) >>> 24);
        } else if (!(rem$1 === 0)) {
          a.trunc = true;
        }
        n = quo$1;
      }
      a.nd = (a.nd + delta) >> 0;
      if (a.nd >= 800) {
        a.nd = 800;
      }
      a.dp = (a.dp + delta) >> 0;
      trim(a);
    };
    decimal.ptr.prototype.Shift = function (k) {
      var a, k;
      a = this;
      if (a.nd === 0) {
      } else if (k > 0) {
        while (true) {
          if (!(k > 28)) {
            break;
          }
          leftShift(a, 28);
          k = (k - 28) >> 0;
        }
        leftShift(a, k >>> 0);
      } else if (k < 0) {
        while (true) {
          if (!(k < -28)) {
            break;
          }
          rightShift(a, 28);
          k = (k + 28) >> 0;
        }
        rightShift(a, -k >>> 0);
      }
    };
    decimal.prototype.Shift = function (k) {
      return this.$val.Shift(k);
    };
    shouldRoundUp = function (a, nd) {
      var _r, a, nd, x, x$1, x$2, x$3;
      if (nd < 0 || nd >= a.nd) {
        return false;
      }
      if (
        ((x = a.d),
        nd < 0 || nd >= x.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x[nd]) === 53 &&
        (nd + 1) >> 0 === a.nd
      ) {
        if (a.trunc) {
          return true;
        }
        return (
          nd > 0 &&
          !(
            ((_r =
              (((((x$1 = a.d),
              (x$2 = (nd - 1) >> 0),
              x$2 < 0 || x$2 >= x$1.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1[x$2]) -
                48) <<
                24) >>>
                24) %
              2),
            _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0
          )
        );
      }
      return (
        ((x$3 = a.d),
        nd < 0 || nd >= x$3.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$3[nd]) >= 53
      );
    };
    decimal.ptr.prototype.Round = function (nd) {
      var a, nd;
      a = this;
      if (nd < 0 || nd >= a.nd) {
        return;
      }
      if (shouldRoundUp(a, nd)) {
        a.RoundUp(nd);
      } else {
        a.RoundDown(nd);
      }
    };
    decimal.prototype.Round = function (nd) {
      return this.$val.Round(nd);
    };
    decimal.ptr.prototype.RoundDown = function (nd) {
      var a, nd;
      a = this;
      if (nd < 0 || nd >= a.nd) {
        return;
      }
      a.nd = nd;
      trim(a);
    };
    decimal.prototype.RoundDown = function (nd) {
      return this.$val.RoundDown(nd);
    };
    decimal.ptr.prototype.RoundUp = function (nd) {
      var a, c, i, nd, x, x$1, x$2;
      a = this;
      if (nd < 0 || nd >= a.nd) {
        return;
      }
      i = (nd - 1) >> 0;
      while (true) {
        if (!(i >= 0)) {
          break;
        }
        c =
          ((x = a.d),
          i < 0 || i >= x.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x[i]);
        if (c < 57) {
          (x$2 = a.d),
            i < 0 || i >= x$2.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (x$2[i] =
                  ((((x$1 = a.d),
                  i < 0 || i >= x$1.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : x$1[i]) +
                    1) <<
                    24) >>>
                  24);
          a.nd = (i + 1) >> 0;
          return;
        }
        i = (i - 1) >> 0;
      }
      a.d[0] = 49;
      a.nd = 1;
      a.dp = (a.dp + 1) >> 0;
    };
    decimal.prototype.RoundUp = function (nd) {
      return this.$val.RoundUp(nd);
    };
    decimal.ptr.prototype.RoundedInteger = function () {
      var a, i, n, x, x$1, x$2, x$3;
      a = this;
      if (a.dp > 20) {
        return new $Uint64(4294967295, 4294967295);
      }
      i = 0;
      n = new $Uint64(0, 0);
      i = 0;
      while (true) {
        if (!(i < a.dp && i < a.nd)) {
          break;
        }
        n =
          ((x = $mul64(n, new $Uint64(0, 10))),
          (x$1 = new $Uint64(
            0,
            ((((x$2 = a.d),
            i < 0 || i >= x$2.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$2[i]) -
              48) <<
              24) >>>
              24
          )),
          new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));
        i = (i + 1) >> 0;
      }
      while (true) {
        if (!(i < a.dp)) {
          break;
        }
        n = $mul64(n, new $Uint64(0, 10));
        i = (i + 1) >> 0;
      }
      if (shouldRoundUp(a, a.dp)) {
        n =
          ((x$3 = new $Uint64(0, 1)),
          new $Uint64(n.$high + x$3.$high, n.$low + x$3.$low));
      }
      return n;
    };
    decimal.prototype.RoundedInteger = function () {
      return this.$val.RoundedInteger();
    };
    index = function (s, c) {
      var c, s;
      return bytealg.IndexByteString(s, c);
    };
    lower = function (c) {
      var c;
      return (c | 32) >>> 0;
    };
    NumError.ptr.prototype.Error = function () {
      var { $24r, _r, e, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _r = e.Err.Error();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r =
              "strconv." +
              e.Func +
              ": " +
              "parsing " +
              Quote(e.Num) +
              ": " +
              _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: NumError.ptr.prototype.Error,
        $c: true,
        $r,
        $24r,
        _r,
        e,
        $s,
      };
      return $f;
    };
    NumError.prototype.Error = function () {
      return this.$val.Error();
    };
    NumError.ptr.prototype.Unwrap = function () {
      var e;
      e = this;
      return e.Err;
    };
    NumError.prototype.Unwrap = function () {
      return this.$val.Unwrap();
    };
    syntaxError = function (fn, str) {
      var fn, str;
      return new NumError.ptr(fn, str, $pkg.ErrSyntax);
    };
    rangeError = function (fn, str) {
      var fn, str;
      return new NumError.ptr(fn, str, $pkg.ErrRange);
    };
    baseError = function (fn, str, base) {
      var base, fn, str;
      return new NumError.ptr(
        fn,
        str,
        errors.New("invalid base " + Itoa(base))
      );
    };
    bitSizeError = function (fn, str, bitSize) {
      var bitSize, fn, str;
      return new NumError.ptr(
        fn,
        str,
        errors.New("invalid bit size " + Itoa(bitSize))
      );
    };
    ParseUint = function (s, base, bitSize) {
      var _1,
        _i,
        _ref,
        base,
        base0,
        bitSize,
        c,
        cutoff,
        d,
        maxVal,
        n,
        n1,
        s,
        s0,
        underscores,
        x,
        x$1,
        x$2;
      if (s === "") {
        return [new $Uint64(0, 0), syntaxError("ParseUint", s)];
      }
      base0 = base === 0;
      s0 = s;
      if (2 <= base && base <= 36) {
      } else if (base === 0) {
        base = 10;
        if (s.charCodeAt(0) === 48) {
          if (s.length >= 3 && lower(s.charCodeAt(1)) === 98) {
            base = 2;
            s = $substring(s, 2);
          } else if (s.length >= 3 && lower(s.charCodeAt(1)) === 111) {
            base = 8;
            s = $substring(s, 2);
          } else if (s.length >= 3 && lower(s.charCodeAt(1)) === 120) {
            base = 16;
            s = $substring(s, 2);
          } else {
            base = 8;
            s = $substring(s, 1);
          }
        }
      } else {
        return [new $Uint64(0, 0), baseError("ParseUint", s0, base)];
      }
      if (bitSize === 0) {
        bitSize = 32;
      } else if (bitSize < 0 || bitSize > 64) {
        return [new $Uint64(0, 0), bitSizeError("ParseUint", s0, bitSize)];
      }
      cutoff = new $Uint64(0, 0);
      _1 = base;
      if (_1 === 10) {
        cutoff = new $Uint64(429496729, 2576980378);
      } else if (_1 === 16) {
        cutoff = new $Uint64(268435456, 0);
      } else {
        cutoff =
          ((x = $div64(
            new $Uint64(4294967295, 4294967295),
            new $Uint64(0, base),
            false
          )),
          new $Uint64(x.$high + 0, x.$low + 1));
      }
      maxVal =
        ((x$1 = $shiftLeft64(new $Uint64(0, 1), bitSize >>> 0)),
        new $Uint64(x$1.$high - 0, x$1.$low - 1));
      underscores = false;
      n = new $Uint64(0, 0);
      _ref = new sliceType$6($stringToBytes(s));
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        c =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        d = 0;
        if (c === 95 && base0) {
          underscores = true;
          _i++;
          continue;
        } else if (48 <= c && c <= 57) {
          d = ((c - 48) << 24) >>> 24;
        } else if (97 <= lower(c) && lower(c) <= 122) {
          d = (((((lower(c) - 97) << 24) >>> 24) + 10) << 24) >>> 24;
        } else {
          return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
        }
        if (d >= (base << 24) >>> 24) {
          return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
        }
        if (
          n.$high > cutoff.$high ||
          (n.$high === cutoff.$high && n.$low >= cutoff.$low)
        ) {
          return [maxVal, rangeError("ParseUint", s0)];
        }
        n = $mul64(n, new $Uint64(0, base));
        n1 =
          ((x$2 = new $Uint64(0, d)),
          new $Uint64(n.$high + x$2.$high, n.$low + x$2.$low));
        if (
          n1.$high < n.$high ||
          (n1.$high === n.$high && n1.$low < n.$low) ||
          n1.$high > maxVal.$high ||
          (n1.$high === maxVal.$high && n1.$low > maxVal.$low)
        ) {
          return [maxVal, rangeError("ParseUint", s0)];
        }
        n = n1;
        _i++;
      }
      if (underscores && !underscoreOK(s0)) {
        return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
      }
      return [n, $ifaceNil];
    };
    $pkg.ParseUint = ParseUint;
    underscoreOK = function (s) {
      var hex, i, s, saw;
      saw = 94;
      i = 0;
      if (s.length >= 1 && (s.charCodeAt(0) === 45 || s.charCodeAt(0) === 43)) {
        s = $substring(s, 1);
      }
      hex = false;
      if (
        s.length >= 2 &&
        s.charCodeAt(0) === 48 &&
        (lower(s.charCodeAt(1)) === 98 ||
          lower(s.charCodeAt(1)) === 111 ||
          lower(s.charCodeAt(1)) === 120)
      ) {
        i = 2;
        saw = 48;
        hex = lower(s.charCodeAt(1)) === 120;
      }
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        if (
          (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) ||
          (hex && 97 <= lower(s.charCodeAt(i)) && lower(s.charCodeAt(i)) <= 102)
        ) {
          saw = 48;
          i = (i + 1) >> 0;
          continue;
        }
        if (s.charCodeAt(i) === 95) {
          if (!(saw === 48)) {
            return false;
          }
          saw = 95;
          i = (i + 1) >> 0;
          continue;
        }
        if (saw === 95) {
          return false;
        }
        saw = 33;
        i = (i + 1) >> 0;
      }
      return !(saw === 95);
    };
    commonPrefixLenIgnoreCase = function (s, prefix) {
      var c, i, n, prefix, s;
      n = prefix.length;
      if (n > s.length) {
        n = s.length;
      }
      i = 0;
      while (true) {
        if (!(i < n)) {
          break;
        }
        c = s.charCodeAt(i);
        if (65 <= c && c <= 90) {
          c = ((c + 32) << 24) >>> 24;
        }
        if (!(c === prefix.charCodeAt(i))) {
          return i;
        }
        i = (i + 1) >> 0;
      }
      return n;
    };
    special = function (s) {
      var _1,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        f,
        n,
        n$1,
        nsign,
        ok,
        s,
        sign;
      f = 0;
      n = 0;
      ok = false;
      if (s.length === 0) {
        _tmp = 0;
        _tmp$1 = 0;
        _tmp$2 = false;
        f = _tmp;
        n = _tmp$1;
        ok = _tmp$2;
        return [f, n, ok];
      }
      sign = 1;
      nsign = 0;
      _1 = s.charCodeAt(0);
      if (_1 === 43 || _1 === 45) {
        if (s.charCodeAt(0) === 45) {
          sign = -1;
        }
        nsign = 1;
        s = $substring(s, 1);
        n$1 = commonPrefixLenIgnoreCase(s, "infinity");
        if (3 < n$1 && n$1 < 8) {
          n$1 = 3;
        }
        if (n$1 === 3 || n$1 === 8) {
          _tmp$3 = math.Inf(sign);
          _tmp$4 = (nsign + n$1) >> 0;
          _tmp$5 = true;
          f = _tmp$3;
          n = _tmp$4;
          ok = _tmp$5;
          return [f, n, ok];
        }
      } else if (_1 === 105 || _1 === 73) {
        n$1 = commonPrefixLenIgnoreCase(s, "infinity");
        if (3 < n$1 && n$1 < 8) {
          n$1 = 3;
        }
        if (n$1 === 3 || n$1 === 8) {
          _tmp$6 = math.Inf(sign);
          _tmp$7 = (nsign + n$1) >> 0;
          _tmp$8 = true;
          f = _tmp$6;
          n = _tmp$7;
          ok = _tmp$8;
          return [f, n, ok];
        }
      } else if (_1 === 110 || _1 === 78) {
        if (commonPrefixLenIgnoreCase(s, "nan") === 3) {
          _tmp$9 = math.NaN();
          _tmp$10 = 3;
          _tmp$11 = true;
          f = _tmp$9;
          n = _tmp$10;
          ok = _tmp$11;
          return [f, n, ok];
        }
      }
      _tmp$12 = 0;
      _tmp$13 = 0;
      _tmp$14 = false;
      f = _tmp$12;
      n = _tmp$13;
      ok = _tmp$14;
      return [f, n, ok];
    };
    decimal.ptr.prototype.set = function (s) {
      var b, e, esign, i, ok, s, sawdigits, sawdot, x, x$1;
      ok = false;
      b = this;
      i = 0;
      b.neg = false;
      b.trunc = false;
      if (i >= s.length) {
        return ok;
      }
      if (s.charCodeAt(i) === 43) {
        i = (i + 1) >> 0;
      } else if (s.charCodeAt(i) === 45) {
        b.neg = true;
        i = (i + 1) >> 0;
      }
      sawdot = false;
      sawdigits = false;
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        if (s.charCodeAt(i) === 95) {
          i = (i + 1) >> 0;
          continue;
        } else if (s.charCodeAt(i) === 46) {
          if (sawdot) {
            return ok;
          }
          sawdot = true;
          b.dp = b.nd;
          i = (i + 1) >> 0;
          continue;
        } else if (48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) {
          sawdigits = true;
          if (s.charCodeAt(i) === 48 && b.nd === 0) {
            b.dp = (b.dp - 1) >> 0;
            i = (i + 1) >> 0;
            continue;
          }
          if (b.nd < 800) {
            (x = b.d),
              (x$1 = b.nd),
              x$1 < 0 || x$1 >= x.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (x[x$1] = s.charCodeAt(i));
            b.nd = (b.nd + 1) >> 0;
          } else if (!(s.charCodeAt(i) === 48)) {
            b.trunc = true;
          }
          i = (i + 1) >> 0;
          continue;
        }
        break;
      }
      if (!sawdigits) {
        return ok;
      }
      if (!sawdot) {
        b.dp = b.nd;
      }
      if (i < s.length && lower(s.charCodeAt(i)) === 101) {
        i = (i + 1) >> 0;
        if (i >= s.length) {
          return ok;
        }
        esign = 1;
        if (s.charCodeAt(i) === 43) {
          i = (i + 1) >> 0;
        } else if (s.charCodeAt(i) === 45) {
          i = (i + 1) >> 0;
          esign = -1;
        }
        if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
          return ok;
        }
        e = 0;
        while (true) {
          if (
            !(
              i < s.length &&
              ((48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) ||
                s.charCodeAt(i) === 95)
            )
          ) {
            break;
          }
          if (s.charCodeAt(i) === 95) {
            i = (i + 1) >> 0;
            continue;
          }
          if (e < 10000) {
            e = ((($imul(e, 10) + (s.charCodeAt(i) >> 0)) >> 0) - 48) >> 0;
          }
          i = (i + 1) >> 0;
        }
        b.dp = (b.dp + $imul(e, esign)) >> 0;
      }
      if (!(i === s.length)) {
        return ok;
      }
      ok = true;
      return ok;
    };
    decimal.prototype.set = function (s) {
      return this.$val.set(s);
    };
    readFloat = function (s) {
      var _1,
        base,
        c,
        dp,
        e,
        esign,
        exp,
        expChar,
        hex,
        i,
        mantissa,
        maxMantDigits,
        nd,
        ndMant,
        neg,
        ok,
        s,
        sawdigits,
        sawdot,
        trunc,
        underscores,
        x,
        x$1;
      mantissa = new $Uint64(0, 0);
      exp = 0;
      neg = false;
      trunc = false;
      hex = false;
      i = 0;
      ok = false;
      underscores = false;
      if (i >= s.length) {
        return [mantissa, exp, neg, trunc, hex, i, ok];
      }
      if (s.charCodeAt(i) === 43) {
        i = (i + 1) >> 0;
      } else if (s.charCodeAt(i) === 45) {
        neg = true;
        i = (i + 1) >> 0;
      }
      base = new $Uint64(0, 10);
      maxMantDigits = 19;
      expChar = 101;
      if (
        (i + 2) >> 0 < s.length &&
        s.charCodeAt(i) === 48 &&
        lower(s.charCodeAt((i + 1) >> 0)) === 120
      ) {
        base = new $Uint64(0, 16);
        maxMantDigits = 16;
        i = (i + 2) >> 0;
        expChar = 112;
        hex = true;
      }
      sawdot = false;
      sawdigits = false;
      nd = 0;
      ndMant = 0;
      dp = 0;
      loop: while (true) {
        if (!(i < s.length)) {
          break;
        }
        c = s.charCodeAt(i);
        _1 = true;
        if (_1 === (c === 95)) {
          underscores = true;
          i = (i + 1) >> 0;
          continue;
        } else if (_1 === (c === 46)) {
          if (sawdot) {
            break loop;
          }
          sawdot = true;
          dp = nd;
          i = (i + 1) >> 0;
          continue;
        } else if (_1 === (48 <= c && c <= 57)) {
          sawdigits = true;
          if (c === 48 && nd === 0) {
            dp = (dp - 1) >> 0;
            i = (i + 1) >> 0;
            continue;
          }
          nd = (nd + 1) >> 0;
          if (ndMant < maxMantDigits) {
            mantissa = $mul64(mantissa, base);
            mantissa =
              ((x = new $Uint64(0, ((c - 48) << 24) >>> 24)),
              new $Uint64(mantissa.$high + x.$high, mantissa.$low + x.$low));
            ndMant = (ndMant + 1) >> 0;
          } else if (!(c === 48)) {
            trunc = true;
          }
          i = (i + 1) >> 0;
          continue;
        } else if (
          _1 ===
          (base.$high === 0 &&
            base.$low === 16 &&
            97 <= lower(c) &&
            lower(c) <= 102)
        ) {
          sawdigits = true;
          nd = (nd + 1) >> 0;
          if (ndMant < maxMantDigits) {
            mantissa = $mul64(mantissa, new $Uint64(0, 16));
            mantissa =
              ((x$1 = new $Uint64(
                0,
                (((((lower(c) - 97) << 24) >>> 24) + 10) << 24) >>> 24
              )),
              new $Uint64(
                mantissa.$high + x$1.$high,
                mantissa.$low + x$1.$low
              ));
            ndMant = (ndMant + 1) >> 0;
          } else {
            trunc = true;
          }
          i = (i + 1) >> 0;
          continue;
        }
        break;
      }
      if (!sawdigits) {
        return [mantissa, exp, neg, trunc, hex, i, ok];
      }
      if (!sawdot) {
        dp = nd;
      }
      if (base.$high === 0 && base.$low === 16) {
        dp = $imul(dp, 4);
        ndMant = $imul(ndMant, 4);
      }
      if (i < s.length && lower(s.charCodeAt(i)) === expChar) {
        i = (i + 1) >> 0;
        if (i >= s.length) {
          return [mantissa, exp, neg, trunc, hex, i, ok];
        }
        esign = 1;
        if (s.charCodeAt(i) === 43) {
          i = (i + 1) >> 0;
        } else if (s.charCodeAt(i) === 45) {
          i = (i + 1) >> 0;
          esign = -1;
        }
        if (i >= s.length || s.charCodeAt(i) < 48 || s.charCodeAt(i) > 57) {
          return [mantissa, exp, neg, trunc, hex, i, ok];
        }
        e = 0;
        while (true) {
          if (
            !(
              i < s.length &&
              ((48 <= s.charCodeAt(i) && s.charCodeAt(i) <= 57) ||
                s.charCodeAt(i) === 95)
            )
          ) {
            break;
          }
          if (s.charCodeAt(i) === 95) {
            underscores = true;
            i = (i + 1) >> 0;
            continue;
          }
          if (e < 10000) {
            e = ((($imul(e, 10) + (s.charCodeAt(i) >> 0)) >> 0) - 48) >> 0;
          }
          i = (i + 1) >> 0;
        }
        dp = (dp + $imul(e, esign)) >> 0;
      } else if (base.$high === 0 && base.$low === 16) {
        return [mantissa, exp, neg, trunc, hex, i, ok];
      }
      if (!(mantissa.$high === 0 && mantissa.$low === 0)) {
        exp = (dp - ndMant) >> 0;
      }
      if (underscores && !underscoreOK($substring(s, 0, i))) {
        return [mantissa, exp, neg, trunc, hex, i, ok];
      }
      ok = true;
      return [mantissa, exp, neg, trunc, hex, i, ok];
    };
    decimal.ptr.prototype.floatBits = function (flt) {
      var _tmp,
        _tmp$1,
        b,
        bits$1,
        d,
        exp,
        flt,
        mant,
        n,
        n$1,
        n$2,
        overflow,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        y,
        y$1,
        y$2,
        y$3,
        $s;
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            b = new $Uint64(0, 0);
            overflow = false;
            d = this;
            exp = 0;
            mant = new $Uint64(0, 0);
            /* */ if (d.nd === 0) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (d.nd === 0) { */ case 1:
            mant = new $Uint64(0, 0);
            exp = flt.bias;
            /* goto out */ $s = 3;
            continue;
          /* } */ case 2:
            /* */ if (d.dp > 310) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (d.dp > 310) { */ case 4:
            /* goto overflow */ $s = 6;
            continue;
          /* } */ case 5:
            /* */ if (d.dp < -330) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (d.dp < -330) { */ case 7:
            mant = new $Uint64(0, 0);
            exp = flt.bias;
            /* goto out */ $s = 3;
            continue;
          /* } */ case 8:
            exp = 0;
            while (true) {
              if (!(d.dp > 0)) {
                break;
              }
              n = 0;
              if (d.dp >= powtab.$length) {
                n = 27;
              } else {
                n =
                  ((x = d.dp),
                  x < 0 || x >= powtab.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : powtab.$array[powtab.$offset + x]);
              }
              d.Shift(-n);
              exp = (exp + n) >> 0;
            }
            while (true) {
              if (!(d.dp < 0 || (d.dp === 0 && d.d[0] < 53))) {
                break;
              }
              n$1 = 0;
              if (-d.dp >= powtab.$length) {
                n$1 = 27;
              } else {
                n$1 =
                  ((x$1 = -d.dp),
                  x$1 < 0 || x$1 >= powtab.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : powtab.$array[powtab.$offset + x$1]);
              }
              d.Shift(n$1);
              exp = (exp - n$1) >> 0;
            }
            exp = (exp - 1) >> 0;
            if (exp < (flt.bias + 1) >> 0) {
              n$2 = (((flt.bias + 1) >> 0) - exp) >> 0;
              d.Shift(-n$2);
              exp = (exp + n$2) >> 0;
            }
            /* */ if (
              (exp - flt.bias) >> 0 >=
              ((((y = flt.expbits), y < 32 ? 1 << y : 0) >> 0) - 1) >> 0
            ) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if ((exp - flt.bias >> 0) >= (((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0)) { */ case 9:
            /* goto overflow */ $s = 6;
            continue;
          /* } */ case 10:
            d.Shift(((1 + flt.mantbits) >>> 0) >> 0);
            mant = d.RoundedInteger();
            /* */ if (
              ((x$2 = $shiftLeft64(new $Uint64(0, 2), flt.mantbits)),
              mant.$high === x$2.$high && mant.$low === x$2.$low)
            ) {
              $s = 11;
              continue;
            }
            /* */ $s = 12;
            continue;
          /* if ((x$2 = $shiftLeft64(new $Uint64(0, 2), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) { */ case 11:
            mant = $shiftRightUint64(mant, 1);
            exp = (exp + 1) >> 0;
            /* */ if (
              (exp - flt.bias) >> 0 >=
              ((((y$1 = flt.expbits), y$1 < 32 ? 1 << y$1 : 0) >> 0) - 1) >> 0
            ) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if ((exp - flt.bias >> 0) >= (((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0)) { */ case 13:
            /* goto overflow */ $s = 6;
            continue;
          /* } */ case 14:
          /* } */ case 12:
            if (
              ((x$3 =
                ((x$4 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
                new $Uint64(
                  mant.$high & x$4.$high,
                  (mant.$low & x$4.$low) >>> 0
                ))),
              x$3.$high === 0 && x$3.$low === 0)
            ) {
              exp = flt.bias;
            }
            /* goto out */ $s = 3;
            continue;
          /* overflow: */ case 6:
            mant = new $Uint64(0, 0);
            exp =
              ((((((y$2 = flt.expbits), y$2 < 32 ? 1 << y$2 : 0) >> 0) - 1) >>
                0) +
                flt.bias) >>
              0;
            overflow = true;
          /* out: */ case 3:
            bits$1 =
              ((x$5 =
                ((x$6 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
                new $Uint64(x$6.$high - 0, x$6.$low - 1))),
              new $Uint64(
                mant.$high & x$5.$high,
                (mant.$low & x$5.$low) >>> 0
              ));
            bits$1 =
              ((x$7 = $shiftLeft64(
                new $Uint64(
                  0,
                  ((exp - flt.bias) >> 0) &
                    (((((y$3 = flt.expbits), y$3 < 32 ? 1 << y$3 : 0) >> 0) -
                      1) >>
                      0)
                ),
                flt.mantbits
              )),
              new $Uint64(
                bits$1.$high | x$7.$high,
                (bits$1.$low | x$7.$low) >>> 0
              ));
            if (d.neg) {
              bits$1 =
                ((x$8 = $shiftLeft64(
                  $shiftLeft64(new $Uint64(0, 1), flt.mantbits),
                  flt.expbits
                )),
                new $Uint64(
                  bits$1.$high | x$8.$high,
                  (bits$1.$low | x$8.$low) >>> 0
                ));
            }
            _tmp = bits$1;
            _tmp$1 = overflow;
            b = _tmp;
            overflow = _tmp$1;
            $s = -1;
            return [b, overflow];
          /* */
        }
        return;
      }
    };
    decimal.prototype.floatBits = function (flt) {
      return this.$val.floatBits(flt);
    };
    atof64exact = function (mantissa, exp, neg) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        exp,
        f,
        mantissa,
        neg,
        ok,
        x,
        x$1,
        x$2;
      f = 0;
      ok = false;
      if (
        !((x = $shiftRightUint64(mantissa, float64info.mantbits)),
        x.$high === 0 && x.$low === 0)
      ) {
        return [f, ok];
      }
      f = $flatten64(mantissa);
      if (neg) {
        f = -f;
      }
      if (exp === 0) {
        _tmp = f;
        _tmp$1 = true;
        f = _tmp;
        ok = _tmp$1;
        return [f, ok];
      } else if (exp > 0 && exp <= 37) {
        if (exp > 22) {
          f =
            f *
            ((x$1 = (exp - 22) >> 0),
            x$1 < 0 || x$1 >= float64pow10.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : float64pow10.$array[float64pow10.$offset + x$1]);
          exp = 22;
        }
        if (f > 1e15 || f < -1e15) {
          return [f, ok];
        }
        _tmp$2 =
          f *
          (exp < 0 || exp >= float64pow10.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : float64pow10.$array[float64pow10.$offset + exp]);
        _tmp$3 = true;
        f = _tmp$2;
        ok = _tmp$3;
        return [f, ok];
      } else if (exp < 0 && exp >= -22) {
        _tmp$4 =
          f /
          ((x$2 = -exp),
          x$2 < 0 || x$2 >= float64pow10.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : float64pow10.$array[float64pow10.$offset + x$2]);
        _tmp$5 = true;
        f = _tmp$4;
        ok = _tmp$5;
        return [f, ok];
      }
      return [f, ok];
    };
    atof32exact = function (mantissa, exp, neg) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        exp,
        f,
        mantissa,
        neg,
        ok,
        x,
        x$1,
        x$2;
      f = 0;
      ok = false;
      if (
        !((x = $shiftRightUint64(mantissa, float32info.mantbits)),
        x.$high === 0 && x.$low === 0)
      ) {
        return [f, ok];
      }
      f = $flatten64(mantissa);
      if (neg) {
        f = -f;
      }
      if (exp === 0) {
        _tmp = f;
        _tmp$1 = true;
        f = _tmp;
        ok = _tmp$1;
        return [f, ok];
      } else if (exp > 0 && exp <= 17) {
        if (exp > 10) {
          f = $fround(
            f *
              ((x$1 = (exp - 10) >> 0),
              x$1 < 0 || x$1 >= float32pow10.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : float32pow10.$array[float32pow10.$offset + x$1])
          );
          exp = 10;
        }
        if (f > 1e7 || f < -1e7) {
          return [f, ok];
        }
        _tmp$2 = $fround(
          f *
            (exp < 0 || exp >= float32pow10.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : float32pow10.$array[float32pow10.$offset + exp])
        );
        _tmp$3 = true;
        f = _tmp$2;
        ok = _tmp$3;
        return [f, ok];
      } else if (exp < 0 && exp >= -10) {
        _tmp$4 = $fround(
          f /
            ((x$2 = -exp),
            x$2 < 0 || x$2 >= float32pow10.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : float32pow10.$array[float32pow10.$offset + x$2])
        );
        _tmp$5 = true;
        f = _tmp$4;
        ok = _tmp$5;
        return [f, ok];
      }
      return [f, ok];
    };
    atofHex = function (s, flt, mantissa, exp, neg, trunc) {
      var bits$1,
        err,
        exp,
        flt,
        mantissa,
        maxExp,
        minExp,
        neg,
        round,
        s,
        trunc,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        y,
        y$1;
      maxExp =
        ((((((y = flt.expbits), y < 32 ? 1 << y : 0) >> 0) + flt.bias) >> 0) -
          2) >>
        0;
      minExp = (flt.bias + 1) >> 0;
      exp = (exp + (flt.mantbits >> 0)) >> 0;
      while (true) {
        if (
          !(
            !(mantissa.$high === 0 && mantissa.$low === 0) &&
            ((x = $shiftRightUint64(mantissa, (flt.mantbits + 2) >>> 0)),
            x.$high === 0 && x.$low === 0)
          )
        ) {
          break;
        }
        mantissa = $shiftLeft64(mantissa, 1);
        exp = (exp - 1) >> 0;
      }
      if (trunc) {
        mantissa =
          ((x$1 = new $Uint64(0, 1)),
          new $Uint64(
            mantissa.$high | x$1.$high,
            (mantissa.$low | x$1.$low) >>> 0
          ));
      }
      while (true) {
        if (
          !!((x$2 = $shiftRightUint64(
            mantissa,
            (((1 + flt.mantbits) >>> 0) + 2) >>> 0
          )),
          x$2.$high === 0 && x$2.$low === 0)
        ) {
          break;
        }
        mantissa =
          ((x$3 = $shiftRightUint64(mantissa, 1)),
          (x$4 = new $Uint64(mantissa.$high & 0, (mantissa.$low & 1) >>> 0)),
          new $Uint64(x$3.$high | x$4.$high, (x$3.$low | x$4.$low) >>> 0));
        exp = (exp + 1) >> 0;
      }
      while (true) {
        if (
          !(
            (mantissa.$high > 0 ||
              (mantissa.$high === 0 && mantissa.$low > 1)) &&
            exp < (minExp - 2) >> 0
          )
        ) {
          break;
        }
        mantissa =
          ((x$5 = $shiftRightUint64(mantissa, 1)),
          (x$6 = new $Uint64(mantissa.$high & 0, (mantissa.$low & 1) >>> 0)),
          new $Uint64(x$5.$high | x$6.$high, (x$5.$low | x$6.$low) >>> 0));
        exp = (exp + 1) >> 0;
      }
      round = new $Uint64(mantissa.$high & 0, (mantissa.$low & 3) >>> 0);
      mantissa = $shiftRightUint64(mantissa, 2);
      round =
        ((x$7 = new $Uint64(mantissa.$high & 0, (mantissa.$low & 1) >>> 0)),
        new $Uint64(round.$high | x$7.$high, (round.$low | x$7.$low) >>> 0));
      exp = (exp + 2) >> 0;
      if (round.$high === 0 && round.$low === 3) {
        mantissa =
          ((x$8 = new $Uint64(0, 1)),
          new $Uint64(mantissa.$high + x$8.$high, mantissa.$low + x$8.$low));
        if (
          ((x$9 = $shiftLeft64(new $Uint64(0, 1), (1 + flt.mantbits) >>> 0)),
          mantissa.$high === x$9.$high && mantissa.$low === x$9.$low)
        ) {
          mantissa = $shiftRightUint64(mantissa, 1);
          exp = (exp + 1) >> 0;
        }
      }
      if (
        ((x$10 = $shiftRightUint64(mantissa, flt.mantbits)),
        x$10.$high === 0 && x$10.$low === 0)
      ) {
        exp = flt.bias;
      }
      err = $ifaceNil;
      if (exp > maxExp) {
        mantissa = $shiftLeft64(new $Uint64(0, 1), flt.mantbits);
        exp = (maxExp + 1) >> 0;
        err = rangeError("ParseFloat", s);
      }
      bits$1 =
        ((x$11 =
          ((x$12 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits)),
          new $Uint64(x$12.$high - 0, x$12.$low - 1))),
        new $Uint64(
          mantissa.$high & x$11.$high,
          (mantissa.$low & x$11.$low) >>> 0
        ));
      bits$1 =
        ((x$13 = $shiftLeft64(
          new $Uint64(
            0,
            ((exp - flt.bias) >> 0) &
              (((((y$1 = flt.expbits), y$1 < 32 ? 1 << y$1 : 0) >> 0) - 1) >> 0)
          ),
          flt.mantbits
        )),
        new $Uint64(
          bits$1.$high | x$13.$high,
          (bits$1.$low | x$13.$low) >>> 0
        ));
      if (neg) {
        bits$1 =
          ((x$14 = $shiftLeft64(
            $shiftLeft64(new $Uint64(0, 1), flt.mantbits),
            flt.expbits
          )),
          new $Uint64(
            bits$1.$high | x$14.$high,
            (bits$1.$low | x$14.$low) >>> 0
          ));
      }
      if (flt === float32info) {
        return [math.Float32frombits(bits$1.$low >>> 0), err];
      }
      return [math.Float64frombits(bits$1), err];
    };
    atof32 = function (s) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        b,
        d,
        err,
        err$1,
        exp,
        f,
        f$1,
        f$2,
        f$3,
        fUp,
        hex,
        mantissa,
        n,
        n$1,
        neg,
        ok,
        ok$1,
        ok$2,
        ok$3,
        ok$4,
        ovf,
        s,
        trunc,
        val;
      f = 0;
      n = 0;
      err = $ifaceNil;
      _tuple = special(s);
      val = _tuple[0];
      n$1 = _tuple[1];
      ok = _tuple[2];
      if (ok) {
        _tmp = $fround(val);
        _tmp$1 = n$1;
        _tmp$2 = $ifaceNil;
        f = _tmp;
        n = _tmp$1;
        err = _tmp$2;
        return [f, n, err];
      }
      _tuple$1 = readFloat(s);
      mantissa = _tuple$1[0];
      exp = _tuple$1[1];
      neg = _tuple$1[2];
      trunc = _tuple$1[3];
      hex = _tuple$1[4];
      n = _tuple$1[5];
      ok$1 = _tuple$1[6];
      if (!ok$1) {
        _tmp$3 = 0;
        _tmp$4 = n;
        _tmp$5 = syntaxError("ParseFloat", s);
        f = _tmp$3;
        n = _tmp$4;
        err = _tmp$5;
        return [f, n, err];
      }
      if (hex) {
        _tuple$2 = atofHex(
          $substring(s, 0, n),
          float32info,
          mantissa,
          exp,
          neg,
          trunc
        );
        f$1 = _tuple$2[0];
        err$1 = _tuple$2[1];
        _tmp$6 = $fround(f$1);
        _tmp$7 = n;
        _tmp$8 = err$1;
        f = _tmp$6;
        n = _tmp$7;
        err = _tmp$8;
        return [f, n, err];
      }
      if (optimize) {
        if (!trunc) {
          _tuple$3 = atof32exact(mantissa, exp, neg);
          f$2 = _tuple$3[0];
          ok$2 = _tuple$3[1];
          if (ok$2) {
            _tmp$9 = f$2;
            _tmp$10 = n;
            _tmp$11 = $ifaceNil;
            f = _tmp$9;
            n = _tmp$10;
            err = _tmp$11;
            return [f, n, err];
          }
        }
        _tuple$4 = eiselLemire32(mantissa, exp, neg);
        f$3 = _tuple$4[0];
        ok$3 = _tuple$4[1];
        if (ok$3) {
          if (!trunc) {
            _tmp$12 = f$3;
            _tmp$13 = n;
            _tmp$14 = $ifaceNil;
            f = _tmp$12;
            n = _tmp$13;
            err = _tmp$14;
            return [f, n, err];
          }
          _tuple$5 = eiselLemire32(
            new $Uint64(mantissa.$high + 0, mantissa.$low + 1),
            exp,
            neg
          );
          fUp = _tuple$5[0];
          ok$4 = _tuple$5[1];
          if (ok$4 && f$3 === fUp) {
            _tmp$15 = f$3;
            _tmp$16 = n;
            _tmp$17 = $ifaceNil;
            f = _tmp$15;
            n = _tmp$16;
            err = _tmp$17;
            return [f, n, err];
          }
        }
      }
      d = new decimal.ptr(arrayType$5.zero(), 0, 0, false, false);
      if (!d.set($substring(s, 0, n))) {
        _tmp$18 = 0;
        _tmp$19 = n;
        _tmp$20 = syntaxError("ParseFloat", s);
        f = _tmp$18;
        n = _tmp$19;
        err = _tmp$20;
        return [f, n, err];
      }
      _tuple$6 = d.floatBits(float32info);
      b = _tuple$6[0];
      ovf = _tuple$6[1];
      f = math.Float32frombits(b.$low >>> 0);
      if (ovf) {
        err = rangeError("ParseFloat", s);
      }
      _tmp$21 = f;
      _tmp$22 = n;
      _tmp$23 = err;
      f = _tmp$21;
      n = _tmp$22;
      err = _tmp$23;
      return [f, n, err];
    };
    atof64 = function (s) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        b,
        d,
        err,
        err$1,
        exp,
        f,
        f$1,
        f$2,
        f$3,
        fUp,
        hex,
        mantissa,
        n,
        n$1,
        neg,
        ok,
        ok$1,
        ok$2,
        ok$3,
        ok$4,
        ovf,
        s,
        trunc,
        val;
      f = 0;
      n = 0;
      err = $ifaceNil;
      _tuple = special(s);
      val = _tuple[0];
      n$1 = _tuple[1];
      ok = _tuple[2];
      if (ok) {
        _tmp = val;
        _tmp$1 = n$1;
        _tmp$2 = $ifaceNil;
        f = _tmp;
        n = _tmp$1;
        err = _tmp$2;
        return [f, n, err];
      }
      _tuple$1 = readFloat(s);
      mantissa = _tuple$1[0];
      exp = _tuple$1[1];
      neg = _tuple$1[2];
      trunc = _tuple$1[3];
      hex = _tuple$1[4];
      n = _tuple$1[5];
      ok$1 = _tuple$1[6];
      if (!ok$1) {
        _tmp$3 = 0;
        _tmp$4 = n;
        _tmp$5 = syntaxError("ParseFloat", s);
        f = _tmp$3;
        n = _tmp$4;
        err = _tmp$5;
        return [f, n, err];
      }
      if (hex) {
        _tuple$2 = atofHex(
          $substring(s, 0, n),
          float64info,
          mantissa,
          exp,
          neg,
          trunc
        );
        f$1 = _tuple$2[0];
        err$1 = _tuple$2[1];
        _tmp$6 = f$1;
        _tmp$7 = n;
        _tmp$8 = err$1;
        f = _tmp$6;
        n = _tmp$7;
        err = _tmp$8;
        return [f, n, err];
      }
      if (optimize) {
        if (!trunc) {
          _tuple$3 = atof64exact(mantissa, exp, neg);
          f$2 = _tuple$3[0];
          ok$2 = _tuple$3[1];
          if (ok$2) {
            _tmp$9 = f$2;
            _tmp$10 = n;
            _tmp$11 = $ifaceNil;
            f = _tmp$9;
            n = _tmp$10;
            err = _tmp$11;
            return [f, n, err];
          }
        }
        _tuple$4 = eiselLemire64(mantissa, exp, neg);
        f$3 = _tuple$4[0];
        ok$3 = _tuple$4[1];
        if (ok$3) {
          if (!trunc) {
            _tmp$12 = f$3;
            _tmp$13 = n;
            _tmp$14 = $ifaceNil;
            f = _tmp$12;
            n = _tmp$13;
            err = _tmp$14;
            return [f, n, err];
          }
          _tuple$5 = eiselLemire64(
            new $Uint64(mantissa.$high + 0, mantissa.$low + 1),
            exp,
            neg
          );
          fUp = _tuple$5[0];
          ok$4 = _tuple$5[1];
          if (ok$4 && f$3 === fUp) {
            _tmp$15 = f$3;
            _tmp$16 = n;
            _tmp$17 = $ifaceNil;
            f = _tmp$15;
            n = _tmp$16;
            err = _tmp$17;
            return [f, n, err];
          }
        }
      }
      d = new decimal.ptr(arrayType$5.zero(), 0, 0, false, false);
      if (!d.set($substring(s, 0, n))) {
        _tmp$18 = 0;
        _tmp$19 = n;
        _tmp$20 = syntaxError("ParseFloat", s);
        f = _tmp$18;
        n = _tmp$19;
        err = _tmp$20;
        return [f, n, err];
      }
      _tuple$6 = d.floatBits(float64info);
      b = _tuple$6[0];
      ovf = _tuple$6[1];
      f = math.Float64frombits(b);
      if (ovf) {
        err = rangeError("ParseFloat", s);
      }
      _tmp$21 = f;
      _tmp$22 = n;
      _tmp$23 = err;
      f = _tmp$21;
      n = _tmp$22;
      err = _tmp$23;
      return [f, n, err];
    };
    ParseFloat = function (s, bitSize) {
      var _tuple, bitSize, err, f, n, s;
      _tuple = parseFloatPrefix(s, bitSize);
      f = _tuple[0];
      n = _tuple[1];
      err = _tuple[2];
      if (
        !(n === s.length) &&
        ($interfaceIsEqual(err, $ifaceNil) ||
          !$interfaceIsEqual($assertType(err, ptrType$1).Err, $pkg.ErrSyntax))
      ) {
        return [0, syntaxError("ParseFloat", s)];
      }
      return [f, err];
    };
    $pkg.ParseFloat = ParseFloat;
    parseFloatPrefix = function (s, bitSize) {
      var _tuple, bitSize, err, f, n, s;
      if (bitSize === 32) {
        _tuple = atof32(s);
        f = _tuple[0];
        n = _tuple[1];
        err = _tuple[2];
        return [f, n, err];
      }
      return atof64(s);
    };
    FormatBool = function (b) {
      var b;
      if (b) {
        return "true";
      }
      return "false";
    };
    $pkg.FormatBool = FormatBool;
    ptrType$2.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Assign",
        name: "Assign",
        pkg: "",
        typ: $funcType([$Uint64], [], false),
      },
      {
        prop: "Shift",
        name: "Shift",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "Round",
        name: "Round",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "RoundDown",
        name: "RoundDown",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "RoundUp",
        name: "RoundUp",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "RoundedInteger",
        name: "RoundedInteger",
        pkg: "",
        typ: $funcType([], [$Uint64], false),
      },
      {
        prop: "set",
        name: "set",
        pkg: "strconv",
        typ: $funcType([$String], [$Bool], false),
      },
      {
        prop: "floatBits",
        name: "floatBits",
        pkg: "strconv",
        typ: $funcType([ptrType], [$Uint64, $Bool], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Unwrap",
        name: "Unwrap",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
    ];
    floatInfo.init("strconv", [
      {
        prop: "mantbits",
        name: "mantbits",
        embedded: false,
        exported: false,
        typ: $Uint,
        tag: "",
      },
      {
        prop: "expbits",
        name: "expbits",
        embedded: false,
        exported: false,
        typ: $Uint,
        tag: "",
      },
      {
        prop: "bias",
        name: "bias",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    decimalSlice.init("strconv", [
      {
        prop: "d",
        name: "d",
        embedded: false,
        exported: false,
        typ: sliceType$6,
        tag: "",
      },
      {
        prop: "nd",
        name: "nd",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "dp",
        name: "dp",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "neg",
        name: "neg",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    decimal.init("strconv", [
      {
        prop: "d",
        name: "d",
        embedded: false,
        exported: false,
        typ: arrayType$5,
        tag: "",
      },
      {
        prop: "nd",
        name: "nd",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "dp",
        name: "dp",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "neg",
        name: "neg",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "trunc",
        name: "trunc",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    leftCheat.init("strconv", [
      {
        prop: "delta",
        name: "delta",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "cutoff",
        name: "cutoff",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    NumError.init("", [
      {
        prop: "Func",
        name: "Func",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Num",
        name: "Num",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Err",
        name: "Err",
        embedded: false,
        exported: true,
        typ: $error,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bytealg.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = math.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bits.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            isPrint16 = new sliceType([
              32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479,
              1488, 1514, 1519, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869,
              1969, 1984, 2042, 2045, 2093, 2096, 2139, 2142, 2154, 2208, 2247,
              2259, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503,
              2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2558, 2561, 2570,
              2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641,
              2641, 2649, 2654, 2662, 2678, 2689, 2745, 2748, 2765, 2768, 2768,
              2784, 2787, 2790, 2801, 2809, 2828, 2831, 2832, 2835, 2873, 2876,
              2884, 2887, 2888, 2891, 2893, 2901, 2903, 2908, 2915, 2918, 2935,
              2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990,
              3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066,
              3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3191,
              3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3328, 3407,
              3412, 3427, 3430, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535,
              3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3773,
              3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096,
              4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789,
              4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024,
              5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942,
              5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144,
              6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6443,
              6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576,
              6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809,
              6816, 6829, 6832, 6848, 6912, 6987, 6992, 7036, 7040, 7155, 7164,
              7223, 7227, 7241, 7245, 7304, 7312, 7354, 7357, 7367, 7376, 7418,
              7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064,
              8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305,
              8308, 8348, 8352, 8383, 8400, 8432, 8448, 8587, 8592, 9254, 9280,
              9290, 9312, 11123, 11126, 11507, 11513, 11559, 11565, 11565,
              11568, 11623, 11631, 11632, 11647, 11670, 11680, 11858, 11904,
              12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543,
              12549, 12771, 12784, 40956, 40960, 42124, 42128, 42182, 42192,
              42539, 42560, 42743, 42752, 42943, 42946, 42954, 42997, 43052,
              43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232,
              43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597,
              43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785,
              43790, 43793, 43798, 43808, 43883, 43888, 44013, 44016, 44025,
              44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112,
              64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831,
              64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056,
              65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487,
              65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533,
            ]);
            isNotPrint16 = new sliceType([
              173, 907, 909, 930, 1328, 1424, 1757, 2111, 2143, 2229, 2274,
              2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653,
              2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2816, 2820, 2857,
              2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3085, 3089, 3113,
              3141, 3145, 3159, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312,
              3341, 3345, 3397, 3401, 3456, 3460, 3506, 3516, 3541, 3543, 3715,
              3717, 3723, 3748, 3750, 3781, 3783, 3912, 3992, 4029, 4045, 4294,
              4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901,
              5997, 6001, 6431, 6751, 7674, 8024, 8026, 8028, 8030, 8117, 8133,
              8156, 8181, 8335, 11158, 11311, 11359, 11558, 11687, 11695, 11703,
              11711, 11719, 11727, 11735, 11743, 11930, 12352, 12592, 12687,
              12831, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322,
              64325, 65107, 65127, 65141, 65511,
            ]);
            isPrint32 = new sliceType$1([
              65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799,
              65843, 65847, 65948, 65952, 65952, 66000, 66045, 66176, 66204,
              66208, 66256, 66272, 66299, 66304, 66339, 66349, 66378, 66384,
              66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729,
              66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927,
              66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589,
              67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808,
              67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023,
              68028, 68047, 68050, 68102, 68108, 68149, 68152, 68154, 68159,
              68168, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342,
              68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505,
              68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850,
              68858, 68903, 68912, 68921, 69216, 69293, 69296, 69297, 69376,
              69415, 69424, 69465, 69552, 69579, 69600, 69622, 69632, 69709,
              69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888,
              69959, 69968, 70006, 70016, 70132, 70144, 70206, 70272, 70313,
              70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419,
              70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487,
              70493, 70499, 70502, 70508, 70512, 70516, 70656, 70753, 70784,
              70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236,
              71248, 71257, 71264, 71276, 71296, 71352, 71360, 71369, 71424,
              71450, 71453, 71467, 71472, 71487, 71680, 71739, 71840, 71922,
              71935, 71942, 71945, 71945, 71948, 71992, 71995, 72006, 72016,
              72025, 72096, 72103, 72106, 72151, 72154, 72164, 72192, 72263,
              72272, 72354, 72384, 72440, 72704, 72773, 72784, 72812, 72816,
              72847, 72850, 72886, 72960, 73014, 73018, 73031, 73040, 73049,
              73056, 73112, 73120, 73129, 73440, 73464, 73648, 73648, 73664,
              73713, 73727, 74649, 74752, 74868, 74880, 75075, 77824, 78894,
              82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880,
              92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071,
              93760, 93850, 93952, 94026, 94031, 94087, 94095, 94111, 94176,
              94180, 94192, 94193, 94208, 100343, 100352, 101589, 101632,
              101640, 110592, 110878, 110928, 110930, 110948, 110951, 110960,
              111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808,
              113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081,
              119154, 119163, 119272, 119296, 119365, 119520, 119539, 119552,
              119638, 119648, 119672, 119808, 119967, 119970, 119970, 119973,
              119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488,
              120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907,
              122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214,
              123215, 123584, 123641, 123647, 123647, 124928, 125124, 125127,
              125142, 125184, 125259, 125264, 125273, 125278, 125279, 126065,
              126132, 126209, 126269, 126464, 126500, 126503, 126523, 126530,
              126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625,
              126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136,
              127150, 127153, 127221, 127232, 127405, 127462, 127490, 127504,
              127547, 127552, 127560, 127568, 127569, 127584, 127589, 127744,
              128727, 128736, 128748, 128752, 128764, 128768, 128883, 128896,
              128984, 128992, 129003, 129024, 129035, 129040, 129095, 129104,
              129113, 129120, 129159, 129168, 129197, 129200, 129201, 129280,
              129619, 129632, 129645, 129648, 129652, 129656, 129658, 129664,
              129670, 129680, 129704, 129712, 129718, 129728, 129730, 129744,
              129750, 129792, 129994, 130032, 130041, 131072, 173789, 173824,
              177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560,
              195101, 196608, 201546, 917760, 917999,
            ]);
            isNotPrint32 = new sliceType([
              12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580,
              2584, 3711, 3754, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766,
              4868, 4905, 4913, 4916, 4922, 5212, 6420, 6423, 6454, 7177, 7223,
              7336, 7431, 7434, 7483, 7486, 7526, 7529, 7567, 7570, 9327, 27231,
              27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534,
              54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378,
              57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000,
              61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024,
              61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098,
              61632, 61648, 63865, 63948, 64403,
            ]);
            isGraphic = new sliceType([
              160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,
              8201, 8202, 8239, 8287, 12288,
            ]);
            uint64pow10 = $toNativeArray($kindUint64, [
              new $Uint64(0, 1),
              new $Uint64(0, 10),
              new $Uint64(0, 100),
              new $Uint64(0, 1000),
              new $Uint64(0, 10000),
              new $Uint64(0, 100000),
              new $Uint64(0, 1000000),
              new $Uint64(0, 10000000),
              new $Uint64(0, 100000000),
              new $Uint64(0, 1000000000),
              new $Uint64(2, 1410065408),
              new $Uint64(23, 1215752192),
              new $Uint64(232, 3567587328),
              new $Uint64(2328, 1316134912),
              new $Uint64(23283, 276447232),
              new $Uint64(232830, 2764472320),
              new $Uint64(2328306, 1874919424),
              new $Uint64(23283064, 1569325056),
              new $Uint64(232830643, 2808348672),
              new $Uint64(2328306436, 2313682944),
            ]);
            float32info = new floatInfo.ptr(23, 8, -127);
            float64info = new floatInfo.ptr(52, 11, -1023);
            detailedPowersOfTen = $toNativeArray($kindArray, [
              $toNativeArray($kindUint64, [
                new $Uint64(389204073, 3445679187),
                new $Uint64(4203730336, 136053384),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(243252546, 542936756),
                new $Uint64(2627331460, 85033365),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1377807506, 2826154593),
                new $Uint64(3284164325, 106291706),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3869743031, 1385209593),
                new $Uint64(4105205406, 1206606456),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2418589394, 2476368732),
                new $Uint64(2565753378, 3975354507),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1949494919, 947977267),
                new $Uint64(3207191723, 2821709486),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(289385001, 111229759),
                new $Uint64(4008989654, 2453395034),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1254607449, 2753873159),
                new $Uint64(2505618534, 459630072),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1568259312, 221115977),
                new $Uint64(3132023167, 2722021238),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4107807788, 276394972),
                new $Uint64(3915028959, 2328784723),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2030508955, 2320230505),
                new $Uint64(2446893099, 3066103188),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2538136194, 1826546308),
                new $Uint64(3058616374, 2758887161),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4246412067, 135699237),
                new $Uint64(3823270468, 1301125303),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4264620277, 3842908407),
                new $Uint64(2389544042, 2960686962),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3183291699, 1582410037),
                new $Uint64(2986930053, 1553375055),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2905372800, 904270722),
                new $Uint64(3733662566, 3015460643),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1278987088, 565169201),
                new $Uint64(2333539104, 810921078),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3746217508, 706461501),
                new $Uint64(2916923880, 1013651347),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3609030061, 883076877),
                new $Uint64(3646154850, 1267064184),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2255643788, 1088793960),
                new $Uint64(2278846781, 1865656939),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1745812911, 1360992450),
                new $Uint64(2848558476, 3405812998),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(34782491, 627498738),
                new $Uint64(3560698095, 4257266248),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(21739056, 4150283095),
                new $Uint64(2225436309, 4271404141),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1100915645, 892886573),
                new $Uint64(2781795387, 2118029704),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1376144556, 2189850041),
                new $Uint64(3477244234, 1573795306),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1933832171, 3516139923),
                new $Uint64(2173277646, 2057363890),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(269806566, 3321433080),
                new $Uint64(2716597058, 424221215),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3558483680, 2004307702),
                new $Uint64(3395746322, 2677760166),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2300620952, 2505384628),
                new $Uint64(4244682903, 1199716560),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1437888095, 1565865392),
                new $Uint64(2652926814, 2360435586),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3944843767, 883589917),
                new $Uint64(3316158518, 803060834),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2783571061, 30745572),
                new $Uint64(4145198147, 3151309691),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1202861001, 556086894),
                new $Uint64(2590748842, 1432697645),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2577318075, 1768850442),
                new $Uint64(3238436052, 3938355704),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3221647594, 1137321229),
                new $Uint64(4048045066, 627977334),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(939787922, 1784567592),
                new $Uint64(2530028166, 1466227658),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3322218551, 83225842),
                new $Uint64(3162535207, 3980268220),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4152773188, 3325257774),
                new $Uint64(3953169009, 3901593451),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2058612330, 4225769757),
                new $Uint64(2470730631, 827883171),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1499523589, 3134728548),
                new $Uint64(3088413288, 4256079436),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1874404487, 697185213),
                new $Uint64(3860516611, 1025131999),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2782115540, 2046353494),
                new $Uint64(2412822882, 103836587),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2403902601, 2557941868),
                new $Uint64(3016028602, 2277279382),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(857394603, 4271169159),
                new $Uint64(3770035753, 699115580),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2683355275, 2132609812),
                new $Uint64(2356272345, 3121301797),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(132968622, 1592020441),
                new $Uint64(2945340432, 680401775),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3387436249, 4137509200),
                new $Uint64(3681675540, 850502218),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3190889480, 975330514),
                new $Uint64(2301047212, 2679047534),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1841128202, 1219163142),
                new $Uint64(2876309015, 3348809418),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(153926604, 3671437576),
                new $Uint64(3595386269, 3112269949),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(633075040, 147164837),
                new $Uint64(2247116418, 2482039630),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2938827448, 183956046),
                new $Uint64(2808895523, 955065889),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(452308838, 229945057),
                new $Uint64(3511119404, 120090538),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1356434847, 3364941133),
                new $Uint64(2194449627, 2222540234),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3843027207, 3132434592),
                new $Uint64(2743062034, 1704433468),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(508816713, 2841801416),
                new $Uint64(3428827542, 4278025484),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(636020892, 331026298),
                new $Uint64(4286034428, 3200048207),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2008125793, 2354375084),
                new $Uint64(2678771517, 4147513777),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3583899065, 4016710679),
                new $Uint64(3348464397, 1963166749),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1258648360, 1799662877),
                new $Uint64(4185580496, 3527700261),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1323526137, 1124789298),
                new $Uint64(2615987810, 2204812663),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(580665847, 2479728447),
                new $Uint64(3269984763, 608532181),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1799574133, 2025918735),
                new $Uint64(4087480953, 3981890698),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2198475657, 1803070121),
                new $Uint64(2554675596, 878068950),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(600610923, 3327579475),
                new $Uint64(3193344495, 1097586188),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(750763654, 3085732520),
                new $Uint64(3991680619, 298240911),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2079840020, 854841001),
                new $Uint64(2494800386, 3944496953),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3673541849, 1068551251),
                new $Uint64(3118500483, 2783137543),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3518185487, 2409430888),
                new $Uint64(3898125604, 2405180105),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(588253193, 3116507041),
                new $Uint64(2436328502, 3650721214),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2882800140, 674408330),
                new $Uint64(3045410628, 2415917869),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(382274703, 843010412),
                new $Uint64(3806763285, 3019897337),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2923276249, 2137494243),
                new $Uint64(2379227053, 2424306747),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2580353487, 3745609628),
                new $Uint64(2974033816, 4104125258),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1077958211, 3608270211),
                new $Uint64(3717542271, 835189277),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1210594794, 1718297970),
                new $Uint64(2323463919, 2132606034),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3660727141, 388815),
                new $Uint64(2904329899, 1592015718),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2428425278, 1074227842),
                new $Uint64(3630412374, 916277824),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1517765798, 3892617873),
                new $Uint64(2269007733, 3793899112),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1897207248, 2718288694),
                new $Uint64(2836259667, 1521148418),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(224025412, 3397860867),
                new $Uint64(3545324584, 827693699),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3898112266, 4271146690),
                new $Uint64(2215827865, 517308561),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1651414861, 3191449714),
                new $Uint64(2769784831, 1720377526),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4211752225, 768086671),
                new $Uint64(3462231039, 1076730083),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2095474228, 3164408729),
                new $Uint64(2163894399, 2283569038),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(471859137, 3955510912),
                new $Uint64(2704867999, 1780719474),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2737307570, 1723163168),
                new $Uint64(3381084999, 1152157518),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1274150815, 6470312),
                new $Uint64(4226356249, 366455074),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1870086083, 1614656681),
                new $Uint64(2641472655, 2913388981),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3411349428, 944579027),
                new $Uint64(3301840819, 2567994402),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2116703137, 1180723784),
                new $Uint64(4127301024, 2136251179),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(786068548, 3422306925),
                new $Uint64(2579563140, 1335156987),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4203811157, 4277883656),
                new $Uint64(3224453925, 1668946233),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2033538475, 2126129098),
                new $Uint64(4030567406, 3159924616),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1270961547, 791959774),
                new $Uint64(2519104629, 901211061),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2662443757, 4211175190),
                new $Uint64(3148880786, 2200255650),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1180571049, 2042743516),
                new $Uint64(3936100983, 602835915),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(200985993, 3961069257),
                new $Uint64(2460063114, 1987385183),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3472457964, 1730111099),
                new $Uint64(3075078893, 336747830),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2193088807, 2162638874),
                new $Uint64(3843848616, 1494676612),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3518164152, 2962262032),
                new $Uint64(2402405385, 934172882),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2250221542, 3702827541),
                new $Uint64(3003006731, 2241457927),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1739035104, 2481050778),
                new $Uint64(3753758414, 1728080585),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3771251500, 1550656736),
                new $Uint64(2346099009, 6308541),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1492838903, 1938320920),
                new $Uint64(2932623761, 1081627501),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2939790453, 1349159326),
                new $Uint64(3665779701, 2425776200),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1837369033, 1380095491),
                new $Uint64(2291112313, 2052981037),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3370453115, 2798861187),
                new $Uint64(2863890391, 3639968120),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4213066394, 2424834660),
                new $Uint64(3579862989, 3476218326),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1559424672, 2589263487),
                new $Uint64(2237414368, 2709507366),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4096764488, 3236579358),
                new $Uint64(2796767960, 3386884207),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4047213786, 4045724198),
                new $Uint64(3495959950, 4233605259),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1992637704, 3602319448),
                new $Uint64(2184974969, 1572261463),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1417055307, 207932014),
                new $Uint64(2731218711, 3039068653),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2845060957, 3481140489),
                new $Uint64(3414023389, 2725093992),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3556326197, 1130200140),
                new $Uint64(4267529237, 185142018),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3296445697, 1243245999),
                new $Uint64(2667205773, 652584673),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(899331649, 2627799323),
                new $Uint64(3334007216, 1889472666),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3271648210, 63523682),
                new $Uint64(4167509020, 2361840832),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2044780131, 1113444125),
                new $Uint64(2604693137, 3623634168),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2555975164, 318063332),
                new $Uint64(3255866422, 1308317238),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1047485307, 397579165),
                new $Uint64(4069833027, 3782880196),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2802161964, 4006583362),
                new $Uint64(2543645642, 1827429210),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1355218808, 713261907),
                new $Uint64(3179557053, 136802865),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2767765334, 891577384),
                new $Uint64(3974446316, 1244745405),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2266724245, 3778461337),
                new $Uint64(2484028947, 2925449526),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(685921659, 1501851199),
                new $Uint64(3105036184, 2583070084),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(857402074, 803572175),
                new $Uint64(3881295230, 3228837605),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1072747208, 1575974433),
                new $Uint64(2425809519, 944281679),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(267192186, 1969968041),
                new $Uint64(3032261899, 106610275),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3555215705, 314976404),
                new $Uint64(3790327373, 3354488315),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1685138903, 2881214812),
                new $Uint64(2368954608, 2633426109),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3180165453, 2527776691),
                new $Uint64(2961193260, 3291782636),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3975206816, 4233462688),
                new $Uint64(3701491575, 4114728295),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4095116996, 2645914180),
                new $Uint64(2313432234, 4182317920),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(823928949, 3307392725),
                new $Uint64(2891790293, 3080413753),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2103653011, 913015435),
                new $Uint64(3614737867, 629291719),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2925395868, 33763735),
                new $Uint64(2259211166, 4151403708),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3656744835, 42204668),
                new $Uint64(2824013958, 3041770987),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3497189219, 3273981307),
                new $Uint64(3530017448, 1654730086),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1112001438, 1509367405),
                new $Uint64(2206260905, 1034206304),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1390001797, 4034192904),
                new $Uint64(2757826131, 2366499704),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1737502247, 1821515659),
                new $Uint64(3447282664, 1884382806),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(12197080, 2749060022),
                new $Uint64(2154551665, 1177739254),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2162729998, 3436325028),
                new $Uint64(2693189581, 2545915891),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1629670674, 2147922637),
                new $Uint64(3366486976, 4256136688),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2037088343, 537419649),
                new $Uint64(4208108721, 1025203564),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3420663862, 1946500016),
                new $Uint64(2630067950, 3325106787),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3202088004, 285641372),
                new $Uint64(3287584938, 2008899836),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4002610005, 357051716),
                new $Uint64(4109481173, 363641147),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1964760341, 760028234),
                new $Uint64(2568425733, 764146629),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3529692250, 2023777117),
                new $Uint64(3210532166, 2028925110),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2264631665, 382237748),
                new $Uint64(4013165208, 388672740),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3562878438, 2923253152),
                new $Uint64(2508228255, 242920462),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2306114400, 1506582793),
                new $Uint64(3135285318, 3524876050),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(735159352, 1883228491),
                new $Uint64(3919106648, 2258611415),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2070087331, 1177017807),
                new $Uint64(2449441655, 1411632134),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(440125516, 397530434),
                new $Uint64(3061802069, 690798344),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(550156895, 496913043),
                new $Uint64(3827252586, 1937239754),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1417589883, 1921183388),
                new $Uint64(2392032866, 2284516670),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3919471002, 1327737411),
                new $Uint64(2990041083, 708162189),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1678113280, 3807155412),
                new $Uint64(3737551353, 4106428209),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3733175360, 2379472132),
                new $Uint64(2335969596, 955904894),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2518985552, 2974340165),
                new $Uint64(2919961995, 1194881118),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1001248292, 3717925207),
                new $Uint64(3649952494, 419859574),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3847005655, 176219606),
                new $Uint64(2281220308, 3483637705),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1587531596, 3441499980),
                new $Uint64(2851525386, 59579836),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1984414496, 6907679),
                new $Uint64(3564406732, 2221958443),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(703388148, 4317299),
                new $Uint64(2227754207, 3536207675),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4100460657, 5396624),
                new $Uint64(2784692759, 3346517769),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1904350349, 1080487604),
                new $Uint64(3480865949, 3109405388),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3337702616, 1212175664),
                new $Uint64(2175541218, 2480249279),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3098386446, 1515219580),
                new $Uint64(2719426523, 952827951),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2799241233, 4041508124),
                new $Uint64(3399283154, 117293115),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2425309718, 1830659683),
                new $Uint64(4249103942, 2294100042),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2589560398, 70420478),
                new $Uint64(2655689964, 360070702),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1089466849, 2235509245),
                new $Uint64(3319612455, 450088378),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3509317209, 3868128380),
                new $Uint64(4149515568, 3783835944),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2193323256, 806967502),
                new $Uint64(2593447230, 2364897465),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3815395894, 1008709377),
                new $Uint64(3241809038, 808638183),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3695503043, 3408370369),
                new $Uint64(4052261297, 3158281377),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(699076666, 1593360569),
                new $Uint64(2532663311, 363313125),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1947587656, 4139184359),
                new $Uint64(3165829138, 3675366878),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(287000923, 879013153),
                new $Uint64(3957286423, 2446724950),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3400601049, 12512308),
                new $Uint64(2473304014, 3139815829),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1029525839, 1089382210),
                new $Uint64(3091630018, 1777286139),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(213165475, 287985938),
                new $Uint64(3864537523, 74124026),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1206970245, 3938087595),
                new $Uint64(2415335951, 3804423900),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1508712807, 1701384022),
                new $Uint64(3019169939, 3681788051),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(812149185, 1052988204),
                new $Uint64(3773962424, 3528493240),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(507593240, 3342472187),
                new $Uint64(2358726515, 2205308275),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3855717022, 4178090234),
                new $Uint64(2948408144, 1682893519),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3745904454, 3075129145),
                new $Uint64(3685510180, 2103616899),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1804319372, 848213891),
                new $Uint64(2303443862, 3462244210),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(107915567, 1060267364),
                new $Uint64(2879304828, 2180321615),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3356119931, 251592381),
                new $Uint64(3599131035, 2725402018),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3171316780, 3915341622),
                new $Uint64(2249456897, 1166505349),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(742920504, 599209732),
                new $Uint64(2811821121, 2531873511),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4149876102, 749012165),
                new $Uint64(3514776401, 4238583712),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2593672563, 3689358075),
                new $Uint64(2196735251, 1038502084),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3242090704, 3537955770),
                new $Uint64(2745919064, 224385781),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(831387909, 127477416),
                new $Uint64(3432398830, 280482227),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4260460358, 1233088594),
                new $Uint64(4290498537, 2498086431),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4273400459, 3991905843),
                new $Uint64(2681561585, 4245658579),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4268008750, 3916140480),
                new $Uint64(3351951982, 2085847752),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1040043642, 2747691952),
                new $Uint64(4189939978, 459826043),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(113156364, 2791049294),
                new $Uint64(2618712486, 1361133101),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1215187279, 3488811618),
                new $Uint64(3273390607, 3848900024),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1518984099, 3287272698),
                new $Uint64(4091738259, 3737383206),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4170590534, 1517674524),
                new $Uint64(2557336412, 1798993591),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4139496343, 4044576803),
                new $Uint64(3196670515, 2248741989),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1953144957, 3981979180),
                new $Uint64(3995838144, 1737185663),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2831328334, 3025607900),
                new $Uint64(2497398840, 1085741039),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2465418594, 1634526227),
                new $Uint64(3121748550, 1357176299),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2008031418, 4190641431),
                new $Uint64(3902185687, 3843954022),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(181277812, 3692892718),
                new $Uint64(2438866054, 4013084000),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(226597266, 321148602),
                new $Uint64(3048582568, 2868871352),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(283246582, 2548919401),
                new $Uint64(3810728210, 3586089190),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3398254586, 519332801),
                new $Uint64(2381705131, 3315047567),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3174076408, 2796649650),
                new $Uint64(2977131414, 3070067635),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2893853686, 3495812062),
                new $Uint64(3721414268, 1690100896),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1808658554, 1111140715),
                new $Uint64(2325883917, 3203796708),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2260823192, 3536409542),
                new $Uint64(2907354897, 783520413),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3899770815, 125544631),
                new $Uint64(3634193621, 2053142340),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(289873111, 1689078130),
                new $Uint64(2271371013, 1820084875),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3583566861, 1037605839),
                new $Uint64(2839213766, 3348847917),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1258233104, 2370749123),
                new $Uint64(3549017208, 2038576249),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3470750250, 1481718202),
                new $Uint64(2218135755, 1274110155),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3264695988, 3999631400),
                new $Uint64(2772669694, 518895870),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1933386338, 704571954),
                new $Uint64(3465837117, 2796103486),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(134624637, 1514099295),
                new $Uint64(2166148198, 2284435591),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3389506268, 2966365943),
                new $Uint64(2707685248, 708060840),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4236882835, 3707957429),
                new $Uint64(3384606560, 885076050),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3148619896, 3561204962),
                new $Uint64(4230758200, 1106345063),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3578500171, 2225753101),
                new $Uint64(2644223875, 691465664),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(178157918, 1708449553),
                new $Uint64(3305279843, 4085557553),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1296439221, 4283045589),
                new $Uint64(4131599804, 4033205117),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1347145425, 3213774405),
                new $Uint64(2582249878, 373269550),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3831415430, 795992534),
                new $Uint64(3227812347, 2614070585),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1568043815, 3142474316),
                new $Uint64(4034765434, 2193846408),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(980027384, 3574659183),
                new $Uint64(2521728396, 2444895829),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2298776055, 173356683),
                new $Uint64(3152160495, 3056119786),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(725986420, 3437921326),
                new $Uint64(3940200619, 2746407909),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(990612425, 1217181),
                new $Uint64(2462625387, 1179634031),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(164523707, 1075263300),
                new $Uint64(3078281734, 400800715),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3426880106, 270337301),
                new $Uint64(3847852167, 2648484541),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2678670978, 1242702637),
                new $Uint64(2404907604, 3265915574),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1200855074, 3700861945),
                new $Uint64(3006134505, 4082394468),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1501068843, 2478593783),
                new $Uint64(3757668132, 1881767613),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1475038939, 1012250202),
                new $Uint64(2348542582, 3323588406),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3991282322, 191570929),
                new $Uint64(2935678228, 2007001859),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3915361078, 2386947309),
                new $Uint64(3669597785, 2508752324),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(299617026, 418100244),
                new $Uint64(2293498615, 4252324763),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3595746754, 2670108953),
                new $Uint64(2866873269, 4241664129),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1273457971, 1190152543),
                new $Uint64(3583591587, 2080854690),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1869653056, 206974427),
                new $Uint64(2239744742, 763663269),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3410808144, 258718034),
                new $Uint64(2799680927, 3102062734),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2116026532, 323397543),
                new $Uint64(3499601159, 2803836594),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2396258406, 2349607112),
                new $Uint64(2187250724, 3363010607),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1921581184, 789525242),
                new $Uint64(2734063405, 4203763259),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1328234656, 986906553),
                new $Uint64(3417579257, 2033478602),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3807776968, 1233633192),
                new $Uint64(4271974071, 3615590076),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(232376957, 771020745),
                new $Uint64(2669983794, 3870356534),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2437954844, 2037517755),
                new $Uint64(3337479743, 2690462019),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1973701731, 2546897194),
                new $Uint64(4171849679, 2289335700),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3381047230, 1054939834),
                new $Uint64(2607406049, 3041447548),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4226309037, 3466158440),
                new $Uint64(3259257562, 580583963),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4209144473, 1111472579),
                new $Uint64(4074071952, 2873213602),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3704457119, 3379024922),
                new $Uint64(2546294970, 1795758501),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1409345927, 3150039328),
                new $Uint64(3182868713, 97214479),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(687940585, 2863807336),
                new $Uint64(3978585891, 1195259923),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4188059250, 179266849),
                new $Uint64(2486616182, 210166539),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4161332238, 2371567209),
                new $Uint64(3108270227, 2410191822),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3054181650, 816975364),
                new $Uint64(3885337784, 1938997954),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2982605355, 1584351426),
                new $Uint64(2428336115, 1211873721),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(507031222, 906697459),
                new $Uint64(3035420144, 441100328),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(633789027, 3280855472),
                new $Uint64(3794275180, 551375410),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1469859966, 1513663758),
                new $Uint64(2371421987, 2492093279),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(763583133, 4039563345),
                new $Uint64(2964277484, 2041374775),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4175704389, 1828228709),
                new $Uint64(3705346855, 2551718468),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(462331595, 1679513855),
                new $Uint64(2315841784, 3205436779),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3799139966, 1025650495),
                new $Uint64(2894802230, 4006795973),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1527699485, 3429546767),
                new $Uint64(3618502788, 2861011319),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2565424914, 2680337641),
                new $Uint64(2261564242, 3935615722),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1059297495, 1202938404),
                new $Uint64(2826955303, 2772036005),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2397863693, 429931181),
                new $Uint64(3533694129, 2391303182),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(424922984, 805577900),
                new $Uint64(2208558830, 4178919049),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1604895554, 1006972375),
                new $Uint64(2760698538, 3076165163),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(932377618, 3406199117),
                new $Uint64(3450873173, 1697722806),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3803961483, 3202616272),
                new $Uint64(2156795733, 1597947665),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1533726382, 2929528516),
                new $Uint64(2695994666, 3071176406),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4064641626, 1514426997),
                new $Uint64(3369993333, 1691486859),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4007060208, 4040517394),
                new $Uint64(4212491666, 3188100398),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1430670806, 2525323371),
                new $Uint64(2632807291, 3066304573),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2862080332, 1009170566),
                new $Uint64(3291009114, 2759138892),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3577600415, 1261463208),
                new $Uint64(4113761393, 1301439967),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3846612995, 2399027241),
                new $Uint64(2571100870, 3497754539),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3734524420, 1925042227),
                new $Uint64(3213876088, 2224709526),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2520671877, 2406302784),
                new $Uint64(4017345110, 2780886908),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3722903571, 2040810152),
                new $Uint64(2510840694, 664312493),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1432403992, 1477270866),
                new $Uint64(3138550867, 2977874265),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2864246814, 1846588582),
                new $Uint64(3923188584, 2648601007),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3400766995, 80376040),
                new $Uint64(2451992865, 1655375629),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1029733271, 3321695522),
                new $Uint64(3064991081, 3142961361),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2360908413, 3078377578),
                new $Uint64(3831238852, 707476229),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2012438670, 2460856898),
                new $Uint64(2394524282, 2589656291),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1441806514, 928587475),
                new $Uint64(2993155353, 1089586716),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1802258142, 3308217992),
                new $Uint64(3741444191, 2435725219),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(589540427, 993894421),
                new $Uint64(2338402619, 3132940998),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2884409182, 168626202),
                new $Uint64(2923003274, 2842434423),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2531769653, 2358266401),
                new $Uint64(3653754093, 1405559381),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2119226945, 2010787412),
                new $Uint64(2283596308, 1415345525),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3722775505, 3587226089),
                new $Uint64(2854495385, 1769181906),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2505985734, 1262807140),
                new $Uint64(3568119231, 3285219207),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3176853819, 4010479934),
                new $Uint64(2230074519, 3663874740),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3971067274, 3939358094),
                new $Uint64(2787593149, 3506101601),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1742608621, 2776713970),
                new $Uint64(3484491437, 1161401530),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2162872212, 2272317143),
                new $Uint64(2177807148, 1262746868),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2703590265, 2840396429),
                new $Uint64(2722258935, 1578433585),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(158262360, 329270064),
                new $Uint64(3402823669, 899300158),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2345311598, 411587580),
                new $Uint64(4253529586, 2197867021),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2002690660, 3478467709),
                new $Uint64(2658455991, 2447408712),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2503363326, 53117341),
                new $Uint64(3323069989, 1985519066),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(981720509, 2213880324),
                new $Uint64(4153837486, 3555640657),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3297929878, 1920546114),
                new $Uint64(2596148429, 1148533586),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1974928700, 253198995),
                new $Uint64(3245185536, 2509408807),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1394919051, 316498744),
                new $Uint64(4056481920, 3136761009),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3556178966, 3955908099),
                new $Uint64(2535301200, 1960475630),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2297740060, 2797401476),
                new $Uint64(3169126500, 2450594538),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(724691427, 3496751845),
                new $Uint64(3961408125, 3063243173),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(989803054, 1648598991),
                new $Uint64(2475880078, 2451397895),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(163511993, 4208232386),
                new $Uint64(3094850098, 916763721),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1278131816, 2039065011),
                new $Uint64(3868562622, 3293438299),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(261961473, 1274415632),
                new $Uint64(2417851639, 984657113),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1401193665, 2666761364),
                new $Uint64(3022314549, 157079567),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(677750258, 112226233),
                new $Uint64(3777893186, 1270091283),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4181690295, 1143883219),
                new $Uint64(2361183241, 1867548875),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4153371045, 356112200),
                new $Uint64(2951479051, 3408177918),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3044230158, 1518882075),
                new $Uint64(3689348814, 3186480574),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(828902024, 4170526768),
                new $Uint64(2305843009, 917808535),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4257353003, 918191165),
                new $Uint64(2882303761, 2221002492),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1026723958, 73997132),
                new $Uint64(3602879701, 3849994940),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2789186121, 3267473679),
                new $Uint64(2251799813, 2943117749),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(265257180, 863116627),
                new $Uint64(2814749767, 457671715),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3552796947, 1078895784),
                new $Uint64(3518437208, 3793315115),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1683627180, 137438953),
                new $Uint64(2199023255, 2370821947),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1030792151, 171798691),
                new $Uint64(2748779069, 1889785610),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3435973836, 3435973836),
                new $Uint64(3435973836, 3435973836),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2147483648, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2684354560, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3355443200, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(4194304000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2621440000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3276800000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(4096000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2560000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3200000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(4000000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2500000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3125000000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3906250000, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2441406250, 0),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3051757812, 2147483648),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3814697265, 2684354560),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2384185791, 67108864),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2980232238, 3305111552),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3725290298, 1983905792),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2328306436, 2313682944),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2910383045, 2892103680),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3637978807, 393904128),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2273736754, 1856802816),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2842170943, 173519872),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3552713678, 3438125312),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2220446049, 1075086496),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(2775557561, 2417599944),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(0, 0),
                new $Uint64(3469446951, 4095741754),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1073741824, 0),
                new $Uint64(2168404344, 4170451332),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1342177280, 0),
                new $Uint64(2710505431, 918096869),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2751463424, 0),
                new $Uint64(3388131789, 73879262),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1291845632, 0),
                new $Uint64(4235164736, 1166090902),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4028628992, 0),
                new $Uint64(2646977960, 728806813),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1814560768, 0),
                new $Uint64(3308722450, 911008517),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3341942784, 0),
                new $Uint64(4135903062, 3286244294),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1014972416, 0),
                new $Uint64(2584939414, 980160860),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1268715520, 0),
                new $Uint64(3231174267, 3372684723),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(512152576, 0),
                new $Uint64(4038967834, 3142114080),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(320095360, 0),
                new $Uint64(2524354896, 3037563124),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(400119200, 0),
                new $Uint64(3155443620, 3796953905),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1573890824, 0),
                new $Uint64(3944304526, 451225085),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1520552677, 0),
                new $Uint64(2465190328, 3503241150),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4048174494, 1073741824),
                new $Uint64(3081487911, 84084141),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1838992645, 3489660928),
                new $Uint64(3851859888, 3326330649),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3833724963, 2717908992),
                new $Uint64(2407412430, 2078956655),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3718414380, 2323644416),
                new $Uint64(3009265538, 451212171),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3574276151, 2904555520),
                new $Uint64(3761581922, 2711498862),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1160180770, 3425959936),
                new $Uint64(2350988701, 2768428613),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2523967787, 2134966272),
                new $Uint64(2938735877, 239310294),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1007476086, 1594966016),
                new $Uint64(3673419846, 1372879692),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2777156201, 4218079232),
                new $Uint64(2295887403, 4079275279),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2397703428, 2051373568),
                new $Uint64(2869859254, 4025352275),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1923387461, 2564216960),
                new $Uint64(3587324068, 2884206696),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1202117163, 2139506512),
                new $Uint64(2242077542, 3950112833),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2576388278, 1600641316),
                new $Uint64(2802596928, 2790157393),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4294227171, 4148285293),
                new $Uint64(3503246160, 3487696741),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3220762894, 2055807396),
                new $Uint64(2189528850, 2179810463),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2952211794, 422275597),
                new $Uint64(2736911063, 577279431),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2616522918, 2675328144),
                new $Uint64(3421138828, 3942824761),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(49428176, 1196676532),
                new $Uint64(4276423536, 633563656),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(30892610, 747922832),
                new $Uint64(2672764710, 395977285),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1112357586, 3082387189),
                new $Uint64(3340955887, 2642455254),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3537930631, 1705500338),
                new $Uint64(4176194859, 2229327243),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1674335732, 2676550447),
                new $Uint64(2610121787, 856458615),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1019177841, 3345688059),
                new $Uint64(3262652233, 4291798741),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2347714126, 960884602),
                new $Uint64(4078315292, 2143522954),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2541063152, 3821778348),
                new $Uint64(2548947057, 3487185494),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1028845293, 482255639),
                new $Uint64(3186183822, 1137756396),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1286056616, 1676561373),
                new $Uint64(3982729777, 3569679143),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2414398121, 1047850858),
                new $Uint64(2489206111, 620436728),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3017997651, 2383555396),
                new $Uint64(3111507638, 3996771382),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1625013416, 1905702422),
                new $Uint64(3889384548, 2848480580),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3163117033, 1191064013),
                new $Uint64(2430865342, 3927784010),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1806412643, 2562571841),
                new $Uint64(3038581678, 2762246365),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3331757628, 2129472977),
                new $Uint64(3798227098, 1305324308),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4229832165, 3478404258),
                new $Uint64(2373891936, 1889569516),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(992322911, 1126779851),
                new $Uint64(2967364920, 2361961896),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1240403639, 334732990),
                new $Uint64(3709206150, 2952452370),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1848994098, 1819820855),
                new $Uint64(2318253844, 771540907),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1237500799, 127292420),
                new $Uint64(2897817305, 964426134),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3694359646, 3380340998),
                new $Uint64(3622271631, 2279274491),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1772103867, 1038971299),
                new $Uint64(2263919769, 3035159293),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3288871658, 224972300),
                new $Uint64(2829899712, 572723644),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4111089572, 2428699024),
                new $Uint64(3537374640, 715904555),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2032560070, 3665420538),
                new $Uint64(2210859150, 447440347),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1466958264, 2434292024),
                new $Uint64(2763573937, 2706784082),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3981181478, 3042865030),
                new $Uint64(3454467422, 162254630),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1414496600, 828048820),
                new $Uint64(2159042138, 3322634616),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1768120750, 1035061025),
                new $Uint64(2698802673, 2005809622),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(62667289, 3441309929),
                new $Uint64(3373503341, 3581003852),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(78334112, 1080411939),
                new $Uint64(4216879177, 1255029343),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1659571556, 675257462),
                new $Uint64(2635549485, 3468747899),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1000722621, 844071828),
                new $Uint64(3294436857, 1114709402),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3398386924, 2128831609),
                new $Uint64(4118046071, 2467128576),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2123991827, 3478003403),
                new $Uint64(2573778794, 3152568096),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2654989784, 3273762430),
                new $Uint64(3217223493, 1793226472),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3318737230, 4092203038),
                new $Uint64(4021529366, 3315274914),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3147952593, 1483885074),
                new $Uint64(2513455854, 998304997),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(713715269, 2928598167),
                new $Uint64(3141819817, 3395364895),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4113369559, 439522237),
                new $Uint64(3927274772, 1022980646),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1497114150, 1885314134),
                new $Uint64(2454546732, 2786846552),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1871392688, 209159020),
                new $Uint64(3068183415, 3483558190),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(191757212, 261448775),
                new $Uint64(3835229269, 3280705914),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1193590081, 2310889132),
                new $Uint64(2397018293, 2587312108),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1491987601, 3962353239),
                new $Uint64(2996272867, 12914663),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(791242678, 1731716077),
                new $Uint64(3745341083, 3237368801),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3178881234, 8580724),
                new $Uint64(2340838177, 1486484588),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3973601542, 2158209553),
                new $Uint64(2926047721, 2931847559),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3893260104, 550278293),
                new $Uint64(3657559652, 443583977),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(822674829, 343923933),
                new $Uint64(2285974782, 2424723634),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3175827184, 1503646741),
                new $Uint64(2857468478, 883420894),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1822300332, 1879558426),
                new $Uint64(3571835597, 3251759766),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(65195883, 3322207664),
                new $Uint64(2232397248, 2569220766),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2228978502, 3079017756),
                new $Uint64(2790496560, 3211525957),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3859964952, 1701288547),
                new $Uint64(3488120700, 4014407446),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1338736271, 1063305342),
                new $Uint64(2180075438, 361521006),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3820903987, 255389853),
                new $Uint64(2725094297, 2599384905),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1554904511, 3540462789),
                new $Uint64(3406367872, 28005660),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1943630639, 3351836662),
                new $Uint64(4257959840, 35007075),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(677898237, 3705510650),
                new $Uint64(2661224900, 21879422),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2994856445, 1410662840),
                new $Uint64(3326531125, 27349277),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(522345084, 2837070374),
                new $Uint64(4158163906, 1107928421),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(863336589, 3920652632),
                new $Uint64(2598852441, 1766197087),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(5428913, 1679590318),
                new $Uint64(3248565551, 3281488183),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3228011613, 3173229722),
                new $Uint64(4060706939, 3028118404),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4164990906, 2520139488),
                new $Uint64(2537941837, 1355703090),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3058754985, 1002690712),
                new $Uint64(3172427296, 2768370687),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2749701907, 2327105214),
                new $Uint64(3965534120, 3460463359),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3329176428, 917569847),
                new $Uint64(2478458825, 2162789599),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3087728711, 1146962308),
                new $Uint64(3098073531, 3777228823),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2785919065, 359961061),
                new $Uint64(3872591914, 3647794205),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2278070327, 2909330223),
                new $Uint64(2420369946, 3353613202),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(700104261, 2562920955),
                new $Uint64(3025462433, 2044532855),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4096355798, 4277393018),
                new $Uint64(3781828041, 3629407892),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(412738726, 1599628812),
                new $Uint64(2363642526, 657767197),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1589665231, 4147019663),
                new $Uint64(2954553157, 2969692644),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1987081539, 4110032755),
                new $Uint64(3693191447, 490890333),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1778796874, 2031899560),
                new $Uint64(2308244654, 1917419194),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(76012445, 392390802),
                new $Uint64(2885305818, 249290345),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1168757380, 1564230326),
                new $Uint64(3606632272, 2459096579),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(193602450, 3125127602),
                new $Uint64(2254145170, 1536935362),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2389486711, 1758925854),
                new $Uint64(2817681462, 4068652850),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(839374741, 1124915494),
                new $Uint64(3522101828, 2938332415),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2135221949, 1239943096),
                new $Uint64(2201313642, 3983941407),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1595285612, 2623670694),
                new $Uint64(2751642053, 2832443111),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(920365191, 3279588367),
                new $Uint64(3439552567, 319328417),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3259582804, 3660355465),
                new $Uint64(2149720354, 1810192996),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4074478506, 280477036),
                new $Uint64(2687150443, 115257597),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1871872660, 2498079943),
                new $Uint64(3358938053, 3365297469),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3413582649, 3122599929),
                new $Uint64(4198672567, 985396364),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4280972804, 341012219),
                new $Uint64(2624170354, 2226485463),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4277474181, 426265274),
                new $Uint64(3280212943, 635623181),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2125617254, 1606573417),
                new $Uint64(4100266178, 4015754449),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4012865343, 4225333857),
                new $Uint64(2562666361, 3583588354),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2868598031, 4207925498),
                new $Uint64(3203332952, 1258259971),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2512005715, 4186165048),
                new $Uint64(4004166190, 1572824964),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3717487220, 2079482243),
                new $Uint64(2502603868, 4204241074),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2499375377, 2599352804),
                new $Uint64(3128254836, 960334047),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2050477398, 27965533),
                new $Uint64(3910318545, 1200417559),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2892161109, 3238703930),
                new $Uint64(2443949090, 3434615534),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1467717739, 827154441),
                new $Uint64(3054936363, 2145785770),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3982130821, 4255168523),
                new $Uint64(3818670454, 1608490388),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(341348115, 3196351239),
                new $Uint64(2386669033, 4226531965),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1500426968, 2921697224),
                new $Uint64(2983336292, 2061939484),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1875533710, 3652121531),
                new $Uint64(3729170365, 2577424355),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(635337657, 1208834132),
                new $Uint64(2330731478, 2147761134),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2941655719, 2584784490),
                new $Uint64(2913414348, 537217769),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(455844177, 2157238788),
                new $Uint64(3641767935, 671522212),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2432386258, 4032628802),
                new $Uint64(2276104959, 2030314118),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(892999175, 2893302355),
                new $Uint64(2845131199, 1464150824),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1116248969, 2542886120),
                new $Uint64(3556413999, 756446706),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1771397429, 4273658385),
                new $Uint64(2222758749, 2083391927),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1140504963, 2120847509),
                new $Uint64(2778448436, 3677981733),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2499373028, 1577317563),
                new $Uint64(3473060546, 302509870),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(488366318, 3133307125),
                new $Uint64(2170662841, 1262810493),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1684199722, 1769150258),
                new $Uint64(2713328551, 2652254940),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2105249653, 63954174),
                new $Uint64(3391660689, 2241576851),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1557820242, 1153684542),
                new $Uint64(4239575861, 3875712888),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(973637651, 1794794663),
                new $Uint64(2649734913, 2959191467),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(143305240, 1169751504),
                new $Uint64(3312168642, 477763862),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2326615198, 1462189381),
                new $Uint64(4140210802, 2744688475),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(917263586, 4135093835),
                new $Uint64(2587631751, 2789172121),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2220321307, 3021383645),
                new $Uint64(3234539689, 2412723327),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1701659810, 2702987733),
                new $Uint64(4043174611, 4089645983),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2674150117, 2763109157),
                new $Uint64(2526984132, 2019157827),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2268945823, 232660974),
                new $Uint64(3158730165, 2523947284),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2836182278, 3512051690),
                new $Uint64(3948412706, 4228675929),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(162001188, 1121290482),
                new $Uint64(2467757941, 3716664280),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(202501485, 1401613103),
                new $Uint64(3084697427, 1424604878),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2400610504, 2825758202),
                new $Uint64(3855871784, 707014273),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4184736125, 1766098876),
                new $Uint64(2409919865, 441883920),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(935952860, 3281365420),
                new $Uint64(3012399831, 1626096725),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2243682899, 4101706775),
                new $Uint64(3765499789, 958879082),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2476043636, 2026695822),
                new $Uint64(2353437368, 1136170338),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(947570897, 2533369778),
                new $Uint64(2941796710, 1420212923),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(110721797, 4240454046),
                new $Uint64(3677245887, 3922749802),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1142942947, 3187154691),
                new $Uint64(2298278679, 4062331362),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3576162332, 2910201539),
                new $Uint64(2872848349, 4004172378),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2322719267, 3637751924),
                new $Uint64(3591060437, 1783990001),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4136054102, 1736724041),
                new $Uint64(2244412773, 1651864662),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3022583980, 23421403),
                new $Uint64(2805515966, 3138572652),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3778229975, 29276754),
                new $Uint64(3506894958, 1775732167),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3972006470, 1628910707),
                new $Uint64(2191809349, 36090780),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(670040791, 4183622032),
                new $Uint64(2739761686, 1118855300),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(837550989, 4155785716),
                new $Uint64(3424702107, 3546052773),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2120680561, 1973506673),
                new $Uint64(4280877634, 3358824142),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(251683526, 3917796230),
                new $Uint64(2675548521, 3173006913),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1388346232, 2749761640),
                new $Uint64(3344435652, 745033169),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2809174614, 3437202050),
                new $Uint64(4180544565, 931291461),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2292605046, 1074509457),
                new $Uint64(2612840353, 1118928075),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1792014483, 3490620469),
                new $Uint64(3266050441, 2472401918),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(92534456, 3289533763),
                new $Uint64(4082563051, 4164244222),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3279059507, 2055958602),
                new $Uint64(2551601907, 2065781726),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1951340736, 1496206428),
                new $Uint64(3189502384, 1508485334),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(291692272, 1870258035),
                new $Uint64(3986877980, 1885606668),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2329791318, 1168911272),
                new $Uint64(2491798737, 3325987815),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1838497323, 3608622738),
                new $Uint64(3114748422, 936259297),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3371863478, 3437036599),
                new $Uint64(3893435527, 3317807769),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(496801938, 1074406050),
                new $Uint64(2433397204, 3684242592),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(621002422, 3490491211),
                new $Uint64(3041746506, 310335944),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(776253028, 2215630365),
                new $Uint64(3802183132, 2535403578),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1558899966, 3532252626),
                new $Uint64(2376364457, 3732110884),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1948624958, 2267832135),
                new $Uint64(2970455572, 1443913133),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3509523022, 687306521),
                new $Uint64(3713069465, 1804891416),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2193451888, 3650792047),
                new $Uint64(2320668415, 3812411695),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1668073037, 268522763),
                new $Uint64(2900835519, 3691772795),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1011349472, 1409395278),
                new $Uint64(3626044399, 3540974170),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1705835244, 880872049),
                new $Uint64(2266277749, 3823721592),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2132294055, 1101090061),
                new $Uint64(2832847187, 1558426518),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(517883921, 302620752),
                new $Uint64(3541058984, 874291324),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2471161098, 2873492530),
                new $Uint64(2213161865, 546432077),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4162693197, 1444382015),
                new $Uint64(2766452331, 1756781920),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(908399200, 2879219342),
                new $Uint64(3458065414, 1122235577),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3252104060, 1799512089),
                new $Uint64(2161290883, 3922622707),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2991388251, 2249390111),
                new $Uint64(2701613604, 3829536560),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3739235314, 1737995815),
                new $Uint64(3377017006, 491953404),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(379076847, 25011121),
                new $Uint64(4221271257, 2762425404),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2384406677, 1626244686),
                new $Uint64(2638294536, 115903141),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4054250170, 3106547682),
                new $Uint64(3297868170, 144878926),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2920329065, 1735700955),
                new $Uint64(4122335212, 2328582306),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2898947489, 3769167657),
                new $Uint64(2576459507, 3602847589),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(402458890, 1490234099),
                new $Uint64(3220574384, 3429817663),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3724299084, 4010276272),
                new $Uint64(4025717980, 4287272078),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1253945104, 358939022),
                new $Uint64(2516073738, 532061401),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2641173204, 448673777),
                new $Uint64(3145092172, 2812560399),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2227724681, 560842221),
                new $Uint64(3931365215, 3515700499),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(855457013, 3034880948),
                new $Uint64(2457103259, 3807925548),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1069321267, 572375713),
                new $Uint64(3071379074, 3686165111),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(262909759, 3936695114),
                new $Uint64(3839223843, 2460222741),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(701189511, 4071047182),
                new $Uint64(2399514902, 1000768301),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1950228713, 4015067154),
                new $Uint64(2999393627, 3398444024),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2437785892, 1797608470),
                new $Uint64(3749242034, 3174313206),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(449874358, 3270988942),
                new $Uint64(2343276271, 3057687578),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2709826596, 1941252529),
                new $Uint64(2929095339, 2748367648),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3387283245, 2426565662),
                new $Uint64(3661369174, 2361717736),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2117052028, 2053474450),
                new $Uint64(2288355734, 402331761),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3720056859, 2566843063),
                new $Uint64(2860444667, 2650398349),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1428845602, 2134812005),
                new $Uint64(3575555834, 2239256113),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3577383061, 2407999327),
                new $Uint64(2234722396, 2473276894),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2324245178, 4083740983),
                new $Uint64(2793402995, 3091596118),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(757822825, 2957192581),
                new $Uint64(3491753744, 2790753324),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2621122914, 237632627),
                new $Uint64(2182346090, 1744220827),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2202661818, 2444524431),
                new $Uint64(2727932613, 32792386),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(605843625, 908171891),
                new $Uint64(3409915766, 1114732307),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3978530003, 2208956688),
                new $Uint64(4262394707, 3540899031),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4097193988, 843727018),
                new $Uint64(2663996692, 1676190982),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2974008837, 1054658773),
                new $Uint64(3329995865, 2095238728),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3717511046, 2392065290),
                new $Uint64(4162494831, 3692790234),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3397186228, 421298982),
                new $Uint64(2601559269, 3918606632),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4246482785, 526623728),
                new $Uint64(3251949087, 1677032818),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3160619833, 1732021484),
                new $Uint64(4064936359, 1022549199),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3586000131, 3766867987),
                new $Uint64(2540585224, 2249705985),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1261274692, 3634843160),
                new $Uint64(3175731530, 2812132482),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3724077014, 248586654),
                new $Uint64(3969664413, 1367681954),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3401289957, 3376592131),
                new $Uint64(2481040258, 1391672133),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1030386975, 999514691),
                new $Uint64(3101300322, 3887073815),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(214241895, 175651540),
                new $Uint64(3876625403, 2711358621),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(670772096, 1720394949),
                new $Uint64(2422890877, 1157728226),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2985948768, 2150493686),
                new $Uint64(3028613596, 2520902106),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1584952312, 2688117107),
                new $Uint64(3785766995, 3151127633),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3674949755, 1680073192),
                new $Uint64(2366104372, 1432583858),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2446203546, 1026349666),
                new $Uint64(2957630465, 1790729823),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1984012608, 3430420731),
                new $Uint64(3697038081, 3312154103),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2850620616, 2144012957),
                new $Uint64(2310648801, 459483578),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1415792122, 2680016196),
                new $Uint64(2888311001, 1648096297),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2843481977, 1202536597),
                new $Uint64(3610388751, 3133862195),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1240305323, 3435939933),
                new $Uint64(2256492969, 3569276608),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1550381654, 3221183092),
                new $Uint64(2820616212, 1240370288),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1937977068, 1878995217),
                new $Uint64(3525770265, 1550462860),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3358719315, 3321855659),
                new $Uint64(2203606415, 3653393847),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3124657320, 3078577749),
                new $Uint64(2754508019, 3493000485),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(684596178, 3848222187),
                new $Uint64(3443135024, 3292508783),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2038485347, 3478880691),
                new $Uint64(2151959390, 2057817989),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3621848508, 3274859039),
                new $Uint64(2689949238, 424788838),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2379826987, 4093573799),
                new $Uint64(3362436547, 2678469696),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2974783734, 4043225425),
                new $Uint64(4203045684, 2274345296),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1859239834, 1453274067),
                new $Uint64(2626903552, 3568949458),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(176566144, 3964076232),
                new $Uint64(3283629441, 166219527),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3441933153, 660127994),
                new $Uint64(4104536801, 1281516232),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2151208220, 3096934556),
                new $Uint64(2565335500, 3485302205),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3762752099, 3871168195),
                new $Uint64(3206669376, 61660460),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(408472828, 3765218420),
                new $Uint64(4008336720, 77075576),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(255295518, 205777864),
                new $Uint64(2505210450, 48172235),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3540344869, 2404705978),
                new $Uint64(3131513062, 2207698941),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1204205614, 4079624297),
                new $Uint64(3914391328, 612140029),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1289499421, 1476023361),
                new $Uint64(2446494580, 382587518),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3759357924, 2918771026),
                new $Uint64(3058118225, 478234397),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1477971933, 3648463782),
                new $Uint64(3822647781, 1671534821),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1460603370, 2817160776),
                new $Uint64(2389154863, 1581580175),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(752012389, 1373967322),
                new $Uint64(2986443579, 903233395),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4161240958, 2791200977),
                new $Uint64(3733054474, 55299919),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4211388335, 670758786),
                new $Uint64(2333159046, 1108304273),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2043009946, 4059673955),
                new $Uint64(2916448807, 3532863990),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(406278785, 2927108796),
                new $Uint64(3645561009, 3342338164),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2401407889, 218830261),
                new $Uint64(2278475631, 478348616),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3001759861, 1347279650),
                new $Uint64(2848094538, 3819161242),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1604716178, 2757841387),
                new $Uint64(3560118173, 2626467905),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3687302171, 2797392691),
                new $Uint64(2225073858, 2178413352),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(314160418, 2422999040),
                new $Uint64(2781342323, 575533043),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3613925995, 881265152),
                new $Uint64(3476677903, 3940641775),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3869316483, 13919808),
                new $Uint64(2172923689, 4073513845),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1615420131, 3238625232),
                new $Uint64(2716154612, 1870666835),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(945533340, 2974539716),
                new $Uint64(3395193265, 2338333544),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1181916675, 3718174645),
                new $Uint64(4243991581, 3996658754),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1812439746, 1786988241),
                new $Uint64(2652494738, 3034782633),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3339291507, 86251653),
                new $Uint64(3315618423, 1645994643),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3100372559, 3329040039),
                new $Uint64(4144523029, 983751480),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1937732849, 3691262760),
                new $Uint64(2590326893, 1151715587),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1348424238, 1392852978),
                new $Uint64(3237908616, 2513386308),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1685530297, 3888549871),
                new $Uint64(4047385770, 3141732885),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1590327348, 819730933),
                new $Uint64(2529616106, 3037324877),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3061651009, 1024663666),
                new $Uint64(3162020133, 1649172448),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3827063761, 2354571407),
                new $Uint64(3952525166, 3135207384),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2391914850, 4155961689),
                new $Uint64(2470328229, 885762791),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1916151739, 3047468464),
                new $Uint64(3087910286, 2180945313),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3468931498, 2735593756),
                new $Uint64(3859887858, 578697993),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(557469450, 2783487921),
                new $Uint64(2412429911, 1435428070),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2844320461, 1331876253),
                new $Uint64(3015537389, 720543263),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2481658752, 2738587141),
                new $Uint64(3769421736, 1974420903),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3161649456, 1711616963),
                new $Uint64(2355888585, 1234013064),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(3952061820, 2139521204),
                new $Uint64(2944860731, 2616258154),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2792593627, 2674401505),
                new $Uint64(3681075914, 2196580869),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2282241929, 1134630028),
                new $Uint64(2300672446, 2446604867),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1779060587, 2492029360),
                new $Uint64(2875840558, 910772436),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(2223825734, 2041294876),
                new $Uint64(3594800697, 3285949193),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(4074245644, 202067473),
                new $Uint64(2246750436, 443105509),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1871581583, 252584341),
                new $Uint64(2808438045, 553881887),
              ]),
              $toNativeArray($kindUint64, [
                new $Uint64(1265735154, 3536955899),
                new $Uint64(3510547556, 1766094183),
              ]),
            ]);
            leftcheats = new sliceType$2([
              new leftCheat.ptr(0, ""),
              new leftCheat.ptr(1, "5"),
              new leftCheat.ptr(1, "25"),
              new leftCheat.ptr(1, "125"),
              new leftCheat.ptr(2, "625"),
              new leftCheat.ptr(2, "3125"),
              new leftCheat.ptr(2, "15625"),
              new leftCheat.ptr(3, "78125"),
              new leftCheat.ptr(3, "390625"),
              new leftCheat.ptr(3, "1953125"),
              new leftCheat.ptr(4, "9765625"),
              new leftCheat.ptr(4, "48828125"),
              new leftCheat.ptr(4, "244140625"),
              new leftCheat.ptr(4, "1220703125"),
              new leftCheat.ptr(5, "6103515625"),
              new leftCheat.ptr(5, "30517578125"),
              new leftCheat.ptr(5, "152587890625"),
              new leftCheat.ptr(6, "762939453125"),
              new leftCheat.ptr(6, "3814697265625"),
              new leftCheat.ptr(6, "19073486328125"),
              new leftCheat.ptr(7, "95367431640625"),
              new leftCheat.ptr(7, "476837158203125"),
              new leftCheat.ptr(7, "2384185791015625"),
              new leftCheat.ptr(7, "11920928955078125"),
              new leftCheat.ptr(8, "59604644775390625"),
              new leftCheat.ptr(8, "298023223876953125"),
              new leftCheat.ptr(8, "1490116119384765625"),
              new leftCheat.ptr(9, "7450580596923828125"),
              new leftCheat.ptr(9, "37252902984619140625"),
              new leftCheat.ptr(9, "186264514923095703125"),
              new leftCheat.ptr(10, "931322574615478515625"),
              new leftCheat.ptr(10, "4656612873077392578125"),
              new leftCheat.ptr(10, "23283064365386962890625"),
              new leftCheat.ptr(10, "116415321826934814453125"),
              new leftCheat.ptr(11, "582076609134674072265625"),
              new leftCheat.ptr(11, "2910383045673370361328125"),
              new leftCheat.ptr(11, "14551915228366851806640625"),
              new leftCheat.ptr(12, "72759576141834259033203125"),
              new leftCheat.ptr(12, "363797880709171295166015625"),
              new leftCheat.ptr(12, "1818989403545856475830078125"),
              new leftCheat.ptr(13, "9094947017729282379150390625"),
              new leftCheat.ptr(13, "45474735088646411895751953125"),
              new leftCheat.ptr(13, "227373675443232059478759765625"),
              new leftCheat.ptr(13, "1136868377216160297393798828125"),
              new leftCheat.ptr(14, "5684341886080801486968994140625"),
              new leftCheat.ptr(14, "28421709430404007434844970703125"),
              new leftCheat.ptr(14, "142108547152020037174224853515625"),
              new leftCheat.ptr(15, "710542735760100185871124267578125"),
              new leftCheat.ptr(15, "3552713678800500929355621337890625"),
              new leftCheat.ptr(15, "17763568394002504646778106689453125"),
              new leftCheat.ptr(16, "88817841970012523233890533447265625"),
              new leftCheat.ptr(16, "444089209850062616169452667236328125"),
              new leftCheat.ptr(16, "2220446049250313080847263336181640625"),
              new leftCheat.ptr(16, "11102230246251565404236316680908203125"),
              new leftCheat.ptr(17, "55511151231257827021181583404541015625"),
              new leftCheat.ptr(17, "277555756156289135105907917022705078125"),
              new leftCheat.ptr(17, "1387778780781445675529539585113525390625"),
              new leftCheat.ptr(18, "6938893903907228377647697925567626953125"),
              new leftCheat.ptr(
                18,
                "34694469519536141888238489627838134765625"
              ),
              new leftCheat.ptr(
                18,
                "173472347597680709441192448139190673828125"
              ),
              new leftCheat.ptr(
                19,
                "867361737988403547205962240695953369140625"
              ),
            ]);
            $pkg.ErrRange = errors.New("value out of range");
            $pkg.ErrSyntax = errors.New("invalid syntax");
            optimize = true;
            powtab = new sliceType$3([1, 3, 6, 9, 13, 16, 19, 23, 26]);
            float64pow10 = new sliceType$4([
              1, 10, 100, 1000, 10000, 100000, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11,
              1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22,
            ]);
            float32pow10 = new sliceType$5([
              1, 10, 100, 1000, 10000, 100000, 1e6, 1e7, 1e8, 1e9, 1e10,
            ]);
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/race"] = (function () {
    var $pkg = {},
      $init,
      Acquire,
      Release,
      ReleaseMerge,
      Disable,
      Enable;
    Acquire = function (addr) {
      var addr;
    };
    $pkg.Acquire = Acquire;
    Release = function (addr) {
      var addr;
    };
    $pkg.Release = Release;
    ReleaseMerge = function (addr) {
      var addr;
    };
    $pkg.ReleaseMerge = ReleaseMerge;
    Disable = function () {};
    $pkg.Disable = Disable;
    Enable = function () {};
    $pkg.Enable = Enable;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["sync/atomic"] = (function () {
    var $pkg = {},
      $init,
      js,
      Value,
      ptrType,
      CompareAndSwapInt32,
      CompareAndSwapUint64,
      AddInt32,
      LoadInt32,
      LoadUint64,
      StoreInt32,
      StoreUint32,
      sameType;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    Value = $pkg.Value = $newType(
      0,
      $kindStruct,
      "atomic.Value",
      true,
      "sync/atomic",
      true,
      function (v_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.v = $ifaceNil;
          return;
        }
        this.v = v_;
      }
    );
    ptrType = $ptrType(Value);
    CompareAndSwapInt32 = function (addr, old, new$1) {
      var addr, new$1, old;
      if (addr.$get() === old) {
        addr.$set(new$1);
        return true;
      }
      return false;
    };
    $pkg.CompareAndSwapInt32 = CompareAndSwapInt32;
    CompareAndSwapUint64 = function (addr, old, new$1) {
      var addr, new$1, old, x;
      if (((x = addr.$get()), x.$high === old.$high && x.$low === old.$low)) {
        addr.$set(new$1);
        return true;
      }
      return false;
    };
    $pkg.CompareAndSwapUint64 = CompareAndSwapUint64;
    AddInt32 = function (addr, delta) {
      var addr, delta, new$1;
      new$1 = (addr.$get() + delta) >> 0;
      addr.$set(new$1);
      return new$1;
    };
    $pkg.AddInt32 = AddInt32;
    LoadInt32 = function (addr) {
      var addr;
      return addr.$get();
    };
    $pkg.LoadInt32 = LoadInt32;
    LoadUint64 = function (addr) {
      var addr;
      return addr.$get();
    };
    $pkg.LoadUint64 = LoadUint64;
    StoreInt32 = function (addr, val) {
      var addr, val;
      addr.$set(val);
    };
    $pkg.StoreInt32 = StoreInt32;
    StoreUint32 = function (addr, val) {
      var addr, val;
      addr.$set(val);
    };
    $pkg.StoreUint32 = StoreUint32;
    Value.ptr.prototype.Load = function () {
      var v, x;
      x = $ifaceNil;
      v = this;
      x = v.v;
      return x;
    };
    Value.prototype.Load = function () {
      return this.$val.Load();
    };
    Value.ptr.prototype.Store = function (new$1) {
      var new$1, v;
      v = this;
      v.checkNew("store", new$1);
      v.v = new$1;
    };
    Value.prototype.Store = function (new$1) {
      return this.$val.Store(new$1);
    };
    Value.ptr.prototype.Swap = function (new$1) {
      var _tmp, _tmp$1, new$1, old, v;
      old = $ifaceNil;
      v = this;
      v.checkNew("swap", new$1);
      _tmp = v.v;
      _tmp$1 = new$1;
      old = _tmp;
      v.v = _tmp$1;
      old = old;
      return old;
    };
    Value.prototype.Swap = function (new$1) {
      return this.$val.Swap(new$1);
    };
    Value.ptr.prototype.CompareAndSwap = function (old, new$1) {
      var new$1, old, swapped, v;
      swapped = false;
      v = this;
      v.checkNew("compare and swap", new$1);
      if (
        !(
          $interfaceIsEqual(v.v, $ifaceNil) && $interfaceIsEqual(old, $ifaceNil)
        ) &&
        !sameType(old, new$1)
      ) {
        $panic(
          new $String(
            "sync/atomic: compare and swap of inconsistently typed values into Value"
          )
        );
      }
      if (!$interfaceIsEqual(v.v, old)) {
        swapped = false;
        return swapped;
      }
      v.v = new$1;
      swapped = true;
      return swapped;
    };
    Value.prototype.CompareAndSwap = function (old, new$1) {
      return this.$val.CompareAndSwap(old, new$1);
    };
    Value.ptr.prototype.checkNew = function (op, new$1) {
      var new$1, op, v;
      v = this;
      if ($interfaceIsEqual(new$1, $ifaceNil)) {
        $panic(new $String("sync/atomic: " + op + " of nil value into Value"));
      }
      if (!$interfaceIsEqual(v.v, $ifaceNil) && !sameType(new$1, v.v)) {
        $panic(
          new $String(
            "sync/atomic: " + op + " of inconsistently typed value into Value"
          )
        );
      }
    };
    Value.prototype.checkNew = function (op, new$1) {
      return this.$val.checkNew(op, new$1);
    };
    sameType = function (x, y) {
      var x, y;
      return x.constructor === y.constructor;
    };
    ptrType.methods = [
      {
        prop: "Load",
        name: "Load",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
      {
        prop: "Store",
        name: "Store",
        pkg: "",
        typ: $funcType([$emptyInterface], [], false),
      },
      {
        prop: "Swap",
        name: "Swap",
        pkg: "",
        typ: $funcType([$emptyInterface], [$emptyInterface], false),
      },
      {
        prop: "CompareAndSwap",
        name: "CompareAndSwap",
        pkg: "",
        typ: $funcType([$emptyInterface, $emptyInterface], [$Bool], false),
      },
      {
        prop: "checkNew",
        name: "checkNew",
        pkg: "sync/atomic",
        typ: $funcType([$String, $emptyInterface], [], false),
      },
    ];
    Value.init("sync/atomic", [
      {
        prop: "v",
        name: "v",
        embedded: false,
        exported: false,
        typ: $emptyInterface,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["sync"] = (function () {
    var $pkg = {},
      $init,
      js,
      race,
      atomic,
      RWMutex,
      rlocker,
      notifyList,
      Mutex,
      Locker,
      Pool,
      ptrType$1,
      ptrType$2,
      ptrType$3,
      ptrType$4,
      chanType,
      sliceType$2,
      ptrType$15,
      sliceType$3,
      ptrType$18,
      funcType$2,
      expunged,
      semWaiters,
      semAwoken,
      init,
      runtime_doSpin,
      runtime_Semacquire,
      runtime_SemacquireMutex,
      runtime_Semrelease,
      runtime_notifyListCheck,
      runtime_canSpin,
      runtime_nanotime,
      throw$1;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    race = $packages["internal/race"];
    atomic = $packages["sync/atomic"];
    RWMutex = $pkg.RWMutex = $newType(
      0,
      $kindStruct,
      "sync.RWMutex",
      true,
      "sync",
      true,
      function (w_, writerSem_, readerSem_, readerCount_, readerWait_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.w = new Mutex.ptr(0, 0);
          this.writerSem = 0;
          this.readerSem = 0;
          this.readerCount = 0;
          this.readerWait = 0;
          return;
        }
        this.w = w_;
        this.writerSem = writerSem_;
        this.readerSem = readerSem_;
        this.readerCount = readerCount_;
        this.readerWait = readerWait_;
      }
    );
    rlocker = $pkg.rlocker = $newType(
      0,
      $kindStruct,
      "sync.rlocker",
      true,
      "sync",
      false,
      function (w_, writerSem_, readerSem_, readerCount_, readerWait_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.w = new Mutex.ptr(0, 0);
          this.writerSem = 0;
          this.readerSem = 0;
          this.readerCount = 0;
          this.readerWait = 0;
          return;
        }
        this.w = w_;
        this.writerSem = writerSem_;
        this.readerSem = readerSem_;
        this.readerCount = readerCount_;
        this.readerWait = readerWait_;
      }
    );
    notifyList = $pkg.notifyList = $newType(
      0,
      $kindStruct,
      "sync.notifyList",
      true,
      "sync",
      false,
      function (wait_, notify_, lock_, head_, tail_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.wait = 0;
          this.notify = 0;
          this.lock = 0;
          this.head = 0;
          this.tail = 0;
          return;
        }
        this.wait = wait_;
        this.notify = notify_;
        this.lock = lock_;
        this.head = head_;
        this.tail = tail_;
      }
    );
    Mutex = $pkg.Mutex = $newType(
      0,
      $kindStruct,
      "sync.Mutex",
      true,
      "sync",
      true,
      function (state_, sema_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.state = 0;
          this.sema = 0;
          return;
        }
        this.state = state_;
        this.sema = sema_;
      }
    );
    Locker = $pkg.Locker = $newType(
      8,
      $kindInterface,
      "sync.Locker",
      true,
      "sync",
      true,
      null
    );
    Pool = $pkg.Pool = $newType(
      0,
      $kindStruct,
      "sync.Pool",
      true,
      "sync",
      true,
      function (store_, New_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.store = sliceType$3.nil;
          this.New = $throwNilPointerError;
          return;
        }
        this.store = store_;
        this.New = New_;
      }
    );
    ptrType$1 = $ptrType($Uint32);
    ptrType$2 = $ptrType($Int32);
    ptrType$3 = $ptrType(rlocker);
    ptrType$4 = $ptrType(RWMutex);
    chanType = $chanType($Bool, false, false);
    sliceType$2 = $sliceType(chanType);
    ptrType$15 = $ptrType(Mutex);
    sliceType$3 = $sliceType($emptyInterface);
    ptrType$18 = $ptrType(Pool);
    funcType$2 = $funcType([], [$emptyInterface], false);
    RWMutex.ptr.prototype.RLock = function () {
      var { rw, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if (false) {
              $unused(rw.w.state);
              race.Disable();
            }
            /* */ if (
              atomic.AddInt32(
                rw.$ptr_readerCount ||
                  (rw.$ptr_readerCount = new ptrType$2(
                    function () {
                      return this.$target.readerCount;
                    },
                    function ($v) {
                      this.$target.readerCount = $v;
                    },
                    rw
                  )),
                1
              ) < 0
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$2(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1) < 0) { */ case 1:
            $r = runtime_SemacquireMutex(
              rw.$ptr_readerSem ||
                (rw.$ptr_readerSem = new ptrType$1(
                  function () {
                    return this.$target.readerSem;
                  },
                  function ($v) {
                    this.$target.readerSem = $v;
                  },
                  rw
                )),
              false,
              0
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            if (false) {
              race.Enable();
              race.Acquire(
                rw.$ptr_readerSem ||
                  (rw.$ptr_readerSem = new ptrType$1(
                    function () {
                      return this.$target.readerSem;
                    },
                    function ($v) {
                      this.$target.readerSem = $v;
                    },
                    rw
                  ))
              );
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: RWMutex.ptr.prototype.RLock, $c: true, $r, rw, $s };
      return $f;
    };
    RWMutex.prototype.RLock = function () {
      return this.$val.RLock();
    };
    RWMutex.ptr.prototype.TryRLock = function () {
      var c, rw;
      rw = this;
      if (false) {
        $unused(rw.w.state);
        race.Disable();
      }
      while (true) {
        c = atomic.LoadInt32(
          rw.$ptr_readerCount ||
            (rw.$ptr_readerCount = new ptrType$2(
              function () {
                return this.$target.readerCount;
              },
              function ($v) {
                this.$target.readerCount = $v;
              },
              rw
            ))
        );
        if (c < 0) {
          if (false) {
            race.Enable();
          }
          return false;
        }
        if (
          atomic.CompareAndSwapInt32(
            rw.$ptr_readerCount ||
              (rw.$ptr_readerCount = new ptrType$2(
                function () {
                  return this.$target.readerCount;
                },
                function ($v) {
                  this.$target.readerCount = $v;
                },
                rw
              )),
            c,
            (c + 1) >> 0
          )
        ) {
          if (false) {
            race.Enable();
            race.Acquire(
              rw.$ptr_readerSem ||
                (rw.$ptr_readerSem = new ptrType$1(
                  function () {
                    return this.$target.readerSem;
                  },
                  function ($v) {
                    this.$target.readerSem = $v;
                  },
                  rw
                ))
            );
          }
          return true;
        }
      }
    };
    RWMutex.prototype.TryRLock = function () {
      return this.$val.TryRLock();
    };
    RWMutex.ptr.prototype.RUnlock = function () {
      var { r, rw, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if (false) {
              $unused(rw.w.state);
              race.ReleaseMerge(
                rw.$ptr_writerSem ||
                  (rw.$ptr_writerSem = new ptrType$1(
                    function () {
                      return this.$target.writerSem;
                    },
                    function ($v) {
                      this.$target.writerSem = $v;
                    },
                    rw
                  ))
              );
              race.Disable();
            }
            r = atomic.AddInt32(
              rw.$ptr_readerCount ||
                (rw.$ptr_readerCount = new ptrType$2(
                  function () {
                    return this.$target.readerCount;
                  },
                  function ($v) {
                    this.$target.readerCount = $v;
                  },
                  rw
                )),
              -1
            );
            /* */ if (r < 0) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (r < 0) { */ case 1:
            $r = rw.rUnlockSlow(r);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            if (false) {
              race.Enable();
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: RWMutex.ptr.prototype.RUnlock, $c: true, $r, r, rw, $s };
      return $f;
    };
    RWMutex.prototype.RUnlock = function () {
      return this.$val.RUnlock();
    };
    RWMutex.ptr.prototype.rUnlockSlow = function (r) {
      var { r, rw, $s, $r, $c } = $restore(this, { r });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if ((r + 1) >> 0 === 0 || (r + 1) >> 0 === -1073741824) {
              race.Enable();
              throw$1("sync: RUnlock of unlocked RWMutex");
            }
            /* */ if (
              atomic.AddInt32(
                rw.$ptr_readerWait ||
                  (rw.$ptr_readerWait = new ptrType$2(
                    function () {
                      return this.$target.readerWait;
                    },
                    function ($v) {
                      this.$target.readerWait = $v;
                    },
                    rw
                  )),
                -1
              ) === 0
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$2(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), -1) === 0) { */ case 1:
            $r = runtime_Semrelease(
              rw.$ptr_writerSem ||
                (rw.$ptr_writerSem = new ptrType$1(
                  function () {
                    return this.$target.writerSem;
                  },
                  function ($v) {
                    this.$target.writerSem = $v;
                  },
                  rw
                )),
              false,
              1
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: RWMutex.ptr.prototype.rUnlockSlow,
        $c: true,
        $r,
        r,
        rw,
        $s,
      };
      return $f;
    };
    RWMutex.prototype.rUnlockSlow = function (r) {
      return this.$val.rUnlockSlow(r);
    };
    RWMutex.ptr.prototype.Lock = function () {
      var { r, rw, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if (false) {
              $unused(rw.w.state);
              race.Disable();
            }
            $r = rw.w.Lock();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            r =
              (atomic.AddInt32(
                rw.$ptr_readerCount ||
                  (rw.$ptr_readerCount = new ptrType$2(
                    function () {
                      return this.$target.readerCount;
                    },
                    function ($v) {
                      this.$target.readerCount = $v;
                    },
                    rw
                  )),
                -1073741824
              ) +
                1073741824) >>
              0;
            /* */ if (
              !(r === 0) &&
              !(
                atomic.AddInt32(
                  rw.$ptr_readerWait ||
                    (rw.$ptr_readerWait = new ptrType$2(
                      function () {
                        return this.$target.readerWait;
                      },
                      function ($v) {
                        this.$target.readerWait = $v;
                      },
                      rw
                    )),
                  r
                ) === 0
              )
            ) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!((r === 0)) && !((atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$2(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), r) === 0))) { */ case 2:
            $r = runtime_SemacquireMutex(
              rw.$ptr_writerSem ||
                (rw.$ptr_writerSem = new ptrType$1(
                  function () {
                    return this.$target.writerSem;
                  },
                  function ($v) {
                    this.$target.writerSem = $v;
                  },
                  rw
                )),
              false,
              0
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 3:
            if (false) {
              race.Enable();
              race.Acquire(
                rw.$ptr_readerSem ||
                  (rw.$ptr_readerSem = new ptrType$1(
                    function () {
                      return this.$target.readerSem;
                    },
                    function ($v) {
                      this.$target.readerSem = $v;
                    },
                    rw
                  ))
              );
              race.Acquire(
                rw.$ptr_writerSem ||
                  (rw.$ptr_writerSem = new ptrType$1(
                    function () {
                      return this.$target.writerSem;
                    },
                    function ($v) {
                      this.$target.writerSem = $v;
                    },
                    rw
                  ))
              );
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: RWMutex.ptr.prototype.Lock, $c: true, $r, r, rw, $s };
      return $f;
    };
    RWMutex.prototype.Lock = function () {
      return this.$val.Lock();
    };
    RWMutex.ptr.prototype.TryLock = function () {
      var { rw, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if (false) {
              $unused(rw.w.state);
              race.Disable();
            }
            if (!rw.w.TryLock()) {
              if (false) {
                race.Enable();
              }
              $s = -1;
              return false;
            }
            /* */ if (
              !atomic.CompareAndSwapInt32(
                rw.$ptr_readerCount ||
                  (rw.$ptr_readerCount = new ptrType$2(
                    function () {
                      return this.$target.readerCount;
                    },
                    function ($v) {
                      this.$target.readerCount = $v;
                    },
                    rw
                  )),
                0,
                -1073741824
              )
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!atomic.CompareAndSwapInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$2(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 0, -1073741824)) { */ case 1:
            $r = rw.w.Unlock();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (false) {
              race.Enable();
            }
            $s = -1;
            return false;
          /* } */ case 2:
            if (false) {
              race.Enable();
              race.Acquire(
                rw.$ptr_readerSem ||
                  (rw.$ptr_readerSem = new ptrType$1(
                    function () {
                      return this.$target.readerSem;
                    },
                    function ($v) {
                      this.$target.readerSem = $v;
                    },
                    rw
                  ))
              );
              race.Acquire(
                rw.$ptr_writerSem ||
                  (rw.$ptr_writerSem = new ptrType$1(
                    function () {
                      return this.$target.writerSem;
                    },
                    function ($v) {
                      this.$target.writerSem = $v;
                    },
                    rw
                  ))
              );
            }
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = { $blk: RWMutex.ptr.prototype.TryLock, $c: true, $r, rw, $s };
      return $f;
    };
    RWMutex.prototype.TryLock = function () {
      return this.$val.TryLock();
    };
    RWMutex.ptr.prototype.Unlock = function () {
      var { i, r, rw, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            rw = this;
            if (false) {
              $unused(rw.w.state);
              race.Release(
                rw.$ptr_readerSem ||
                  (rw.$ptr_readerSem = new ptrType$1(
                    function () {
                      return this.$target.readerSem;
                    },
                    function ($v) {
                      this.$target.readerSem = $v;
                    },
                    rw
                  ))
              );
              race.Disable();
            }
            r = atomic.AddInt32(
              rw.$ptr_readerCount ||
                (rw.$ptr_readerCount = new ptrType$2(
                  function () {
                    return this.$target.readerCount;
                  },
                  function ($v) {
                    this.$target.readerCount = $v;
                  },
                  rw
                )),
              1073741824
            );
            if (r >= 1073741824) {
              race.Enable();
              throw$1("sync: Unlock of unlocked RWMutex");
            }
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < ((r >> 0)))) { break; } */ if (!(i < r >> 0)) {
              $s = 2;
              continue;
            }
            $r = runtime_Semrelease(
              rw.$ptr_readerSem ||
                (rw.$ptr_readerSem = new ptrType$1(
                  function () {
                    return this.$target.readerSem;
                  },
                  function ($v) {
                    this.$target.readerSem = $v;
                  },
                  rw
                )),
              false,
              0
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $r = rw.w.Unlock();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (false) {
              race.Enable();
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: RWMutex.ptr.prototype.Unlock,
        $c: true,
        $r,
        i,
        r,
        rw,
        $s,
      };
      return $f;
    };
    RWMutex.prototype.Unlock = function () {
      return this.$val.Unlock();
    };
    RWMutex.ptr.prototype.RLocker = function () {
      var rw;
      rw = this;
      return $pointerOfStructConversion(rw, ptrType$3);
    };
    RWMutex.prototype.RLocker = function () {
      return this.$val.RLocker();
    };
    rlocker.ptr.prototype.Lock = function () {
      var { r, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            r = this;
            $r = $pointerOfStructConversion(r, ptrType$4).RLock();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: rlocker.ptr.prototype.Lock, $c: true, $r, r, $s };
      return $f;
    };
    rlocker.prototype.Lock = function () {
      return this.$val.Lock();
    };
    rlocker.ptr.prototype.Unlock = function () {
      var { r, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            r = this;
            $r = $pointerOfStructConversion(r, ptrType$4).RUnlock();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: rlocker.ptr.prototype.Unlock, $c: true, $r, r, $s };
      return $f;
    };
    rlocker.prototype.Unlock = function () {
      return this.$val.Unlock();
    };
    init = function () {
      var n;
      n = new notifyList.ptr(0, 0, 0, 0, 0);
      runtime_notifyListCheck(20);
    };
    runtime_doSpin = function () {
      $throwRuntimeError(
        "native function not implemented: sync.runtime_doSpin"
      );
    };
    Mutex.ptr.prototype.Lock = function () {
      var { m, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            m = this;
            if (
              atomic.CompareAndSwapInt32(
                m.$ptr_state ||
                  (m.$ptr_state = new ptrType$2(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    m
                  )),
                0,
                1
              )
            ) {
              if (false) {
                race.Acquire(m);
              }
              $s = -1;
              return;
            }
            $r = m.lockSlow();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: Mutex.ptr.prototype.Lock, $c: true, $r, m, $s };
      return $f;
    };
    Mutex.prototype.Lock = function () {
      return this.$val.Lock();
    };
    Mutex.ptr.prototype.TryLock = function () {
      var m, old;
      m = this;
      old = m.state;
      if (!((old & 5) === 0)) {
        return false;
      }
      if (
        !atomic.CompareAndSwapInt32(
          m.$ptr_state ||
            (m.$ptr_state = new ptrType$2(
              function () {
                return this.$target.state;
              },
              function ($v) {
                this.$target.state = $v;
              },
              m
            )),
          old,
          old | 1
        )
      ) {
        return false;
      }
      if (false) {
        race.Acquire(m);
      }
      return true;
    };
    Mutex.prototype.TryLock = function () {
      return this.$val.TryLock();
    };
    Mutex.ptr.prototype.lockSlow = function () {
      var {
        awoke,
        delta,
        iter,
        m,
        new$1,
        old,
        queueLifo,
        starving,
        waitStartTime,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            m = this;
            waitStartTime = new $Int64(0, 0);
            starving = false;
            awoke = false;
            iter = 0;
            old = m.state;
          /* while (true) { */ case 1:
            /* */ if ((old & 5) === 1 && runtime_canSpin(iter)) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (((old & 5) === 1) && runtime_canSpin(iter)) { */ case 3:
            if (
              !awoke &&
              (old & 2) === 0 &&
              !((old >> 3) >> 0 === 0) &&
              atomic.CompareAndSwapInt32(
                m.$ptr_state ||
                  (m.$ptr_state = new ptrType$2(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    m
                  )),
                old,
                old | 2
              )
            ) {
              awoke = true;
            }
            $r = runtime_doSpin();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            iter = (iter + 1) >> 0;
            old = m.state;
            /* continue; */ $s = 1;
            continue;
          /* } */ case 4:
            new$1 = old;
            if ((old & 4) === 0) {
              new$1 = new$1 | 1;
            }
            if (!((old & 5) === 0)) {
              new$1 = (new$1 + 8) >> 0;
            }
            if (starving && !((old & 1) === 0)) {
              new$1 = new$1 | 4;
            }
            if (awoke) {
              if ((new$1 & 2) === 0) {
                throw$1("sync: inconsistent mutex state");
              }
              new$1 = (new$1 & ~2) >> 0;
            }
            /* */ if (
              atomic.CompareAndSwapInt32(
                m.$ptr_state ||
                  (m.$ptr_state = new ptrType$2(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    m
                  )),
                old,
                new$1
              )
            ) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$2(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
            if ((old & 5) === 0) {
              /* break; */ $s = 2;
              continue;
            }
            queueLifo = !(
              waitStartTime.$high === 0 && waitStartTime.$low === 0
            );
            if (waitStartTime.$high === 0 && waitStartTime.$low === 0) {
              waitStartTime = runtime_nanotime();
            }
            $r = runtime_SemacquireMutex(
              m.$ptr_sema ||
                (m.$ptr_sema = new ptrType$1(
                  function () {
                    return this.$target.sema;
                  },
                  function ($v) {
                    this.$target.sema = $v;
                  },
                  m
                )),
              queueLifo,
              1
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            starving =
              starving ||
              ((x =
                ((x$1 = runtime_nanotime()),
                new $Int64(
                  x$1.$high - waitStartTime.$high,
                  x$1.$low - waitStartTime.$low
                ))),
              x.$high > 0 || (x.$high === 0 && x.$low > 1000000));
            old = m.state;
            if (!((old & 4) === 0)) {
              if (!((old & 3) === 0) || (old >> 3) >> 0 === 0) {
                throw$1("sync: inconsistent mutex state");
              }
              delta = -7;
              if (!starving || (old >> 3) >> 0 === 1) {
                delta = (delta - 4) >> 0;
              }
              atomic.AddInt32(
                m.$ptr_state ||
                  (m.$ptr_state = new ptrType$2(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    m
                  )),
                delta
              );
              /* break; */ $s = 2;
              continue;
            }
            awoke = true;
            iter = 0;
            $s = 8;
            continue;
          /* } else { */ case 7:
            old = m.state;
          /* } */ case 8:
            $s = 1;
            continue;
          case 2:
            if (false) {
              race.Acquire(m);
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Mutex.ptr.prototype.lockSlow,
        $c: true,
        $r,
        awoke,
        delta,
        iter,
        m,
        new$1,
        old,
        queueLifo,
        starving,
        waitStartTime,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    Mutex.prototype.lockSlow = function () {
      return this.$val.lockSlow();
    };
    Mutex.ptr.prototype.Unlock = function () {
      var { m, new$1, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            m = this;
            if (false) {
              $unused(m.state);
              race.Release(m);
            }
            new$1 = atomic.AddInt32(
              m.$ptr_state ||
                (m.$ptr_state = new ptrType$2(
                  function () {
                    return this.$target.state;
                  },
                  function ($v) {
                    this.$target.state = $v;
                  },
                  m
                )),
              -1
            );
            /* */ if (!(new$1 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((new$1 === 0))) { */ case 1:
            $r = m.unlockSlow(new$1);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: Mutex.ptr.prototype.Unlock, $c: true, $r, m, new$1, $s };
      return $f;
    };
    Mutex.prototype.Unlock = function () {
      return this.$val.Unlock();
    };
    Mutex.ptr.prototype.unlockSlow = function (new$1) {
      var { m, new$1, old, $s, $r, $c } = $restore(this, { new$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            m = this;
            if ((((new$1 + 1) >> 0) & 1) === 0) {
              throw$1("sync: unlock of unlocked mutex");
            }
            /* */ if ((new$1 & 4) === 0) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ((new$1 & 4) === 0) { */ case 1:
            old = new$1;
          /* while (true) { */ case 4:
            if ((old >> 3) >> 0 === 0 || !((old & 7) === 0)) {
              $s = -1;
              return;
            }
            new$1 = ((old - 8) >> 0) | 2;
            /* */ if (
              atomic.CompareAndSwapInt32(
                m.$ptr_state ||
                  (m.$ptr_state = new ptrType$2(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    m
                  )),
                old,
                new$1
              )
            ) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$2(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
            $r = runtime_Semrelease(
              m.$ptr_sema ||
                (m.$ptr_sema = new ptrType$1(
                  function () {
                    return this.$target.sema;
                  },
                  function ($v) {
                    this.$target.sema = $v;
                  },
                  m
                )),
              false,
              1
            );
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 7:
            old = m.state;
            $s = 4;
            continue;
          case 5:
            $s = 3;
            continue;
          /* } else { */ case 2:
            $r = runtime_Semrelease(
              m.$ptr_sema ||
                (m.$ptr_sema = new ptrType$1(
                  function () {
                    return this.$target.sema;
                  },
                  function ($v) {
                    this.$target.sema = $v;
                  },
                  m
                )),
              true,
              1
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 3:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Mutex.ptr.prototype.unlockSlow,
        $c: true,
        $r,
        m,
        new$1,
        old,
        $s,
      };
      return $f;
    };
    Mutex.prototype.unlockSlow = function (new$1) {
      return this.$val.unlockSlow(new$1);
    };
    runtime_Semacquire = function (s) {
      var { s, $s, $r, $c } = $restore(this, { s });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            $r = runtime_SemacquireMutex(s, false, 1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: runtime_Semacquire, $c: true, $r, s, $s };
      return $f;
    };
    $linknames["sync.runtime_Semacquire"] = runtime_Semacquire;
    runtime_SemacquireMutex = function (s, lifo, skipframes) {
      var {
        _entry,
        _entry$1,
        _entry$2,
        _entry$3,
        _entry$4,
        _key,
        _key$1,
        _key$2,
        _r,
        ch,
        lifo,
        s,
        skipframes,
        $s,
        $r,
        $c,
      } = $restore(this, { s, lifo, skipframes });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            /* */ if (
              (s.$get() -
                ((_entry = $mapIndex(semAwoken, ptrType$1.keyFor(s))),
                _entry !== undefined ? _entry.v : 0)) >>>
                0 ===
              0
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (((s.$get() - (_entry = $mapIndex(semAwoken,ptrType$1.keyFor(s)), _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { */ case 1:
            ch = new $Chan($Bool, 0);
            if (lifo) {
              _key = s;
              (
                semWaiters ||
                $throwRuntimeError("assignment to entry in nil map")
              ).set(ptrType$1.keyFor(_key), {
                k: _key,
                v: $appendSlice(
                  new sliceType$2([ch]),
                  ((_entry$1 = $mapIndex(semWaiters, ptrType$1.keyFor(s))),
                  _entry$1 !== undefined ? _entry$1.v : sliceType$2.nil)
                ),
              });
            } else {
              _key$1 = s;
              (
                semWaiters ||
                $throwRuntimeError("assignment to entry in nil map")
              ).set(ptrType$1.keyFor(_key$1), {
                k: _key$1,
                v: $append(
                  ((_entry$2 = $mapIndex(semWaiters, ptrType$1.keyFor(s))),
                  _entry$2 !== undefined ? _entry$2.v : sliceType$2.nil),
                  ch
                ),
              });
            }
            _r = $recv(ch);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r[0];
            _key$2 = s;
            (
              semAwoken || $throwRuntimeError("assignment to entry in nil map")
            ).set(ptrType$1.keyFor(_key$2), {
              k: _key$2,
              v:
                (((_entry$3 = $mapIndex(semAwoken, ptrType$1.keyFor(s))),
                _entry$3 !== undefined ? _entry$3.v : 0) -
                  1) >>>
                0,
            });
            if (
              ((_entry$4 = $mapIndex(semAwoken, ptrType$1.keyFor(s))),
              _entry$4 !== undefined ? _entry$4.v : 0) === 0
            ) {
              $mapDelete(semAwoken, ptrType$1.keyFor(s));
            }
          /* } */ case 2:
            s.$set((s.$get() - 1) >>> 0);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: runtime_SemacquireMutex,
        $c: true,
        $r,
        _entry,
        _entry$1,
        _entry$2,
        _entry$3,
        _entry$4,
        _key,
        _key$1,
        _key$2,
        _r,
        ch,
        lifo,
        s,
        skipframes,
        $s,
      };
      return $f;
    };
    runtime_Semrelease = function (s, handoff, skipframes) {
      var {
        _entry,
        _entry$1,
        _key,
        _key$1,
        ch,
        handoff,
        s,
        skipframes,
        w,
        $s,
        $r,
        $c,
      } = $restore(this, { s, handoff, skipframes });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s.$set((s.$get() + 1) >>> 0);
            w =
              ((_entry = $mapIndex(semWaiters, ptrType$1.keyFor(s))),
              _entry !== undefined ? _entry.v : sliceType$2.nil);
            if (w.$length === 0) {
              $s = -1;
              return;
            }
            ch =
              0 >= w.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : w.$array[w.$offset + 0];
            w = $subslice(w, 1);
            _key = s;
            (
              semWaiters || $throwRuntimeError("assignment to entry in nil map")
            ).set(ptrType$1.keyFor(_key), { k: _key, v: w });
            if (w.$length === 0) {
              $mapDelete(semWaiters, ptrType$1.keyFor(s));
            }
            _key$1 = s;
            (
              semAwoken || $throwRuntimeError("assignment to entry in nil map")
            ).set(ptrType$1.keyFor(_key$1), {
              k: _key$1,
              v:
                (((_entry$1 = $mapIndex(semAwoken, ptrType$1.keyFor(s))),
                _entry$1 !== undefined ? _entry$1.v : 0) +
                  1) >>>
                0,
            });
            $r = $send(ch, true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: runtime_Semrelease,
        $c: true,
        $r,
        _entry,
        _entry$1,
        _key,
        _key$1,
        ch,
        handoff,
        s,
        skipframes,
        w,
        $s,
      };
      return $f;
    };
    $linknames["sync.runtime_Semrelease"] = runtime_Semrelease;
    runtime_notifyListCheck = function (size) {
      var size;
    };
    runtime_canSpin = function (i) {
      var i;
      return false;
    };
    runtime_nanotime = function () {
      return $mul64(
        $internalize(new $global.Date().getTime(), $Int64),
        new $Int64(0, 1000000)
      );
    };
    throw$1 = function (s) {
      var s;
      $throwRuntimeError($externalize(s, $String));
    };
    Pool.ptr.prototype.Get = function () {
      var { $24r, _r, p, x, x$1, x$2, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            /* */ if (p.store.$length === 0) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (p.store.$length === 0) { */ case 1:
            /* */ if (!(p.New === $throwNilPointerError)) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!(p.New === $throwNilPointerError)) { */ case 3:
            _r = p.New();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 6;
          case 6:
            return $24r;
          /* } */ case 4:
            $s = -1;
            return $ifaceNil;
          /* } */ case 2:
            x$2 =
              ((x = p.store),
              (x$1 = (p.store.$length - 1) >> 0),
              x$1 < 0 || x$1 >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + x$1]);
            p.store = $subslice(p.store, 0, (p.store.$length - 1) >> 0);
            $s = -1;
            return x$2;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Pool.ptr.prototype.Get,
        $c: true,
        $r,
        $24r,
        _r,
        p,
        x,
        x$1,
        x$2,
        $s,
      };
      return $f;
    };
    Pool.prototype.Get = function () {
      return this.$val.Get();
    };
    Pool.ptr.prototype.Put = function (x) {
      var p, x;
      p = this;
      if ($interfaceIsEqual(x, $ifaceNil)) {
        return;
      }
      p.store = $append(p.store, x);
    };
    Pool.prototype.Put = function (x) {
      return this.$val.Put(x);
    };
    ptrType$4.methods = [
      { prop: "RLock", name: "RLock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "TryRLock",
        name: "TryRLock",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "RUnlock",
        name: "RUnlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "rUnlockSlow",
        name: "rUnlockSlow",
        pkg: "sync",
        typ: $funcType([$Int32], [], false),
      },
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "TryLock",
        name: "TryLock",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "RLocker",
        name: "RLocker",
        pkg: "",
        typ: $funcType([], [Locker], false),
      },
    ];
    ptrType$3.methods = [
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ];
    ptrType$15.methods = [
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "TryLock",
        name: "TryLock",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "lockSlow",
        name: "lockSlow",
        pkg: "sync",
        typ: $funcType([], [], false),
      },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "unlockSlow",
        name: "unlockSlow",
        pkg: "sync",
        typ: $funcType([$Int32], [], false),
      },
    ];
    ptrType$18.methods = [
      {
        prop: "Get",
        name: "Get",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
      {
        prop: "Put",
        name: "Put",
        pkg: "",
        typ: $funcType([$emptyInterface], [], false),
      },
    ];
    RWMutex.init("sync", [
      {
        prop: "w",
        name: "w",
        embedded: false,
        exported: false,
        typ: Mutex,
        tag: "",
      },
      {
        prop: "writerSem",
        name: "writerSem",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "readerSem",
        name: "readerSem",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "readerCount",
        name: "readerCount",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "readerWait",
        name: "readerWait",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
    ]);
    rlocker.init("sync", [
      {
        prop: "w",
        name: "w",
        embedded: false,
        exported: false,
        typ: Mutex,
        tag: "",
      },
      {
        prop: "writerSem",
        name: "writerSem",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "readerSem",
        name: "readerSem",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "readerCount",
        name: "readerCount",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "readerWait",
        name: "readerWait",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
    ]);
    notifyList.init("sync", [
      {
        prop: "wait",
        name: "wait",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "notify",
        name: "notify",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "lock",
        name: "lock",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "head",
        name: "head",
        embedded: false,
        exported: false,
        typ: $UnsafePointer,
        tag: "",
      },
      {
        prop: "tail",
        name: "tail",
        embedded: false,
        exported: false,
        typ: $UnsafePointer,
        tag: "",
      },
    ]);
    Mutex.init("sync", [
      {
        prop: "state",
        name: "state",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "sema",
        name: "sema",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
    ]);
    Locker.init([
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ]);
    Pool.init("sync", [
      {
        prop: "store",
        name: "store",
        embedded: false,
        exported: false,
        typ: sliceType$3,
        tag: "",
      },
      {
        prop: "New",
        name: "New",
        embedded: false,
        exported: true,
        typ: funcType$2,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = race.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = atomic.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            expunged = new Uint8Array(8);
            semWaiters = new $global.Map();
            semAwoken = new $global.Map();
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["unicode"] = (function () {
    var $pkg = {},
      $init,
      RangeTable,
      Range16,
      Range32,
      sliceType,
      sliceType$1,
      _L,
      _Nd,
      properties,
      is16,
      is32,
      isExcludingLatin,
      IsLetter,
      IsDigit;
    RangeTable = $pkg.RangeTable = $newType(
      0,
      $kindStruct,
      "unicode.RangeTable",
      true,
      "unicode",
      true,
      function (R16_, R32_, LatinOffset_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.R16 = sliceType.nil;
          this.R32 = sliceType$1.nil;
          this.LatinOffset = 0;
          return;
        }
        this.R16 = R16_;
        this.R32 = R32_;
        this.LatinOffset = LatinOffset_;
      }
    );
    Range16 = $pkg.Range16 = $newType(
      0,
      $kindStruct,
      "unicode.Range16",
      true,
      "unicode",
      true,
      function (Lo_, Hi_, Stride_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Lo = 0;
          this.Hi = 0;
          this.Stride = 0;
          return;
        }
        this.Lo = Lo_;
        this.Hi = Hi_;
        this.Stride = Stride_;
      }
    );
    Range32 = $pkg.Range32 = $newType(
      0,
      $kindStruct,
      "unicode.Range32",
      true,
      "unicode",
      true,
      function (Lo_, Hi_, Stride_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Lo = 0;
          this.Hi = 0;
          this.Stride = 0;
          return;
        }
        this.Lo = Lo_;
        this.Hi = Hi_;
        this.Stride = Stride_;
      }
    );
    sliceType = $sliceType(Range16);
    sliceType$1 = $sliceType(Range32);
    is16 = function (ranges, r) {
      var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
      if (ranges.$length <= 18 || r <= 255) {
        _ref = ranges;
        _i = 0;
        while (true) {
          if (!(_i < _ref.$length)) {
            break;
          }
          i = _i;
          range_ =
            i < 0 || i >= ranges.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : ranges.$array[ranges.$offset + i];
          if (r < range_.Lo) {
            return false;
          }
          if (r <= range_.Hi) {
            return (
              range_.Stride === 1 ||
              ((_r = (((r - range_.Lo) << 16) >>> 16) % range_.Stride),
              _r === _r ? _r : $throwRuntimeError("integer divide by zero")) ===
                0
            );
          }
          _i++;
        }
        return false;
      }
      lo = 0;
      hi = ranges.$length;
      while (true) {
        if (!(lo < hi)) {
          break;
        }
        m =
          (lo +
            ((_q = ((hi - lo) >> 0) / 2),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >> 0
              : $throwRuntimeError("integer divide by zero"))) >>
          0;
        range_$1 =
          m < 0 || m >= ranges.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : ranges.$array[ranges.$offset + m];
        if (range_$1.Lo <= r && r <= range_$1.Hi) {
          return (
            range_$1.Stride === 1 ||
            ((_r$1 = (((r - range_$1.Lo) << 16) >>> 16) % range_$1.Stride),
            _r$1 === _r$1
              ? _r$1
              : $throwRuntimeError("integer divide by zero")) === 0
          );
        }
        if (r < range_$1.Lo) {
          hi = m;
        } else {
          lo = (m + 1) >> 0;
        }
      }
      return false;
    };
    is32 = function (ranges, r) {
      var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
      if (ranges.$length <= 18) {
        _ref = ranges;
        _i = 0;
        while (true) {
          if (!(_i < _ref.$length)) {
            break;
          }
          i = _i;
          range_ =
            i < 0 || i >= ranges.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : ranges.$array[ranges.$offset + i];
          if (r < range_.Lo) {
            return false;
          }
          if (r <= range_.Hi) {
            return (
              range_.Stride === 1 ||
              ((_r = ((r - range_.Lo) >>> 0) % range_.Stride),
              _r === _r ? _r : $throwRuntimeError("integer divide by zero")) ===
                0
            );
          }
          _i++;
        }
        return false;
      }
      lo = 0;
      hi = ranges.$length;
      while (true) {
        if (!(lo < hi)) {
          break;
        }
        m =
          (lo +
            ((_q = ((hi - lo) >> 0) / 2),
            _q === _q && _q !== 1 / 0 && _q !== -1 / 0
              ? _q >> 0
              : $throwRuntimeError("integer divide by zero"))) >>
          0;
        range_$1 = $clone(
          m < 0 || m >= ranges.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : ranges.$array[ranges.$offset + m],
          Range32
        );
        if (range_$1.Lo <= r && r <= range_$1.Hi) {
          return (
            range_$1.Stride === 1 ||
            ((_r$1 = ((r - range_$1.Lo) >>> 0) % range_$1.Stride),
            _r$1 === _r$1
              ? _r$1
              : $throwRuntimeError("integer divide by zero")) === 0
          );
        }
        if (r < range_$1.Lo) {
          hi = m;
        } else {
          lo = (m + 1) >> 0;
        }
      }
      return false;
    };
    isExcludingLatin = function (rangeTab, r) {
      var off, r, r16, r32, rangeTab, x;
      r16 = rangeTab.R16;
      off = rangeTab.LatinOffset;
      if (
        r16.$length > off &&
        r >>> 0 <=
          ((x = (r16.$length - 1) >> 0),
          x < 0 || x >= r16.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : r16.$array[r16.$offset + x]).Hi >>>
            0
      ) {
        return is16($subslice(r16, off), (r << 16) >>> 16);
      }
      r32 = rangeTab.R32;
      if (
        r32.$length > 0 &&
        r >=
          (0 >= r32.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : r32.$array[r32.$offset + 0]
          ).Lo >>
            0
      ) {
        return is32(r32, r >>> 0);
      }
      return false;
    };
    IsLetter = function (r) {
      var r, x;
      if (r >>> 0 <= 255) {
        return !(
          (((x = (r << 24) >>> 24),
          x < 0 || x >= properties.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : properties[x]) &
            96) >>>
            0 ===
          0
        );
      }
      return isExcludingLatin($pkg.Letter, r);
    };
    $pkg.IsLetter = IsLetter;
    IsDigit = function (r) {
      var r;
      if (r <= 255) {
        return 48 <= r && r <= 57;
      }
      return isExcludingLatin($pkg.Digit, r);
    };
    $pkg.IsDigit = IsDigit;
    RangeTable.init("", [
      {
        prop: "R16",
        name: "R16",
        embedded: false,
        exported: true,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "R32",
        name: "R32",
        embedded: false,
        exported: true,
        typ: sliceType$1,
        tag: "",
      },
      {
        prop: "LatinOffset",
        name: "LatinOffset",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    Range16.init("", [
      {
        prop: "Lo",
        name: "Lo",
        embedded: false,
        exported: true,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "Hi",
        name: "Hi",
        embedded: false,
        exported: true,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "Stride",
        name: "Stride",
        embedded: false,
        exported: true,
        typ: $Uint16,
        tag: "",
      },
    ]);
    Range32.init("", [
      {
        prop: "Lo",
        name: "Lo",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Hi",
        name: "Hi",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Stride",
        name: "Stride",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            _L = new RangeTable.ptr(
              new sliceType([
                new Range16.ptr(65, 90, 1),
                new Range16.ptr(97, 122, 1),
                new Range16.ptr(170, 181, 11),
                new Range16.ptr(186, 192, 6),
                new Range16.ptr(193, 214, 1),
                new Range16.ptr(216, 246, 1),
                new Range16.ptr(248, 705, 1),
                new Range16.ptr(710, 721, 1),
                new Range16.ptr(736, 740, 1),
                new Range16.ptr(748, 750, 2),
                new Range16.ptr(880, 884, 1),
                new Range16.ptr(886, 887, 1),
                new Range16.ptr(890, 893, 1),
                new Range16.ptr(895, 902, 7),
                new Range16.ptr(904, 906, 1),
                new Range16.ptr(908, 910, 2),
                new Range16.ptr(911, 929, 1),
                new Range16.ptr(931, 1013, 1),
                new Range16.ptr(1015, 1153, 1),
                new Range16.ptr(1162, 1327, 1),
                new Range16.ptr(1329, 1366, 1),
                new Range16.ptr(1369, 1376, 7),
                new Range16.ptr(1377, 1416, 1),
                new Range16.ptr(1488, 1514, 1),
                new Range16.ptr(1519, 1522, 1),
                new Range16.ptr(1568, 1610, 1),
                new Range16.ptr(1646, 1647, 1),
                new Range16.ptr(1649, 1747, 1),
                new Range16.ptr(1749, 1765, 16),
                new Range16.ptr(1766, 1774, 8),
                new Range16.ptr(1775, 1786, 11),
                new Range16.ptr(1787, 1788, 1),
                new Range16.ptr(1791, 1808, 17),
                new Range16.ptr(1810, 1839, 1),
                new Range16.ptr(1869, 1957, 1),
                new Range16.ptr(1969, 1994, 25),
                new Range16.ptr(1995, 2026, 1),
                new Range16.ptr(2036, 2037, 1),
                new Range16.ptr(2042, 2048, 6),
                new Range16.ptr(2049, 2069, 1),
                new Range16.ptr(2074, 2084, 10),
                new Range16.ptr(2088, 2112, 24),
                new Range16.ptr(2113, 2136, 1),
                new Range16.ptr(2144, 2154, 1),
                new Range16.ptr(2208, 2228, 1),
                new Range16.ptr(2230, 2247, 1),
                new Range16.ptr(2308, 2361, 1),
                new Range16.ptr(2365, 2384, 19),
                new Range16.ptr(2392, 2401, 1),
                new Range16.ptr(2417, 2432, 1),
                new Range16.ptr(2437, 2444, 1),
                new Range16.ptr(2447, 2448, 1),
                new Range16.ptr(2451, 2472, 1),
                new Range16.ptr(2474, 2480, 1),
                new Range16.ptr(2482, 2486, 4),
                new Range16.ptr(2487, 2489, 1),
                new Range16.ptr(2493, 2510, 17),
                new Range16.ptr(2524, 2525, 1),
                new Range16.ptr(2527, 2529, 1),
                new Range16.ptr(2544, 2545, 1),
                new Range16.ptr(2556, 2565, 9),
                new Range16.ptr(2566, 2570, 1),
                new Range16.ptr(2575, 2576, 1),
                new Range16.ptr(2579, 2600, 1),
                new Range16.ptr(2602, 2608, 1),
                new Range16.ptr(2610, 2611, 1),
                new Range16.ptr(2613, 2614, 1),
                new Range16.ptr(2616, 2617, 1),
                new Range16.ptr(2649, 2652, 1),
                new Range16.ptr(2654, 2674, 20),
                new Range16.ptr(2675, 2676, 1),
                new Range16.ptr(2693, 2701, 1),
                new Range16.ptr(2703, 2705, 1),
                new Range16.ptr(2707, 2728, 1),
                new Range16.ptr(2730, 2736, 1),
                new Range16.ptr(2738, 2739, 1),
                new Range16.ptr(2741, 2745, 1),
                new Range16.ptr(2749, 2768, 19),
                new Range16.ptr(2784, 2785, 1),
                new Range16.ptr(2809, 2821, 12),
                new Range16.ptr(2822, 2828, 1),
                new Range16.ptr(2831, 2832, 1),
                new Range16.ptr(2835, 2856, 1),
                new Range16.ptr(2858, 2864, 1),
                new Range16.ptr(2866, 2867, 1),
                new Range16.ptr(2869, 2873, 1),
                new Range16.ptr(2877, 2908, 31),
                new Range16.ptr(2909, 2911, 2),
                new Range16.ptr(2912, 2913, 1),
                new Range16.ptr(2929, 2947, 18),
                new Range16.ptr(2949, 2954, 1),
                new Range16.ptr(2958, 2960, 1),
                new Range16.ptr(2962, 2965, 1),
                new Range16.ptr(2969, 2970, 1),
                new Range16.ptr(2972, 2974, 2),
                new Range16.ptr(2975, 2979, 4),
                new Range16.ptr(2980, 2984, 4),
                new Range16.ptr(2985, 2986, 1),
                new Range16.ptr(2990, 3001, 1),
                new Range16.ptr(3024, 3077, 53),
                new Range16.ptr(3078, 3084, 1),
                new Range16.ptr(3086, 3088, 1),
                new Range16.ptr(3090, 3112, 1),
                new Range16.ptr(3114, 3129, 1),
                new Range16.ptr(3133, 3160, 27),
                new Range16.ptr(3161, 3162, 1),
                new Range16.ptr(3168, 3169, 1),
                new Range16.ptr(3200, 3205, 5),
                new Range16.ptr(3206, 3212, 1),
                new Range16.ptr(3214, 3216, 1),
                new Range16.ptr(3218, 3240, 1),
                new Range16.ptr(3242, 3251, 1),
                new Range16.ptr(3253, 3257, 1),
                new Range16.ptr(3261, 3294, 33),
                new Range16.ptr(3296, 3297, 1),
                new Range16.ptr(3313, 3314, 1),
                new Range16.ptr(3332, 3340, 1),
                new Range16.ptr(3342, 3344, 1),
                new Range16.ptr(3346, 3386, 1),
                new Range16.ptr(3389, 3406, 17),
                new Range16.ptr(3412, 3414, 1),
                new Range16.ptr(3423, 3425, 1),
                new Range16.ptr(3450, 3455, 1),
                new Range16.ptr(3461, 3478, 1),
                new Range16.ptr(3482, 3505, 1),
                new Range16.ptr(3507, 3515, 1),
                new Range16.ptr(3517, 3520, 3),
                new Range16.ptr(3521, 3526, 1),
                new Range16.ptr(3585, 3632, 1),
                new Range16.ptr(3634, 3635, 1),
                new Range16.ptr(3648, 3654, 1),
                new Range16.ptr(3713, 3714, 1),
                new Range16.ptr(3716, 3718, 2),
                new Range16.ptr(3719, 3722, 1),
                new Range16.ptr(3724, 3747, 1),
                new Range16.ptr(3749, 3751, 2),
                new Range16.ptr(3752, 3760, 1),
                new Range16.ptr(3762, 3763, 1),
                new Range16.ptr(3773, 3776, 3),
                new Range16.ptr(3777, 3780, 1),
                new Range16.ptr(3782, 3804, 22),
                new Range16.ptr(3805, 3807, 1),
                new Range16.ptr(3840, 3904, 64),
                new Range16.ptr(3905, 3911, 1),
                new Range16.ptr(3913, 3948, 1),
                new Range16.ptr(3976, 3980, 1),
                new Range16.ptr(4096, 4138, 1),
                new Range16.ptr(4159, 4176, 17),
                new Range16.ptr(4177, 4181, 1),
                new Range16.ptr(4186, 4189, 1),
                new Range16.ptr(4193, 4197, 4),
                new Range16.ptr(4198, 4206, 8),
                new Range16.ptr(4207, 4208, 1),
                new Range16.ptr(4213, 4225, 1),
                new Range16.ptr(4238, 4256, 18),
                new Range16.ptr(4257, 4293, 1),
                new Range16.ptr(4295, 4301, 6),
                new Range16.ptr(4304, 4346, 1),
                new Range16.ptr(4348, 4680, 1),
                new Range16.ptr(4682, 4685, 1),
                new Range16.ptr(4688, 4694, 1),
                new Range16.ptr(4696, 4698, 2),
                new Range16.ptr(4699, 4701, 1),
                new Range16.ptr(4704, 4744, 1),
                new Range16.ptr(4746, 4749, 1),
                new Range16.ptr(4752, 4784, 1),
                new Range16.ptr(4786, 4789, 1),
                new Range16.ptr(4792, 4798, 1),
                new Range16.ptr(4800, 4802, 2),
                new Range16.ptr(4803, 4805, 1),
                new Range16.ptr(4808, 4822, 1),
                new Range16.ptr(4824, 4880, 1),
                new Range16.ptr(4882, 4885, 1),
                new Range16.ptr(4888, 4954, 1),
                new Range16.ptr(4992, 5007, 1),
                new Range16.ptr(5024, 5109, 1),
                new Range16.ptr(5112, 5117, 1),
                new Range16.ptr(5121, 5740, 1),
                new Range16.ptr(5743, 5759, 1),
                new Range16.ptr(5761, 5786, 1),
                new Range16.ptr(5792, 5866, 1),
                new Range16.ptr(5873, 5880, 1),
                new Range16.ptr(5888, 5900, 1),
                new Range16.ptr(5902, 5905, 1),
                new Range16.ptr(5920, 5937, 1),
                new Range16.ptr(5952, 5969, 1),
                new Range16.ptr(5984, 5996, 1),
                new Range16.ptr(5998, 6000, 1),
                new Range16.ptr(6016, 6067, 1),
                new Range16.ptr(6103, 6108, 5),
                new Range16.ptr(6176, 6264, 1),
                new Range16.ptr(6272, 6276, 1),
                new Range16.ptr(6279, 6312, 1),
                new Range16.ptr(6314, 6320, 6),
                new Range16.ptr(6321, 6389, 1),
                new Range16.ptr(6400, 6430, 1),
                new Range16.ptr(6480, 6509, 1),
                new Range16.ptr(6512, 6516, 1),
                new Range16.ptr(6528, 6571, 1),
                new Range16.ptr(6576, 6601, 1),
                new Range16.ptr(6656, 6678, 1),
                new Range16.ptr(6688, 6740, 1),
                new Range16.ptr(6823, 6917, 94),
                new Range16.ptr(6918, 6963, 1),
                new Range16.ptr(6981, 6987, 1),
                new Range16.ptr(7043, 7072, 1),
                new Range16.ptr(7086, 7087, 1),
                new Range16.ptr(7098, 7141, 1),
                new Range16.ptr(7168, 7203, 1),
                new Range16.ptr(7245, 7247, 1),
                new Range16.ptr(7258, 7293, 1),
                new Range16.ptr(7296, 7304, 1),
                new Range16.ptr(7312, 7354, 1),
                new Range16.ptr(7357, 7359, 1),
                new Range16.ptr(7401, 7404, 1),
                new Range16.ptr(7406, 7411, 1),
                new Range16.ptr(7413, 7414, 1),
                new Range16.ptr(7418, 7424, 6),
                new Range16.ptr(7425, 7615, 1),
                new Range16.ptr(7680, 7957, 1),
                new Range16.ptr(7960, 7965, 1),
                new Range16.ptr(7968, 8005, 1),
                new Range16.ptr(8008, 8013, 1),
                new Range16.ptr(8016, 8023, 1),
                new Range16.ptr(8025, 8031, 2),
                new Range16.ptr(8032, 8061, 1),
                new Range16.ptr(8064, 8116, 1),
                new Range16.ptr(8118, 8124, 1),
                new Range16.ptr(8126, 8130, 4),
                new Range16.ptr(8131, 8132, 1),
                new Range16.ptr(8134, 8140, 1),
                new Range16.ptr(8144, 8147, 1),
                new Range16.ptr(8150, 8155, 1),
                new Range16.ptr(8160, 8172, 1),
                new Range16.ptr(8178, 8180, 1),
                new Range16.ptr(8182, 8188, 1),
                new Range16.ptr(8305, 8319, 14),
                new Range16.ptr(8336, 8348, 1),
                new Range16.ptr(8450, 8455, 5),
                new Range16.ptr(8458, 8467, 1),
                new Range16.ptr(8469, 8473, 4),
                new Range16.ptr(8474, 8477, 1),
                new Range16.ptr(8484, 8490, 2),
                new Range16.ptr(8491, 8493, 1),
                new Range16.ptr(8495, 8505, 1),
                new Range16.ptr(8508, 8511, 1),
                new Range16.ptr(8517, 8521, 1),
                new Range16.ptr(8526, 8579, 53),
                new Range16.ptr(8580, 11264, 2684),
                new Range16.ptr(11265, 11310, 1),
                new Range16.ptr(11312, 11358, 1),
                new Range16.ptr(11360, 11492, 1),
                new Range16.ptr(11499, 11502, 1),
                new Range16.ptr(11506, 11507, 1),
                new Range16.ptr(11520, 11557, 1),
                new Range16.ptr(11559, 11565, 6),
                new Range16.ptr(11568, 11623, 1),
                new Range16.ptr(11631, 11648, 17),
                new Range16.ptr(11649, 11670, 1),
                new Range16.ptr(11680, 11686, 1),
                new Range16.ptr(11688, 11694, 1),
                new Range16.ptr(11696, 11702, 1),
                new Range16.ptr(11704, 11710, 1),
                new Range16.ptr(11712, 11718, 1),
                new Range16.ptr(11720, 11726, 1),
                new Range16.ptr(11728, 11734, 1),
                new Range16.ptr(11736, 11742, 1),
                new Range16.ptr(11823, 12293, 470),
                new Range16.ptr(12294, 12337, 43),
                new Range16.ptr(12338, 12341, 1),
                new Range16.ptr(12347, 12348, 1),
                new Range16.ptr(12353, 12438, 1),
                new Range16.ptr(12445, 12447, 1),
                new Range16.ptr(12449, 12538, 1),
                new Range16.ptr(12540, 12543, 1),
                new Range16.ptr(12549, 12591, 1),
                new Range16.ptr(12593, 12686, 1),
                new Range16.ptr(12704, 12735, 1),
                new Range16.ptr(12784, 12799, 1),
                new Range16.ptr(13312, 19903, 1),
                new Range16.ptr(19968, 40956, 1),
                new Range16.ptr(40960, 42124, 1),
                new Range16.ptr(42192, 42237, 1),
                new Range16.ptr(42240, 42508, 1),
                new Range16.ptr(42512, 42527, 1),
                new Range16.ptr(42538, 42539, 1),
                new Range16.ptr(42560, 42606, 1),
                new Range16.ptr(42623, 42653, 1),
                new Range16.ptr(42656, 42725, 1),
                new Range16.ptr(42775, 42783, 1),
                new Range16.ptr(42786, 42888, 1),
                new Range16.ptr(42891, 42943, 1),
                new Range16.ptr(42946, 42954, 1),
                new Range16.ptr(42997, 43009, 1),
                new Range16.ptr(43011, 43013, 1),
                new Range16.ptr(43015, 43018, 1),
                new Range16.ptr(43020, 43042, 1),
                new Range16.ptr(43072, 43123, 1),
                new Range16.ptr(43138, 43187, 1),
                new Range16.ptr(43250, 43255, 1),
                new Range16.ptr(43259, 43261, 2),
                new Range16.ptr(43262, 43274, 12),
                new Range16.ptr(43275, 43301, 1),
                new Range16.ptr(43312, 43334, 1),
                new Range16.ptr(43360, 43388, 1),
                new Range16.ptr(43396, 43442, 1),
                new Range16.ptr(43471, 43488, 17),
                new Range16.ptr(43489, 43492, 1),
                new Range16.ptr(43494, 43503, 1),
                new Range16.ptr(43514, 43518, 1),
                new Range16.ptr(43520, 43560, 1),
                new Range16.ptr(43584, 43586, 1),
                new Range16.ptr(43588, 43595, 1),
                new Range16.ptr(43616, 43638, 1),
                new Range16.ptr(43642, 43646, 4),
                new Range16.ptr(43647, 43695, 1),
                new Range16.ptr(43697, 43701, 4),
                new Range16.ptr(43702, 43705, 3),
                new Range16.ptr(43706, 43709, 1),
                new Range16.ptr(43712, 43714, 2),
                new Range16.ptr(43739, 43741, 1),
                new Range16.ptr(43744, 43754, 1),
                new Range16.ptr(43762, 43764, 1),
                new Range16.ptr(43777, 43782, 1),
                new Range16.ptr(43785, 43790, 1),
                new Range16.ptr(43793, 43798, 1),
                new Range16.ptr(43808, 43814, 1),
                new Range16.ptr(43816, 43822, 1),
                new Range16.ptr(43824, 43866, 1),
                new Range16.ptr(43868, 43881, 1),
                new Range16.ptr(43888, 44002, 1),
                new Range16.ptr(44032, 55203, 1),
                new Range16.ptr(55216, 55238, 1),
                new Range16.ptr(55243, 55291, 1),
                new Range16.ptr(63744, 64109, 1),
                new Range16.ptr(64112, 64217, 1),
                new Range16.ptr(64256, 64262, 1),
                new Range16.ptr(64275, 64279, 1),
                new Range16.ptr(64285, 64287, 2),
                new Range16.ptr(64288, 64296, 1),
                new Range16.ptr(64298, 64310, 1),
                new Range16.ptr(64312, 64316, 1),
                new Range16.ptr(64318, 64320, 2),
                new Range16.ptr(64321, 64323, 2),
                new Range16.ptr(64324, 64326, 2),
                new Range16.ptr(64327, 64433, 1),
                new Range16.ptr(64467, 64829, 1),
                new Range16.ptr(64848, 64911, 1),
                new Range16.ptr(64914, 64967, 1),
                new Range16.ptr(65008, 65019, 1),
                new Range16.ptr(65136, 65140, 1),
                new Range16.ptr(65142, 65276, 1),
                new Range16.ptr(65313, 65338, 1),
                new Range16.ptr(65345, 65370, 1),
                new Range16.ptr(65382, 65470, 1),
                new Range16.ptr(65474, 65479, 1),
                new Range16.ptr(65482, 65487, 1),
                new Range16.ptr(65490, 65495, 1),
                new Range16.ptr(65498, 65500, 1),
              ]),
              new sliceType$1([
                new Range32.ptr(65536, 65547, 1),
                new Range32.ptr(65549, 65574, 1),
                new Range32.ptr(65576, 65594, 1),
                new Range32.ptr(65596, 65597, 1),
                new Range32.ptr(65599, 65613, 1),
                new Range32.ptr(65616, 65629, 1),
                new Range32.ptr(65664, 65786, 1),
                new Range32.ptr(66176, 66204, 1),
                new Range32.ptr(66208, 66256, 1),
                new Range32.ptr(66304, 66335, 1),
                new Range32.ptr(66349, 66368, 1),
                new Range32.ptr(66370, 66377, 1),
                new Range32.ptr(66384, 66421, 1),
                new Range32.ptr(66432, 66461, 1),
                new Range32.ptr(66464, 66499, 1),
                new Range32.ptr(66504, 66511, 1),
                new Range32.ptr(66560, 66717, 1),
                new Range32.ptr(66736, 66771, 1),
                new Range32.ptr(66776, 66811, 1),
                new Range32.ptr(66816, 66855, 1),
                new Range32.ptr(66864, 66915, 1),
                new Range32.ptr(67072, 67382, 1),
                new Range32.ptr(67392, 67413, 1),
                new Range32.ptr(67424, 67431, 1),
                new Range32.ptr(67584, 67589, 1),
                new Range32.ptr(67592, 67594, 2),
                new Range32.ptr(67595, 67637, 1),
                new Range32.ptr(67639, 67640, 1),
                new Range32.ptr(67644, 67647, 3),
                new Range32.ptr(67648, 67669, 1),
                new Range32.ptr(67680, 67702, 1),
                new Range32.ptr(67712, 67742, 1),
                new Range32.ptr(67808, 67826, 1),
                new Range32.ptr(67828, 67829, 1),
                new Range32.ptr(67840, 67861, 1),
                new Range32.ptr(67872, 67897, 1),
                new Range32.ptr(67968, 68023, 1),
                new Range32.ptr(68030, 68031, 1),
                new Range32.ptr(68096, 68112, 16),
                new Range32.ptr(68113, 68115, 1),
                new Range32.ptr(68117, 68119, 1),
                new Range32.ptr(68121, 68149, 1),
                new Range32.ptr(68192, 68220, 1),
                new Range32.ptr(68224, 68252, 1),
                new Range32.ptr(68288, 68295, 1),
                new Range32.ptr(68297, 68324, 1),
                new Range32.ptr(68352, 68405, 1),
                new Range32.ptr(68416, 68437, 1),
                new Range32.ptr(68448, 68466, 1),
                new Range32.ptr(68480, 68497, 1),
                new Range32.ptr(68608, 68680, 1),
                new Range32.ptr(68736, 68786, 1),
                new Range32.ptr(68800, 68850, 1),
                new Range32.ptr(68864, 68899, 1),
                new Range32.ptr(69248, 69289, 1),
                new Range32.ptr(69296, 69297, 1),
                new Range32.ptr(69376, 69404, 1),
                new Range32.ptr(69415, 69424, 9),
                new Range32.ptr(69425, 69445, 1),
                new Range32.ptr(69552, 69572, 1),
                new Range32.ptr(69600, 69622, 1),
                new Range32.ptr(69635, 69687, 1),
                new Range32.ptr(69763, 69807, 1),
                new Range32.ptr(69840, 69864, 1),
                new Range32.ptr(69891, 69926, 1),
                new Range32.ptr(69956, 69959, 3),
                new Range32.ptr(69968, 70002, 1),
                new Range32.ptr(70006, 70019, 13),
                new Range32.ptr(70020, 70066, 1),
                new Range32.ptr(70081, 70084, 1),
                new Range32.ptr(70106, 70108, 2),
                new Range32.ptr(70144, 70161, 1),
                new Range32.ptr(70163, 70187, 1),
                new Range32.ptr(70272, 70278, 1),
                new Range32.ptr(70280, 70282, 2),
                new Range32.ptr(70283, 70285, 1),
                new Range32.ptr(70287, 70301, 1),
                new Range32.ptr(70303, 70312, 1),
                new Range32.ptr(70320, 70366, 1),
                new Range32.ptr(70405, 70412, 1),
                new Range32.ptr(70415, 70416, 1),
                new Range32.ptr(70419, 70440, 1),
                new Range32.ptr(70442, 70448, 1),
                new Range32.ptr(70450, 70451, 1),
                new Range32.ptr(70453, 70457, 1),
                new Range32.ptr(70461, 70480, 19),
                new Range32.ptr(70493, 70497, 1),
                new Range32.ptr(70656, 70708, 1),
                new Range32.ptr(70727, 70730, 1),
                new Range32.ptr(70751, 70753, 1),
                new Range32.ptr(70784, 70831, 1),
                new Range32.ptr(70852, 70853, 1),
                new Range32.ptr(70855, 71040, 185),
                new Range32.ptr(71041, 71086, 1),
                new Range32.ptr(71128, 71131, 1),
                new Range32.ptr(71168, 71215, 1),
                new Range32.ptr(71236, 71296, 60),
                new Range32.ptr(71297, 71338, 1),
                new Range32.ptr(71352, 71424, 72),
                new Range32.ptr(71425, 71450, 1),
                new Range32.ptr(71680, 71723, 1),
                new Range32.ptr(71840, 71903, 1),
                new Range32.ptr(71935, 71942, 1),
                new Range32.ptr(71945, 71948, 3),
                new Range32.ptr(71949, 71955, 1),
                new Range32.ptr(71957, 71958, 1),
                new Range32.ptr(71960, 71983, 1),
                new Range32.ptr(71999, 72001, 2),
                new Range32.ptr(72096, 72103, 1),
                new Range32.ptr(72106, 72144, 1),
                new Range32.ptr(72161, 72163, 2),
                new Range32.ptr(72192, 72203, 11),
                new Range32.ptr(72204, 72242, 1),
                new Range32.ptr(72250, 72272, 22),
                new Range32.ptr(72284, 72329, 1),
                new Range32.ptr(72349, 72384, 35),
                new Range32.ptr(72385, 72440, 1),
                new Range32.ptr(72704, 72712, 1),
                new Range32.ptr(72714, 72750, 1),
                new Range32.ptr(72768, 72818, 50),
                new Range32.ptr(72819, 72847, 1),
                new Range32.ptr(72960, 72966, 1),
                new Range32.ptr(72968, 72969, 1),
                new Range32.ptr(72971, 73008, 1),
                new Range32.ptr(73030, 73056, 26),
                new Range32.ptr(73057, 73061, 1),
                new Range32.ptr(73063, 73064, 1),
                new Range32.ptr(73066, 73097, 1),
                new Range32.ptr(73112, 73440, 328),
                new Range32.ptr(73441, 73458, 1),
                new Range32.ptr(73648, 73728, 80),
                new Range32.ptr(73729, 74649, 1),
                new Range32.ptr(74880, 75075, 1),
                new Range32.ptr(77824, 78894, 1),
                new Range32.ptr(82944, 83526, 1),
                new Range32.ptr(92160, 92728, 1),
                new Range32.ptr(92736, 92766, 1),
                new Range32.ptr(92880, 92909, 1),
                new Range32.ptr(92928, 92975, 1),
                new Range32.ptr(92992, 92995, 1),
                new Range32.ptr(93027, 93047, 1),
                new Range32.ptr(93053, 93071, 1),
                new Range32.ptr(93760, 93823, 1),
                new Range32.ptr(93952, 94026, 1),
                new Range32.ptr(94032, 94099, 67),
                new Range32.ptr(94100, 94111, 1),
                new Range32.ptr(94176, 94177, 1),
                new Range32.ptr(94179, 94208, 29),
                new Range32.ptr(94209, 100343, 1),
                new Range32.ptr(100352, 101589, 1),
                new Range32.ptr(101632, 101640, 1),
                new Range32.ptr(110592, 110878, 1),
                new Range32.ptr(110928, 110930, 1),
                new Range32.ptr(110948, 110951, 1),
                new Range32.ptr(110960, 111355, 1),
                new Range32.ptr(113664, 113770, 1),
                new Range32.ptr(113776, 113788, 1),
                new Range32.ptr(113792, 113800, 1),
                new Range32.ptr(113808, 113817, 1),
                new Range32.ptr(119808, 119892, 1),
                new Range32.ptr(119894, 119964, 1),
                new Range32.ptr(119966, 119967, 1),
                new Range32.ptr(119970, 119973, 3),
                new Range32.ptr(119974, 119977, 3),
                new Range32.ptr(119978, 119980, 1),
                new Range32.ptr(119982, 119993, 1),
                new Range32.ptr(119995, 119997, 2),
                new Range32.ptr(119998, 120003, 1),
                new Range32.ptr(120005, 120069, 1),
                new Range32.ptr(120071, 120074, 1),
                new Range32.ptr(120077, 120084, 1),
                new Range32.ptr(120086, 120092, 1),
                new Range32.ptr(120094, 120121, 1),
                new Range32.ptr(120123, 120126, 1),
                new Range32.ptr(120128, 120132, 1),
                new Range32.ptr(120134, 120138, 4),
                new Range32.ptr(120139, 120144, 1),
                new Range32.ptr(120146, 120485, 1),
                new Range32.ptr(120488, 120512, 1),
                new Range32.ptr(120514, 120538, 1),
                new Range32.ptr(120540, 120570, 1),
                new Range32.ptr(120572, 120596, 1),
                new Range32.ptr(120598, 120628, 1),
                new Range32.ptr(120630, 120654, 1),
                new Range32.ptr(120656, 120686, 1),
                new Range32.ptr(120688, 120712, 1),
                new Range32.ptr(120714, 120744, 1),
                new Range32.ptr(120746, 120770, 1),
                new Range32.ptr(120772, 120779, 1),
                new Range32.ptr(123136, 123180, 1),
                new Range32.ptr(123191, 123197, 1),
                new Range32.ptr(123214, 123584, 370),
                new Range32.ptr(123585, 123627, 1),
                new Range32.ptr(124928, 125124, 1),
                new Range32.ptr(125184, 125251, 1),
                new Range32.ptr(125259, 126464, 1205),
                new Range32.ptr(126465, 126467, 1),
                new Range32.ptr(126469, 126495, 1),
                new Range32.ptr(126497, 126498, 1),
                new Range32.ptr(126500, 126503, 3),
                new Range32.ptr(126505, 126514, 1),
                new Range32.ptr(126516, 126519, 1),
                new Range32.ptr(126521, 126523, 2),
                new Range32.ptr(126530, 126535, 5),
                new Range32.ptr(126537, 126541, 2),
                new Range32.ptr(126542, 126543, 1),
                new Range32.ptr(126545, 126546, 1),
                new Range32.ptr(126548, 126551, 3),
                new Range32.ptr(126553, 126561, 2),
                new Range32.ptr(126562, 126564, 2),
                new Range32.ptr(126567, 126570, 1),
                new Range32.ptr(126572, 126578, 1),
                new Range32.ptr(126580, 126583, 1),
                new Range32.ptr(126585, 126588, 1),
                new Range32.ptr(126590, 126592, 2),
                new Range32.ptr(126593, 126601, 1),
                new Range32.ptr(126603, 126619, 1),
                new Range32.ptr(126625, 126627, 1),
                new Range32.ptr(126629, 126633, 1),
                new Range32.ptr(126635, 126651, 1),
                new Range32.ptr(131072, 173789, 1),
                new Range32.ptr(173824, 177972, 1),
                new Range32.ptr(177984, 178205, 1),
                new Range32.ptr(178208, 183969, 1),
                new Range32.ptr(183984, 191456, 1),
                new Range32.ptr(194560, 195101, 1),
                new Range32.ptr(196608, 201546, 1),
              ]),
              6
            );
            _Nd = new RangeTable.ptr(
              new sliceType([
                new Range16.ptr(48, 57, 1),
                new Range16.ptr(1632, 1641, 1),
                new Range16.ptr(1776, 1785, 1),
                new Range16.ptr(1984, 1993, 1),
                new Range16.ptr(2406, 2415, 1),
                new Range16.ptr(2534, 2543, 1),
                new Range16.ptr(2662, 2671, 1),
                new Range16.ptr(2790, 2799, 1),
                new Range16.ptr(2918, 2927, 1),
                new Range16.ptr(3046, 3055, 1),
                new Range16.ptr(3174, 3183, 1),
                new Range16.ptr(3302, 3311, 1),
                new Range16.ptr(3430, 3439, 1),
                new Range16.ptr(3558, 3567, 1),
                new Range16.ptr(3664, 3673, 1),
                new Range16.ptr(3792, 3801, 1),
                new Range16.ptr(3872, 3881, 1),
                new Range16.ptr(4160, 4169, 1),
                new Range16.ptr(4240, 4249, 1),
                new Range16.ptr(6112, 6121, 1),
                new Range16.ptr(6160, 6169, 1),
                new Range16.ptr(6470, 6479, 1),
                new Range16.ptr(6608, 6617, 1),
                new Range16.ptr(6784, 6793, 1),
                new Range16.ptr(6800, 6809, 1),
                new Range16.ptr(6992, 7001, 1),
                new Range16.ptr(7088, 7097, 1),
                new Range16.ptr(7232, 7241, 1),
                new Range16.ptr(7248, 7257, 1),
                new Range16.ptr(42528, 42537, 1),
                new Range16.ptr(43216, 43225, 1),
                new Range16.ptr(43264, 43273, 1),
                new Range16.ptr(43472, 43481, 1),
                new Range16.ptr(43504, 43513, 1),
                new Range16.ptr(43600, 43609, 1),
                new Range16.ptr(44016, 44025, 1),
                new Range16.ptr(65296, 65305, 1),
              ]),
              new sliceType$1([
                new Range32.ptr(66720, 66729, 1),
                new Range32.ptr(68912, 68921, 1),
                new Range32.ptr(69734, 69743, 1),
                new Range32.ptr(69872, 69881, 1),
                new Range32.ptr(69942, 69951, 1),
                new Range32.ptr(70096, 70105, 1),
                new Range32.ptr(70384, 70393, 1),
                new Range32.ptr(70736, 70745, 1),
                new Range32.ptr(70864, 70873, 1),
                new Range32.ptr(71248, 71257, 1),
                new Range32.ptr(71360, 71369, 1),
                new Range32.ptr(71472, 71481, 1),
                new Range32.ptr(71904, 71913, 1),
                new Range32.ptr(72016, 72025, 1),
                new Range32.ptr(72784, 72793, 1),
                new Range32.ptr(73040, 73049, 1),
                new Range32.ptr(73120, 73129, 1),
                new Range32.ptr(92768, 92777, 1),
                new Range32.ptr(93008, 93017, 1),
                new Range32.ptr(120782, 120831, 1),
                new Range32.ptr(123200, 123209, 1),
                new Range32.ptr(123632, 123641, 1),
                new Range32.ptr(125264, 125273, 1),
                new Range32.ptr(130032, 130041, 1),
              ]),
              1
            );
            $pkg.Digit = _Nd;
            $pkg.Letter = _L;
            properties = $toNativeArray(
              $kindUint8,
              [
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130,
                130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132,
                132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130,
                130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160,
                160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160,
                160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192,
                192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192,
                192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1,
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136,
                130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132,
                136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160,
                160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160,
                160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160,
                160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192,
                192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192,
                192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192,
              ]
            );
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["reflect"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js,
      abi,
      bytealg,
      goarch,
      goexperiment,
      itoa,
      unsafeheader,
      math,
      runtime,
      strconv,
      sync,
      unicode,
      utf8,
      Value,
      flag,
      ValueError,
      MapIter,
      Type,
      Kind,
      tflag,
      rtype,
      method,
      ChanDir,
      arrayType,
      chanType,
      imethod,
      interfaceType,
      mapType,
      ptrType,
      sliceType,
      structField,
      structType,
      Method,
      nameOff,
      typeOff,
      textOff,
      StructField,
      StructTag,
      fieldScan,
      uncommonType,
      funcType,
      name,
      nameData,
      hiter,
      sliceType$1,
      ptrType$1,
      sliceType$2,
      sliceType$3,
      sliceType$4,
      ptrType$2,
      funcType$1,
      sliceType$6,
      ptrType$4,
      sliceType$7,
      ptrType$7,
      ptrType$8,
      sliceType$9,
      sliceType$10,
      ptrType$9,
      sliceType$11,
      ptrType$10,
      ptrType$11,
      sliceType$12,
      ptrType$12,
      ptrType$13,
      funcType$2,
      sliceType$14,
      sliceType$15,
      ptrType$17,
      structType$3,
      sliceType$16,
      ptrType$18,
      ptrType$19,
      sliceType$17,
      sliceType$18,
      funcType$3,
      ptrType$22,
      arrayType$7,
      ptrType$23,
      funcType$4,
      funcType$5,
      ptrType$25,
      ptrType$26,
      uint8Type,
      kindNames,
      initialized,
      nameMap,
      nameOffList,
      typeOffList,
      callHelper,
      jsObjectPtr,
      selectHelper,
      methodName,
      copyVal,
      overflowFloat32,
      convertOp,
      makeFloat,
      makeFloat32,
      makeComplex,
      makeString,
      makeBytes,
      makeRunes,
      cvtInt,
      cvtUint,
      cvtFloatInt,
      cvtFloatUint,
      cvtIntFloat,
      cvtUintFloat,
      cvtFloat,
      cvtComplex,
      cvtIntString,
      cvtUintString,
      cvtBytesString,
      cvtStringBytes,
      cvtRunesString,
      cvtStringRunes,
      cvtT2I,
      cvtI2I,
      PtrTo,
      PointerTo,
      implements$1,
      specialChannelAssignability,
      directlyAssignable,
      haveIdenticalType,
      haveIdenticalUnderlyingType,
      toType,
      ifaceIndir,
      methodValueCallCodePtr,
      methodValueCall,
      init,
      New,
      jsType,
      reflectType,
      setKindType,
      newName,
      newMethodName,
      resolveReflectName,
      newTypeOff,
      internalStr,
      isWrapped,
      copyStruct,
      makeValue,
      MakeSlice,
      TypeOf,
      ValueOf,
      FuncOf,
      SliceOf,
      Zero,
      unsafe_New,
      makeInt,
      typedmemmove,
      keyFor,
      mapaccess,
      mapassign,
      mapdelete,
      mapaccess_faststr,
      mapassign_faststr,
      mapdelete_faststr,
      mapiterinit,
      mapiterkey,
      mapiterelem,
      mapiternext,
      maplen,
      cvtDirect,
      cvtSliceArrayPtr,
      methodReceiver,
      valueInterface,
      ifaceE2I,
      makeMethodValue,
      wrapJsObject,
      unwrapJsObject,
      getJsTag,
      chanrecv,
      chansend,
      methodNameSkip,
      verifyNotInHeapPtr;
    errors = $packages["errors"];
    js = $packages["github.com/gopherjs/gopherjs/js"];
    abi = $packages["internal/abi"];
    bytealg = $packages["internal/bytealg"];
    goarch = $packages["internal/goarch"];
    goexperiment = $packages["internal/goexperiment"];
    itoa = $packages["internal/itoa"];
    unsafeheader = $packages["internal/unsafeheader"];
    math = $packages["math"];
    runtime = $packages["runtime"];
    strconv = $packages["strconv"];
    sync = $packages["sync"];
    unicode = $packages["unicode"];
    utf8 = $packages["unicode/utf8"];
    Value = $pkg.Value = $newType(
      0,
      $kindStruct,
      "reflect.Value",
      true,
      "reflect",
      true,
      function (typ_, ptr_, flag_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.typ = ptrType$1.nil;
          this.ptr = 0;
          this.flag = 0;
          return;
        }
        this.typ = typ_;
        this.ptr = ptr_;
        this.flag = flag_;
      }
    );
    flag = $pkg.flag = $newType(
      4,
      $kindUintptr,
      "reflect.flag",
      true,
      "reflect",
      false,
      null
    );
    ValueError = $pkg.ValueError = $newType(
      0,
      $kindStruct,
      "reflect.ValueError",
      true,
      "reflect",
      true,
      function (Method_, Kind_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Method = "";
          this.Kind = 0;
          return;
        }
        this.Method = Method_;
        this.Kind = Kind_;
      }
    );
    MapIter = $pkg.MapIter = $newType(
      0,
      $kindStruct,
      "reflect.MapIter",
      true,
      "reflect",
      true,
      function (m_, hiter_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.m = new Value.ptr(ptrType$1.nil, 0, 0);
          this.hiter = new hiter.ptr($ifaceNil, null, null, 0, null);
          return;
        }
        this.m = m_;
        this.hiter = hiter_;
      }
    );
    Type = $pkg.Type = $newType(
      8,
      $kindInterface,
      "reflect.Type",
      true,
      "reflect",
      true,
      null
    );
    Kind = $pkg.Kind = $newType(
      4,
      $kindUint,
      "reflect.Kind",
      true,
      "reflect",
      true,
      null
    );
    tflag = $pkg.tflag = $newType(
      1,
      $kindUint8,
      "reflect.tflag",
      true,
      "reflect",
      false,
      null
    );
    rtype = $pkg.rtype = $newType(
      0,
      $kindStruct,
      "reflect.rtype",
      true,
      "reflect",
      false,
      function (
        size_,
        ptrdata_,
        hash_,
        tflag_,
        align_,
        fieldAlign_,
        kind_,
        equal_,
        gcdata_,
        str_,
        ptrToThis_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.size = 0;
          this.ptrdata = 0;
          this.hash = 0;
          this.tflag = 0;
          this.align = 0;
          this.fieldAlign = 0;
          this.kind = 0;
          this.equal = $throwNilPointerError;
          this.gcdata = ptrType$13.nil;
          this.str = 0;
          this.ptrToThis = 0;
          return;
        }
        this.size = size_;
        this.ptrdata = ptrdata_;
        this.hash = hash_;
        this.tflag = tflag_;
        this.align = align_;
        this.fieldAlign = fieldAlign_;
        this.kind = kind_;
        this.equal = equal_;
        this.gcdata = gcdata_;
        this.str = str_;
        this.ptrToThis = ptrToThis_;
      }
    );
    method = $pkg.method = $newType(
      0,
      $kindStruct,
      "reflect.method",
      true,
      "reflect",
      false,
      function (name_, mtyp_, ifn_, tfn_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = 0;
          this.mtyp = 0;
          this.ifn = 0;
          this.tfn = 0;
          return;
        }
        this.name = name_;
        this.mtyp = mtyp_;
        this.ifn = ifn_;
        this.tfn = tfn_;
      }
    );
    ChanDir = $pkg.ChanDir = $newType(
      4,
      $kindInt,
      "reflect.ChanDir",
      true,
      "reflect",
      true,
      null
    );
    arrayType = $pkg.arrayType = $newType(
      0,
      $kindStruct,
      "reflect.arrayType",
      true,
      "reflect",
      false,
      function (rtype_, elem_, slice_, len_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          this.slice = ptrType$1.nil;
          this.len = 0;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
        this.slice = slice_;
        this.len = len_;
      }
    );
    chanType = $pkg.chanType = $newType(
      0,
      $kindStruct,
      "reflect.chanType",
      true,
      "reflect",
      false,
      function (rtype_, elem_, dir_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          this.dir = 0;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
        this.dir = dir_;
      }
    );
    imethod = $pkg.imethod = $newType(
      0,
      $kindStruct,
      "reflect.imethod",
      true,
      "reflect",
      false,
      function (name_, typ_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = 0;
          this.typ = 0;
          return;
        }
        this.name = name_;
        this.typ = typ_;
      }
    );
    interfaceType = $pkg.interfaceType = $newType(
      0,
      $kindStruct,
      "reflect.interfaceType",
      true,
      "reflect",
      false,
      function (rtype_, pkgPath_, methods_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.pkgPath = new name.ptr(ptrType$13.nil);
          this.methods = sliceType$14.nil;
          return;
        }
        this.rtype = rtype_;
        this.pkgPath = pkgPath_;
        this.methods = methods_;
      }
    );
    mapType = $pkg.mapType = $newType(
      0,
      $kindStruct,
      "reflect.mapType",
      true,
      "reflect",
      false,
      function (
        rtype_,
        key_,
        elem_,
        bucket_,
        hasher_,
        keysize_,
        valuesize_,
        bucketsize_,
        flags_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.key = ptrType$1.nil;
          this.elem = ptrType$1.nil;
          this.bucket = ptrType$1.nil;
          this.hasher = $throwNilPointerError;
          this.keysize = 0;
          this.valuesize = 0;
          this.bucketsize = 0;
          this.flags = 0;
          return;
        }
        this.rtype = rtype_;
        this.key = key_;
        this.elem = elem_;
        this.bucket = bucket_;
        this.hasher = hasher_;
        this.keysize = keysize_;
        this.valuesize = valuesize_;
        this.bucketsize = bucketsize_;
        this.flags = flags_;
      }
    );
    ptrType = $pkg.ptrType = $newType(
      0,
      $kindStruct,
      "reflect.ptrType",
      true,
      "reflect",
      false,
      function (rtype_, elem_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
      }
    );
    sliceType = $pkg.sliceType = $newType(
      0,
      $kindStruct,
      "reflect.sliceType",
      true,
      "reflect",
      false,
      function (rtype_, elem_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.elem = ptrType$1.nil;
          return;
        }
        this.rtype = rtype_;
        this.elem = elem_;
      }
    );
    structField = $pkg.structField = $newType(
      0,
      $kindStruct,
      "reflect.structField",
      true,
      "reflect",
      false,
      function (name_, typ_, offsetEmbed_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = new name.ptr(ptrType$13.nil);
          this.typ = ptrType$1.nil;
          this.offsetEmbed = 0;
          return;
        }
        this.name = name_;
        this.typ = typ_;
        this.offsetEmbed = offsetEmbed_;
      }
    );
    structType = $pkg.structType = $newType(
      0,
      $kindStruct,
      "reflect.structType",
      true,
      "reflect",
      false,
      function (rtype_, pkgPath_, fields_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.pkgPath = new name.ptr(ptrType$13.nil);
          this.fields = sliceType$15.nil;
          return;
        }
        this.rtype = rtype_;
        this.pkgPath = pkgPath_;
        this.fields = fields_;
      }
    );
    Method = $pkg.Method = $newType(
      0,
      $kindStruct,
      "reflect.Method",
      true,
      "reflect",
      true,
      function (Name_, PkgPath_, Type_, Func_, Index_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Name = "";
          this.PkgPath = "";
          this.Type = $ifaceNil;
          this.Func = new Value.ptr(ptrType$1.nil, 0, 0);
          this.Index = 0;
          return;
        }
        this.Name = Name_;
        this.PkgPath = PkgPath_;
        this.Type = Type_;
        this.Func = Func_;
        this.Index = Index_;
      }
    );
    nameOff = $pkg.nameOff = $newType(
      4,
      $kindInt32,
      "reflect.nameOff",
      true,
      "reflect",
      false,
      null
    );
    typeOff = $pkg.typeOff = $newType(
      4,
      $kindInt32,
      "reflect.typeOff",
      true,
      "reflect",
      false,
      null
    );
    textOff = $pkg.textOff = $newType(
      4,
      $kindInt32,
      "reflect.textOff",
      true,
      "reflect",
      false,
      null
    );
    StructField = $pkg.StructField = $newType(
      0,
      $kindStruct,
      "reflect.StructField",
      true,
      "reflect",
      true,
      function (Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Name = "";
          this.PkgPath = "";
          this.Type = $ifaceNil;
          this.Tag = "";
          this.Offset = 0;
          this.Index = sliceType$6.nil;
          this.Anonymous = false;
          return;
        }
        this.Name = Name_;
        this.PkgPath = PkgPath_;
        this.Type = Type_;
        this.Tag = Tag_;
        this.Offset = Offset_;
        this.Index = Index_;
        this.Anonymous = Anonymous_;
      }
    );
    StructTag = $pkg.StructTag = $newType(
      8,
      $kindString,
      "reflect.StructTag",
      true,
      "reflect",
      true,
      null
    );
    fieldScan = $pkg.fieldScan = $newType(
      0,
      $kindStruct,
      "reflect.fieldScan",
      true,
      "reflect",
      false,
      function (typ_, index_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.typ = ptrType$12.nil;
          this.index = sliceType$6.nil;
          return;
        }
        this.typ = typ_;
        this.index = index_;
      }
    );
    uncommonType = $pkg.uncommonType = $newType(
      0,
      $kindStruct,
      "reflect.uncommonType",
      true,
      "reflect",
      false,
      function (pkgPath_, mcount_, xcount_, moff_, _methods_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.pkgPath = 0;
          this.mcount = 0;
          this.xcount = 0;
          this.moff = 0;
          this._methods = sliceType$11.nil;
          return;
        }
        this.pkgPath = pkgPath_;
        this.mcount = mcount_;
        this.xcount = xcount_;
        this.moff = moff_;
        this._methods = _methods_;
      }
    );
    funcType = $pkg.funcType = $newType(
      0,
      $kindStruct,
      "reflect.funcType",
      true,
      "reflect",
      false,
      function (rtype_, inCount_, outCount_, _in_, _out_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rtype = new rtype.ptr(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            $throwNilPointerError,
            ptrType$13.nil,
            0,
            0
          );
          this.inCount = 0;
          this.outCount = 0;
          this._in = sliceType$2.nil;
          this._out = sliceType$2.nil;
          return;
        }
        this.rtype = rtype_;
        this.inCount = inCount_;
        this.outCount = outCount_;
        this._in = _in_;
        this._out = _out_;
      }
    );
    name = $pkg.name = $newType(
      0,
      $kindStruct,
      "reflect.name",
      true,
      "reflect",
      false,
      function (bytes_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.bytes = ptrType$13.nil;
          return;
        }
        this.bytes = bytes_;
      }
    );
    nameData = $pkg.nameData = $newType(
      0,
      $kindStruct,
      "reflect.nameData",
      true,
      "reflect",
      false,
      function (name_, tag_, exported_, pkgPath_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.tag = "";
          this.exported = false;
          this.pkgPath = "";
          return;
        }
        this.name = name_;
        this.tag = tag_;
        this.exported = exported_;
        this.pkgPath = pkgPath_;
      }
    );
    hiter = $pkg.hiter = $newType(
      0,
      $kindStruct,
      "reflect.hiter",
      true,
      "reflect",
      false,
      function (t_, m_, keys_, i_, last_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.t = $ifaceNil;
          this.m = null;
          this.keys = null;
          this.i = 0;
          this.last = null;
          return;
        }
        this.t = t_;
        this.m = m_;
        this.keys = keys_;
        this.i = i_;
        this.last = last_;
      }
    );
    sliceType$1 = $sliceType(name);
    ptrType$1 = $ptrType(rtype);
    sliceType$2 = $sliceType(ptrType$1);
    sliceType$3 = $sliceType($String);
    sliceType$4 = $sliceType($emptyInterface);
    ptrType$2 = $ptrType(js.Object);
    funcType$1 = $funcType([sliceType$4], [ptrType$2], true);
    sliceType$6 = $sliceType($Int);
    ptrType$4 = $ptrType(runtime.Func);
    sliceType$7 = $sliceType(Value);
    ptrType$7 = $ptrType($UnsafePointer);
    ptrType$8 = $ptrType(unsafeheader.Slice);
    sliceType$9 = $sliceType($Uint8);
    sliceType$10 = $sliceType($Int32);
    ptrType$9 = $ptrType(uncommonType);
    sliceType$11 = $sliceType(method);
    ptrType$10 = $ptrType(interfaceType);
    ptrType$11 = $ptrType(imethod);
    sliceType$12 = $sliceType(fieldScan);
    ptrType$12 = $ptrType(structType);
    ptrType$13 = $ptrType($Uint8);
    funcType$2 = $funcType([], [], false);
    sliceType$14 = $sliceType(imethod);
    sliceType$15 = $sliceType(structField);
    ptrType$17 = $ptrType(nameData);
    structType$3 = $structType("reflect", [
      {
        prop: "str",
        name: "str",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    sliceType$16 = $sliceType(ptrType$2);
    ptrType$18 = $ptrType($String);
    ptrType$19 = $ptrType(funcType);
    sliceType$17 = $sliceType(Type);
    sliceType$18 = $sliceType(sliceType$16);
    funcType$3 = $funcType([$String], [$Bool], false);
    ptrType$22 = $ptrType(MapIter);
    arrayType$7 = $arrayType($Uintptr, 2);
    ptrType$23 = $ptrType(ValueError);
    funcType$4 = $funcType([$UnsafePointer, $UnsafePointer], [$Bool], false);
    funcType$5 = $funcType([$UnsafePointer, $Uintptr], [$Uintptr], false);
    ptrType$25 = $ptrType(structField);
    ptrType$26 = $ptrType(hiter);
    flag.prototype.kind = function () {
      var f;
      f = this.$val;
      return ((f & 31) >>> 0) >>> 0;
    };
    $ptrType(flag).prototype.kind = function () {
      return new flag(this.$get()).kind();
    };
    flag.prototype.ro = function () {
      var f;
      f = this.$val;
      if (!((f & 96) >>> 0 === 0)) {
        return 32;
      }
      return 0;
    };
    $ptrType(flag).prototype.ro = function () {
      return new flag(this.$get()).ro();
    };
    Value.ptr.prototype.pointer = function () {
      var v;
      v = this;
      if (!(v.typ.size === 4) || !v.typ.pointers()) {
        $panic(new $String("can't call pointer on a non-pointer Value"));
      }
      if (!((v.flag & 128) >>> 0 === 0)) {
        return v.ptr.$get();
      }
      return v.ptr;
    };
    Value.prototype.pointer = function () {
      return this.$val.pointer();
    };
    ValueError.ptr.prototype.Error = function () {
      var e;
      e = this;
      if (e.Kind === 0) {
        return "reflect: call of " + e.Method + " on zero Value";
      }
      return (
        "reflect: call of " +
        e.Method +
        " on " +
        new Kind(e.Kind).String() +
        " Value"
      );
    };
    ValueError.prototype.Error = function () {
      return this.$val.Error();
    };
    methodName = function () {
      var _tuple, f, pc;
      _tuple = runtime.Caller(2);
      pc = _tuple[0];
      f = runtime.FuncForPC(pc);
      if (f === ptrType$4.nil) {
        return "unknown method";
      }
      return f.Name();
    };
    flag.prototype.mustBe = function (expected) {
      var expected, f;
      f = this.$val;
      if (!(((f & 31) >>> 0) >>> 0 === expected)) {
        $panic(new ValueError.ptr(methodName(), new flag(f).kind()));
      }
    };
    $ptrType(flag).prototype.mustBe = function (expected) {
      return new flag(this.$get()).mustBe(expected);
    };
    flag.prototype.mustBeExported = function () {
      var f;
      f = this.$val;
      if (f === 0 || !((f & 96) >>> 0 === 0)) {
        new flag(f).mustBeExportedSlow();
      }
    };
    $ptrType(flag).prototype.mustBeExported = function () {
      return new flag(this.$get()).mustBeExported();
    };
    flag.prototype.mustBeExportedSlow = function () {
      var f;
      f = this.$val;
      if (f === 0) {
        $panic(new ValueError.ptr(methodNameSkip(), 0));
      }
      if (!((f & 96) >>> 0 === 0)) {
        $panic(
          new $String(
            "reflect: " +
              methodNameSkip() +
              " using value obtained using unexported field"
          )
        );
      }
    };
    $ptrType(flag).prototype.mustBeExportedSlow = function () {
      return new flag(this.$get()).mustBeExportedSlow();
    };
    flag.prototype.mustBeAssignable = function () {
      var f;
      f = this.$val;
      if (!((f & 96) >>> 0 === 0) || (f & 256) >>> 0 === 0) {
        new flag(f).mustBeAssignableSlow();
      }
    };
    $ptrType(flag).prototype.mustBeAssignable = function () {
      return new flag(this.$get()).mustBeAssignable();
    };
    flag.prototype.mustBeAssignableSlow = function () {
      var f;
      f = this.$val;
      if (f === 0) {
        $panic(new ValueError.ptr(methodNameSkip(), 0));
      }
      if (!((f & 96) >>> 0 === 0)) {
        $panic(
          new $String(
            "reflect: " +
              methodNameSkip() +
              " using value obtained using unexported field"
          )
        );
      }
      if ((f & 256) >>> 0 === 0) {
        $panic(
          new $String(
            "reflect: " + methodNameSkip() + " using unaddressable value"
          )
        );
      }
    };
    $ptrType(flag).prototype.mustBeAssignableSlow = function () {
      return new flag(this.$get()).mustBeAssignableSlow();
    };
    Value.ptr.prototype.Addr = function () {
      var fl, v;
      v = this;
      if ((v.flag & 256) >>> 0 === 0) {
        $panic(new $String("reflect.Value.Addr of unaddressable value"));
      }
      fl = (v.flag & 96) >>> 0;
      return new Value.ptr(v.typ.ptrTo(), v.ptr, (fl | 22) >>> 0);
    };
    Value.prototype.Addr = function () {
      return this.$val.Addr();
    };
    Value.ptr.prototype.Bool = function () {
      var v;
      v = this;
      new flag(v.flag).mustBe(1);
      return v.ptr.$get();
    };
    Value.prototype.Bool = function () {
      return this.$val.Bool();
    };
    Value.ptr.prototype.Bytes = function () {
      var { _r, v, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(23);
            _r = v.typ.Elem().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 8)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 8))) { */ case 1:
            $panic(new $String("reflect.Value.Bytes of non-byte slice"));
          /* } */ case 2:
            $s = -1;
            return v.ptr.$get();
          /* */
        }
        return;
      }
      var $f = { $blk: Value.ptr.prototype.Bytes, $c: true, $r, _r, v, $s };
      return $f;
    };
    Value.prototype.Bytes = function () {
      return this.$val.Bytes();
    };
    Value.ptr.prototype.runes = function () {
      var { _r, v, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(23);
            _r = v.typ.Elem().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 5)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 5))) { */ case 1:
            $panic(new $String("reflect.Value.Bytes of non-rune slice"));
          /* } */ case 2:
            $s = -1;
            return v.ptr.$get();
          /* */
        }
        return;
      }
      var $f = { $blk: Value.ptr.prototype.runes, $c: true, $r, _r, v, $s };
      return $f;
    };
    Value.prototype.runes = function () {
      return this.$val.runes();
    };
    Value.ptr.prototype.CanAddr = function () {
      var v;
      v = this;
      return !((v.flag & 256) >>> 0 === 0);
    };
    Value.prototype.CanAddr = function () {
      return this.$val.CanAddr();
    };
    Value.ptr.prototype.CanSet = function () {
      var v;
      v = this;
      return (v.flag & 352) >>> 0 === 256;
    };
    Value.prototype.CanSet = function () {
      return this.$val.CanSet();
    };
    Value.ptr.prototype.Call = function (in$1) {
      var { $24r, _r, in$1, v, $s, $r, $c } = $restore(this, { in$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(19);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).call("Call", in$1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Call,
        $c: true,
        $r,
        $24r,
        _r,
        in$1,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Call = function (in$1) {
      return this.$val.Call(in$1);
    };
    Value.ptr.prototype.CallSlice = function (in$1) {
      var { $24r, _r, in$1, v, $s, $r, $c } = $restore(this, { in$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(19);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).call("CallSlice", in$1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.CallSlice,
        $c: true,
        $r,
        $24r,
        _r,
        in$1,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.CallSlice = function (in$1) {
      return this.$val.CallSlice(in$1);
    };
    Value.ptr.prototype.CanComplex = function () {
      var _1, v;
      v = this;
      _1 = new flag(v.flag).kind();
      if (_1 === 15 || _1 === 16) {
        return true;
      } else {
        return false;
      }
    };
    Value.prototype.CanComplex = function () {
      return this.$val.CanComplex();
    };
    Value.ptr.prototype.Complex = function () {
      var _1, k, v, x;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 15) {
        return (x = v.ptr.$get()), new $Complex128(x.$real, x.$imag);
      } else if (_1 === 16) {
        return v.ptr.$get();
      }
      $panic(
        new ValueError.ptr("reflect.Value.Complex", new flag(v.flag).kind())
      );
    };
    Value.prototype.Complex = function () {
      return this.$val.Complex();
    };
    Value.ptr.prototype.FieldByIndex = function (index) {
      var {
        $24r,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _ref,
        _v,
        i,
        index,
        v,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { index });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            /* */ if (index.$length === 1) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (index.$length === 1) { */ case 1:
            _r = $clone(v, Value).Field(
              0 >= index.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : index.$array[index.$offset + 0]
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            new flag(v.flag).mustBe(25);
            _ref = index;
            _i = 0;
          /* while (true) { */ case 5:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 6;
              continue;
            }
            i = _i;
            x =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            /* */ if (i > 0) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (i > 0) { */ case 7:
            if (!($clone(v, Value).Kind() === 22)) {
              _v = false;
              $s = 11;
              continue s;
            }
            _r$1 = v.typ.Elem().Kind();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = _r$1 === 25;
          case 11:
            /* */ if (_v) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (_v) { */ case 9:
            if ($clone(v, Value).IsNil()) {
              $panic(
                new $String(
                  "reflect: indirection through nil pointer to embedded struct"
                )
              );
            }
            _r$2 = $clone(v, Value).Elem();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            v = _r$2;
          /* } */ case 10:
          /* } */ case 8:
            _r$3 = $clone(v, Value).Field(x);
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            v = _r$3;
            _i++;
            $s = 5;
            continue;
          case 6:
            $s = -1;
            return v;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.FieldByIndex,
        $c: true,
        $r,
        $24r,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _ref,
        _v,
        i,
        index,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.FieldByIndex = function (index) {
      return this.$val.FieldByIndex(index);
    };
    Value.ptr.prototype.FieldByIndexErr = function (index) {
      var {
        $24r,
        $24r$1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _ref,
        _v,
        i,
        index,
        v,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { index });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            /* */ if (index.$length === 1) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (index.$length === 1) { */ case 1:
            _r = $clone(v, Value).Field(
              0 >= index.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : index.$array[index.$offset + 0]
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = [_r, $ifaceNil];
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            new flag(v.flag).mustBe(25);
            _ref = index;
            _i = 0;
          /* while (true) { */ case 5:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 6;
              continue;
            }
            i = _i;
            x =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            /* */ if (i > 0) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (i > 0) { */ case 7:
            if (!($clone(v, Value).Kind() === 22)) {
              _v = false;
              $s = 11;
              continue s;
            }
            _r$1 = v.typ.Elem().Kind();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = _r$1 === 25;
          case 11:
            /* */ if (_v) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (_v) { */ case 9:
            /* */ if ($clone(v, Value).IsNil()) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if ($clone(v, Value).IsNil()) { */ case 13:
            _r$2 = v.typ.Elem().Name();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$3 = errors.New(
              "reflect: indirection through nil pointer to embedded struct field " +
                _r$2
            );
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r$1 = [new Value.ptr(ptrType$1.nil, 0, 0), _r$3];
            $s = 17;
          case 17:
            return $24r$1;
          /* } */ case 14:
            _r$4 = $clone(v, Value).Elem();
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            v = _r$4;
          /* } */ case 10:
          /* } */ case 8:
            _r$5 = $clone(v, Value).Field(x);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            v = _r$5;
            _i++;
            $s = 5;
            continue;
          case 6:
            $s = -1;
            return [v, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.FieldByIndexErr,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _ref,
        _v,
        i,
        index,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.FieldByIndexErr = function (index) {
      return this.$val.FieldByIndexErr(index);
    };
    Value.ptr.prototype.FieldByName = function (name$1) {
      var { $24r, _r, _r$1, _tuple, f, name$1, ok, v, $s, $r, $c } = $restore(
        this,
        { name$1 }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(25);
            _r = v.typ.FieldByName(name$1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            f = $clone(_tuple[0], StructField);
            ok = _tuple[1];
            /* */ if (ok) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (ok) { */ case 2:
            _r$1 = $clone(v, Value).FieldByIndex(f.Index);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 5;
          case 5:
            return $24r;
          /* } */ case 3:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.FieldByName,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _tuple,
        f,
        name$1,
        ok,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.FieldByName = function (name$1) {
      return this.$val.FieldByName(name$1);
    };
    Value.ptr.prototype.FieldByNameFunc = function (match) {
      var { $24r, _r, _r$1, _tuple, f, match, ok, v, $s, $r, $c } = $restore(
        this,
        { match }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            _r = v.typ.FieldByNameFunc(match);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            f = $clone(_tuple[0], StructField);
            ok = _tuple[1];
            /* */ if (ok) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (ok) { */ case 2:
            _r$1 = $clone(v, Value).FieldByIndex(f.Index);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 5;
          case 5:
            return $24r;
          /* } */ case 3:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.FieldByNameFunc,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _tuple,
        f,
        match,
        ok,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.FieldByNameFunc = function (match) {
      return this.$val.FieldByNameFunc(match);
    };
    Value.ptr.prototype.CanFloat = function () {
      var _1, v;
      v = this;
      _1 = new flag(v.flag).kind();
      if (_1 === 13 || _1 === 14) {
        return true;
      } else {
        return false;
      }
    };
    Value.prototype.CanFloat = function () {
      return this.$val.CanFloat();
    };
    Value.ptr.prototype.Float = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 13) {
        return v.ptr.$get();
      } else if (_1 === 14) {
        return v.ptr.$get();
      }
      $panic(
        new ValueError.ptr("reflect.Value.Float", new flag(v.flag).kind())
      );
    };
    Value.prototype.Float = function () {
      return this.$val.Float();
    };
    Value.ptr.prototype.CanInt = function () {
      var _1, v;
      v = this;
      _1 = new flag(v.flag).kind();
      if (_1 === 2 || _1 === 3 || _1 === 4 || _1 === 5 || _1 === 6) {
        return true;
      } else {
        return false;
      }
    };
    Value.prototype.CanInt = function () {
      return this.$val.CanInt();
    };
    Value.ptr.prototype.Int = function () {
      var _1, k, p, v;
      v = this;
      k = new flag(v.flag).kind();
      p = v.ptr;
      _1 = k;
      if (_1 === 2) {
        return new $Int64(0, p.$get());
      } else if (_1 === 3) {
        return new $Int64(0, p.$get());
      } else if (_1 === 4) {
        return new $Int64(0, p.$get());
      } else if (_1 === 5) {
        return new $Int64(0, p.$get());
      } else if (_1 === 6) {
        return p.$get();
      }
      $panic(new ValueError.ptr("reflect.Value.Int", new flag(v.flag).kind()));
    };
    Value.prototype.Int = function () {
      return this.$val.Int();
    };
    Value.ptr.prototype.CanInterface = function () {
      var v;
      v = this;
      if (v.flag === 0) {
        $panic(new ValueError.ptr("reflect.Value.CanInterface", 0));
      }
      return (v.flag & 96) >>> 0 === 0;
    };
    Value.prototype.CanInterface = function () {
      return this.$val.CanInterface();
    };
    Value.ptr.prototype.Interface = function () {
      var { $24r, _r, i, v, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            i = $ifaceNil;
            v = this;
            _r = valueInterface($clone(v, Value), true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            i = _r;
            $24r = i;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Interface,
        $c: true,
        $r,
        $24r,
        _r,
        i,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Interface = function () {
      return this.$val.Interface();
    };
    Value.ptr.prototype.IsValid = function () {
      var v;
      v = this;
      return !(v.flag === 0);
    };
    Value.prototype.IsValid = function () {
      return this.$val.IsValid();
    };
    Value.ptr.prototype.IsZero = function () {
      var {
        _1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        c,
        i,
        i$1,
        v,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            _1 = new flag(v.flag).kind();
            /* */ if (_1 === 1) {
              $s = 2;
              continue;
            }
            /* */ if (
              _1 === 2 ||
              _1 === 3 ||
              _1 === 4 ||
              _1 === 5 ||
              _1 === 6
            ) {
              $s = 3;
              continue;
            }
            /* */ if (
              _1 === 7 ||
              _1 === 8 ||
              _1 === 9 ||
              _1 === 10 ||
              _1 === 11 ||
              _1 === 12
            ) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 13 || _1 === 14) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 15 || _1 === 16) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 17) {
              $s = 7;
              continue;
            }
            /* */ if (
              _1 === 18 ||
              _1 === 19 ||
              _1 === 20 ||
              _1 === 21 ||
              _1 === 22 ||
              _1 === 23 ||
              _1 === 26
            ) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 9;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_1 === (1)) { */ case 2:
            $s = -1;
            return !$clone(v, Value).Bool();
          /* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 3:
            $s = -1;
            return (x = $clone(v, Value).Int()), x.$high === 0 && x.$low === 0;
          /* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 4:
            $s = -1;
            return (
              (x$1 = $clone(v, Value).Uint()), x$1.$high === 0 && x$1.$low === 0
            );
          /* } else if ((_1 === (13)) || (_1 === (14))) { */ case 5:
            $s = -1;
            return (
              (x$2 = math.Float64bits($clone(v, Value).Float())),
              x$2.$high === 0 && x$2.$low === 0
            );
          /* } else if ((_1 === (15)) || (_1 === (16))) { */ case 6:
            c = $clone(v, Value).Complex();
            $s = -1;
            return (
              ((x$3 = math.Float64bits(c.$real)),
              x$3.$high === 0 && x$3.$low === 0) &&
              ((x$4 = math.Float64bits(c.$imag)),
              x$4.$high === 0 && x$4.$low === 0)
            );
          /* } else if (_1 === (17)) { */ case 7:
            i = 0;
          /* while (true) { */ case 13:
            /* if (!(i < $clone(v, Value).Len())) { break; } */ if (
              !(i < $clone(v, Value).Len())
            ) {
              $s = 14;
              continue;
            }
            _r = $clone(v, Value).Index(i);
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = $clone(_r, Value).IsZero();
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$1) {
              $s = 15;
              continue;
            }
            /* */ $s = 16;
            continue;
          /* if (!_r$1) { */ case 15:
            $s = -1;
            return false;
          /* } */ case 16:
            i = (i + 1) >> 0;
            $s = 13;
            continue;
          case 14:
            $s = -1;
            return true;
          /* } else if ((_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { */ case 8:
            $s = -1;
            return $clone(v, Value).IsNil();
          /* } else if (_1 === (24)) { */ case 9:
            $s = -1;
            return $clone(v, Value).Len() === 0;
          /* } else if (_1 === (25)) { */ case 10:
            i$1 = 0;
          /* while (true) { */ case 19:
            /* if (!(i$1 < $clone(v, Value).NumField())) { break; } */ if (
              !(i$1 < $clone(v, Value).NumField())
            ) {
              $s = 20;
              continue;
            }
            _r$2 = $clone(v, Value).Field(i$1);
            /* */ $s = 23;
          case 23:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$3 = $clone(_r$2, Value).IsZero();
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$3) {
              $s = 21;
              continue;
            }
            /* */ $s = 22;
            continue;
          /* if (!_r$3) { */ case 21:
            $s = -1;
            return false;
          /* } */ case 22:
            i$1 = (i$1 + 1) >> 0;
            $s = 19;
            continue;
          case 20:
            $s = -1;
            return true;
          /* } else { */ case 11:
            $panic(
              new ValueError.ptr(
                "reflect.Value.IsZero",
                $clone(v, Value).Kind()
              )
            );
          /* } */ case 12:
          case 1:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.IsZero,
        $c: true,
        $r,
        _1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        c,
        i,
        i$1,
        v,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
      };
      return $f;
    };
    Value.prototype.IsZero = function () {
      return this.$val.IsZero();
    };
    Value.ptr.prototype.Kind = function () {
      var v;
      v = this;
      return new flag(v.flag).kind();
    };
    Value.prototype.Kind = function () {
      return this.$val.Kind();
    };
    Value.ptr.prototype.MapIndex = function (key) {
      var { _r, e, fl, k, k$1, key, tt, typ, v, $s, $r, $c } = $restore(this, {
        key,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(21);
            tt = v.typ.kindType;
            e = 0;
            /* */ if (
              new flag(key.flag).kind() === 24 &&
              tt.key.Kind() === 24 &&
              tt.elem.size <= 128
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ((new flag(key.flag).kind() === 24) && (tt.key.Kind() === 24) && tt.elem.size <= 128) { */ case 1:
            k = key.ptr.$get();
            e = mapaccess_faststr(v.typ, $clone(v, Value).pointer(), k);
            $s = 3;
            continue;
          /* } else { */ case 2:
            _r = $clone(key, Value).assignTo(
              "reflect.Value.MapIndex",
              tt.key,
              0
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            key = _r;
            k$1 = 0;
            if (!((key.flag & 128) >>> 0 === 0)) {
              k$1 = key.ptr;
            } else {
              k$1 =
                key.$ptr_ptr ||
                (key.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  key
                ));
            }
            e = mapaccess(v.typ, $clone(v, Value).pointer(), k$1);
          /* } */ case 3:
            if (e === 0) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            typ = tt.elem;
            fl = new flag((v.flag | key.flag) >>> 0).ro();
            fl = (fl | (typ.Kind() >>> 0)) >>> 0;
            $s = -1;
            return copyVal(typ, fl, e);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.MapIndex,
        $c: true,
        $r,
        _r,
        e,
        fl,
        k,
        k$1,
        key,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.MapIndex = function (key) {
      return this.$val.MapIndex(key);
    };
    Value.ptr.prototype.MapKeys = function () {
      var { _r, a, fl, i, it, key, keyType, m, mlen, tt, v, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            it = [it];
            v = this;
            new flag(v.flag).mustBe(21);
            tt = v.typ.kindType;
            keyType = tt.key;
            fl = (new flag(v.flag).ro() | (keyType.Kind() >>> 0)) >>> 0;
            m = $clone(v, Value).pointer();
            mlen = 0;
            if (!(m === 0)) {
              mlen = maplen(m);
            }
            it[0] = new hiter.ptr($ifaceNil, null, null, 0, null);
            mapiterinit(v.typ, m, it[0]);
            a = $makeSlice(sliceType$7, mlen);
            i = 0;
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < a.$length)) { break; } */ if (!(i < a.$length)) {
              $s = 2;
              continue;
            }
            _r = mapiterkey(it[0]);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            key = _r;
            if (key === 0) {
              /* break; */ $s = 2;
              continue;
            }
            i < 0 || i >= a.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (a.$array[a.$offset + i] = copyVal(keyType, fl, key));
            mapiternext(it[0]);
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return $subslice(a, 0, i);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.MapKeys,
        $c: true,
        $r,
        _r,
        a,
        fl,
        i,
        it,
        key,
        keyType,
        m,
        mlen,
        tt,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.MapKeys = function () {
      return this.$val.MapKeys();
    };
    hiter.ptr.prototype.initialized = function () {
      var h;
      h = this;
      return !$interfaceIsEqual(h.t, $ifaceNil);
    };
    hiter.prototype.initialized = function () {
      return this.$val.initialized();
    };
    MapIter.ptr.prototype.Key = function () {
      var { _r, iter, iterkey, ktype, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            iter = this;
            if (!iter.hiter.initialized()) {
              $panic(new $String("MapIter.Key called before Next"));
            }
            _r = mapiterkey(iter.hiter);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            iterkey = _r;
            if (iterkey === 0) {
              $panic(new $String("MapIter.Key called on exhausted iterator"));
            }
            t = iter.m.typ.kindType;
            ktype = t.key;
            $s = -1;
            return copyVal(
              ktype,
              (new flag(iter.m.flag).ro() | (ktype.Kind() >>> 0)) >>> 0,
              iterkey
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: MapIter.ptr.prototype.Key,
        $c: true,
        $r,
        _r,
        iter,
        iterkey,
        ktype,
        t,
        $s,
      };
      return $f;
    };
    MapIter.prototype.Key = function () {
      return this.$val.Key();
    };
    Value.ptr.prototype.SetIterKey = function (iter) {
      var { _r, _r$1, iter, iterkey, key, ktype, t, target, v, $s, $r, $c } =
        $restore(this, { iter });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            if (!iter.hiter.initialized()) {
              $panic(
                new $String("reflect: Value.SetIterKey called before Next")
              );
            }
            _r = mapiterkey(iter.hiter);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            iterkey = _r;
            if (iterkey === 0) {
              $panic(
                new $String(
                  "reflect: Value.SetIterKey called on exhausted iterator"
                )
              );
            }
            new flag(v.flag).mustBeAssignable();
            target = 0;
            if (new flag(v.flag).kind() === 20) {
              target = v.ptr;
            }
            t = iter.m.typ.kindType;
            ktype = t.key;
            key = new Value.ptr(
              ktype,
              iterkey,
              (((iter.m.flag | (ktype.Kind() >>> 0)) >>> 0) | 128) >>> 0
            );
            _r$1 = $clone(key, Value).assignTo(
              "reflect.MapIter.SetKey",
              v.typ,
              target
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            key = _r$1;
            typedmemmove(v.typ, v.ptr, key.ptr);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.SetIterKey,
        $c: true,
        $r,
        _r,
        _r$1,
        iter,
        iterkey,
        key,
        ktype,
        t,
        target,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.SetIterKey = function (iter) {
      return this.$val.SetIterKey(iter);
    };
    MapIter.ptr.prototype.Value = function () {
      var { _r, iter, iterelem, t, vtype, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            iter = this;
            if (!iter.hiter.initialized()) {
              $panic(new $String("MapIter.Value called before Next"));
            }
            _r = mapiterelem(iter.hiter);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            iterelem = _r;
            if (iterelem === 0) {
              $panic(new $String("MapIter.Value called on exhausted iterator"));
            }
            t = iter.m.typ.kindType;
            vtype = t.elem;
            $s = -1;
            return copyVal(
              vtype,
              (new flag(iter.m.flag).ro() | (vtype.Kind() >>> 0)) >>> 0,
              iterelem
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: MapIter.ptr.prototype.Value,
        $c: true,
        $r,
        _r,
        iter,
        iterelem,
        t,
        vtype,
        $s,
      };
      return $f;
    };
    MapIter.prototype.Value = function () {
      return this.$val.Value();
    };
    Value.ptr.prototype.SetIterValue = function (iter) {
      var { _r, _r$1, elem, iter, iterelem, t, target, v, vtype, $s, $r, $c } =
        $restore(this, { iter });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            if (!iter.hiter.initialized()) {
              $panic(
                new $String("reflect: Value.SetIterValue called before Next")
              );
            }
            _r = mapiterelem(iter.hiter);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            iterelem = _r;
            if (iterelem === 0) {
              $panic(
                new $String(
                  "reflect: Value.SetIterValue called on exhausted iterator"
                )
              );
            }
            new flag(v.flag).mustBeAssignable();
            target = 0;
            if (new flag(v.flag).kind() === 20) {
              target = v.ptr;
            }
            t = iter.m.typ.kindType;
            vtype = t.elem;
            elem = new Value.ptr(
              vtype,
              iterelem,
              (((iter.m.flag | (vtype.Kind() >>> 0)) >>> 0) | 128) >>> 0
            );
            _r$1 = $clone(elem, Value).assignTo(
              "reflect.MapIter.SetValue",
              v.typ,
              target
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            elem = _r$1;
            typedmemmove(v.typ, v.ptr, elem.ptr);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.SetIterValue,
        $c: true,
        $r,
        _r,
        _r$1,
        elem,
        iter,
        iterelem,
        t,
        target,
        v,
        vtype,
        $s,
      };
      return $f;
    };
    Value.prototype.SetIterValue = function (iter) {
      return this.$val.SetIterValue(iter);
    };
    MapIter.ptr.prototype.Next = function () {
      var { $24r, _r, _r$1, iter, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            iter = this;
            if (!$clone(iter.m, Value).IsValid()) {
              $panic(
                new $String(
                  "MapIter.Next called on an iterator that does not have an associated map Value"
                )
              );
            }
            /* */ if (!iter.hiter.initialized()) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!iter.hiter.initialized()) { */ case 1:
            mapiterinit(
              iter.m.typ,
              $clone(iter.m, Value).pointer(),
              iter.hiter
            );
            $s = 3;
            continue;
          /* } else { */ case 2:
            _r = mapiterkey(iter.hiter);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (_r === 0) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_r === 0) { */ case 4:
            $panic(new $String("MapIter.Next called on exhausted iterator"));
          /* } */ case 5:
            mapiternext(iter.hiter);
          /* } */ case 3:
            _r$1 = mapiterkey(iter.hiter);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = !(_r$1 === 0);
            $s = 8;
          case 8:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: MapIter.ptr.prototype.Next,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        iter,
        $s,
      };
      return $f;
    };
    MapIter.prototype.Next = function () {
      return this.$val.Next();
    };
    MapIter.ptr.prototype.Reset = function (v) {
      var iter, v;
      iter = this;
      if ($clone(v, Value).IsValid()) {
        new flag(v.flag).mustBe(21);
      }
      iter.m = v;
      hiter.copy(iter.hiter, new hiter.ptr($ifaceNil, null, null, 0, null));
    };
    MapIter.prototype.Reset = function (v) {
      return this.$val.Reset(v);
    };
    Value.ptr.prototype.MapRange = function () {
      var v;
      v = this;
      new flag(v.flag).mustBe(21);
      return new MapIter.ptr(
        $clone(v, Value),
        new hiter.ptr($ifaceNil, null, null, 0, null)
      );
    };
    Value.prototype.MapRange = function () {
      return this.$val.MapRange();
    };
    copyVal = function (typ, fl, ptr) {
      var c, fl, ptr, typ;
      if (ifaceIndir(typ)) {
        c = unsafe_New(typ);
        typedmemmove(typ, c, ptr);
        return new Value.ptr(typ, c, (fl | 128) >>> 0);
      }
      return new Value.ptr(typ, ptr.$get(), fl);
    };
    Value.ptr.prototype.Method = function (i) {
      var fl, i, v;
      v = this;
      if (v.typ === ptrType$1.nil) {
        $panic(new ValueError.ptr("reflect.Value.Method", 0));
      }
      if (!((v.flag & 512) >>> 0 === 0) || i >>> 0 >= v.typ.NumMethod() >>> 0) {
        $panic(new $String("reflect: Method index out of range"));
      }
      if (v.typ.Kind() === 20 && $clone(v, Value).IsNil()) {
        $panic(new $String("reflect: Method on nil interface value"));
      }
      fl = (new flag(v.flag).ro() | ((v.flag & 128) >>> 0)) >>> 0;
      fl = (fl | 19) >>> 0;
      fl = (fl | (((((i >>> 0) << 10) >>> 0) | 512) >>> 0)) >>> 0;
      return new Value.ptr(v.typ, v.ptr, fl);
    };
    Value.prototype.Method = function (i) {
      return this.$val.Method(i);
    };
    Value.ptr.prototype.NumMethod = function () {
      var v;
      v = this;
      if (v.typ === ptrType$1.nil) {
        $panic(new ValueError.ptr("reflect.Value.NumMethod", 0));
      }
      if (!((v.flag & 512) >>> 0 === 0)) {
        return 0;
      }
      return v.typ.NumMethod();
    };
    Value.prototype.NumMethod = function () {
      return this.$val.NumMethod();
    };
    Value.ptr.prototype.MethodByName = function (name$1) {
      var { _r, _tuple, m, name$1, ok, v, $s, $r, $c } = $restore(this, {
        name$1,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            if (v.typ === ptrType$1.nil) {
              $panic(new ValueError.ptr("reflect.Value.MethodByName", 0));
            }
            if (!((v.flag & 512) >>> 0 === 0)) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            _r = v.typ.MethodByName(name$1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            m = $clone(_tuple[0], Method);
            ok = _tuple[1];
            if (!ok) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            $s = -1;
            return $clone(v, Value).Method(m.Index);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.MethodByName,
        $c: true,
        $r,
        _r,
        _tuple,
        m,
        name$1,
        ok,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.MethodByName = function (name$1) {
      return this.$val.MethodByName(name$1);
    };
    Value.ptr.prototype.NumField = function () {
      var tt, v;
      v = this;
      new flag(v.flag).mustBe(25);
      tt = v.typ.kindType;
      return tt.fields.$length;
    };
    Value.prototype.NumField = function () {
      return this.$val.NumField();
    };
    Value.ptr.prototype.OverflowComplex = function (x) {
      var _1, k, v, x;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 15) {
        return overflowFloat32(x.$real) || overflowFloat32(x.$imag);
      } else if (_1 === 16) {
        return false;
      }
      $panic(
        new ValueError.ptr(
          "reflect.Value.OverflowComplex",
          new flag(v.flag).kind()
        )
      );
    };
    Value.prototype.OverflowComplex = function (x) {
      return this.$val.OverflowComplex(x);
    };
    Value.ptr.prototype.OverflowFloat = function (x) {
      var _1, k, v, x;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 13) {
        return overflowFloat32(x);
      } else if (_1 === 14) {
        return false;
      }
      $panic(
        new ValueError.ptr(
          "reflect.Value.OverflowFloat",
          new flag(v.flag).kind()
        )
      );
    };
    Value.prototype.OverflowFloat = function (x) {
      return this.$val.OverflowFloat(x);
    };
    overflowFloat32 = function (x) {
      var x;
      if (x < 0) {
        x = -x;
      }
      return 3.4028234663852886e38 < x && x <= 1.7976931348623157e308;
    };
    Value.ptr.prototype.OverflowInt = function (x) {
      var _1, bitSize, k, trunc, v, x;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 2 || _1 === 3 || _1 === 4 || _1 === 5 || _1 === 6) {
        bitSize = $imul(v.typ.size, 8) >>> 0;
        trunc = $shiftRightInt64(
          $shiftLeft64(x, (64 - bitSize) >>> 0),
          (64 - bitSize) >>> 0
        );
        return !(x.$high === trunc.$high && x.$low === trunc.$low);
      }
      $panic(
        new ValueError.ptr("reflect.Value.OverflowInt", new flag(v.flag).kind())
      );
    };
    Value.prototype.OverflowInt = function (x) {
      return this.$val.OverflowInt(x);
    };
    Value.ptr.prototype.OverflowUint = function (x) {
      var _1, bitSize, k, trunc, v, x;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (
        _1 === 7 ||
        _1 === 12 ||
        _1 === 8 ||
        _1 === 9 ||
        _1 === 10 ||
        _1 === 11
      ) {
        bitSize = $imul(v.typ.size, 8) >>> 0;
        trunc = $shiftRightUint64(
          $shiftLeft64(x, (64 - bitSize) >>> 0),
          (64 - bitSize) >>> 0
        );
        return !(x.$high === trunc.$high && x.$low === trunc.$low);
      }
      $panic(
        new ValueError.ptr(
          "reflect.Value.OverflowUint",
          new flag(v.flag).kind()
        )
      );
    };
    Value.prototype.OverflowUint = function (x) {
      return this.$val.OverflowUint(x);
    };
    Value.ptr.prototype.Recv = function () {
      var { $24r, _r, _tuple, ok, v, x, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            x = new Value.ptr(ptrType$1.nil, 0, 0);
            ok = false;
            v = this;
            new flag(v.flag).mustBe(18);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).recv(false);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            x = _tuple[0];
            ok = _tuple[1];
            $24r = [x, ok];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Recv,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        ok,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.Recv = function () {
      return this.$val.Recv();
    };
    Value.ptr.prototype.recv = function (nb) {
      var { _r, _tuple, nb, ok, p, selected, t, tt, v, val, $s, $r, $c } =
        $restore(this, { nb });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            val = new Value.ptr(ptrType$1.nil, 0, 0);
            ok = false;
            v = this;
            tt = v.typ.kindType;
            if (((tt.dir >> 0) & 1) === 0) {
              $panic(new $String("reflect: recv on send-only channel"));
            }
            t = tt.elem;
            val = new Value.ptr(t, 0, t.Kind() >>> 0);
            p = 0;
            if (ifaceIndir(t)) {
              p = unsafe_New(t);
              val.ptr = p;
              val.flag = (val.flag | 128) >>> 0;
            } else {
              p =
                val.$ptr_ptr ||
                (val.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  val
                ));
            }
            _r = chanrecv($clone(v, Value).pointer(), nb, p);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            selected = _tuple[0];
            ok = _tuple[1];
            if (!selected) {
              val = new Value.ptr(ptrType$1.nil, 0, 0);
            }
            $s = -1;
            return [val, ok];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.recv,
        $c: true,
        $r,
        _r,
        _tuple,
        nb,
        ok,
        p,
        selected,
        t,
        tt,
        v,
        val,
        $s,
      };
      return $f;
    };
    Value.prototype.recv = function (nb) {
      return this.$val.recv(nb);
    };
    Value.ptr.prototype.Send = function (x) {
      var { _r, v, x, $s, $r, $c } = $restore(this, { x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(18);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).send($clone(x, Value), false);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r;
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: Value.ptr.prototype.Send, $c: true, $r, _r, v, x, $s };
      return $f;
    };
    Value.prototype.Send = function (x) {
      return this.$val.Send(x);
    };
    Value.ptr.prototype.send = function (x, nb) {
      var { $24r, _r, _r$1, nb, p, selected, tt, v, x, $s, $r, $c } = $restore(
        this,
        { x, nb }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            selected = false;
            v = this;
            tt = v.typ.kindType;
            if (((tt.dir >> 0) & 2) === 0) {
              $panic(new $String("reflect: send on recv-only channel"));
            }
            new flag(x.flag).mustBeExported();
            _r = $clone(x, Value).assignTo("reflect.Value.Send", tt.elem, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            x = _r;
            p = 0;
            if (!((x.flag & 128) >>> 0 === 0)) {
              p = x.ptr;
            } else {
              p =
                x.$ptr_ptr ||
                (x.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  x
                ));
            }
            _r$1 = chansend($clone(v, Value).pointer(), p, nb);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            selected = _r$1;
            $24r = selected;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.send,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        nb,
        p,
        selected,
        tt,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.send = function (x, nb) {
      return this.$val.send(x, nb);
    };
    Value.ptr.prototype.SetBool = function (x) {
      var v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(1);
      v.ptr.$set(x);
    };
    Value.prototype.SetBool = function (x) {
      return this.$val.SetBool(x);
    };
    Value.ptr.prototype.setRunes = function (x) {
      var { _r, v, x, $s, $r, $c } = $restore(this, { x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBeAssignable();
            new flag(v.flag).mustBe(23);
            _r = v.typ.Elem().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 5)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 5))) { */ case 1:
            $panic(new $String("reflect.Value.setRunes of non-rune slice"));
          /* } */ case 2:
            v.ptr.$set(x);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.setRunes,
        $c: true,
        $r,
        _r,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.setRunes = function (x) {
      return this.$val.setRunes(x);
    };
    Value.ptr.prototype.SetComplex = function (x) {
      var _1, k, v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 15) {
        v.ptr.$set(new $Complex64(x.$real, x.$imag));
      } else if (_1 === 16) {
        v.ptr.$set(x);
      } else {
        $panic(
          new ValueError.ptr(
            "reflect.Value.SetComplex",
            new flag(v.flag).kind()
          )
        );
      }
    };
    Value.prototype.SetComplex = function (x) {
      return this.$val.SetComplex(x);
    };
    Value.ptr.prototype.SetFloat = function (x) {
      var _1, k, v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 13) {
        v.ptr.$set($fround(x));
      } else if (_1 === 14) {
        v.ptr.$set(x);
      } else {
        $panic(
          new ValueError.ptr("reflect.Value.SetFloat", new flag(v.flag).kind())
        );
      }
    };
    Value.prototype.SetFloat = function (x) {
      return this.$val.SetFloat(x);
    };
    Value.ptr.prototype.SetInt = function (x) {
      var _1, k, v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 2) {
        v.ptr.$set((x.$low + (x.$high >> 31) * 4294967296) >> 0);
      } else if (_1 === 3) {
        v.ptr.$set(((x.$low + (x.$high >> 31) * 4294967296) << 24) >> 24);
      } else if (_1 === 4) {
        v.ptr.$set(((x.$low + (x.$high >> 31) * 4294967296) << 16) >> 16);
      } else if (_1 === 5) {
        v.ptr.$set((x.$low + (x.$high >> 31) * 4294967296) >> 0);
      } else if (_1 === 6) {
        v.ptr.$set(x);
      } else {
        $panic(
          new ValueError.ptr("reflect.Value.SetInt", new flag(v.flag).kind())
        );
      }
    };
    Value.prototype.SetInt = function (x) {
      return this.$val.SetInt(x);
    };
    Value.ptr.prototype.SetMapIndex = function (key, elem) {
      var { _r, _r$1, _r$2, e, e$1, elem, k, k$1, key, tt, v, $s, $r, $c } =
        $restore(this, { key, elem });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(21);
            new flag(v.flag).mustBeExported();
            new flag(key.flag).mustBeExported();
            tt = v.typ.kindType;
            /* */ if (
              new flag(key.flag).kind() === 24 &&
              tt.key.Kind() === 24 &&
              tt.elem.size <= 128
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ((new flag(key.flag).kind() === 24) && (tt.key.Kind() === 24) && tt.elem.size <= 128) { */ case 1:
            k = key.ptr.$get();
            if (elem.typ === ptrType$1.nil) {
              mapdelete_faststr(v.typ, $clone(v, Value).pointer(), k);
              $s = -1;
              return;
            }
            new flag(elem.flag).mustBeExported();
            _r = $clone(elem, Value).assignTo(
              "reflect.Value.SetMapIndex",
              tt.elem,
              0
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            elem = _r;
            e = 0;
            if (!((elem.flag & 128) >>> 0 === 0)) {
              e = elem.ptr;
            } else {
              e =
                elem.$ptr_ptr ||
                (elem.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  elem
                ));
            }
            $r = mapassign_faststr(v.typ, $clone(v, Value).pointer(), k, e);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 2:
            _r$1 = $clone(key, Value).assignTo(
              "reflect.Value.SetMapIndex",
              tt.key,
              0
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            key = _r$1;
            k$1 = 0;
            if (!((key.flag & 128) >>> 0 === 0)) {
              k$1 = key.ptr;
            } else {
              k$1 =
                key.$ptr_ptr ||
                (key.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  key
                ));
            }
            if (elem.typ === ptrType$1.nil) {
              mapdelete(v.typ, $clone(v, Value).pointer(), k$1);
              $s = -1;
              return;
            }
            new flag(elem.flag).mustBeExported();
            _r$2 = $clone(elem, Value).assignTo(
              "reflect.Value.SetMapIndex",
              tt.elem,
              0
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            elem = _r$2;
            e$1 = 0;
            if (!((elem.flag & 128) >>> 0 === 0)) {
              e$1 = elem.ptr;
            } else {
              e$1 =
                elem.$ptr_ptr ||
                (elem.$ptr_ptr = new ptrType$7(
                  function () {
                    return this.$target.ptr;
                  },
                  function ($v) {
                    this.$target.ptr = $v;
                  },
                  elem
                ));
            }
            $r = mapassign(v.typ, $clone(v, Value).pointer(), k$1, e$1);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.SetMapIndex,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        e,
        e$1,
        elem,
        k,
        k$1,
        key,
        tt,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.SetMapIndex = function (key, elem) {
      return this.$val.SetMapIndex(key, elem);
    };
    Value.ptr.prototype.SetUint = function (x) {
      var _1, k, v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 7) {
        v.ptr.$set(x.$low >>> 0);
      } else if (_1 === 8) {
        v.ptr.$set((x.$low << 24) >>> 24);
      } else if (_1 === 9) {
        v.ptr.$set((x.$low << 16) >>> 16);
      } else if (_1 === 10) {
        v.ptr.$set(x.$low >>> 0);
      } else if (_1 === 11) {
        v.ptr.$set(x);
      } else if (_1 === 12) {
        v.ptr.$set(x.$low >>> 0);
      } else {
        $panic(
          new ValueError.ptr("reflect.Value.SetUint", new flag(v.flag).kind())
        );
      }
    };
    Value.prototype.SetUint = function (x) {
      return this.$val.SetUint(x);
    };
    Value.ptr.prototype.SetPointer = function (x) {
      var v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(26);
      v.ptr.$set(x);
    };
    Value.prototype.SetPointer = function (x) {
      return this.$val.SetPointer(x);
    };
    Value.ptr.prototype.SetString = function (x) {
      var v, x;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(24);
      v.ptr.$set(x);
    };
    Value.prototype.SetString = function (x) {
      return this.$val.SetString(x);
    };
    Value.ptr.prototype.String = function () {
      var { $24r, _1, _r, k, v, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            if (_1 === 0) {
              $s = -1;
              return "<invalid Value>";
            } else if (_1 === 24) {
              $s = -1;
              return v.ptr.$get();
            }
            _r = $clone(v, Value).Type().String();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = "<" + _r + " Value>";
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.String,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        k,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.String = function () {
      return this.$val.String();
    };
    Value.ptr.prototype.TryRecv = function () {
      var { $24r, _r, _tuple, ok, v, x, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            x = new Value.ptr(ptrType$1.nil, 0, 0);
            ok = false;
            v = this;
            new flag(v.flag).mustBe(18);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).recv(true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            x = _tuple[0];
            ok = _tuple[1];
            $24r = [x, ok];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.TryRecv,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        ok,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.TryRecv = function () {
      return this.$val.TryRecv();
    };
    Value.ptr.prototype.TrySend = function (x) {
      var { $24r, _r, v, x, $s, $r, $c } = $restore(this, { x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBe(18);
            new flag(v.flag).mustBeExported();
            _r = $clone(v, Value).send($clone(x, Value), true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.TrySend,
        $c: true,
        $r,
        $24r,
        _r,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.TrySend = function (x) {
      return this.$val.TrySend(x);
    };
    Value.ptr.prototype.Type = function () {
      var f, i, m, m$1, ms, tt, v, x;
      v = this;
      f = v.flag;
      if (f === 0) {
        $panic(new ValueError.ptr("reflect.Value.Type", 0));
      }
      if ((f & 512) >>> 0 === 0) {
        return v.typ;
      }
      i = ((v.flag >> 0) >> 10) >> 0;
      if (v.typ.Kind() === 20) {
        tt = v.typ.kindType;
        if (i >>> 0 >= tt.methods.$length >>> 0) {
          $panic(new $String("reflect: internal error: invalid method index"));
        }
        m =
          ((x = tt.methods),
          i < 0 || i >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + i]);
        return v.typ.typeOff(m.typ);
      }
      ms = v.typ.exportedMethods();
      if (i >>> 0 >= ms.$length >>> 0) {
        $panic(new $String("reflect: internal error: invalid method index"));
      }
      m$1 = $clone(
        i < 0 || i >= ms.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : ms.$array[ms.$offset + i],
        method
      );
      return v.typ.typeOff(m$1.mtyp);
    };
    Value.prototype.Type = function () {
      return this.$val.Type();
    };
    Value.ptr.prototype.CanUint = function () {
      var _1, v;
      v = this;
      _1 = new flag(v.flag).kind();
      if (
        _1 === 7 ||
        _1 === 8 ||
        _1 === 9 ||
        _1 === 10 ||
        _1 === 11 ||
        _1 === 12
      ) {
        return true;
      } else {
        return false;
      }
    };
    Value.prototype.CanUint = function () {
      return this.$val.CanUint();
    };
    Value.ptr.prototype.Uint = function () {
      var _1, k, p, v, x;
      v = this;
      k = new flag(v.flag).kind();
      p = v.ptr;
      _1 = k;
      if (_1 === 7) {
        return new $Uint64(0, p.$get());
      } else if (_1 === 8) {
        return new $Uint64(0, p.$get());
      } else if (_1 === 9) {
        return new $Uint64(0, p.$get());
      } else if (_1 === 10) {
        return new $Uint64(0, p.$get());
      } else if (_1 === 11) {
        return p.$get();
      } else if (_1 === 12) {
        return (x = p.$get()), new $Uint64(0, x.constructor === Number ? x : 1);
      }
      $panic(new ValueError.ptr("reflect.Value.Uint", new flag(v.flag).kind()));
    };
    Value.prototype.Uint = function () {
      return this.$val.Uint();
    };
    Value.ptr.prototype.UnsafeAddr = function () {
      var v;
      v = this;
      if (v.typ === ptrType$1.nil) {
        $panic(new ValueError.ptr("reflect.Value.UnsafeAddr", 0));
      }
      if ((v.flag & 256) >>> 0 === 0) {
        $panic(new $String("reflect.Value.UnsafeAddr of unaddressable value"));
      }
      return v.ptr;
    };
    Value.prototype.UnsafeAddr = function () {
      return this.$val.UnsafeAddr();
    };
    Value.ptr.prototype.UnsafePointer = function () {
      var { _1, _r, code, k, p, v, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            code = [code];
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            /* */ if (_1 === 22) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 18 || _1 === 21 || _1 === 26) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 19) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (_1 === (22)) { */ case 2:
            if (v.typ.ptrdata === 0) {
              if (!verifyNotInHeapPtr(v.ptr.$get())) {
                $panic(
                  new $String(
                    "reflect: reflect.Value.UnsafePointer on an invalid notinheap pointer"
                  )
                );
              }
              $s = -1;
              return v.ptr.$get();
            }
            $s = -1;
            return $clone(v, Value).pointer();
          /* } else if ((_1 === (18)) || (_1 === (21)) || (_1 === (26))) { */ case 3:
            $s = -1;
            return $clone(v, Value).pointer();
          /* } else if (_1 === (19)) { */ case 4:
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 7:
            _r = methodValueCallCodePtr();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            code[0] = _r;
            $s = -1;
            return code[0];
          /* } */ case 8:
            p = $clone(v, Value).pointer();
            if (!(p === 0)) {
              p = p.$get();
            }
            $s = -1;
            return p;
          /* } else if (_1 === (23)) { */ case 5:
            $s = -1;
            return $pointerOfStructConversion(v.ptr, ptrType$8).Data;
          /* } */ case 6:
          case 1:
            $panic(
              new ValueError.ptr(
                "reflect.Value.UnsafePointer",
                new flag(v.flag).kind()
              )
            );
            $s = -1;
            return 0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.UnsafePointer,
        $c: true,
        $r,
        _1,
        _r,
        code,
        k,
        p,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.UnsafePointer = function () {
      return this.$val.UnsafePointer();
    };
    Value.ptr.prototype.Convert = function (t) {
      var { $24r, _r, _r$1, _r$2, _r$3, _r$4, op, t, v, $s, $r, $c } = $restore(
        this,
        { t }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
            _r = makeMethodValue("Convert", $clone(v, Value));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
          /* } */ case 2:
            _r$1 = t.common();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = convertOp(_r$1, v.typ);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            op = _r$2;
            /* */ if (op === $throwNilPointerError) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (op === $throwNilPointerError) { */ case 6:
            _r$3 = t.String();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $panic(
              new $String(
                "reflect.Value.Convert: value of type " +
                  v.typ.String() +
                  " cannot be converted to type " +
                  _r$3
              )
            );
          /* } */ case 7:
            _r$4 = op($clone(v, Value), t);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $24r = _r$4;
            $s = 10;
          case 10:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Convert,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        op,
        t,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Convert = function (t) {
      return this.$val.Convert(t);
    };
    Value.ptr.prototype.CanConvert = function (t) {
      var {
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _v,
        _v$1,
        n,
        t,
        v,
        vt,
        $s,
        $r,
        $c,
      } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            vt = $clone(v, Value).Type();
            _r = vt.ConvertibleTo(t);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!_r) { */ case 1:
            $s = -1;
            return false;
          /* } */ case 2:
            _r$1 = vt.Kind();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            if (!(_r$1 === 23)) {
              _v$1 = false;
              $s = 7;
              continue s;
            }
            _r$2 = t.Kind();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$2 === 22;
          case 7:
            if (!_v$1) {
              _v = false;
              $s = 6;
              continue s;
            }
            _r$3 = t.Elem();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _r$4 = _r$3.Kind();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _v = _r$4 === 17;
          case 6:
            /* */ if (_v) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_v) { */ case 4:
            _r$5 = t.Elem();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _r$6 = _r$5.Len();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            n = _r$6;
            if (n > $clone(v, Value).Len()) {
              $s = -1;
              return false;
            }
          /* } */ case 5:
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.CanConvert,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _v,
        _v$1,
        n,
        t,
        v,
        vt,
        $s,
      };
      return $f;
    };
    Value.prototype.CanConvert = function (t) {
      return this.$val.CanConvert(t);
    };
    convertOp = function (dst, src) {
      var {
        _1,
        _2,
        _3,
        _4,
        _5,
        _6,
        _7,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$10,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _v,
        _v$1,
        _v$2,
        _v$3,
        _v$4,
        _v$5,
        dst,
        src,
        $s,
        $r,
        $c,
      } = $restore(this, { dst, src });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _1 = src.Kind();
            /* */ if (
              _1 === 2 ||
              _1 === 3 ||
              _1 === 4 ||
              _1 === 5 ||
              _1 === 6
            ) {
              $s = 2;
              continue;
            }
            /* */ if (
              _1 === 7 ||
              _1 === 8 ||
              _1 === 9 ||
              _1 === 10 ||
              _1 === 11 ||
              _1 === 12
            ) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 13 || _1 === 14) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 15 || _1 === 16) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 18) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
            _2 = dst.Kind();
            if (
              _2 === 2 ||
              _2 === 3 ||
              _2 === 4 ||
              _2 === 5 ||
              _2 === 6 ||
              _2 === 7 ||
              _2 === 8 ||
              _2 === 9 ||
              _2 === 10 ||
              _2 === 11 ||
              _2 === 12
            ) {
              $s = -1;
              return cvtInt;
            } else if (_2 === 13 || _2 === 14) {
              $s = -1;
              return cvtIntFloat;
            } else if (_2 === 24) {
              $s = -1;
              return cvtIntString;
            }
            $s = 9;
            continue;
          /* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
            _3 = dst.Kind();
            if (
              _3 === 2 ||
              _3 === 3 ||
              _3 === 4 ||
              _3 === 5 ||
              _3 === 6 ||
              _3 === 7 ||
              _3 === 8 ||
              _3 === 9 ||
              _3 === 10 ||
              _3 === 11 ||
              _3 === 12
            ) {
              $s = -1;
              return cvtUint;
            } else if (_3 === 13 || _3 === 14) {
              $s = -1;
              return cvtUintFloat;
            } else if (_3 === 24) {
              $s = -1;
              return cvtUintString;
            }
            $s = 9;
            continue;
          /* } else if ((_1 === (13)) || (_1 === (14))) { */ case 4:
            _4 = dst.Kind();
            if (_4 === 2 || _4 === 3 || _4 === 4 || _4 === 5 || _4 === 6) {
              $s = -1;
              return cvtFloatInt;
            } else if (
              _4 === 7 ||
              _4 === 8 ||
              _4 === 9 ||
              _4 === 10 ||
              _4 === 11 ||
              _4 === 12
            ) {
              $s = -1;
              return cvtFloatUint;
            } else if (_4 === 13 || _4 === 14) {
              $s = -1;
              return cvtFloat;
            }
            $s = 9;
            continue;
          /* } else if ((_1 === (15)) || (_1 === (16))) { */ case 5:
            _5 = dst.Kind();
            if (_5 === 15 || _5 === 16) {
              $s = -1;
              return cvtComplex;
            }
            $s = 9;
            continue;
          /* } else if (_1 === (24)) { */ case 6:
            if (!(dst.Kind() === 23)) {
              _v = false;
              $s = 12;
              continue s;
            }
            _r = dst.Elem().PkgPath();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r === "";
          case 12:
            /* */ if (_v) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_v) { */ case 10:
            _r$1 = dst.Elem().Kind();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _6 = _r$1;
            if (_6 === 8) {
              $s = -1;
              return cvtStringBytes;
            } else if (_6 === 5) {
              $s = -1;
              return cvtStringRunes;
            }
          case 14:
          /* } */ case 11:
            $s = 9;
            continue;
          /* } else if (_1 === (23)) { */ case 7:
            if (!(dst.Kind() === 24)) {
              _v$1 = false;
              $s = 18;
              continue s;
            }
            _r$2 = src.Elem().PkgPath();
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$2 === "";
          case 18:
            /* */ if (_v$1) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (_v$1) { */ case 16:
            _r$3 = src.Elem().Kind();
            /* */ $s = 21;
          case 21:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _7 = _r$3;
            if (_7 === 8) {
              $s = -1;
              return cvtBytesString;
            } else if (_7 === 5) {
              $s = -1;
              return cvtRunesString;
            }
          case 20:
          /* } */ case 17:
            if (!(dst.Kind() === 22)) {
              _v$3 = false;
              $s = 25;
              continue s;
            }
            _r$4 = dst.Elem().Kind();
            /* */ $s = 26;
          case 26:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _v$3 = _r$4 === 17;
          case 25:
            if (!_v$3) {
              _v$2 = false;
              $s = 24;
              continue s;
            }
            _r$5 = dst.Elem().Elem();
            /* */ $s = 27;
          case 27:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _v$2 = $interfaceIsEqual(src.Elem(), _r$5);
          case 24:
            /* */ if (_v$2) {
              $s = 22;
              continue;
            }
            /* */ $s = 23;
            continue;
          /* if (_v$2) { */ case 22:
            $s = -1;
            return cvtSliceArrayPtr;
          /* } */ case 23:
            $s = 9;
            continue;
          /* } else if (_1 === (18)) { */ case 8:
            if (!(dst.Kind() === 18)) {
              _v$4 = false;
              $s = 30;
              continue s;
            }
            _r$6 = specialChannelAssignability(dst, src);
            /* */ $s = 31;
          case 31:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _v$4 = _r$6;
          case 30:
            /* */ if (_v$4) {
              $s = 28;
              continue;
            }
            /* */ $s = 29;
            continue;
          /* if (_v$4) { */ case 28:
            $s = -1;
            return cvtDirect;
          /* } */ case 29:
          /* } */ case 9:
          case 1:
            _r$7 = haveIdenticalUnderlyingType(dst, src, false);
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$7) {
              $s = 32;
              continue;
            }
            /* */ $s = 33;
            continue;
          /* if (_r$7) { */ case 32:
            $s = -1;
            return cvtDirect;
          /* } */ case 33:
            if (
              !(
                dst.Kind() === 22 &&
                dst.Name() === "" &&
                src.Kind() === 22 &&
                src.Name() === ""
              )
            ) {
              _v$5 = false;
              $s = 37;
              continue s;
            }
            _r$8 = dst.Elem().common();
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            _arg = _r$8;
            _r$9 = src.Elem().common();
            /* */ $s = 39;
          case 39:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r$9;
            _r$10 = haveIdenticalUnderlyingType(_arg, _arg$1, false);
            /* */ $s = 40;
          case 40:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _v$5 = _r$10;
          case 37:
            /* */ if (_v$5) {
              $s = 35;
              continue;
            }
            /* */ $s = 36;
            continue;
          /* if (_v$5) { */ case 35:
            $s = -1;
            return cvtDirect;
          /* } */ case 36:
            if (implements$1(dst, src)) {
              if (src.Kind() === 20) {
                $s = -1;
                return cvtI2I;
              }
              $s = -1;
              return cvtT2I;
            }
            $s = -1;
            return $throwNilPointerError;
          /* */
        }
        return;
      }
      var $f = {
        $blk: convertOp,
        $c: true,
        $r,
        _1,
        _2,
        _3,
        _4,
        _5,
        _6,
        _7,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$10,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _v,
        _v$1,
        _v$2,
        _v$3,
        _v$4,
        _v$5,
        dst,
        src,
        $s,
      };
      return $f;
    };
    makeFloat = function (f, v, t) {
      var { _1, _r, f, ptr, t, typ, v, $s, $r, $c } = $restore(this, {
        f,
        v,
        t,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            typ = _r;
            ptr = unsafe_New(typ);
            _1 = typ.size;
            if (_1 === 4) {
              ptr.$set($fround(v));
            } else if (_1 === 8) {
              ptr.$set(v);
            }
            $s = -1;
            return new Value.ptr(
              typ,
              ptr,
              (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0
            );
          /* */
        }
        return;
      }
      var $f = { $blk: makeFloat, $c: true, $r, _1, _r, f, ptr, t, typ, v, $s };
      return $f;
    };
    makeFloat32 = function (f, v, t) {
      var { _r, f, ptr, t, typ, v, $s, $r, $c } = $restore(this, { f, v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            typ = _r;
            ptr = unsafe_New(typ);
            ptr.$set(v);
            $s = -1;
            return new Value.ptr(
              typ,
              ptr,
              (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0
            );
          /* */
        }
        return;
      }
      var $f = { $blk: makeFloat32, $c: true, $r, _r, f, ptr, t, typ, v, $s };
      return $f;
    };
    makeComplex = function (f, v, t) {
      var { _1, _r, f, ptr, t, typ, v, $s, $r, $c } = $restore(this, {
        f,
        v,
        t,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            typ = _r;
            ptr = unsafe_New(typ);
            _1 = typ.size;
            if (_1 === 8) {
              ptr.$set(new $Complex64(v.$real, v.$imag));
            } else if (_1 === 16) {
              ptr.$set(v);
            }
            $s = -1;
            return new Value.ptr(
              typ,
              ptr,
              (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeComplex,
        $c: true,
        $r,
        _1,
        _r,
        f,
        ptr,
        t,
        typ,
        v,
        $s,
      };
      return $f;
    };
    makeString = function (f, v, t) {
      var { _r, f, ret, t, v, $s, $r, $c } = $restore(this, { f, v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(New(t), Value).Elem();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            ret = _r;
            $clone(ret, Value).SetString(v);
            ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
            $s = -1;
            return ret;
          /* */
        }
        return;
      }
      var $f = { $blk: makeString, $c: true, $r, _r, f, ret, t, v, $s };
      return $f;
    };
    makeBytes = function (f, v, t) {
      var { _r, f, ret, t, v, $s, $r, $c } = $restore(this, { f, v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(New(t), Value).Elem();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            ret = _r;
            $r = $clone(ret, Value).SetBytes(v);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
            $s = -1;
            return ret;
          /* */
        }
        return;
      }
      var $f = { $blk: makeBytes, $c: true, $r, _r, f, ret, t, v, $s };
      return $f;
    };
    makeRunes = function (f, v, t) {
      var { _r, f, ret, t, v, $s, $r, $c } = $restore(this, { f, v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(New(t), Value).Elem();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            ret = _r;
            $r = $clone(ret, Value).setRunes(v);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
            $s = -1;
            return ret;
          /* */
        }
        return;
      }
      var $f = { $blk: makeRunes, $c: true, $r, _r, f, ret, t, v, $s };
      return $f;
    };
    cvtInt = function (v, t) {
      var { $24r, _r, t, v, x, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeInt(
              new flag(v.flag).ro(),
              ((x = $clone(v, Value).Int()), new $Uint64(x.$high, x.$low)),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtInt, $c: true, $r, $24r, _r, t, v, x, $s };
      return $f;
    };
    cvtUint = function (v, t) {
      var { $24r, _r, t, v, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeInt(new flag(v.flag).ro(), $clone(v, Value).Uint(), t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtUint, $c: true, $r, $24r, _r, t, v, $s };
      return $f;
    };
    cvtFloatInt = function (v, t) {
      var { $24r, _r, t, v, x, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeInt(
              new flag(v.flag).ro(),
              ((x = new $Int64(0, $clone(v, Value).Float())),
              new $Uint64(x.$high, x.$low)),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtFloatInt, $c: true, $r, $24r, _r, t, v, x, $s };
      return $f;
    };
    cvtFloatUint = function (v, t) {
      var { $24r, _r, t, v, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeInt(
              new flag(v.flag).ro(),
              new $Uint64(0, $clone(v, Value).Float()),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtFloatUint, $c: true, $r, $24r, _r, t, v, $s };
      return $f;
    };
    cvtIntFloat = function (v, t) {
      var { $24r, _r, t, v, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeFloat(
              new flag(v.flag).ro(),
              $flatten64($clone(v, Value).Int()),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtIntFloat, $c: true, $r, $24r, _r, t, v, $s };
      return $f;
    };
    cvtUintFloat = function (v, t) {
      var { $24r, _r, t, v, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeFloat(
              new flag(v.flag).ro(),
              $flatten64($clone(v, Value).Uint()),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtUintFloat, $c: true, $r, $24r, _r, t, v, $s };
      return $f;
    };
    cvtFloat = function (v, t) {
      var { $24r, $24r$1, _r, _r$1, _r$2, _r$3, _v, t, v, $s, $r, $c } =
        $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(v, Value).Type().Kind();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            if (!(_r === 13)) {
              _v = false;
              $s = 3;
              continue s;
            }
            _r$1 = t.Kind();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = _r$1 === 13;
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            _r$2 = makeFloat32(new flag(v.flag).ro(), v.ptr.$get(), t);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 7;
          case 7:
            return $24r;
          /* } */ case 2:
            _r$3 = makeFloat(
              new flag(v.flag).ro(),
              $clone(v, Value).Float(),
              t
            );
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$3;
            $s = 9;
          case 9:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtFloat,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _v,
        t,
        v,
        $s,
      };
      return $f;
    };
    cvtComplex = function (v, t) {
      var { $24r, _r, t, v, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeComplex(
              new flag(v.flag).ro(),
              $clone(v, Value).Complex(),
              t
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: cvtComplex, $c: true, $r, $24r, _r, t, v, $s };
      return $f;
    };
    cvtIntString = function (v, t) {
      var { $24r, _r, s, t, v, x, x$1, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = "\xEF\xBF\xBD";
            x = $clone(v, Value).Int();
            if (
              ((x$1 = new $Int64(
                0,
                (x.$low + (x.$high >> 31) * 4294967296) >> 0
              )),
              x$1.$high === x.$high && x$1.$low === x.$low)
            ) {
              s = $encodeRune((x.$low + (x.$high >> 31) * 4294967296) >> 0);
            }
            _r = makeString(new flag(v.flag).ro(), s, t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtIntString,
        $c: true,
        $r,
        $24r,
        _r,
        s,
        t,
        v,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    cvtUintString = function (v, t) {
      var { $24r, _r, s, t, v, x, x$1, $s, $r, $c } = $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = "\xEF\xBF\xBD";
            x = $clone(v, Value).Uint();
            if (
              ((x$1 = new $Uint64(0, x.$low >> 0)),
              x$1.$high === x.$high && x$1.$low === x.$low)
            ) {
              s = $encodeRune(x.$low >> 0);
            }
            _r = makeString(new flag(v.flag).ro(), s, t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtUintString,
        $c: true,
        $r,
        $24r,
        _r,
        s,
        t,
        v,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    cvtBytesString = function (v, t) {
      var { $24r, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r, $c } = $restore(
        this,
        { v, t }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _arg = new flag(v.flag).ro();
            _r = $clone(v, Value).Bytes();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = $bytesToString(_r);
            _arg$2 = t;
            _r$1 = makeString(_arg, _arg$1, _arg$2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtBytesString,
        $c: true,
        $r,
        $24r,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        t,
        v,
        $s,
      };
      return $f;
    };
    cvtStringBytes = function (v, t) {
      var { $24r, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r, $c } = $restore(
        this,
        { v, t }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _arg = new flag(v.flag).ro();
            _r = $clone(v, Value).String();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = new sliceType$9($stringToBytes(_r));
            _arg$2 = t;
            _r$1 = makeBytes(_arg, _arg$1, _arg$2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtStringBytes,
        $c: true,
        $r,
        $24r,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        t,
        v,
        $s,
      };
      return $f;
    };
    cvtRunesString = function (v, t) {
      var { $24r, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r, $c } = $restore(
        this,
        { v, t }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _arg = new flag(v.flag).ro();
            _r = $clone(v, Value).runes();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = $runesToString(_r);
            _arg$2 = t;
            _r$1 = makeString(_arg, _arg$1, _arg$2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtRunesString,
        $c: true,
        $r,
        $24r,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        t,
        v,
        $s,
      };
      return $f;
    };
    cvtStringRunes = function (v, t) {
      var { $24r, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r, $c } = $restore(
        this,
        { v, t }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _arg = new flag(v.flag).ro();
            _r = $clone(v, Value).String();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = new sliceType$10($stringToRunes(_r));
            _arg$2 = t;
            _r$1 = makeRunes(_arg, _arg$1, _arg$2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtStringRunes,
        $c: true,
        $r,
        $24r,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        t,
        v,
        $s,
      };
      return $f;
    };
    cvtT2I = function (v, typ) {
      var { $24r, _r, _r$1, _r$2, _r$3, _r$4, target, typ, v, x, $s, $r, $c } =
        $restore(this, { v, typ });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = typ.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = unsafe_New(_r);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            target = _r$1;
            _r$2 = valueInterface($clone(v, Value), false);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            x = _r$2;
            _r$3 = typ.NumMethod();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$3 === 0) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_r$3 === 0) { */ case 4:
            target.$set(x);
            $s = 6;
            continue;
          /* } else { */ case 5:
            ifaceE2I($assertType(typ, ptrType$1), x, target);
          /* } */ case 6:
            _r$4 = typ.common();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(
              _r$4,
              target,
              (((new flag(v.flag).ro() | 128) >>> 0) | 20) >>> 0
            );
            $s = 9;
          case 9:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtT2I,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        target,
        typ,
        v,
        x,
        $s,
      };
      return $f;
    };
    cvtI2I = function (v, typ) {
      var { $24r, _r, _r$1, _r$2, ret, typ, v, $s, $r, $c } = $restore(this, {
        v,
        typ,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            /* */ if ($clone(v, Value).IsNil()) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ($clone(v, Value).IsNil()) { */ case 1:
            _r = Zero(typ);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            ret = _r;
            ret.flag = (ret.flag | new flag(v.flag).ro()) >>> 0;
            $s = -1;
            return ret;
          /* } */ case 2:
            _r$1 = $clone(v, Value).Elem();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = cvtT2I($clone(_r$1, Value), typ);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 6;
          case 6:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtI2I,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        ret,
        typ,
        v,
        $s,
      };
      return $f;
    };
    structField.ptr.prototype.offset = function () {
      var f;
      f = this;
      return (f.offsetEmbed >>> 1) >>> 0;
    };
    structField.prototype.offset = function () {
      return this.$val.offset();
    };
    structField.ptr.prototype.embedded = function () {
      var f;
      f = this;
      return !((f.offsetEmbed & 1) >>> 0 === 0);
    };
    structField.prototype.embedded = function () {
      return this.$val.embedded();
    };
    Method.ptr.prototype.IsExported = function () {
      var m;
      m = this;
      return m.PkgPath === "";
    };
    Method.prototype.IsExported = function () {
      return this.$val.IsExported();
    };
    Kind.prototype.String = function () {
      var k;
      k = this.$val;
      if (k >> 0 < kindNames.$length) {
        return k < 0 || k >= kindNames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : kindNames.$array[kindNames.$offset + k];
      }
      return "kind" + strconv.Itoa(k >> 0);
    };
    $ptrType(Kind).prototype.String = function () {
      return new Kind(this.$get()).String();
    };
    rtype.ptr.prototype.String = function () {
      var s, t;
      t = this;
      s = $clone(t.nameOff(t.str), name).name();
      if (!((t.tflag & 2) >>> 0 === 0)) {
        return $substring(s, 1);
      }
      return s;
    };
    rtype.prototype.String = function () {
      return this.$val.String();
    };
    rtype.ptr.prototype.Size = function () {
      var t;
      t = this;
      return t.size;
    };
    rtype.prototype.Size = function () {
      return this.$val.Size();
    };
    rtype.ptr.prototype.Bits = function () {
      var k, t;
      t = this;
      if (t === ptrType$1.nil) {
        $panic(new $String("reflect: Bits of nil Type"));
      }
      k = t.Kind();
      if (k < 2 || k > 16) {
        $panic(
          new $String("reflect: Bits of non-arithmetic Type " + t.String())
        );
      }
      return $imul(t.size >> 0, 8);
    };
    rtype.prototype.Bits = function () {
      return this.$val.Bits();
    };
    rtype.ptr.prototype.Align = function () {
      var t;
      t = this;
      return t.align >> 0;
    };
    rtype.prototype.Align = function () {
      return this.$val.Align();
    };
    rtype.ptr.prototype.FieldAlign = function () {
      var t;
      t = this;
      return t.fieldAlign >> 0;
    };
    rtype.prototype.FieldAlign = function () {
      return this.$val.FieldAlign();
    };
    rtype.ptr.prototype.Kind = function () {
      var t;
      t = this;
      return ((t.kind & 31) >>> 0) >>> 0;
    };
    rtype.prototype.Kind = function () {
      return this.$val.Kind();
    };
    rtype.ptr.prototype.common = function () {
      var t;
      t = this;
      return t;
    };
    rtype.prototype.common = function () {
      return this.$val.common();
    };
    rtype.ptr.prototype.exportedMethods = function () {
      var t, ut;
      t = this;
      ut = t.uncommon();
      if (ut === ptrType$9.nil) {
        return sliceType$11.nil;
      }
      return ut.exportedMethods();
    };
    rtype.prototype.exportedMethods = function () {
      return this.$val.exportedMethods();
    };
    rtype.ptr.prototype.NumMethod = function () {
      var t, tt;
      t = this;
      if (t.Kind() === 20) {
        tt = t.kindType;
        return tt.NumMethod();
      }
      return t.exportedMethods().$length;
    };
    rtype.prototype.NumMethod = function () {
      return this.$val.NumMethod();
    };
    rtype.ptr.prototype.MethodByName = function (name$1) {
      var {
        $24r,
        _i,
        _r,
        _ref,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        i,
        m,
        name$1,
        ok,
        p,
        t,
        tt,
        ut,
        $s,
        $r,
        $c,
      } = $restore(this, { name$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            m = new Method.ptr(
              "",
              "",
              $ifaceNil,
              new Value.ptr(ptrType$1.nil, 0, 0),
              0
            );
            ok = false;
            t = this;
            if (t.Kind() === 20) {
              tt = t.kindType;
              _tuple = tt.MethodByName(name$1);
              Method.copy(m, _tuple[0]);
              ok = _tuple[1];
              $s = -1;
              return [m, ok];
            }
            ut = t.uncommon();
            if (ut === ptrType$9.nil) {
              _tmp = new Method.ptr(
                "",
                "",
                $ifaceNil,
                new Value.ptr(ptrType$1.nil, 0, 0),
                0
              );
              _tmp$1 = false;
              Method.copy(m, _tmp);
              ok = _tmp$1;
              $s = -1;
              return [m, ok];
            }
            _ref = ut.exportedMethods();
            _i = 0;
          /* while (true) { */ case 1:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 2;
              continue;
            }
            i = _i;
            p = $clone(
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i],
              method
            );
            /* */ if ($clone(t.nameOff(p.name), name).name() === name$1) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if ($clone(t.nameOff(p.name), name).name() === name$1) { */ case 3:
            _r = t.Method(i);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tmp$2 = $clone(_r, Method);
            _tmp$3 = true;
            Method.copy(m, _tmp$2);
            ok = _tmp$3;
            $24r = [m, ok];
            $s = 6;
          case 6:
            return $24r;
          /* } */ case 4:
            _i++;
            $s = 1;
            continue;
          case 2:
            _tmp$4 = new Method.ptr(
              "",
              "",
              $ifaceNil,
              new Value.ptr(ptrType$1.nil, 0, 0),
              0
            );
            _tmp$5 = false;
            Method.copy(m, _tmp$4);
            ok = _tmp$5;
            $s = -1;
            return [m, ok];
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.MethodByName,
        $c: true,
        $r,
        $24r,
        _i,
        _r,
        _ref,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        i,
        m,
        name$1,
        ok,
        p,
        t,
        tt,
        ut,
        $s,
      };
      return $f;
    };
    rtype.prototype.MethodByName = function (name$1) {
      return this.$val.MethodByName(name$1);
    };
    rtype.ptr.prototype.PkgPath = function () {
      var t, ut;
      t = this;
      if ((t.tflag & 4) >>> 0 === 0) {
        return "";
      }
      ut = t.uncommon();
      if (ut === ptrType$9.nil) {
        return "";
      }
      return $clone(t.nameOff(ut.pkgPath), name).name();
    };
    rtype.prototype.PkgPath = function () {
      return this.$val.PkgPath();
    };
    rtype.ptr.prototype.hasName = function () {
      var t;
      t = this;
      return !((t.tflag & 4) >>> 0 === 0);
    };
    rtype.prototype.hasName = function () {
      return this.$val.hasName();
    };
    rtype.ptr.prototype.Name = function () {
      var _1, i, s, sqBrackets, t;
      t = this;
      if (!t.hasName()) {
        return "";
      }
      s = t.String();
      i = (s.length - 1) >> 0;
      sqBrackets = 0;
      while (true) {
        if (!(i >= 0 && (!(s.charCodeAt(i) === 46) || !(sqBrackets === 0)))) {
          break;
        }
        _1 = s.charCodeAt(i);
        if (_1 === 93) {
          sqBrackets = (sqBrackets + 1) >> 0;
        } else if (_1 === 91) {
          sqBrackets = (sqBrackets - 1) >> 0;
        }
        i = (i - 1) >> 0;
      }
      return $substring(s, (i + 1) >> 0);
    };
    rtype.prototype.Name = function () {
      return this.$val.Name();
    };
    rtype.ptr.prototype.ChanDir = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 18)) {
        $panic(new $String("reflect: ChanDir of non-chan type " + t.String()));
      }
      tt = t.kindType;
      return tt.dir >> 0;
    };
    rtype.prototype.ChanDir = function () {
      return this.$val.ChanDir();
    };
    rtype.ptr.prototype.IsVariadic = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(
          new $String("reflect: IsVariadic of non-func type " + t.String())
        );
      }
      tt = t.kindType;
      return !((tt.outCount & 32768) >>> 0 === 0);
    };
    rtype.prototype.IsVariadic = function () {
      return this.$val.IsVariadic();
    };
    rtype.ptr.prototype.Elem = function () {
      var _1, t, tt, tt$1, tt$2, tt$3, tt$4;
      t = this;
      _1 = t.Kind();
      if (_1 === 17) {
        tt = t.kindType;
        return toType(tt.elem);
      } else if (_1 === 18) {
        tt$1 = t.kindType;
        return toType(tt$1.elem);
      } else if (_1 === 21) {
        tt$2 = t.kindType;
        return toType(tt$2.elem);
      } else if (_1 === 22) {
        tt$3 = t.kindType;
        return toType(tt$3.elem);
      } else if (_1 === 23) {
        tt$4 = t.kindType;
        return toType(tt$4.elem);
      }
      $panic(new $String("reflect: Elem of invalid type " + t.String()));
    };
    rtype.prototype.Elem = function () {
      return this.$val.Elem();
    };
    rtype.ptr.prototype.Field = function (i) {
      var i, t, tt;
      t = this;
      if (!(t.Kind() === 25)) {
        $panic(new $String("reflect: Field of non-struct type " + t.String()));
      }
      tt = t.kindType;
      return tt.Field(i);
    };
    rtype.prototype.Field = function (i) {
      return this.$val.Field(i);
    };
    rtype.ptr.prototype.FieldByIndex = function (index) {
      var { $24r, _r, index, t, tt, $s, $r, $c } = $restore(this, { index });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if (!(t.Kind() === 25)) {
              $panic(
                new $String(
                  "reflect: FieldByIndex of non-struct type " + t.String()
                )
              );
            }
            tt = t.kindType;
            _r = tt.FieldByIndex(index);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.FieldByIndex,
        $c: true,
        $r,
        $24r,
        _r,
        index,
        t,
        tt,
        $s,
      };
      return $f;
    };
    rtype.prototype.FieldByIndex = function (index) {
      return this.$val.FieldByIndex(index);
    };
    rtype.ptr.prototype.FieldByName = function (name$1) {
      var { $24r, _r, name$1, t, tt, $s, $r, $c } = $restore(this, { name$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if (!(t.Kind() === 25)) {
              $panic(
                new $String(
                  "reflect: FieldByName of non-struct type " + t.String()
                )
              );
            }
            tt = t.kindType;
            _r = tt.FieldByName(name$1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.FieldByName,
        $c: true,
        $r,
        $24r,
        _r,
        name$1,
        t,
        tt,
        $s,
      };
      return $f;
    };
    rtype.prototype.FieldByName = function (name$1) {
      return this.$val.FieldByName(name$1);
    };
    rtype.ptr.prototype.FieldByNameFunc = function (match) {
      var { $24r, _r, match, t, tt, $s, $r, $c } = $restore(this, { match });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if (!(t.Kind() === 25)) {
              $panic(
                new $String(
                  "reflect: FieldByNameFunc of non-struct type " + t.String()
                )
              );
            }
            tt = t.kindType;
            _r = tt.FieldByNameFunc(match);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.FieldByNameFunc,
        $c: true,
        $r,
        $24r,
        _r,
        match,
        t,
        tt,
        $s,
      };
      return $f;
    };
    rtype.prototype.FieldByNameFunc = function (match) {
      return this.$val.FieldByNameFunc(match);
    };
    rtype.ptr.prototype.In = function (i) {
      var i, t, tt, x;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: In of non-func type " + t.String()));
      }
      tt = t.kindType;
      return toType(
        ((x = tt.in$()),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i])
      );
    };
    rtype.prototype.In = function (i) {
      return this.$val.In(i);
    };
    rtype.ptr.prototype.Key = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 21)) {
        $panic(new $String("reflect: Key of non-map type " + t.String()));
      }
      tt = t.kindType;
      return toType(tt.key);
    };
    rtype.prototype.Key = function () {
      return this.$val.Key();
    };
    rtype.ptr.prototype.Len = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 17)) {
        $panic(new $String("reflect: Len of non-array type " + t.String()));
      }
      tt = t.kindType;
      return tt.len >> 0;
    };
    rtype.prototype.Len = function () {
      return this.$val.Len();
    };
    rtype.ptr.prototype.NumField = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 25)) {
        $panic(
          new $String("reflect: NumField of non-struct type " + t.String())
        );
      }
      tt = t.kindType;
      return tt.fields.$length;
    };
    rtype.prototype.NumField = function () {
      return this.$val.NumField();
    };
    rtype.ptr.prototype.NumIn = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: NumIn of non-func type " + t.String()));
      }
      tt = t.kindType;
      return tt.inCount >> 0;
    };
    rtype.prototype.NumIn = function () {
      return this.$val.NumIn();
    };
    rtype.ptr.prototype.NumOut = function () {
      var t, tt;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: NumOut of non-func type " + t.String()));
      }
      tt = t.kindType;
      return tt.out().$length;
    };
    rtype.prototype.NumOut = function () {
      return this.$val.NumOut();
    };
    rtype.ptr.prototype.Out = function (i) {
      var i, t, tt, x;
      t = this;
      if (!(t.Kind() === 19)) {
        $panic(new $String("reflect: Out of non-func type " + t.String()));
      }
      tt = t.kindType;
      return toType(
        ((x = tt.out()),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i])
      );
    };
    rtype.prototype.Out = function (i) {
      return this.$val.Out(i);
    };
    ChanDir.prototype.String = function () {
      var _1, d;
      d = this.$val;
      _1 = d;
      if (_1 === 2) {
        return "chan<-";
      } else if (_1 === 1) {
        return "<-chan";
      } else if (_1 === 3) {
        return "chan";
      }
      return "ChanDir" + strconv.Itoa(d >> 0);
    };
    $ptrType(ChanDir).prototype.String = function () {
      return new ChanDir(this.$get()).String();
    };
    interfaceType.ptr.prototype.Method = function (i) {
      var i, m, p, pname, t, x;
      m = new Method.ptr(
        "",
        "",
        $ifaceNil,
        new Value.ptr(ptrType$1.nil, 0, 0),
        0
      );
      t = this;
      if (i < 0 || i >= t.methods.$length) {
        return m;
      }
      p =
        ((x = t.methods),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i]);
      pname = $clone(t.rtype.nameOff(p.name), name);
      m.Name = $clone(pname, name).name();
      if (!$clone(pname, name).isExported()) {
        m.PkgPath = $clone(pname, name).pkgPath();
        if (m.PkgPath === "") {
          m.PkgPath = $clone(t.pkgPath, name).name();
        }
      }
      m.Type = toType(t.rtype.typeOff(p.typ));
      m.Index = i;
      return m;
    };
    interfaceType.prototype.Method = function (i) {
      return this.$val.Method(i);
    };
    interfaceType.ptr.prototype.NumMethod = function () {
      var t;
      t = this;
      return t.methods.$length;
    };
    interfaceType.prototype.NumMethod = function () {
      return this.$val.NumMethod();
    };
    interfaceType.ptr.prototype.MethodByName = function (name$1) {
      var _i, _ref, _tmp, _tmp$1, i, m, name$1, ok, p, t, x;
      m = new Method.ptr(
        "",
        "",
        $ifaceNil,
        new Value.ptr(ptrType$1.nil, 0, 0),
        0
      );
      ok = false;
      t = this;
      if (t === ptrType$10.nil) {
        return [m, ok];
      }
      p = ptrType$11.nil;
      _ref = t.methods;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        p =
          ((x = t.methods),
          i < 0 || i >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + i]);
        if ($clone(t.rtype.nameOff(p.name), name).name() === name$1) {
          _tmp = $clone(t.Method(i), Method);
          _tmp$1 = true;
          Method.copy(m, _tmp);
          ok = _tmp$1;
          return [m, ok];
        }
        _i++;
      }
      return [m, ok];
    };
    interfaceType.prototype.MethodByName = function (name$1) {
      return this.$val.MethodByName(name$1);
    };
    StructField.ptr.prototype.IsExported = function () {
      var f;
      f = this;
      return f.PkgPath === "";
    };
    StructField.prototype.IsExported = function () {
      return this.$val.IsExported();
    };
    StructTag.prototype.Get = function (key) {
      var _tuple, key, tag, v;
      tag = this.$val;
      _tuple = new StructTag(tag).Lookup(key);
      v = _tuple[0];
      return v;
    };
    $ptrType(StructTag).prototype.Get = function (key) {
      return new StructTag(this.$get()).Get(key);
    };
    StructTag.prototype.Lookup = function (key) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        err,
        i,
        key,
        name$1,
        ok,
        qvalue,
        tag,
        value,
        value$1;
      value = "";
      ok = false;
      tag = this.$val;
      while (true) {
        if (!!(tag === "")) {
          break;
        }
        i = 0;
        while (true) {
          if (!(i < tag.length && tag.charCodeAt(i) === 32)) {
            break;
          }
          i = (i + 1) >> 0;
        }
        tag = $substring(tag, i);
        if (tag === "") {
          break;
        }
        i = 0;
        while (true) {
          if (
            !(
              i < tag.length &&
              tag.charCodeAt(i) > 32 &&
              !(tag.charCodeAt(i) === 58) &&
              !(tag.charCodeAt(i) === 34) &&
              !(tag.charCodeAt(i) === 127)
            )
          ) {
            break;
          }
          i = (i + 1) >> 0;
        }
        if (
          i === 0 ||
          (i + 1) >> 0 >= tag.length ||
          !(tag.charCodeAt(i) === 58) ||
          !(tag.charCodeAt((i + 1) >> 0) === 34)
        ) {
          break;
        }
        name$1 = $substring(tag, 0, i);
        tag = $substring(tag, (i + 1) >> 0);
        i = 1;
        while (true) {
          if (!(i < tag.length && !(tag.charCodeAt(i) === 34))) {
            break;
          }
          if (tag.charCodeAt(i) === 92) {
            i = (i + 1) >> 0;
          }
          i = (i + 1) >> 0;
        }
        if (i >= tag.length) {
          break;
        }
        qvalue = $substring(tag, 0, (i + 1) >> 0);
        tag = $substring(tag, (i + 1) >> 0);
        if (key === name$1) {
          _tuple = strconv.Unquote(qvalue);
          value$1 = _tuple[0];
          err = _tuple[1];
          if (!$interfaceIsEqual(err, $ifaceNil)) {
            break;
          }
          _tmp = value$1;
          _tmp$1 = true;
          value = _tmp;
          ok = _tmp$1;
          return [value, ok];
        }
      }
      _tmp$2 = "";
      _tmp$3 = false;
      value = _tmp$2;
      ok = _tmp$3;
      return [value, ok];
    };
    $ptrType(StructTag).prototype.Lookup = function (key) {
      return new StructTag(this.$get()).Lookup(key);
    };
    structType.ptr.prototype.Field = function (i) {
      var f, i, p, t, tag, x;
      f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$6.nil, false);
      t = this;
      if (i < 0 || i >= t.fields.$length) {
        $panic(new $String("reflect: Field index out of bounds"));
      }
      p =
        ((x = t.fields),
        i < 0 || i >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + i]);
      f.Type = toType(p.typ);
      f.Name = $clone(p.name, name).name();
      f.Anonymous = p.embedded();
      if (!$clone(p.name, name).isExported()) {
        f.PkgPath = $clone(t.pkgPath, name).name();
      }
      tag = $clone(p.name, name).tag();
      if (!(tag === "")) {
        f.Tag = tag;
      }
      f.Offset = p.offset();
      f.Index = new sliceType$6([i]);
      return f;
    };
    structType.prototype.Field = function (i) {
      return this.$val.Field(i);
    };
    structType.ptr.prototype.FieldByIndex = function (index) {
      var {
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _ref,
        _v,
        f,
        ft,
        i,
        index,
        t,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { index });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = new StructField.ptr(
              "",
              "",
              $ifaceNil,
              "",
              0,
              sliceType$6.nil,
              false
            );
            t = this;
            f.Type = toType(t.rtype);
            _ref = index;
            _i = 0;
          /* while (true) { */ case 1:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 2;
              continue;
            }
            i = _i;
            x =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            /* */ if (i > 0) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (i > 0) { */ case 3:
            ft = f.Type;
            _r = ft.Kind();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            if (!(_r === 22)) {
              _v = false;
              $s = 7;
              continue s;
            }
            _r$1 = ft.Elem();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = _r$1.Kind();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v = _r$2 === 25;
          case 7:
            /* */ if (_v) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (_v) { */ case 5:
            _r$3 = ft.Elem();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            ft = _r$3;
          /* } */ case 6:
            f.Type = ft;
          /* } */ case 4:
            _r$4 = f.Type.Field(x);
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            StructField.copy(f, _r$4);
            _i++;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return f;
          /* */
        }
        return;
      }
      var $f = {
        $blk: structType.ptr.prototype.FieldByIndex,
        $c: true,
        $r,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _ref,
        _v,
        f,
        ft,
        i,
        index,
        t,
        x,
        $s,
      };
      return $f;
    };
    structType.prototype.FieldByIndex = function (index) {
      return this.$val.FieldByIndex(index);
    };
    structType.ptr.prototype.FieldByNameFunc = function (match) {
      var {
        _entry,
        _entry$1,
        _entry$2,
        _entry$3,
        _i,
        _i$1,
        _key,
        _key$1,
        _key$2,
        _key$3,
        _r,
        _r$1,
        _ref,
        _ref$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        count,
        current,
        f,
        fname,
        i,
        index,
        match,
        next,
        nextCount,
        ntyp,
        ok,
        result,
        scan,
        styp,
        t,
        t$1,
        visited,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { match });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            result = new StructField.ptr(
              "",
              "",
              $ifaceNil,
              "",
              0,
              sliceType$6.nil,
              false
            );
            ok = false;
            t = this;
            current = new sliceType$12([]);
            next = new sliceType$12([new fieldScan.ptr(t, sliceType$6.nil)]);
            nextCount = false;
            visited = $makeMap(ptrType$12.keyFor, []);
          /* while (true) { */ case 1:
            /* if (!(next.$length > 0)) { break; } */ if (!(next.$length > 0)) {
              $s = 2;
              continue;
            }
            _tmp = next;
            _tmp$1 = $subslice(current, 0, 0);
            current = _tmp;
            next = _tmp$1;
            count = nextCount;
            nextCount = false;
            _ref = current;
            _i = 0;
          /* while (true) { */ case 3:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 4;
              continue;
            }
            scan = $clone(
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i],
              fieldScan
            );
            t$1 = scan.typ;
            if (
              ((_entry = $mapIndex(visited, ptrType$12.keyFor(t$1))),
              _entry !== undefined ? _entry.v : false)
            ) {
              _i++;
              /* continue; */ $s = 3;
              continue;
            }
            _key = t$1;
            (
              visited || $throwRuntimeError("assignment to entry in nil map")
            ).set(ptrType$12.keyFor(_key), { k: _key, v: true });
            _ref$1 = t$1.fields;
            _i$1 = 0;
          /* while (true) { */ case 5:
            /* if (!(_i$1 < _ref$1.$length)) { break; } */ if (
              !(_i$1 < _ref$1.$length)
            ) {
              $s = 6;
              continue;
            }
            i = _i$1;
            f =
              ((x = t$1.fields),
              i < 0 || i >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + i]);
            fname = $clone(f.name, name).name();
            ntyp = ptrType$1.nil;
            /* */ if (f.embedded()) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (f.embedded()) { */ case 7:
            ntyp = f.typ;
            /* */ if (ntyp.Kind() === 22) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (ntyp.Kind() === 22) { */ case 9:
            _r = ntyp.Elem().common();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            ntyp = _r;
          /* } */ case 10:
          /* } */ case 8:
            _r$1 = match(fname);
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$1) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if (_r$1) { */ case 12:
            if (
              ((_entry$1 = $mapIndex(count, ptrType$12.keyFor(t$1))),
              _entry$1 !== undefined ? _entry$1.v : 0) > 1 ||
              ok
            ) {
              _tmp$2 = new StructField.ptr(
                "",
                "",
                $ifaceNil,
                "",
                0,
                sliceType$6.nil,
                false
              );
              _tmp$3 = false;
              StructField.copy(result, _tmp$2);
              ok = _tmp$3;
              $s = -1;
              return [result, ok];
            }
            StructField.copy(result, t$1.Field(i));
            result.Index = sliceType$6.nil;
            result.Index = $appendSlice(result.Index, scan.index);
            result.Index = $append(result.Index, i);
            ok = true;
            _i$1++;
            /* continue; */ $s = 5;
            continue;
          /* } */ case 13:
            if (ok || ntyp === ptrType$1.nil || !(ntyp.Kind() === 25)) {
              _i$1++;
              /* continue; */ $s = 5;
              continue;
            }
            styp = ntyp.kindType;
            if (
              ((_entry$2 = $mapIndex(nextCount, ptrType$12.keyFor(styp))),
              _entry$2 !== undefined ? _entry$2.v : 0) > 0
            ) {
              _key$1 = styp;
              (
                nextCount ||
                $throwRuntimeError("assignment to entry in nil map")
              ).set(ptrType$12.keyFor(_key$1), { k: _key$1, v: 2 });
              _i$1++;
              /* continue; */ $s = 5;
              continue;
            }
            if (nextCount === false) {
              nextCount = $makeMap(ptrType$12.keyFor, []);
            }
            _key$2 = styp;
            (
              nextCount || $throwRuntimeError("assignment to entry in nil map")
            ).set(ptrType$12.keyFor(_key$2), { k: _key$2, v: 1 });
            if (
              ((_entry$3 = $mapIndex(count, ptrType$12.keyFor(t$1))),
              _entry$3 !== undefined ? _entry$3.v : 0) > 1
            ) {
              _key$3 = styp;
              (
                nextCount ||
                $throwRuntimeError("assignment to entry in nil map")
              ).set(ptrType$12.keyFor(_key$3), { k: _key$3, v: 2 });
            }
            index = sliceType$6.nil;
            index = $appendSlice(index, scan.index);
            index = $append(index, i);
            next = $append(next, new fieldScan.ptr(styp, index));
            _i$1++;
            $s = 5;
            continue;
          case 6:
            _i++;
            $s = 3;
            continue;
          case 4:
            if (ok) {
              /* break; */ $s = 2;
              continue;
            }
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return [result, ok];
          /* */
        }
        return;
      }
      var $f = {
        $blk: structType.ptr.prototype.FieldByNameFunc,
        $c: true,
        $r,
        _entry,
        _entry$1,
        _entry$2,
        _entry$3,
        _i,
        _i$1,
        _key,
        _key$1,
        _key$2,
        _key$3,
        _r,
        _r$1,
        _ref,
        _ref$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        count,
        current,
        f,
        fname,
        i,
        index,
        match,
        next,
        nextCount,
        ntyp,
        ok,
        result,
        scan,
        styp,
        t,
        t$1,
        visited,
        x,
        $s,
      };
      return $f;
    };
    structType.prototype.FieldByNameFunc = function (match) {
      return this.$val.FieldByNameFunc(match);
    };
    structType.ptr.prototype.FieldByName = function (name$1) {
      var {
        $24r,
        _i,
        _r,
        _ref,
        _tmp,
        _tmp$1,
        _tuple,
        f,
        hasEmbeds,
        i,
        name$1,
        present,
        t,
        tf,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { name$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            name$1 = [name$1];
            f = new StructField.ptr(
              "",
              "",
              $ifaceNil,
              "",
              0,
              sliceType$6.nil,
              false
            );
            present = false;
            t = this;
            hasEmbeds = false;
            if (!(name$1[0] === "")) {
              _ref = t.fields;
              _i = 0;
              while (true) {
                if (!(_i < _ref.$length)) {
                  break;
                }
                i = _i;
                tf =
                  ((x = t.fields),
                  i < 0 || i >= x.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : x.$array[x.$offset + i]);
                if ($clone(tf.name, name).name() === name$1[0]) {
                  _tmp = $clone(t.Field(i), StructField);
                  _tmp$1 = true;
                  StructField.copy(f, _tmp);
                  present = _tmp$1;
                  $s = -1;
                  return [f, present];
                }
                if (tf.embedded()) {
                  hasEmbeds = true;
                }
                _i++;
              }
            }
            if (!hasEmbeds) {
              $s = -1;
              return [f, present];
            }
            _r = t.FieldByNameFunc(
              (function (name$1) {
                return function (s) {
                  var s;
                  return s === name$1[0];
                };
              })(name$1)
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            StructField.copy(f, _tuple[0]);
            present = _tuple[1];
            $24r = [f, present];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: structType.ptr.prototype.FieldByName,
        $c: true,
        $r,
        $24r,
        _i,
        _r,
        _ref,
        _tmp,
        _tmp$1,
        _tuple,
        f,
        hasEmbeds,
        i,
        name$1,
        present,
        t,
        tf,
        x,
        $s,
      };
      return $f;
    };
    structType.prototype.FieldByName = function (name$1) {
      return this.$val.FieldByName(name$1);
    };
    PtrTo = function (t) {
      var t;
      return PointerTo(t);
    };
    $pkg.PtrTo = PtrTo;
    PointerTo = function (t) {
      var t;
      return $assertType(t, ptrType$1).ptrTo();
    };
    $pkg.PointerTo = PointerTo;
    rtype.ptr.prototype.Implements = function (u) {
      var { _r, t, u, $s, $r, $c } = $restore(this, { u });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($interfaceIsEqual(u, $ifaceNil)) {
              $panic(
                new $String("reflect: nil type passed to Type.Implements")
              );
            }
            _r = u.Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 20)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 20))) { */ case 1:
            $panic(
              new $String(
                "reflect: non-interface type passed to Type.Implements"
              )
            );
          /* } */ case 2:
            $s = -1;
            return implements$1($assertType(u, ptrType$1), t);
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Implements,
        $c: true,
        $r,
        _r,
        t,
        u,
        $s,
      };
      return $f;
    };
    rtype.prototype.Implements = function (u) {
      return this.$val.Implements(u);
    };
    rtype.ptr.prototype.AssignableTo = function (u) {
      var { $24r, _r, t, u, uu, $s, $r, $c } = $restore(this, { u });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($interfaceIsEqual(u, $ifaceNil)) {
              $panic(
                new $String("reflect: nil type passed to Type.AssignableTo")
              );
            }
            uu = $assertType(u, ptrType$1);
            _r = directlyAssignable(uu, t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r || implements$1(uu, t);
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.AssignableTo,
        $c: true,
        $r,
        $24r,
        _r,
        t,
        u,
        uu,
        $s,
      };
      return $f;
    };
    rtype.prototype.AssignableTo = function (u) {
      return this.$val.AssignableTo(u);
    };
    rtype.ptr.prototype.ConvertibleTo = function (u) {
      var { $24r, _r, t, u, uu, $s, $r, $c } = $restore(this, { u });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($interfaceIsEqual(u, $ifaceNil)) {
              $panic(
                new $String("reflect: nil type passed to Type.ConvertibleTo")
              );
            }
            uu = $assertType(u, ptrType$1);
            _r = convertOp(uu, t);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = !(_r === $throwNilPointerError);
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.ConvertibleTo,
        $c: true,
        $r,
        $24r,
        _r,
        t,
        u,
        uu,
        $s,
      };
      return $f;
    };
    rtype.prototype.ConvertibleTo = function (u) {
      return this.$val.ConvertibleTo(u);
    };
    implements$1 = function (T, V) {
      var T,
        V,
        i,
        i$1,
        j,
        j$1,
        t,
        tm,
        tm$1,
        tmName,
        tmName$1,
        tmPkgPath,
        tmPkgPath$1,
        v,
        v$1,
        vm,
        vm$1,
        vmName,
        vmName$1,
        vmPkgPath,
        vmPkgPath$1,
        vmethods,
        x,
        x$1,
        x$2;
      if (!(T.Kind() === 20)) {
        return false;
      }
      t = T.kindType;
      if (t.methods.$length === 0) {
        return true;
      }
      if (V.Kind() === 20) {
        v = V.kindType;
        i = 0;
        j = 0;
        while (true) {
          if (!(j < v.methods.$length)) {
            break;
          }
          tm =
            ((x = t.methods),
            i < 0 || i >= x.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x.$array[x.$offset + i]);
          tmName = $clone(t.rtype.nameOff(tm.name), name);
          vm =
            ((x$1 = v.methods),
            j < 0 || j >= x$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$1.$array[x$1.$offset + j]);
          vmName = $clone(V.nameOff(vm.name), name);
          if (
            $clone(vmName, name).name() === $clone(tmName, name).name() &&
            V.typeOff(vm.typ) === t.rtype.typeOff(tm.typ)
          ) {
            if (!$clone(tmName, name).isExported()) {
              tmPkgPath = $clone(tmName, name).pkgPath();
              if (tmPkgPath === "") {
                tmPkgPath = $clone(t.pkgPath, name).name();
              }
              vmPkgPath = $clone(vmName, name).pkgPath();
              if (vmPkgPath === "") {
                vmPkgPath = $clone(v.pkgPath, name).name();
              }
              if (!(tmPkgPath === vmPkgPath)) {
                j = (j + 1) >> 0;
                continue;
              }
            }
            i = (i + 1) >> 0;
            if (i >= t.methods.$length) {
              return true;
            }
          }
          j = (j + 1) >> 0;
        }
        return false;
      }
      v$1 = V.uncommon();
      if (v$1 === ptrType$9.nil) {
        return false;
      }
      i$1 = 0;
      vmethods = v$1.methods();
      j$1 = 0;
      while (true) {
        if (!(j$1 < v$1.mcount >> 0)) {
          break;
        }
        tm$1 =
          ((x$2 = t.methods),
          i$1 < 0 || i$1 >= x$2.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x$2.$array[x$2.$offset + i$1]);
        tmName$1 = $clone(t.rtype.nameOff(tm$1.name), name);
        vm$1 = $clone(
          j$1 < 0 || j$1 >= vmethods.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : vmethods.$array[vmethods.$offset + j$1],
          method
        );
        vmName$1 = $clone(V.nameOff(vm$1.name), name);
        if (
          $clone(vmName$1, name).name() === $clone(tmName$1, name).name() &&
          V.typeOff(vm$1.mtyp) === t.rtype.typeOff(tm$1.typ)
        ) {
          if (!$clone(tmName$1, name).isExported()) {
            tmPkgPath$1 = $clone(tmName$1, name).pkgPath();
            if (tmPkgPath$1 === "") {
              tmPkgPath$1 = $clone(t.pkgPath, name).name();
            }
            vmPkgPath$1 = $clone(vmName$1, name).pkgPath();
            if (vmPkgPath$1 === "") {
              vmPkgPath$1 = $clone(V.nameOff(v$1.pkgPath), name).name();
            }
            if (!(tmPkgPath$1 === vmPkgPath$1)) {
              j$1 = (j$1 + 1) >> 0;
              continue;
            }
          }
          i$1 = (i$1 + 1) >> 0;
          if (i$1 >= t.methods.$length) {
            return true;
          }
        }
        j$1 = (j$1 + 1) >> 0;
      }
      return false;
    };
    specialChannelAssignability = function (T, V) {
      var { $24r, T, V, _r, _v, $s, $r, $c } = $restore(this, { T, V });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (!(V.ChanDir() === 3 && (T.Name() === "" || V.Name() === ""))) {
              _v = false;
              $s = 1;
              continue s;
            }
            _r = haveIdenticalType(T.Elem(), V.Elem(), true);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 1:
            $24r = _v;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: specialChannelAssignability,
        $c: true,
        $r,
        $24r,
        T,
        V,
        _r,
        _v,
        $s,
      };
      return $f;
    };
    directlyAssignable = function (T, V) {
      var { $24r, T, V, _r, _r$1, _v, $s, $r, $c } = $restore(this, { T, V });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (T === V) {
              $s = -1;
              return true;
            }
            if ((T.hasName() && V.hasName()) || !(T.Kind() === V.Kind())) {
              $s = -1;
              return false;
            }
            if (!(T.Kind() === 18)) {
              _v = false;
              $s = 3;
              continue s;
            }
            _r = specialChannelAssignability(T, V);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            $s = -1;
            return true;
          /* } */ case 2:
            _r$1 = haveIdenticalUnderlyingType(T, V, true);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 6;
          case 6:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: directlyAssignable,
        $c: true,
        $r,
        $24r,
        T,
        V,
        _r,
        _r$1,
        _v,
        $s,
      };
      return $f;
    };
    haveIdenticalType = function (T, V, cmpTags) {
      var {
        $24r,
        T,
        V,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _v,
        _v$1,
        cmpTags,
        $s,
        $r,
        $c,
      } = $restore(this, { T, V, cmpTags });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (cmpTags) {
              $s = -1;
              return $interfaceIsEqual(T, V);
            }
            _r = T.Name();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = V.Name();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            if (!(_r === _r$1)) {
              _v$1 = true;
              $s = 4;
              continue s;
            }
            _r$2 = T.Kind();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$3 = V.Kind();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _v$1 = !(_r$2 === _r$3);
          case 4:
            if (_v$1) {
              _v = true;
              $s = 3;
              continue s;
            }
            _r$4 = T.PkgPath();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _r$5 = V.PkgPath();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _v = !(_r$4 === _r$5);
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            $s = -1;
            return false;
          /* } */ case 2:
            _r$6 = T.common();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _arg = _r$6;
            _r$7 = V.common();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r$7;
            _r$8 = haveIdenticalUnderlyingType(_arg, _arg$1, false);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            $24r = _r$8;
            $s = 14;
          case 14:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: haveIdenticalType,
        $c: true,
        $r,
        $24r,
        T,
        V,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _v,
        _v$1,
        cmpTags,
        $s,
      };
      return $f;
    };
    haveIdenticalUnderlyingType = function (T, V, cmpTags) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        T,
        V,
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _ref,
        _v,
        _v$1,
        _v$2,
        cmpTags,
        i,
        i$1,
        i$2,
        kind,
        t,
        t$1,
        t$2,
        tf,
        v,
        v$1,
        v$2,
        vf,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { T, V, cmpTags });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (T === V) {
              $s = -1;
              return true;
            }
            kind = T.Kind();
            if (!(kind === V.Kind())) {
              $s = -1;
              return false;
            }
            if ((1 <= kind && kind <= 16) || kind === 24 || kind === 26) {
              $s = -1;
              return true;
            }
            _1 = kind;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 18) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 19) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 21) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 22 || _1 === 23) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (_1 === (17)) { */ case 2:
            if (!(T.Len() === V.Len())) {
              _v = false;
              $s = 10;
              continue s;
            }
            _r = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 10:
            $24r = _v;
            $s = 12;
          case 12:
            return $24r;
          /* } else if (_1 === (18)) { */ case 3:
            if (!(V.ChanDir() === T.ChanDir())) {
              _v$1 = false;
              $s = 13;
              continue s;
            }
            _r$1 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$1;
          case 13:
            $24r$1 = _v$1;
            $s = 15;
          case 15:
            return $24r$1;
          /* } else if (_1 === (19)) { */ case 4:
            t = T.kindType;
            v = V.kindType;
            if (!(t.outCount === v.outCount) || !(t.inCount === v.inCount)) {
              $s = -1;
              return false;
            }
            i = 0;
          /* while (true) { */ case 16:
            /* if (!(i < t.rtype.NumIn())) { break; } */ if (
              !(i < t.rtype.NumIn())
            ) {
              $s = 17;
              continue;
            }
            _r$2 = haveIdenticalType(t.rtype.In(i), v.rtype.In(i), cmpTags);
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$2) {
              $s = 18;
              continue;
            }
            /* */ $s = 19;
            continue;
          /* if (!_r$2) { */ case 18:
            $s = -1;
            return false;
          /* } */ case 19:
            i = (i + 1) >> 0;
            $s = 16;
            continue;
          case 17:
            i$1 = 0;
          /* while (true) { */ case 21:
            /* if (!(i$1 < t.rtype.NumOut())) { break; } */ if (
              !(i$1 < t.rtype.NumOut())
            ) {
              $s = 22;
              continue;
            }
            _r$3 = haveIdenticalType(
              t.rtype.Out(i$1),
              v.rtype.Out(i$1),
              cmpTags
            );
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$3) {
              $s = 23;
              continue;
            }
            /* */ $s = 24;
            continue;
          /* if (!_r$3) { */ case 23:
            $s = -1;
            return false;
          /* } */ case 24:
            i$1 = (i$1 + 1) >> 0;
            $s = 21;
            continue;
          case 22:
            $s = -1;
            return true;
          /* } else if (_1 === (20)) { */ case 5:
            t$1 = T.kindType;
            v$1 = V.kindType;
            if (t$1.methods.$length === 0 && v$1.methods.$length === 0) {
              $s = -1;
              return true;
            }
            $s = -1;
            return false;
          /* } else if (_1 === (21)) { */ case 6:
            _r$4 = haveIdenticalType(T.Key(), V.Key(), cmpTags);
            /* */ $s = 27;
          case 27:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            if (!_r$4) {
              _v$2 = false;
              $s = 26;
              continue s;
            }
            _r$5 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 28;
          case 28:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _v$2 = _r$5;
          case 26:
            $24r$2 = _v$2;
            $s = 29;
          case 29:
            return $24r$2;
          /* } else if ((_1 === (22)) || (_1 === (23))) { */ case 7:
            _r$6 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags);
            /* */ $s = 30;
          case 30:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            $24r$3 = _r$6;
            $s = 31;
          case 31:
            return $24r$3;
          /* } else if (_1 === (25)) { */ case 8:
            t$2 = T.kindType;
            v$2 = V.kindType;
            if (!(t$2.fields.$length === v$2.fields.$length)) {
              $s = -1;
              return false;
            }
            if (
              !(
                $clone(t$2.pkgPath, name).name() ===
                $clone(v$2.pkgPath, name).name()
              )
            ) {
              $s = -1;
              return false;
            }
            _ref = t$2.fields;
            _i = 0;
          /* while (true) { */ case 32:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 33;
              continue;
            }
            i$2 = _i;
            tf =
              ((x = t$2.fields),
              i$2 < 0 || i$2 >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + i$2]);
            vf =
              ((x$1 = v$2.fields),
              i$2 < 0 || i$2 >= x$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1.$array[x$1.$offset + i$2]);
            if (
              !($clone(tf.name, name).name() === $clone(vf.name, name).name())
            ) {
              $s = -1;
              return false;
            }
            _r$7 = haveIdenticalType(tf.typ, vf.typ, cmpTags);
            /* */ $s = 36;
          case 36:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$7) {
              $s = 34;
              continue;
            }
            /* */ $s = 35;
            continue;
          /* if (!_r$7) { */ case 34:
            $s = -1;
            return false;
          /* } */ case 35:
            if (
              cmpTags &&
              !($clone(tf.name, name).tag() === $clone(vf.name, name).tag())
            ) {
              $s = -1;
              return false;
            }
            if (!(tf.offsetEmbed === vf.offsetEmbed)) {
              $s = -1;
              return false;
            }
            _i++;
            $s = 32;
            continue;
          case 33:
            $s = -1;
            return true;
          /* } */ case 9:
          case 1:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: haveIdenticalUnderlyingType,
        $c: true,
        $r,
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        T,
        V,
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _ref,
        _v,
        _v$1,
        _v$2,
        cmpTags,
        i,
        i$1,
        i$2,
        kind,
        t,
        t$1,
        t$2,
        tf,
        v,
        v$1,
        v$2,
        vf,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    toType = function (t) {
      var t;
      if (t === ptrType$1.nil) {
        return $ifaceNil;
      }
      return t;
    };
    ifaceIndir = function (t) {
      var t;
      return (t.kind & 32) >>> 0 === 0;
    };
    methodValueCallCodePtr = function () {
      var { $24r, _r, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = abi.FuncPCABI0(new funcType$2(methodValueCall));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: methodValueCallCodePtr, $c: true, $r, $24r, _r, $s };
      return $f;
    };
    methodValueCall = function () {
      $throwRuntimeError(
        "native function not implemented: reflect.methodValueCall"
      );
    };
    init = function () {
      var {
        used,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            used = function (i) {
              var i;
            };
            $r = used(
              ((x = new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              )),
              new x.constructor.elem(x))
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$1 = new uncommonType.ptr(0, 0, 0, 0, sliceType$11.nil)),
              new x$1.constructor.elem(x$1))
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$2 = new method.ptr(0, 0, 0, 0)),
              new x$2.constructor.elem(x$2))
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$3 = new arrayType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                ptrType$1.nil,
                0
              )),
              new x$3.constructor.elem(x$3))
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$4 = new chanType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                0
              )),
              new x$4.constructor.elem(x$4))
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$5 = new funcType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                0,
                0,
                sliceType$2.nil,
                sliceType$2.nil
              )),
              new x$5.constructor.elem(x$5))
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$6 = new interfaceType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                new name.ptr(ptrType$13.nil),
                sliceType$14.nil
              )),
              new x$6.constructor.elem(x$6))
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$7 = new mapType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                ptrType$1.nil,
                ptrType$1.nil,
                ptrType$1.nil,
                $throwNilPointerError,
                0,
                0,
                0,
                0
              )),
              new x$7.constructor.elem(x$7))
            );
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$8 = new ptrType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                ptrType$1.nil
              )),
              new x$8.constructor.elem(x$8))
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$9 = new sliceType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                ptrType$1.nil
              )),
              new x$9.constructor.elem(x$9))
            );
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$10 = new structType.ptr(
                new rtype.ptr(
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  $throwNilPointerError,
                  ptrType$13.nil,
                  0,
                  0
                ),
                new name.ptr(ptrType$13.nil),
                sliceType$15.nil
              )),
              new x$10.constructor.elem(x$10))
            );
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$11 = new imethod.ptr(0, 0)), new x$11.constructor.elem(x$11))
            );
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = used(
              ((x$12 = new structField.ptr(
                new name.ptr(ptrType$13.nil),
                ptrType$1.nil,
                0
              )),
              new x$12.constructor.elem(x$12))
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            initialized = true;
            uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: init,
        $c: true,
        $r,
        used,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
      };
      return $f;
    };
    New = function (typ) {
      var fl, pt, ptr, t, typ;
      if ($interfaceIsEqual(typ, $ifaceNil)) {
        $panic(new $String("reflect: New(nil)"));
      }
      t = $assertType(typ, ptrType$1);
      pt = t.ptrTo();
      ptr = unsafe_New(t);
      fl = 22;
      return new Value.ptr(pt, ptr, fl);
    };
    $pkg.New = New;
    jsType = function (typ) {
      var typ;
      return typ.jsType;
    };
    reflectType = function (typ) {
      var _1,
        _i,
        _i$1,
        _i$2,
        _i$3,
        _ref,
        _ref$1,
        _ref$2,
        _ref$3,
        dir,
        exported,
        exported$1,
        f,
        fields,
        i,
        i$1,
        i$2,
        i$3,
        i$4,
        i$5,
        imethods,
        in$1,
        m,
        m$1,
        m$2,
        methodSet,
        methods,
        offsetEmbed,
        out,
        outCount,
        params,
        reflectFields,
        reflectMethods,
        results,
        rt,
        typ,
        ut,
        xcount;
      if (typ.reflectType === undefined) {
        rt = new rtype.ptr(
          ($parseInt(typ.size) >> 0) >>> 0,
          0,
          0,
          0,
          0,
          0,
          (($parseInt(typ.kind) >> 0) << 24) >>> 24,
          $throwNilPointerError,
          ptrType$13.nil,
          resolveReflectName(
            $clone(newName(internalStr(typ.string), "", !!typ.exported), name)
          ),
          0
        );
        rt.jsType = typ;
        typ.reflectType = rt;
        methodSet = $methodSet(typ);
        if (!($parseInt(methodSet.length) === 0) || !!typ.named) {
          rt.tflag = (rt.tflag | 1) >>> 0;
          if (!!typ.named) {
            rt.tflag = (rt.tflag | 4) >>> 0;
          }
          reflectMethods = sliceType$11.nil;
          i = 0;
          while (true) {
            if (!(i < $parseInt(methodSet.length))) {
              break;
            }
            m = methodSet[i];
            exported = internalStr(m.pkg) === "";
            if (!exported) {
              i = (i + 1) >> 0;
              continue;
            }
            reflectMethods = $append(
              reflectMethods,
              new method.ptr(
                resolveReflectName($clone(newMethodName(m), name)),
                newTypeOff(reflectType(m.typ)),
                0,
                0
              )
            );
            i = (i + 1) >> 0;
          }
          xcount = (reflectMethods.$length << 16) >>> 16;
          i$1 = 0;
          while (true) {
            if (!(i$1 < $parseInt(methodSet.length))) {
              break;
            }
            m$1 = methodSet[i$1];
            exported$1 = internalStr(m$1.pkg) === "";
            if (exported$1) {
              i$1 = (i$1 + 1) >> 0;
              continue;
            }
            reflectMethods = $append(
              reflectMethods,
              new method.ptr(
                resolveReflectName($clone(newMethodName(m$1), name)),
                newTypeOff(reflectType(m$1.typ)),
                0,
                0
              )
            );
            i$1 = (i$1 + 1) >> 0;
          }
          ut = new uncommonType.ptr(
            resolveReflectName(
              $clone(newName(internalStr(typ.pkg), "", false), name)
            ),
            ($parseInt(methodSet.length) << 16) >>> 16,
            xcount,
            0,
            reflectMethods
          );
          ut.jsType = typ;
          rt.uncommonType = ut;
        }
        _1 = rt.Kind();
        if (_1 === 17) {
          setKindType(
            rt,
            new arrayType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              ),
              reflectType(typ.elem),
              ptrType$1.nil,
              ($parseInt(typ.len) >> 0) >>> 0
            )
          );
        } else if (_1 === 18) {
          dir = 3;
          if (!!typ.sendOnly) {
            dir = 2;
          }
          if (!!typ.recvOnly) {
            dir = 1;
          }
          setKindType(
            rt,
            new chanType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              ),
              reflectType(typ.elem),
              dir >>> 0
            )
          );
        } else if (_1 === 19) {
          params = typ.params;
          in$1 = $makeSlice(sliceType$2, $parseInt(params.length));
          _ref = in$1;
          _i = 0;
          while (true) {
            if (!(_i < _ref.$length)) {
              break;
            }
            i$2 = _i;
            i$2 < 0 || i$2 >= in$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (in$1.$array[in$1.$offset + i$2] = reflectType(params[i$2]));
            _i++;
          }
          results = typ.results;
          out = $makeSlice(sliceType$2, $parseInt(results.length));
          _ref$1 = out;
          _i$1 = 0;
          while (true) {
            if (!(_i$1 < _ref$1.$length)) {
              break;
            }
            i$3 = _i$1;
            i$3 < 0 || i$3 >= out.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (out.$array[out.$offset + i$3] = reflectType(results[i$3]));
            _i$1++;
          }
          outCount = ($parseInt(results.length) << 16) >>> 16;
          if (!!typ.variadic) {
            outCount = (outCount | 32768) >>> 0;
          }
          setKindType(
            rt,
            new funcType.ptr(
              $clone(rt, rtype),
              ($parseInt(params.length) << 16) >>> 16,
              outCount,
              in$1,
              out
            )
          );
        } else if (_1 === 20) {
          methods = typ.methods;
          imethods = $makeSlice(sliceType$14, $parseInt(methods.length));
          _ref$2 = imethods;
          _i$2 = 0;
          while (true) {
            if (!(_i$2 < _ref$2.$length)) {
              break;
            }
            i$4 = _i$2;
            m$2 = methods[i$4];
            imethod.copy(
              i$4 < 0 || i$4 >= imethods.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : imethods.$array[imethods.$offset + i$4],
              new imethod.ptr(
                resolveReflectName($clone(newMethodName(m$2), name)),
                newTypeOff(reflectType(m$2.typ))
              )
            );
            _i$2++;
          }
          setKindType(
            rt,
            new interfaceType.ptr(
              $clone(rt, rtype),
              $clone(newName(internalStr(typ.pkg), "", false), name),
              imethods
            )
          );
        } else if (_1 === 21) {
          setKindType(
            rt,
            new mapType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              ),
              reflectType(typ.key),
              reflectType(typ.elem),
              ptrType$1.nil,
              $throwNilPointerError,
              0,
              0,
              0,
              0
            )
          );
        } else if (_1 === 22) {
          setKindType(
            rt,
            new ptrType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              ),
              reflectType(typ.elem)
            )
          );
        } else if (_1 === 23) {
          setKindType(
            rt,
            new sliceType.ptr(
              new rtype.ptr(
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                $throwNilPointerError,
                ptrType$13.nil,
                0,
                0
              ),
              reflectType(typ.elem)
            )
          );
        } else if (_1 === 25) {
          fields = typ.fields;
          reflectFields = $makeSlice(sliceType$15, $parseInt(fields.length));
          _ref$3 = reflectFields;
          _i$3 = 0;
          while (true) {
            if (!(_i$3 < _ref$3.$length)) {
              break;
            }
            i$5 = _i$3;
            f = fields[i$5];
            offsetEmbed = ((i$5 >>> 0) << 1) >>> 0;
            if (!!f.embedded) {
              offsetEmbed = (offsetEmbed | 1) >>> 0;
            }
            structField.copy(
              i$5 < 0 || i$5 >= reflectFields.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : reflectFields.$array[reflectFields.$offset + i$5],
              new structField.ptr(
                $clone(
                  newName(
                    internalStr(f.name),
                    internalStr(f.tag),
                    !!f.exported
                  ),
                  name
                ),
                reflectType(f.typ),
                offsetEmbed
              )
            );
            _i$3++;
          }
          setKindType(
            rt,
            new structType.ptr(
              $clone(rt, rtype),
              $clone(newName(internalStr(typ.pkgPath), "", false), name),
              reflectFields
            )
          );
        }
      }
      return typ.reflectType;
    };
    setKindType = function (rt, kindType) {
      var kindType, rt;
      rt.kindType = kindType;
      kindType.rtype = rt;
    };
    uncommonType.ptr.prototype.methods = function () {
      var t;
      t = this;
      return t._methods;
    };
    uncommonType.prototype.methods = function () {
      return this.$val.methods();
    };
    uncommonType.ptr.prototype.exportedMethods = function () {
      var t;
      t = this;
      return $subslice(t._methods, 0, t.xcount, t.xcount);
    };
    uncommonType.prototype.exportedMethods = function () {
      return this.$val.exportedMethods();
    };
    rtype.ptr.prototype.uncommon = function () {
      var obj, t;
      t = this;
      obj = t.uncommonType;
      if (obj === undefined) {
        return ptrType$9.nil;
      }
      return obj;
    };
    rtype.prototype.uncommon = function () {
      return this.$val.uncommon();
    };
    funcType.ptr.prototype.in$ = function () {
      var t;
      t = this;
      return t._in;
    };
    funcType.prototype.in$ = function () {
      return this.$val.in$();
    };
    funcType.ptr.prototype.out = function () {
      var t;
      t = this;
      return t._out;
    };
    funcType.prototype.out = function () {
      return this.$val.out();
    };
    name.ptr.prototype.name = function () {
      var _entry, n, s;
      s = "";
      n = this;
      s = ((_entry = $mapIndex(nameMap, ptrType$13.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$17.nil).name;
      return s;
    };
    name.prototype.name = function () {
      return this.$val.name();
    };
    name.ptr.prototype.tag = function () {
      var _entry, n, s;
      s = "";
      n = this;
      s = ((_entry = $mapIndex(nameMap, ptrType$13.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$17.nil).tag;
      return s;
    };
    name.prototype.tag = function () {
      return this.$val.tag();
    };
    name.ptr.prototype.pkgPath = function () {
      var _entry, n;
      n = this;
      return ((_entry = $mapIndex(nameMap, ptrType$13.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$17.nil).pkgPath;
    };
    name.prototype.pkgPath = function () {
      return this.$val.pkgPath();
    };
    name.ptr.prototype.isExported = function () {
      var _entry, n;
      n = this;
      return ((_entry = $mapIndex(nameMap, ptrType$13.keyFor(n.bytes))),
      _entry !== undefined ? _entry.v : ptrType$17.nil).exported;
    };
    name.prototype.isExported = function () {
      return this.$val.isExported();
    };
    newName = function (n, tag, exported) {
      var _key, b, exported, n, tag;
      b = $newDataPointer(0, ptrType$13);
      _key = b;
      (nameMap || $throwRuntimeError("assignment to entry in nil map")).set(
        ptrType$13.keyFor(_key),
        { k: _key, v: new nameData.ptr(n, tag, exported, "") }
      );
      return new name.ptr(b);
    };
    newMethodName = function (m) {
      var _key, b, m;
      b = $newDataPointer(0, ptrType$13);
      _key = b;
      (nameMap || $throwRuntimeError("assignment to entry in nil map")).set(
        ptrType$13.keyFor(_key),
        {
          k: _key,
          v: new nameData.ptr(
            internalStr(m.name),
            "",
            internalStr(m.pkg) === "",
            internalStr(m.pkg)
          ),
        }
      );
      return new name.ptr(b);
    };
    rtype.ptr.prototype.nameOff = function (off) {
      var off, t, x;
      t = this;
      return (
        (x = off >> 0),
        x < 0 || x >= nameOffList.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : nameOffList.$array[nameOffList.$offset + x]
      );
    };
    rtype.prototype.nameOff = function (off) {
      return this.$val.nameOff(off);
    };
    resolveReflectName = function (n) {
      var i, n;
      i = nameOffList.$length;
      nameOffList = $append(nameOffList, n);
      return i >> 0;
    };
    rtype.ptr.prototype.typeOff = function (off) {
      var off, t, x;
      t = this;
      return (
        (x = off >> 0),
        x < 0 || x >= typeOffList.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : typeOffList.$array[typeOffList.$offset + x]
      );
    };
    rtype.prototype.typeOff = function (off) {
      return this.$val.typeOff(off);
    };
    newTypeOff = function (t) {
      var i, t;
      i = typeOffList.$length;
      typeOffList = $append(typeOffList, t);
      return i >> 0;
    };
    internalStr = function (strObj) {
      var c, strObj;
      c = new structType$3.ptr("");
      c.str = strObj;
      return c.str;
    };
    isWrapped = function (typ) {
      var typ;
      return !!jsType(typ).wrapped;
    };
    copyStruct = function (dst, src, typ) {
      var dst, fields, i, prop, src, typ;
      fields = jsType(typ).fields;
      i = 0;
      while (true) {
        if (!(i < $parseInt(fields.length))) {
          break;
        }
        prop = $internalize(fields[i].prop, $String);
        dst[$externalize(prop, $String)] = src[$externalize(prop, $String)];
        i = (i + 1) >> 0;
      }
    };
    makeValue = function (t, v, fl) {
      var {
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _v,
        _v$1,
        fl,
        rt,
        t,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { t, v, fl });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            rt = _r;
            _r$1 = t.Kind();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            if (_r$1 === 17) {
              _v$1 = true;
              $s = 5;
              continue s;
            }
            _r$2 = t.Kind();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _v$1 = _r$2 === 25;
          case 5:
            if (_v$1) {
              _v = true;
              $s = 4;
              continue s;
            }
            _r$3 = t.Kind();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _v = _r$3 === 22;
          case 4:
            /* */ if (_v) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (_v) { */ case 2:
            _r$4 = t.Kind();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(rt, v, (fl | (_r$4 >>> 0)) >>> 0);
            $s = 10;
          case 10:
            return $24r;
          /* } */ case 3:
            _r$5 = t.Kind();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $24r$1 = new Value.ptr(
              rt,
              $newDataPointer(v, jsType(rt.ptrTo())),
              (((fl | (_r$5 >>> 0)) >>> 0) | 128) >>> 0
            );
            $s = 12;
          case 12:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeValue,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _v,
        _v$1,
        fl,
        rt,
        t,
        v,
        $s,
      };
      return $f;
    };
    MakeSlice = function (typ, len, cap) {
      var { $24r, _r, _r$1, cap, len, typ, $s, $r, $c } = $restore(this, {
        typ,
        len,
        cap,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            typ = [typ];
            _r = typ[0].Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 23)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 23))) { */ case 1:
            $panic(new $String("reflect.MakeSlice of non-slice type"));
          /* } */ case 2:
            if (len < 0) {
              $panic(new $String("reflect.MakeSlice: negative len"));
            }
            if (cap < 0) {
              $panic(new $String("reflect.MakeSlice: negative cap"));
            }
            if (len > cap) {
              $panic(new $String("reflect.MakeSlice: len > cap"));
            }
            _r$1 = makeValue(
              typ[0],
              $makeSlice(
                jsType(typ[0]),
                len,
                cap,
                (function (typ) {
                  return function $b() {
                    var { $24r, _r$1, _r$2, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r$1 = typ[0].Elem();
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r$1 = _r$1.$blk();
                          }
                          if (_r$1 && _r$1.$blk !== undefined) {
                            break s;
                          }
                          _r$2 = jsType(_r$1);
                          /* */ $s = 2;
                        case 2:
                          if ($c) {
                            $c = false;
                            _r$2 = _r$2.$blk();
                          }
                          if (_r$2 && _r$2.$blk !== undefined) {
                            break s;
                          }
                          $24r = _r$2.zero();
                          $s = 3;
                        case 3:
                          return $24r;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r, _r$1, _r$2, $s };
                    return $f;
                  };
                })(typ)
              ),
              0
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 5;
          case 5:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: MakeSlice,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        cap,
        len,
        typ,
        $s,
      };
      return $f;
    };
    $pkg.MakeSlice = MakeSlice;
    TypeOf = function (i) {
      var i;
      if (!initialized) {
        return new rtype.ptr(
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          $throwNilPointerError,
          ptrType$13.nil,
          0,
          0
        );
      }
      if ($interfaceIsEqual(i, $ifaceNil)) {
        return $ifaceNil;
      }
      return reflectType(i.constructor);
    };
    $pkg.TypeOf = TypeOf;
    ValueOf = function (i) {
      var { $24r, _r, i, $s, $r, $c } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if ($interfaceIsEqual(i, $ifaceNil)) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            _r = makeValue(reflectType(i.constructor), i.$val, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: ValueOf, $c: true, $r, $24r, _r, i, $s };
      return $f;
    };
    $pkg.ValueOf = ValueOf;
    FuncOf = function (in$1, out, variadic) {
      var {
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        _v,
        _v$1,
        i,
        i$1,
        in$1,
        jsIn,
        jsOut,
        out,
        v,
        v$1,
        variadic,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { in$1, out, variadic });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (!variadic) {
              _v = false;
              $s = 3;
              continue s;
            }
            if (in$1.$length === 0) {
              _v$1 = true;
              $s = 4;
              continue s;
            }
            _r = ((x = (in$1.$length - 1) >> 0),
            x < 0 || x >= in$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : in$1.$array[in$1.$offset + x]).Kind();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v$1 = !(_r === 23);
          case 4:
            _v = _v$1;
          case 3:
            /* */ if (_v) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_v) { */ case 1:
            $panic(
              new $String(
                "reflect.FuncOf: last arg of variadic func must be slice"
              )
            );
          /* } */ case 2:
            jsIn = $makeSlice(sliceType$16, in$1.$length);
            _ref = in$1;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              i = _i;
              v =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              i < 0 || i >= jsIn.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (jsIn.$array[jsIn.$offset + i] = jsType(v));
              _i++;
            }
            jsOut = $makeSlice(sliceType$16, out.$length);
            _ref$1 = out;
            _i$1 = 0;
            while (true) {
              if (!(_i$1 < _ref$1.$length)) {
                break;
              }
              i$1 = _i$1;
              v$1 =
                _i$1 < 0 || _i$1 >= _ref$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref$1.$array[_ref$1.$offset + _i$1];
              i$1 < 0 || i$1 >= jsOut.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (jsOut.$array[jsOut.$offset + i$1] = jsType(v$1));
              _i$1++;
            }
            $s = -1;
            return reflectType(
              $funcType(
                $externalize(jsIn, sliceType$16),
                $externalize(jsOut, sliceType$16),
                $externalize(variadic, $Bool)
              )
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: FuncOf,
        $c: true,
        $r,
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        _v,
        _v$1,
        i,
        i$1,
        in$1,
        jsIn,
        jsOut,
        out,
        v,
        v$1,
        variadic,
        x,
        $s,
      };
      return $f;
    };
    $pkg.FuncOf = FuncOf;
    rtype.ptr.prototype.ptrTo = function () {
      var t;
      t = this;
      return reflectType($ptrType(jsType(t)));
    };
    rtype.prototype.ptrTo = function () {
      return this.$val.ptrTo();
    };
    SliceOf = function (t) {
      var t;
      return reflectType($sliceType(jsType(t)));
    };
    $pkg.SliceOf = SliceOf;
    Zero = function (typ) {
      var { $24r, _r, typ, $s, $r, $c } = $restore(this, { typ });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = makeValue(typ, jsType(typ).zero(), 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: Zero, $c: true, $r, $24r, _r, typ, $s };
      return $f;
    };
    $pkg.Zero = Zero;
    unsafe_New = function (typ) {
      var _1, typ;
      _1 = typ.Kind();
      if (_1 === 25) {
        return new (jsType(typ).ptr)();
      } else if (_1 === 17) {
        return jsType(typ).zero();
      } else {
        return $newDataPointer(jsType(typ).zero(), jsType(typ.ptrTo()));
      }
    };
    makeInt = function (f, bits, t) {
      var { _1, _r, bits, f, ptr, t, typ, $s, $r, $c } = $restore(this, {
        f,
        bits,
        t,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = t.common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            typ = _r;
            ptr = unsafe_New(typ);
            _1 = typ.Kind();
            if (_1 === 3) {
              ptr.$set((bits.$low << 24) >> 24);
            } else if (_1 === 4) {
              ptr.$set((bits.$low << 16) >> 16);
            } else if (_1 === 2 || _1 === 5) {
              ptr.$set(bits.$low >> 0);
            } else if (_1 === 6) {
              ptr.$set(new $Int64(bits.$high, bits.$low));
            } else if (_1 === 8) {
              ptr.$set((bits.$low << 24) >>> 24);
            } else if (_1 === 9) {
              ptr.$set((bits.$low << 16) >>> 16);
            } else if (_1 === 7 || _1 === 10 || _1 === 12) {
              ptr.$set(bits.$low >>> 0);
            } else if (_1 === 11) {
              ptr.$set(bits);
            }
            $s = -1;
            return new Value.ptr(
              typ,
              ptr,
              (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeInt,
        $c: true,
        $r,
        _1,
        _r,
        bits,
        f,
        ptr,
        t,
        typ,
        $s,
      };
      return $f;
    };
    typedmemmove = function (t, dst, src) {
      var dst, src, t;
      dst.$set(src.$get());
    };
    keyFor = function (t, key) {
      var k, key, kv, t;
      kv = key;
      if (!(kv.$get === undefined)) {
        kv = kv.$get();
      }
      k = jsType(t.Key()).keyFor(kv);
      return [kv, k];
    };
    mapaccess = function (t, m, key) {
      var _tuple, entry, k, key, m, t;
      if (!!!m) {
        return 0;
      }
      _tuple = keyFor(t, key);
      k = _tuple[1];
      entry = m.get(k);
      if (entry === undefined) {
        return 0;
      }
      return $newDataPointer(entry.v, jsType(PtrTo(t.Elem())));
    };
    mapassign = function (t, m, key, val) {
      var {
        _r,
        _tuple,
        entry,
        et,
        jsVal,
        k,
        key,
        kv,
        m,
        newVal,
        t,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { t, m, key, val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = keyFor(t, key);
            kv = _tuple[0];
            k = _tuple[1];
            jsVal = val.$get();
            et = t.Elem();
            _r = et.Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (_r === 25) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_r === 25) { */ case 1:
            newVal = jsType(et).zero();
            copyStruct(newVal, jsVal, et);
            jsVal = newVal;
          /* } */ case 2:
            entry = new $global.Object();
            entry.k = kv;
            entry.v = jsVal;
            m.set(k, entry);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mapassign,
        $c: true,
        $r,
        _r,
        _tuple,
        entry,
        et,
        jsVal,
        k,
        key,
        kv,
        m,
        newVal,
        t,
        val,
        $s,
      };
      return $f;
    };
    mapdelete = function (t, m, key) {
      var _tuple, k, key, m, t;
      _tuple = keyFor(t, key);
      k = _tuple[1];
      if (!!!m) {
        return;
      }
      m.delete(k);
    };
    mapaccess_faststr = function (t, m, key) {
      var key, key$24ptr, m, t, val;
      val = 0;
      val = mapaccess(
        t,
        m,
        key$24ptr ||
          (key$24ptr = new ptrType$18(
            function () {
              return key;
            },
            function ($v) {
              key = $v;
            }
          ))
      );
      return val;
    };
    mapassign_faststr = function (t, m, key, val) {
      var { key, m, t, val, $s, $r, $c } = $restore(this, { t, m, key, val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            key = [key];
            $r = mapassign(
              t,
              m,
              key.$ptr ||
                (key.$ptr = new ptrType$18(
                  function () {
                    return this.$target[0];
                  },
                  function ($v) {
                    this.$target[0] = $v;
                  },
                  key
                )),
              val
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: mapassign_faststr, $c: true, $r, key, m, t, val, $s };
      return $f;
    };
    mapdelete_faststr = function (t, m, key) {
      var key, key$24ptr, m, t;
      mapdelete(
        t,
        m,
        key$24ptr ||
          (key$24ptr = new ptrType$18(
            function () {
              return key;
            },
            function ($v) {
              key = $v;
            }
          ))
      );
    };
    hiter.ptr.prototype.skipUntilValidKey = function () {
      var entry, iter, k;
      iter = this;
      while (true) {
        if (!(iter.i < $parseInt(iter.keys.length))) {
          break;
        }
        k = iter.keys[iter.i];
        entry = iter.m.get(k);
        if (!(entry === undefined)) {
          break;
        }
        iter.i = (iter.i + 1) >> 0;
      }
    };
    hiter.prototype.skipUntilValidKey = function () {
      return this.$val.skipUntilValidKey();
    };
    mapiterinit = function (t, m, it) {
      var it, keys, keysIter, m, mapObj, t;
      mapObj = m;
      keys = new $global.Array();
      if (!(mapObj.keys === undefined)) {
        keysIter = mapObj.keys();
        if (!(mapObj.keys === undefined)) {
          keys = $global.Array.from(keysIter);
        }
      }
      hiter.copy(it, new hiter.ptr(t, mapObj, keys, 0, null));
    };
    mapiterkey = function (it) {
      var { $24r, _r, _r$1, _r$2, it, k, kv, $s, $r, $c } = $restore(this, {
        it,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            kv = null;
            if (!(it.last === null)) {
              kv = it.last;
            } else {
              it.skipUntilValidKey();
              if (it.i === $parseInt(it.keys.length)) {
                $s = -1;
                return 0;
              }
              k = it.keys[it.i];
              kv = it.m.get(k);
              it.last = kv;
            }
            _r = it.t.Key();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = PtrTo(_r);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = jsType(_r$1);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = $newDataPointer(kv.k, _r$2);
            $s = 4;
          case 4:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mapiterkey,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        it,
        k,
        kv,
        $s,
      };
      return $f;
    };
    mapiterelem = function (it) {
      var { $24r, _r, _r$1, _r$2, it, k, kv, $s, $r, $c } = $restore(this, {
        it,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            kv = null;
            if (!(it.last === null)) {
              kv = it.last;
            } else {
              it.skipUntilValidKey();
              if (it.i === $parseInt(it.keys.length)) {
                $s = -1;
                return 0;
              }
              k = it.keys[it.i];
              kv = it.m.get(k);
              it.last = kv;
            }
            _r = it.t.Elem();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = PtrTo(_r);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = jsType(_r$1);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = $newDataPointer(kv.v, _r$2);
            $s = 4;
          case 4:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mapiterelem,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        it,
        k,
        kv,
        $s,
      };
      return $f;
    };
    mapiternext = function (it) {
      var it;
      it.last = null;
      it.i = (it.i + 1) >> 0;
    };
    maplen = function (m) {
      var m;
      return $parseInt(m.size) >> 0;
    };
    cvtDirect = function (v, typ) {
      var {
        $24r,
        $24r$1,
        _1,
        _2,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        k,
        slice,
        srcVal,
        typ,
        v,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { v, typ });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            srcVal = $clone(v, Value).object();
            /* */ if (srcVal === jsType(v.typ).nil) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (srcVal === jsType(v.typ).nil) { */ case 1:
            _r = makeValue(typ, jsType(typ).nil, v.flag);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            val = null;
            _r$1 = typ.Kind();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            k = _r$1;
            _1 = k;
            /* */ if (_1 === 23) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 22) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 9;
              continue;
            }
            /* */ if (
              _1 === 17 ||
              _1 === 1 ||
              _1 === 18 ||
              _1 === 19 ||
              _1 === 20 ||
              _1 === 21 ||
              _1 === 24 ||
              _1 === 26
            ) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_1 === (23)) { */ case 7:
            slice = new (jsType(typ))(srcVal.$array);
            slice.$offset = srcVal.$offset;
            slice.$length = srcVal.$length;
            slice.$capacity = srcVal.$capacity;
            val = $newDataPointer(slice, jsType(PtrTo(typ)));
            $s = 12;
            continue;
          /* } else if (_1 === (22)) { */ case 8:
            _r$2 = typ.Elem();
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$3 = _r$2.Kind();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _2 = _r$3;
            /* */ if (_2 === 25) {
              $s = 16;
              continue;
            }
            /* */ if (_2 === 17) {
              $s = 17;
              continue;
            }
            /* */ $s = 18;
            continue;
          /* if (_2 === (25)) { */ case 16:
            _r$4 = typ.Elem();
            /* */ $s = 22;
          case 22:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            /* */ if ($interfaceIsEqual(_r$4, v.typ.Elem())) {
              $s = 20;
              continue;
            }
            /* */ $s = 21;
            continue;
          /* if ($interfaceIsEqual(_r$4, v.typ.Elem())) { */ case 20:
            val = srcVal;
            /* break; */ $s = 13;
            continue;
          /* } */ case 21:
            val = new (jsType(typ))();
            _arg = val;
            _arg$1 = srcVal;
            _r$5 = typ.Elem();
            /* */ $s = 23;
          case 23:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _arg$2 = _r$5;
            $r = copyStruct(_arg, _arg$1, _arg$2);
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 19;
            continue;
          /* } else if (_2 === (17)) { */ case 17:
            val = srcVal;
            $s = 19;
            continue;
          /* } else { */ case 18:
            val = new (jsType(typ))(srcVal.$get, srcVal.$set);
          /* } */ case 19:
          case 13:
            $s = 12;
            continue;
          /* } else if (_1 === (25)) { */ case 9:
            val = new (jsType(typ).ptr)();
            copyStruct(val, srcVal, typ);
            $s = 12;
            continue;
          /* } else if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24)) || (_1 === (26))) { */ case 10:
            val = v.ptr;
            $s = 12;
            continue;
          /* } else { */ case 11:
            $panic(new ValueError.ptr("reflect.Convert", k));
          /* } */ case 12:
          case 5:
            _r$6 = typ.common();
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _r$7 = typ.Kind();
            /* */ $s = 26;
          case 26:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            $24r$1 = new Value.ptr(
              _r$6,
              val,
              (((new flag(v.flag).ro() | ((v.flag & 128) >>> 0)) >>> 0) |
                (_r$7 >>> 0)) >>>
                0
            );
            $s = 27;
          case 27:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtDirect,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _2,
        _arg,
        _arg$1,
        _arg$2,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        k,
        slice,
        srcVal,
        typ,
        v,
        val,
        $s,
      };
      return $f;
    };
    cvtSliceArrayPtr = function (v, t) {
      var { $24r, _r, _r$1, _r$2, alen, array, slen, slice, t, v, $s, $r, $c } =
        $restore(this, { v, t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            slice = $clone(v, Value).object();
            slen = $parseInt(slice.$length) >> 0;
            _r = t.Elem();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = _r.Len();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            alen = _r$1;
            if (alen > slen) {
              $panic(
                new $String(
                  "reflect: cannot convert slice with length " +
                    itoa.Itoa(slen) +
                    " to pointer to array with length " +
                    itoa.Itoa(alen)
                )
              );
            }
            array = $sliceToGoArray(slice, jsType(t));
            _r$2 = t.common();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(
              _r$2,
              array,
              (((v.flag & ~415) >>> 0) | 22) >>> 0
            );
            $s = 4;
          case 4:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: cvtSliceArrayPtr,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        alen,
        array,
        slen,
        slice,
        t,
        v,
        $s,
      };
      return $f;
    };
    methodReceiver = function (op, v, i) {
      var _$49, fn, i, m, m$1, ms, op, prop, rcvr, t, tt, v, x;
      _$49 = ptrType$1.nil;
      t = ptrType$19.nil;
      fn = 0;
      prop = "";
      if (v.typ.Kind() === 20) {
        tt = v.typ.kindType;
        if (i < 0 || i >= tt.methods.$length) {
          $panic(new $String("reflect: internal error: invalid method index"));
        }
        m =
          ((x = tt.methods),
          i < 0 || i >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + i]);
        if (!$clone(tt.rtype.nameOff(m.name), name).isExported()) {
          $panic(new $String("reflect: " + op + " of unexported method"));
        }
        t = tt.rtype.typeOff(m.typ).kindType;
        prop = $clone(tt.rtype.nameOff(m.name), name).name();
      } else {
        ms = v.typ.exportedMethods();
        if (i >>> 0 >= ms.$length >>> 0) {
          $panic(new $String("reflect: internal error: invalid method index"));
        }
        m$1 = $clone(
          i < 0 || i >= ms.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : ms.$array[ms.$offset + i],
          method
        );
        if (!$clone(v.typ.nameOff(m$1.name), name).isExported()) {
          $panic(new $String("reflect: " + op + " of unexported method"));
        }
        t = v.typ.typeOff(m$1.mtyp).kindType;
        prop = $internalize($methodSet(jsType(v.typ))[i].prop, $String);
      }
      rcvr = $clone(v, Value).object();
      if (isWrapped(v.typ)) {
        rcvr = new (jsType(v.typ))(rcvr);
      }
      fn = rcvr[$externalize(prop, $String)];
      return [_$49, t, fn];
    };
    valueInterface = function (v, safe) {
      var { _r, cv, safe, v, $s, $r, $c } = $restore(this, { v, safe });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (v.flag === 0) {
              $panic(new ValueError.ptr("reflect.Value.Interface", 0));
            }
            if (safe && !((v.flag & 96) >>> 0 === 0)) {
              $panic(
                new $String(
                  "reflect.Value.Interface: cannot return value obtained from unexported field or method"
                )
              );
            }
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
            _r = makeMethodValue("Interface", $clone(v, Value));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
          /* } */ case 2:
            if (isWrapped(v.typ)) {
              if (
                !((v.flag & 128) >>> 0 === 0) &&
                $clone(v, Value).Kind() === 25
              ) {
                cv = jsType(v.typ).zero();
                copyStruct(cv, $clone(v, Value).object(), v.typ);
                $s = -1;
                return new (jsType(v.typ))(cv);
              }
              $s = -1;
              return new (jsType(v.typ))($clone(v, Value).object());
            }
            $s = -1;
            return $clone(v, Value).object();
          /* */
        }
        return;
      }
      var $f = { $blk: valueInterface, $c: true, $r, _r, cv, safe, v, $s };
      return $f;
    };
    ifaceE2I = function (t, src, dst) {
      var dst, src, t;
      dst.$set(src);
    };
    makeMethodValue = function (op, v) {
      var { $24r, _r, _tuple, fn, fv, op, rcvr, v, $s, $r, $c } = $restore(
        this,
        { op, v }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fn = [fn];
            rcvr = [rcvr];
            if ((v.flag & 512) >>> 0 === 0) {
              $panic(
                new $String(
                  "reflect: internal error: invalid use of makePartialFunc"
                )
              );
            }
            _tuple = methodReceiver(
              op,
              $clone(v, Value),
              ((v.flag >> 0) >> 10) >> 0
            );
            fn[0] = _tuple[2];
            rcvr[0] = $clone(v, Value).object();
            if (isWrapped(v.typ)) {
              rcvr[0] = new (jsType(v.typ))(rcvr[0]);
            }
            fv = js.MakeFunc(
              (function (fn, rcvr) {
                return function (this$1, arguments$1) {
                  var arguments$1, this$1;
                  return new $jsObjectPtr(
                    fn[0].apply(
                      rcvr[0],
                      $externalize(arguments$1, sliceType$16)
                    )
                  );
                };
              })(fn, rcvr)
            );
            _r = $clone(v, Value).Type().common();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = new Value.ptr(_r, fv, (new flag(v.flag).ro() | 19) >>> 0);
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: makeMethodValue,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        fn,
        fv,
        op,
        rcvr,
        v,
        $s,
      };
      return $f;
    };
    rtype.ptr.prototype.pointers = function () {
      var _1, t;
      t = this;
      _1 = t.Kind();
      if (
        _1 === 22 ||
        _1 === 21 ||
        _1 === 18 ||
        _1 === 19 ||
        _1 === 25 ||
        _1 === 17
      ) {
        return true;
      } else {
        return false;
      }
    };
    rtype.prototype.pointers = function () {
      return this.$val.pointers();
    };
    rtype.ptr.prototype.Comparable = function () {
      var { $24r, _1, _r, _r$1, i, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _1 = t.Kind();
            /* */ if (_1 === 19 || _1 === 23 || _1 === 21) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 17) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { */ case 2:
            $s = -1;
            return false;
          /* } else if (_1 === (17)) { */ case 3:
            _r = t.Elem().Comparable();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 7;
          case 7:
            return $24r;
          /* } else if (_1 === (25)) { */ case 4:
            i = 0;
          /* while (true) { */ case 8:
            /* if (!(i < t.NumField())) { break; } */ if (!(i < t.NumField())) {
              $s = 9;
              continue;
            }
            _r$1 = t.Field(i).Type.Comparable();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$1) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (!_r$1) { */ case 10:
            $s = -1;
            return false;
          /* } */ case 11:
            i = (i + 1) >> 0;
            $s = 8;
            continue;
          case 9:
          /* } */ case 5:
          case 1:
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Comparable,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        _r$1,
        i,
        t,
        $s,
      };
      return $f;
    };
    rtype.prototype.Comparable = function () {
      return this.$val.Comparable();
    };
    rtype.ptr.prototype.Method = function (i) {
      var {
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        arg,
        fl,
        fn,
        ft,
        i,
        in$1,
        m,
        methods,
        mt,
        mtyp,
        out,
        p,
        pname,
        prop,
        ret,
        t,
        tt,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            prop = [prop];
            m = new Method.ptr(
              "",
              "",
              $ifaceNil,
              new Value.ptr(ptrType$1.nil, 0, 0),
              0
            );
            t = this;
            if (t.Kind() === 20) {
              tt = t.kindType;
              Method.copy(m, tt.Method(i));
              $s = -1;
              return m;
            }
            methods = t.exportedMethods();
            if (i < 0 || i >= methods.$length) {
              $panic(new $String("reflect: Method index out of range"));
            }
            p = $clone(
              i < 0 || i >= methods.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : methods.$array[methods.$offset + i],
              method
            );
            pname = $clone(t.nameOff(p.name), name);
            m.Name = $clone(pname, name).name();
            fl = 19;
            mtyp = t.typeOff(p.mtyp);
            ft = mtyp.kindType;
            in$1 = $makeSlice(sliceType$17, 0, (1 + ft.in$().$length) >> 0);
            in$1 = $append(in$1, t);
            _ref = ft.in$();
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              arg =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              in$1 = $append(in$1, arg);
              _i++;
            }
            out = $makeSlice(sliceType$17, 0, ft.out().$length);
            _ref$1 = ft.out();
            _i$1 = 0;
            while (true) {
              if (!(_i$1 < _ref$1.$length)) {
                break;
              }
              ret =
                _i$1 < 0 || _i$1 >= _ref$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref$1.$array[_ref$1.$offset + _i$1];
              out = $append(out, ret);
              _i$1++;
            }
            _r = FuncOf(in$1, out, ft.rtype.IsVariadic());
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            mt = _r;
            m.Type = mt;
            prop[0] = $internalize($methodSet(t.jsType)[i].prop, $String);
            fn = js.MakeFunc(
              (function (prop) {
                return function (this$1, arguments$1) {
                  var arguments$1, rcvr, this$1;
                  rcvr =
                    0 >= arguments$1.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : arguments$1.$array[arguments$1.$offset + 0];
                  return new $jsObjectPtr(
                    rcvr[$externalize(prop[0], $String)].apply(
                      rcvr,
                      $externalize($subslice(arguments$1, 1), sliceType$16)
                    )
                  );
                };
              })(prop)
            );
            m.Func = new Value.ptr($assertType(mt, ptrType$1), fn, fl);
            m.Index = i;
            Method.copy(m, m);
            $s = -1;
            return m;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rtype.ptr.prototype.Method,
        $c: true,
        $r,
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        arg,
        fl,
        fn,
        ft,
        i,
        in$1,
        m,
        methods,
        mt,
        mtyp,
        out,
        p,
        pname,
        prop,
        ret,
        t,
        tt,
        $s,
      };
      return $f;
    };
    rtype.prototype.Method = function (i) {
      return this.$val.Method(i);
    };
    Value.ptr.prototype.object = function () {
      var _1, newVal, v, val;
      v = this;
      if (v.typ.Kind() === 17 || v.typ.Kind() === 25) {
        return v.ptr;
      }
      if (!((v.flag & 128) >>> 0 === 0)) {
        val = v.ptr.$get();
        if (!(val === $ifaceNil) && !(val.constructor === jsType(v.typ))) {
          switch (0) {
            default:
              _1 = v.typ.Kind();
              if (_1 === 11 || _1 === 6) {
                val = new (jsType(v.typ))(val.$high, val.$low);
              } else if (_1 === 15 || _1 === 16) {
                val = new (jsType(v.typ))(val.$real, val.$imag);
              } else if (_1 === 23) {
                if (val === val.constructor.nil) {
                  val = jsType(v.typ).nil;
                  break;
                }
                newVal = new (jsType(v.typ))(val.$array);
                newVal.$offset = val.$offset;
                newVal.$length = val.$length;
                newVal.$capacity = val.$capacity;
                val = newVal;
              }
          }
        }
        return val;
      }
      return v.ptr;
    };
    Value.prototype.object = function () {
      return this.$val.object();
    };
    Value.ptr.prototype.assignTo = function (context, dst, target) {
      var { _r, _r$1, _r$2, context, dst, fl, target, v, x, $s, $r, $c } =
        $restore(this, { context, dst, target });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            /* */ if (!((v.flag & 512) >>> 0 === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
            _r = makeMethodValue(context, $clone(v, Value));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
          /* } */ case 2:
            _r$1 = directlyAssignable(dst, v.typ);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$1) {
              $s = 5;
              continue;
            }
            /* */ if (implements$1(dst, v.typ)) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (_r$1) { */ case 5:
            fl = (((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0;
            fl = (fl | (dst.Kind() >>> 0)) >>> 0;
            $s = -1;
            return new Value.ptr(dst, v.ptr, fl);
          /* } else if (implements$1(dst, v.typ)) { */ case 6:
            if (target === 0) {
              target = unsafe_New(dst);
            }
            _r$2 = valueInterface($clone(v, Value), false);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            x = _r$2;
            if (dst.NumMethod() === 0) {
              target.$set(x);
            } else {
              ifaceE2I(dst, x, target);
            }
            $s = -1;
            return new Value.ptr(dst, target, 148);
          /* } */ case 7:
          case 4:
            $panic(
              new $String(
                context +
                  ": value of type " +
                  v.typ.String() +
                  " is not assignable to type " +
                  dst.String()
              )
            );
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.assignTo,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        context,
        dst,
        fl,
        target,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.assignTo = function (context, dst, target) {
      return this.$val.assignTo(context, dst, target);
    };
    Value.ptr.prototype.call = function (op, in$1) {
      var {
        $24r,
        _1,
        _arg,
        _arg$1,
        _arg$2,
        _arg$3,
        _i,
        _i$1,
        _i$2,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _ref,
        _ref$1,
        _ref$2,
        _tmp,
        _tmp$1,
        _tuple,
        arg,
        argsArray,
        elem,
        fn,
        i,
        i$1,
        i$2,
        i$3,
        in$1,
        isSlice,
        m,
        n,
        nin,
        nout,
        op,
        origIn,
        rcvr,
        results,
        ret,
        slice,
        t,
        targ,
        v,
        x,
        x$1,
        x$2,
        xt,
        xt$1,
        $s,
        $r,
        $c,
      } = $restore(this, { op, in$1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            t = ptrType$19.nil;
            fn = 0;
            rcvr = null;
            if (!((v.flag & 512) >>> 0 === 0)) {
              _tuple = methodReceiver(
                op,
                $clone(v, Value),
                ((v.flag >> 0) >> 10) >> 0
              );
              t = _tuple[1];
              fn = _tuple[2];
              rcvr = $clone(v, Value).object();
              if (isWrapped(v.typ)) {
                rcvr = new (jsType(v.typ))(rcvr);
              }
            } else {
              t = v.typ.kindType;
              fn = $clone(v, Value).object();
              rcvr = undefined;
            }
            if (fn === 0) {
              $panic(new $String("reflect.Value.Call: call of nil function"));
            }
            isSlice = op === "CallSlice";
            n = t.rtype.NumIn();
            if (isSlice) {
              if (!t.rtype.IsVariadic()) {
                $panic(
                  new $String("reflect: CallSlice of non-variadic function")
                );
              }
              if (in$1.$length < n) {
                $panic(
                  new $String("reflect: CallSlice with too few input arguments")
                );
              }
              if (in$1.$length > n) {
                $panic(
                  new $String(
                    "reflect: CallSlice with too many input arguments"
                  )
                );
              }
            } else {
              if (t.rtype.IsVariadic()) {
                n = (n - 1) >> 0;
              }
              if (in$1.$length < n) {
                $panic(
                  new $String("reflect: Call with too few input arguments")
                );
              }
              if (!t.rtype.IsVariadic() && in$1.$length > n) {
                $panic(
                  new $String("reflect: Call with too many input arguments")
                );
              }
            }
            _ref = in$1;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              x =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              if ($clone(x, Value).Kind() === 0) {
                $panic(
                  new $String("reflect: " + op + " using zero Value argument")
                );
              }
              _i++;
            }
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < n)) { break; } */ if (!(i < n)) {
              $s = 2;
              continue;
            }
            _tmp = $clone(
              i < 0 || i >= in$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : in$1.$array[in$1.$offset + i],
              Value
            ).Type();
            _tmp$1 = t.rtype.In(i);
            xt = _tmp;
            targ = _tmp$1;
            _r = xt.AssignableTo(targ);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!_r) { */ case 3:
            _r$1 = xt.String();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = targ.String();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(
              new $String(
                "reflect: " + op + " using " + _r$1 + " as type " + _r$2
              )
            );
          /* } */ case 4:
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            /* */ if (!isSlice && t.rtype.IsVariadic()) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (!isSlice && t.rtype.IsVariadic()) { */ case 8:
            m = (in$1.$length - n) >> 0;
            _r$3 = MakeSlice(t.rtype.In(n), m, m);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            slice = _r$3;
            _r$4 = t.rtype.In(n).Elem();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            elem = _r$4;
            i$1 = 0;
          /* while (true) { */ case 12:
            /* if (!(i$1 < m)) { break; } */ if (!(i$1 < m)) {
              $s = 13;
              continue;
            }
            x$2 =
              ((x$1 = (n + i$1) >> 0),
              x$1 < 0 || x$1 >= in$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : in$1.$array[in$1.$offset + x$1]);
            xt$1 = $clone(x$2, Value).Type();
            _r$5 = xt$1.AssignableTo(elem);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$5) {
              $s = 14;
              continue;
            }
            /* */ $s = 15;
            continue;
          /* if (!_r$5) { */ case 14:
            _r$6 = xt$1.String();
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _r$7 = elem.String();
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            $panic(
              new $String(
                "reflect: cannot use " + _r$6 + " as type " + _r$7 + " in " + op
              )
            );
          /* } */ case 15:
            _r$8 = $clone(slice, Value).Index(i$1);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            $r = $clone(_r$8, Value).Set($clone(x$2, Value));
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i$1 = (i$1 + 1) >> 0;
            $s = 12;
            continue;
          case 13:
            origIn = in$1;
            in$1 = $makeSlice(sliceType$7, (n + 1) >> 0);
            $copySlice($subslice(in$1, 0, n), origIn);
            n < 0 || n >= in$1.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (in$1.$array[in$1.$offset + n] = slice);
          /* } */ case 9:
            nin = in$1.$length;
            if (!(nin === t.rtype.NumIn())) {
              $panic(new $String("reflect.Value.Call: wrong argument count"));
            }
            nout = t.rtype.NumOut();
            argsArray = new $global.Array(t.rtype.NumIn());
            _ref$1 = in$1;
            _i$1 = 0;
          /* while (true) { */ case 21:
            /* if (!(_i$1 < _ref$1.$length)) { break; } */ if (
              !(_i$1 < _ref$1.$length)
            ) {
              $s = 22;
              continue;
            }
            i$2 = _i$1;
            arg =
              _i$1 < 0 || _i$1 >= _ref$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref$1.$array[_ref$1.$offset + _i$1];
            _arg = t.rtype.In(i$2);
            _r$9 = t.rtype.In(i$2).common();
            /* */ $s = 23;
          case 23:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r$9;
            _arg$2 = 0;
            _r$10 = $clone(arg, Value).assignTo(
              "reflect.Value.Call",
              _arg$1,
              _arg$2
            );
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _r$11 = $clone(_r$10, Value).object();
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$11 = _r$11.$blk();
            }
            if (_r$11 && _r$11.$blk !== undefined) {
              break s;
            }
            _arg$3 = _r$11;
            _r$12 = unwrapJsObject(_arg, _arg$3);
            /* */ $s = 26;
          case 26:
            if ($c) {
              $c = false;
              _r$12 = _r$12.$blk();
            }
            if (_r$12 && _r$12.$blk !== undefined) {
              break s;
            }
            argsArray[i$2] = _r$12;
            _i$1++;
            $s = 21;
            continue;
          case 22:
            _r$13 = callHelper(
              new sliceType$4([
                new $jsObjectPtr(fn),
                new $jsObjectPtr(rcvr),
                new $jsObjectPtr(argsArray),
              ])
            );
            /* */ $s = 27;
          case 27:
            if ($c) {
              $c = false;
              _r$13 = _r$13.$blk();
            }
            if (_r$13 && _r$13.$blk !== undefined) {
              break s;
            }
            results = _r$13;
            _1 = nout;
            /* */ if (_1 === 0) {
              $s = 29;
              continue;
            }
            /* */ if (_1 === 1) {
              $s = 30;
              continue;
            }
            /* */ $s = 31;
            continue;
          /* if (_1 === (0)) { */ case 29:
            $s = -1;
            return sliceType$7.nil;
          /* } else if (_1 === (1)) { */ case 30:
            _r$14 = makeValue(
              t.rtype.Out(0),
              wrapJsObject(t.rtype.Out(0), results),
              0
            );
            /* */ $s = 33;
          case 33:
            if ($c) {
              $c = false;
              _r$14 = _r$14.$blk();
            }
            if (_r$14 && _r$14.$blk !== undefined) {
              break s;
            }
            $24r = new sliceType$7([$clone(_r$14, Value)]);
            $s = 34;
          case 34:
            return $24r;
          /* } else { */ case 31:
            ret = $makeSlice(sliceType$7, nout);
            _ref$2 = ret;
            _i$2 = 0;
          /* while (true) { */ case 35:
            /* if (!(_i$2 < _ref$2.$length)) { break; } */ if (
              !(_i$2 < _ref$2.$length)
            ) {
              $s = 36;
              continue;
            }
            i$3 = _i$2;
            _r$15 = makeValue(
              t.rtype.Out(i$3),
              wrapJsObject(t.rtype.Out(i$3), results[i$3]),
              0
            );
            /* */ $s = 37;
          case 37:
            if ($c) {
              $c = false;
              _r$15 = _r$15.$blk();
            }
            if (_r$15 && _r$15.$blk !== undefined) {
              break s;
            }
            i$3 < 0 || i$3 >= ret.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (ret.$array[ret.$offset + i$3] = _r$15);
            _i$2++;
            $s = 35;
            continue;
          case 36:
            $s = -1;
            return ret;
          /* } */ case 32:
          case 28:
            $s = -1;
            return sliceType$7.nil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.call,
        $c: true,
        $r,
        $24r,
        _1,
        _arg,
        _arg$1,
        _arg$2,
        _arg$3,
        _i,
        _i$1,
        _i$2,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _ref,
        _ref$1,
        _ref$2,
        _tmp,
        _tmp$1,
        _tuple,
        arg,
        argsArray,
        elem,
        fn,
        i,
        i$1,
        i$2,
        i$3,
        in$1,
        isSlice,
        m,
        n,
        nin,
        nout,
        op,
        origIn,
        rcvr,
        results,
        ret,
        slice,
        t,
        targ,
        v,
        x,
        x$1,
        x$2,
        xt,
        xt$1,
        $s,
      };
      return $f;
    };
    Value.prototype.call = function (op, in$1) {
      return this.$val.call(op, in$1);
    };
    Value.ptr.prototype.Cap = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 17) {
        return v.typ.Len();
      } else if (_1 === 18 || _1 === 23) {
        return $parseInt($clone(v, Value).object().$capacity) >> 0;
      }
      $panic(new ValueError.ptr("reflect.Value.Cap", k));
    };
    Value.prototype.Cap = function () {
      return this.$val.Cap();
    };
    wrapJsObject = function (typ, val) {
      var typ, val;
      if ($interfaceIsEqual(typ, jsObjectPtr)) {
        return new (jsType(jsObjectPtr))(val);
      }
      return val;
    };
    unwrapJsObject = function (typ, val) {
      var typ, val;
      if ($interfaceIsEqual(typ, jsObjectPtr)) {
        return val.object;
      }
      return val;
    };
    Value.ptr.prototype.Elem = function () {
      var { $24r, _1, _r, fl, k, tt, typ, v, val, val$1, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            /* */ if (_1 === 20) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 22) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (_1 === (20)) { */ case 2:
            val = $clone(v, Value).object();
            if (val === $ifaceNil) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            typ = reflectType(val.constructor);
            _r = makeValue(typ, val.$val, new flag(v.flag).ro());
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 7;
          case 7:
            return $24r;
          /* } else if (_1 === (22)) { */ case 3:
            if ($clone(v, Value).IsNil()) {
              $s = -1;
              return new Value.ptr(ptrType$1.nil, 0, 0);
            }
            val$1 = $clone(v, Value).object();
            tt = v.typ.kindType;
            fl = (((((v.flag & 96) >>> 0) | 128) >>> 0) | 256) >>> 0;
            fl = (fl | (tt.elem.Kind() >>> 0)) >>> 0;
            $s = -1;
            return new Value.ptr(tt.elem, wrapJsObject(tt.elem, val$1), fl);
          /* } else { */ case 4:
            $panic(new ValueError.ptr("reflect.Value.Elem", k));
          /* } */ case 5:
          case 1:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Elem,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        fl,
        k,
        tt,
        typ,
        v,
        val,
        val$1,
        $s,
      };
      return $f;
    };
    Value.prototype.Elem = function () {
      return this.$val.Elem();
    };
    Value.ptr.prototype.Field = function (i) {
      var {
        $24r,
        _r,
        _r$1,
        _r$2,
        field,
        fl,
        i,
        jsTag,
        o,
        prop,
        s,
        tag,
        tt,
        typ,
        v,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            jsTag = [jsTag];
            prop = [prop];
            s = [s];
            typ = [typ];
            v = this;
            if (!(new flag(v.flag).kind() === 25)) {
              $panic(
                new ValueError.ptr(
                  "reflect.Value.Field",
                  new flag(v.flag).kind()
                )
              );
            }
            tt = v.typ.kindType;
            if (i >>> 0 >= tt.fields.$length >>> 0) {
              $panic(new $String("reflect: Field index out of range"));
            }
            prop[0] = $internalize(jsType(v.typ).fields[i].prop, $String);
            field =
              ((x = tt.fields),
              i < 0 || i >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + i]);
            typ[0] = field.typ;
            fl = (((v.flag & 416) >>> 0) | (typ[0].Kind() >>> 0)) >>> 0;
            if (!$clone(field.name, name).isExported()) {
              if (field.embedded()) {
                fl = (fl | 64) >>> 0;
              } else {
                fl = (fl | 32) >>> 0;
              }
            }
            tag = $clone(
              ((x$1 = tt.fields),
              i < 0 || i >= x$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1.$array[x$1.$offset + i]).name,
              name
            ).tag();
            /* */ if (!(tag === "") && !(i === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!(tag === "") && !((i === 0))) { */ case 1:
            jsTag[0] = getJsTag(tag);
            /* */ if (!(jsTag[0] === "")) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!(jsTag[0] === "")) { */ case 3:
          /* while (true) { */ case 5:
            o = [o];
            _r = $clone(v, Value).Field(0);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
            /* */ if (v.typ === jsObjectPtr) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (v.typ === jsObjectPtr) { */ case 8:
            o[0] = $clone(v, Value).object().object;
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (jsTag, o, prop, s, typ) {
                  return function () {
                    return $internalize(
                      o[0][$externalize(jsTag[0], $String)],
                      jsType(typ[0])
                    );
                  };
                })(jsTag, o, prop, s, typ),
                (function (jsTag, o, prop, s, typ) {
                  return function (x$2) {
                    var x$2;
                    o[0][$externalize(jsTag[0], $String)] = $externalize(
                      x$2,
                      jsType(typ[0])
                    );
                  };
                })(jsTag, o, prop, s, typ)
              ),
              fl
            );
          /* } */ case 9:
            /* */ if (v.typ.Kind() === 22) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (v.typ.Kind() === 22) { */ case 10:
            _r$1 = $clone(v, Value).Elem();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            v = _r$1;
          /* } */ case 11:
            $s = 5;
            continue;
          case 6:
          /* } */ case 4:
          /* } */ case 2:
            s[0] = v.ptr;
            /* */ if (
              !((fl & 128) >>> 0 === 0) &&
              !(typ[0].Kind() === 17) &&
              !(typ[0].Kind() === 25)
            ) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 13:
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (jsTag, prop, s, typ) {
                  return function () {
                    return wrapJsObject(
                      typ[0],
                      s[0][$externalize(prop[0], $String)]
                    );
                  };
                })(jsTag, prop, s, typ),
                (function (jsTag, prop, s, typ) {
                  return function (x$2) {
                    var x$2;
                    s[0][$externalize(prop[0], $String)] = unwrapJsObject(
                      typ[0],
                      x$2
                    );
                  };
                })(jsTag, prop, s, typ)
              ),
              fl
            );
          /* } */ case 14:
            _r$2 = makeValue(
              typ[0],
              wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]),
              fl
            );
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 16;
          case 16:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Field,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        _r$2,
        field,
        fl,
        i,
        jsTag,
        o,
        prop,
        s,
        tag,
        tt,
        typ,
        v,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    Value.prototype.Field = function (i) {
      return this.$val.Field(i);
    };
    getJsTag = function (tag) {
      var _tuple, i, name$1, qvalue, tag, value;
      while (true) {
        if (!!(tag === "")) {
          break;
        }
        i = 0;
        while (true) {
          if (!(i < tag.length && tag.charCodeAt(i) === 32)) {
            break;
          }
          i = (i + 1) >> 0;
        }
        tag = $substring(tag, i);
        if (tag === "") {
          break;
        }
        i = 0;
        while (true) {
          if (
            !(
              i < tag.length &&
              !(tag.charCodeAt(i) === 32) &&
              !(tag.charCodeAt(i) === 58) &&
              !(tag.charCodeAt(i) === 34)
            )
          ) {
            break;
          }
          i = (i + 1) >> 0;
        }
        if (
          (i + 1) >> 0 >= tag.length ||
          !(tag.charCodeAt(i) === 58) ||
          !(tag.charCodeAt((i + 1) >> 0) === 34)
        ) {
          break;
        }
        name$1 = $substring(tag, 0, i);
        tag = $substring(tag, (i + 1) >> 0);
        i = 1;
        while (true) {
          if (!(i < tag.length && !(tag.charCodeAt(i) === 34))) {
            break;
          }
          if (tag.charCodeAt(i) === 92) {
            i = (i + 1) >> 0;
          }
          i = (i + 1) >> 0;
        }
        if (i >= tag.length) {
          break;
        }
        qvalue = $substring(tag, 0, (i + 1) >> 0);
        tag = $substring(tag, (i + 1) >> 0);
        if (name$1 === "js") {
          _tuple = strconv.Unquote(qvalue);
          value = _tuple[0];
          return value;
        }
      }
      return "";
    };
    Value.ptr.prototype.Index = function (i) {
      var {
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        a,
        a$1,
        c,
        fl,
        fl$1,
        fl$2,
        i,
        k,
        s,
        str,
        tt,
        tt$1,
        typ,
        typ$1,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            a = [a];
            a$1 = [a$1];
            c = [c];
            i = [i];
            typ = [typ];
            typ$1 = [typ$1];
            v = this;
            k = new flag(v.flag).kind();
            _1 = k;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_1 === (17)) { */ case 2:
            tt = v.typ.kindType;
            if (i[0] < 0 || i[0] > tt.len >> 0) {
              $panic(new $String("reflect: array index out of range"));
            }
            typ[0] = tt.elem;
            fl =
              (((((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0) |
                (typ[0].Kind() >>> 0)) >>>
              0;
            a[0] = v.ptr;
            /* */ if (
              !((fl & 128) >>> 0 === 0) &&
              !(typ[0].Kind() === 17) &&
              !(typ[0].Kind() === 25)
            ) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 7:
            $s = -1;
            return new Value.ptr(
              typ[0],
              new (jsType(PtrTo(typ[0])))(
                (function (a, a$1, c, i, typ, typ$1) {
                  return function () {
                    return wrapJsObject(typ[0], a[0][i[0]]);
                  };
                })(a, a$1, c, i, typ, typ$1),
                (function (a, a$1, c, i, typ, typ$1) {
                  return function (x) {
                    var x;
                    a[0][i[0]] = unwrapJsObject(typ[0], x);
                  };
                })(a, a$1, c, i, typ, typ$1)
              ),
              fl
            );
          /* } */ case 8:
            _r = makeValue(typ[0], wrapJsObject(typ[0], a[0][i[0]]), fl);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 10;
          case 10:
            return $24r;
          /* } else if (_1 === (23)) { */ case 3:
            s = $clone(v, Value).object();
            if (i[0] < 0 || i[0] >= $parseInt(s.$length) >> 0) {
              $panic(new $String("reflect: slice index out of range"));
            }
            tt$1 = v.typ.kindType;
            typ$1[0] = tt$1.elem;
            fl$1 =
              (((384 | new flag(v.flag).ro()) >>> 0) |
                (typ$1[0].Kind() >>> 0)) >>>
              0;
            i[0] = (i[0] + ($parseInt(s.$offset) >> 0)) >> 0;
            a$1[0] = s.$array;
            /* */ if (
              !((fl$1 & 128) >>> 0 === 0) &&
              !(typ$1[0].Kind() === 17) &&
              !(typ$1[0].Kind() === 25)
            ) {
              $s = 11;
              continue;
            }
            /* */ $s = 12;
            continue;
          /* if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { */ case 11:
            $s = -1;
            return new Value.ptr(
              typ$1[0],
              new (jsType(PtrTo(typ$1[0])))(
                (function (a, a$1, c, i, typ, typ$1) {
                  return function () {
                    return wrapJsObject(typ$1[0], a$1[0][i[0]]);
                  };
                })(a, a$1, c, i, typ, typ$1),
                (function (a, a$1, c, i, typ, typ$1) {
                  return function (x) {
                    var x;
                    a$1[0][i[0]] = unwrapJsObject(typ$1[0], x);
                  };
                })(a, a$1, c, i, typ, typ$1)
              ),
              fl$1
            );
          /* } */ case 12:
            _r$1 = makeValue(
              typ$1[0],
              wrapJsObject(typ$1[0], a$1[0][i[0]]),
              fl$1
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$1;
            $s = 14;
          case 14:
            return $24r$1;
          /* } else if (_1 === (24)) { */ case 4:
            str = v.ptr.$get();
            if (i[0] < 0 || i[0] >= str.length) {
              $panic(new $String("reflect: string index out of range"));
            }
            fl$2 = (((new flag(v.flag).ro() | 8) >>> 0) | 128) >>> 0;
            c[0] = str.charCodeAt(i[0]);
            $s = -1;
            return new Value.ptr(
              uint8Type,
              c.$ptr ||
                (c.$ptr = new ptrType$13(
                  function () {
                    return this.$target[0];
                  },
                  function ($v) {
                    this.$target[0] = $v;
                  },
                  c
                )),
              fl$2
            );
          /* } else { */ case 5:
            $panic(new ValueError.ptr("reflect.Value.Index", k));
          /* } */ case 6:
          case 1:
            $s = -1;
            return new Value.ptr(ptrType$1.nil, 0, 0);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Index,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        a,
        a$1,
        c,
        fl,
        fl$1,
        fl$2,
        i,
        k,
        s,
        str,
        tt,
        tt$1,
        typ,
        typ$1,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Index = function (i) {
      return this.$val.Index(i);
    };
    Value.ptr.prototype.InterfaceData = function () {
      var v;
      v = this;
      $panic(errors.New("InterfaceData is not supported by GopherJS"));
    };
    Value.prototype.InterfaceData = function () {
      return this.$val.InterfaceData();
    };
    Value.ptr.prototype.IsNil = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 22 || _1 === 23) {
        return $clone(v, Value).object() === jsType(v.typ).nil;
      } else if (_1 === 18) {
        return $clone(v, Value).object() === $chanNil;
      } else if (_1 === 19) {
        return $clone(v, Value).object() === $throwNilPointerError;
      } else if (_1 === 21) {
        return $clone(v, Value).object() === false;
      } else if (_1 === 20) {
        return $clone(v, Value).object() === $ifaceNil;
      } else if (_1 === 26) {
        return $clone(v, Value).object() === 0;
      } else {
        $panic(new ValueError.ptr("reflect.Value.IsNil", k));
      }
    };
    Value.prototype.IsNil = function () {
      return this.$val.IsNil();
    };
    Value.ptr.prototype.Len = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 17 || _1 === 24) {
        return $parseInt($clone(v, Value).object().length);
      } else if (_1 === 23) {
        return $parseInt($clone(v, Value).object().$length) >> 0;
      } else if (_1 === 18) {
        return $parseInt($clone(v, Value).object().$buffer.length) >> 0;
      } else if (_1 === 21) {
        return $parseInt($clone(v, Value).object().size) >> 0;
      } else {
        $panic(new ValueError.ptr("reflect.Value.Len", k));
      }
    };
    Value.prototype.Len = function () {
      return this.$val.Len();
    };
    Value.ptr.prototype.Pointer = function () {
      var _1, k, v;
      v = this;
      k = new flag(v.flag).kind();
      _1 = k;
      if (_1 === 18 || _1 === 21 || _1 === 22 || _1 === 26) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return $clone(v, Value).object();
      } else if (_1 === 19) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return 1;
      } else if (_1 === 23) {
        if ($clone(v, Value).IsNil()) {
          return 0;
        }
        return $clone(v, Value).object().$array;
      } else {
        $panic(new ValueError.ptr("reflect.Value.Pointer", k));
      }
    };
    Value.prototype.Pointer = function () {
      return this.$val.Pointer();
    };
    Value.ptr.prototype.Set = function (x) {
      var { _1, _r, _r$1, v, x, $s, $r, $c } = $restore(this, { x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBeAssignable();
            new flag(x.flag).mustBeExported();
            _r = $clone(x, Value).assignTo("reflect.Set", v.typ, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            x = _r;
            /* */ if (!((v.flag & 128) >>> 0 === 0)) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!((((v.flag & 128) >>> 0) === 0))) { */ case 2:
            _1 = v.typ.Kind();
            /* */ if (_1 === 17 || _1 === 25) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if ((_1 === (17)) || (_1 === (25))) { */ case 5:
            jsType(v.typ).copy(v.ptr, x.ptr);
            $s = 8;
            continue;
          /* } else if (_1 === (20)) { */ case 6:
            _r$1 = valueInterface($clone(x, Value), false);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            v.ptr.$set(_r$1);
            $s = 8;
            continue;
          /* } else { */ case 7:
            v.ptr.$set($clone(x, Value).object());
          /* } */ case 8:
          case 4:
            $s = -1;
            return;
          /* } */ case 3:
            v.ptr = x.ptr;
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Set,
        $c: true,
        $r,
        _1,
        _r,
        _r$1,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.Set = function (x) {
      return this.$val.Set(x);
    };
    Value.ptr.prototype.SetBytes = function (x) {
      var { _r, _r$1, _v, slice, typedSlice, v, x, $s, $r, $c } = $restore(
        this,
        { x }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            new flag(v.flag).mustBeAssignable();
            new flag(v.flag).mustBe(23);
            _r = v.typ.Elem().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 8)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 8))) { */ case 1:
            $panic(new $String("reflect.Value.SetBytes of non-byte slice"));
          /* } */ case 2:
            slice = x;
            if (!(v.typ.Name() === "")) {
              _v = true;
              $s = 6;
              continue s;
            }
            _r$1 = v.typ.Elem().Name();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = !(_r$1 === "");
          case 6:
            /* */ if (_v) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_v) { */ case 4:
            typedSlice = new (jsType(v.typ))(slice.$array);
            typedSlice.$offset = slice.$offset;
            typedSlice.$length = slice.$length;
            typedSlice.$capacity = slice.$capacity;
            slice = typedSlice;
          /* } */ case 5:
            v.ptr.$set(slice);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.SetBytes,
        $c: true,
        $r,
        _r,
        _r$1,
        _v,
        slice,
        typedSlice,
        v,
        x,
        $s,
      };
      return $f;
    };
    Value.prototype.SetBytes = function (x) {
      return this.$val.SetBytes(x);
    };
    Value.ptr.prototype.SetCap = function (n) {
      var n, newSlice, s, v;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(23);
      s = v.ptr.$get();
      if (n < $parseInt(s.$length) >> 0 || n > $parseInt(s.$capacity) >> 0) {
        $panic(new $String("reflect: slice capacity out of range in SetCap"));
      }
      newSlice = new (jsType(v.typ))(s.$array);
      newSlice.$offset = s.$offset;
      newSlice.$length = s.$length;
      newSlice.$capacity = n;
      v.ptr.$set(newSlice);
    };
    Value.prototype.SetCap = function (n) {
      return this.$val.SetCap(n);
    };
    Value.ptr.prototype.SetLen = function (n) {
      var n, newSlice, s, v;
      v = this;
      new flag(v.flag).mustBeAssignable();
      new flag(v.flag).mustBe(23);
      s = v.ptr.$get();
      if (n < 0 || n > $parseInt(s.$capacity) >> 0) {
        $panic(new $String("reflect: slice length out of range in SetLen"));
      }
      newSlice = new (jsType(v.typ))(s.$array);
      newSlice.$offset = s.$offset;
      newSlice.$length = n;
      newSlice.$capacity = s.$capacity;
      v.ptr.$set(newSlice);
    };
    Value.prototype.SetLen = function (n) {
      return this.$val.SetLen(n);
    };
    Value.ptr.prototype.Slice = function (i, j) {
      var {
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        cap,
        i,
        j,
        kind,
        s,
        str,
        tt,
        typ,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { i, j });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            cap = 0;
            typ = $ifaceNil;
            s = null;
            kind = new flag(v.flag).kind();
            _1 = kind;
            /* */ if (_1 === 17) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 23) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_1 === (17)) { */ case 2:
            if ((v.flag & 256) >>> 0 === 0) {
              $panic(
                new $String("reflect.Value.Slice: slice of unaddressable array")
              );
            }
            tt = v.typ.kindType;
            cap = tt.len >> 0;
            typ = SliceOf(tt.elem);
            s = new (jsType(typ))($clone(v, Value).object());
            $s = 6;
            continue;
          /* } else if (_1 === (23)) { */ case 3:
            typ = v.typ;
            s = $clone(v, Value).object();
            cap = $parseInt(s.$capacity) >> 0;
            $s = 6;
            continue;
          /* } else if (_1 === (24)) { */ case 4:
            str = v.ptr.$get();
            if (i < 0 || j < i || j > str.length) {
              $panic(
                new $String(
                  "reflect.Value.Slice: string slice index out of bounds"
                )
              );
            }
            _r = ValueOf(new $String($substring(str, i, j)));
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 8;
          case 8:
            return $24r;
          /* } else { */ case 5:
            $panic(new ValueError.ptr("reflect.Value.Slice", kind));
          /* } */ case 6:
          case 1:
            if (i < 0 || j < i || j > cap) {
              $panic(
                new $String("reflect.Value.Slice: slice index out of bounds")
              );
            }
            _r$1 = makeValue(typ, $subslice(s, i, j), new flag(v.flag).ro());
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$1;
            $s = 10;
          case 10:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Slice,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _r,
        _r$1,
        cap,
        i,
        j,
        kind,
        s,
        str,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Slice = function (i, j) {
      return this.$val.Slice(i, j);
    };
    Value.ptr.prototype.Slice3 = function (i, j, k) {
      var { $24r, _1, _r, cap, i, j, k, kind, s, tt, typ, v, $s, $r, $c } =
        $restore(this, { i, j, k });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            v = this;
            cap = 0;
            typ = $ifaceNil;
            s = null;
            kind = new flag(v.flag).kind();
            _1 = kind;
            if (_1 === 17) {
              if ((v.flag & 256) >>> 0 === 0) {
                $panic(
                  new $String(
                    "reflect.Value.Slice: slice of unaddressable array"
                  )
                );
              }
              tt = v.typ.kindType;
              cap = tt.len >> 0;
              typ = SliceOf(tt.elem);
              s = new (jsType(typ))($clone(v, Value).object());
            } else if (_1 === 23) {
              typ = v.typ;
              s = $clone(v, Value).object();
              cap = $parseInt(s.$capacity) >> 0;
            } else {
              $panic(new ValueError.ptr("reflect.Value.Slice3", kind));
            }
            if (i < 0 || j < i || k < j || k > cap) {
              $panic(
                new $String("reflect.Value.Slice3: slice index out of bounds")
              );
            }
            _r = makeValue(typ, $subslice(s, i, j, k), new flag(v.flag).ro());
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Value.ptr.prototype.Slice3,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        cap,
        i,
        j,
        k,
        kind,
        s,
        tt,
        typ,
        v,
        $s,
      };
      return $f;
    };
    Value.prototype.Slice3 = function (i, j, k) {
      return this.$val.Slice3(i, j, k);
    };
    Value.ptr.prototype.Close = function () {
      var v;
      v = this;
      new flag(v.flag).mustBe(18);
      new flag(v.flag).mustBeExported();
      $close($clone(v, Value).object());
    };
    Value.prototype.Close = function () {
      return this.$val.Close();
    };
    chanrecv = function (ch, nb, val) {
      var {
        _r,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        ch,
        comms,
        nb,
        received,
        recvRes,
        selectRes,
        selected,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { ch, nb, val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            selected = false;
            received = false;
            comms = new sliceType$18([new sliceType$16([ch])]);
            if (nb) {
              comms = $append(comms, new sliceType$16([]));
            }
            _r = selectHelper(new sliceType$4([comms]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            selectRes = _r;
            if (nb && $parseInt(selectRes[0]) >> 0 === 1) {
              _tmp = false;
              _tmp$1 = false;
              selected = _tmp;
              received = _tmp$1;
              $s = -1;
              return [selected, received];
            }
            recvRes = selectRes[1];
            val.$set(recvRes[0]);
            _tmp$2 = true;
            _tmp$3 = !!recvRes[1];
            selected = _tmp$2;
            received = _tmp$3;
            $s = -1;
            return [selected, received];
          /* */
        }
        return;
      }
      var $f = {
        $blk: chanrecv,
        $c: true,
        $r,
        _r,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        ch,
        comms,
        nb,
        received,
        recvRes,
        selectRes,
        selected,
        val,
        $s,
      };
      return $f;
    };
    chansend = function (ch, val, nb) {
      var { _r, ch, comms, nb, selectRes, val, $s, $r, $c } = $restore(this, {
        ch,
        val,
        nb,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            comms = new sliceType$18([new sliceType$16([ch, val.$get()])]);
            if (nb) {
              comms = $append(comms, new sliceType$16([]));
            }
            _r = selectHelper(new sliceType$4([comms]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            selectRes = _r;
            if (nb && $parseInt(selectRes[0]) >> 0 === 1) {
              $s = -1;
              return false;
            }
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = {
        $blk: chansend,
        $c: true,
        $r,
        _r,
        ch,
        comms,
        nb,
        selectRes,
        val,
        $s,
      };
      return $f;
    };
    methodNameSkip = function () {
      var _tuple, f, idx, name$1, pc;
      _tuple = runtime.Caller(3);
      pc = _tuple[0];
      f = runtime.FuncForPC(pc);
      if (f === ptrType$4.nil) {
        return "unknown method";
      }
      name$1 = f.Name();
      idx = (name$1.length - 1) >> 0;
      while (true) {
        if (!(idx > 0)) {
          break;
        }
        if (name$1.charCodeAt(idx) === 46) {
          break;
        }
        idx = (idx - 1) >> 0;
      }
      if (idx < 0) {
        return name$1;
      }
      return "Value" + $substring(name$1, idx);
    };
    verifyNotInHeapPtr = function (p) {
      var p;
      return true;
    };
    Value.methods = [
      {
        prop: "pointer",
        name: "pointer",
        pkg: "reflect",
        typ: $funcType([], [$UnsafePointer], false),
      },
      {
        prop: "Addr",
        name: "Addr",
        pkg: "",
        typ: $funcType([], [Value], false),
      },
      {
        prop: "Bool",
        name: "Bool",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Bytes",
        name: "Bytes",
        pkg: "",
        typ: $funcType([], [sliceType$9], false),
      },
      {
        prop: "runes",
        name: "runes",
        pkg: "reflect",
        typ: $funcType([], [sliceType$10], false),
      },
      {
        prop: "CanAddr",
        name: "CanAddr",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "CanSet",
        name: "CanSet",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Call",
        name: "Call",
        pkg: "",
        typ: $funcType([sliceType$7], [sliceType$7], false),
      },
      {
        prop: "CallSlice",
        name: "CallSlice",
        pkg: "",
        typ: $funcType([sliceType$7], [sliceType$7], false),
      },
      {
        prop: "CanComplex",
        name: "CanComplex",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Complex",
        name: "Complex",
        pkg: "",
        typ: $funcType([], [$Complex128], false),
      },
      {
        prop: "FieldByIndex",
        name: "FieldByIndex",
        pkg: "",
        typ: $funcType([sliceType$6], [Value], false),
      },
      {
        prop: "FieldByIndexErr",
        name: "FieldByIndexErr",
        pkg: "",
        typ: $funcType([sliceType$6], [Value, $error], false),
      },
      {
        prop: "FieldByName",
        name: "FieldByName",
        pkg: "",
        typ: $funcType([$String], [Value], false),
      },
      {
        prop: "FieldByNameFunc",
        name: "FieldByNameFunc",
        pkg: "",
        typ: $funcType([funcType$3], [Value], false),
      },
      {
        prop: "CanFloat",
        name: "CanFloat",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Float",
        name: "Float",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "CanInt",
        name: "CanInt",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Int",
        name: "Int",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "CanInterface",
        name: "CanInterface",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Interface",
        name: "Interface",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
      {
        prop: "IsValid",
        name: "IsValid",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsZero",
        name: "IsZero",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "MapIndex",
        name: "MapIndex",
        pkg: "",
        typ: $funcType([Value], [Value], false),
      },
      {
        prop: "MapKeys",
        name: "MapKeys",
        pkg: "",
        typ: $funcType([], [sliceType$7], false),
      },
      {
        prop: "SetIterKey",
        name: "SetIterKey",
        pkg: "",
        typ: $funcType([ptrType$22], [], false),
      },
      {
        prop: "SetIterValue",
        name: "SetIterValue",
        pkg: "",
        typ: $funcType([ptrType$22], [], false),
      },
      {
        prop: "MapRange",
        name: "MapRange",
        pkg: "",
        typ: $funcType([], [ptrType$22], false),
      },
      {
        prop: "Method",
        name: "Method",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "MethodByName",
        name: "MethodByName",
        pkg: "",
        typ: $funcType([$String], [Value], false),
      },
      {
        prop: "NumField",
        name: "NumField",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "OverflowComplex",
        name: "OverflowComplex",
        pkg: "",
        typ: $funcType([$Complex128], [$Bool], false),
      },
      {
        prop: "OverflowFloat",
        name: "OverflowFloat",
        pkg: "",
        typ: $funcType([$Float64], [$Bool], false),
      },
      {
        prop: "OverflowInt",
        name: "OverflowInt",
        pkg: "",
        typ: $funcType([$Int64], [$Bool], false),
      },
      {
        prop: "OverflowUint",
        name: "OverflowUint",
        pkg: "",
        typ: $funcType([$Uint64], [$Bool], false),
      },
      {
        prop: "Recv",
        name: "Recv",
        pkg: "",
        typ: $funcType([], [Value, $Bool], false),
      },
      {
        prop: "recv",
        name: "recv",
        pkg: "reflect",
        typ: $funcType([$Bool], [Value, $Bool], false),
      },
      {
        prop: "Send",
        name: "Send",
        pkg: "",
        typ: $funcType([Value], [], false),
      },
      {
        prop: "send",
        name: "send",
        pkg: "reflect",
        typ: $funcType([Value, $Bool], [$Bool], false),
      },
      {
        prop: "SetBool",
        name: "SetBool",
        pkg: "",
        typ: $funcType([$Bool], [], false),
      },
      {
        prop: "setRunes",
        name: "setRunes",
        pkg: "reflect",
        typ: $funcType([sliceType$10], [], false),
      },
      {
        prop: "SetComplex",
        name: "SetComplex",
        pkg: "",
        typ: $funcType([$Complex128], [], false),
      },
      {
        prop: "SetFloat",
        name: "SetFloat",
        pkg: "",
        typ: $funcType([$Float64], [], false),
      },
      {
        prop: "SetInt",
        name: "SetInt",
        pkg: "",
        typ: $funcType([$Int64], [], false),
      },
      {
        prop: "SetMapIndex",
        name: "SetMapIndex",
        pkg: "",
        typ: $funcType([Value, Value], [], false),
      },
      {
        prop: "SetUint",
        name: "SetUint",
        pkg: "",
        typ: $funcType([$Uint64], [], false),
      },
      {
        prop: "SetPointer",
        name: "SetPointer",
        pkg: "",
        typ: $funcType([$UnsafePointer], [], false),
      },
      {
        prop: "SetString",
        name: "SetString",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "TryRecv",
        name: "TryRecv",
        pkg: "",
        typ: $funcType([], [Value, $Bool], false),
      },
      {
        prop: "TrySend",
        name: "TrySend",
        pkg: "",
        typ: $funcType([Value], [$Bool], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "CanUint",
        name: "CanUint",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Uint",
        name: "Uint",
        pkg: "",
        typ: $funcType([], [$Uint64], false),
      },
      {
        prop: "UnsafeAddr",
        name: "UnsafeAddr",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "UnsafePointer",
        name: "UnsafePointer",
        pkg: "",
        typ: $funcType([], [$UnsafePointer], false),
      },
      {
        prop: "Convert",
        name: "Convert",
        pkg: "",
        typ: $funcType([Type], [Value], false),
      },
      {
        prop: "CanConvert",
        name: "CanConvert",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "object",
        name: "object",
        pkg: "reflect",
        typ: $funcType([], [ptrType$2], false),
      },
      {
        prop: "assignTo",
        name: "assignTo",
        pkg: "reflect",
        typ: $funcType([$String, ptrType$1, $UnsafePointer], [Value], false),
      },
      {
        prop: "call",
        name: "call",
        pkg: "reflect",
        typ: $funcType([$String, sliceType$7], [sliceType$7], false),
      },
      { prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Value], false),
      },
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
      {
        prop: "Index",
        name: "Index",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
      {
        prop: "InterfaceData",
        name: "InterfaceData",
        pkg: "",
        typ: $funcType([], [arrayType$7], false),
      },
      {
        prop: "IsNil",
        name: "IsNil",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Pointer",
        name: "Pointer",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      { prop: "Set", name: "Set", pkg: "", typ: $funcType([Value], [], false) },
      {
        prop: "SetBytes",
        name: "SetBytes",
        pkg: "",
        typ: $funcType([sliceType$9], [], false),
      },
      {
        prop: "SetCap",
        name: "SetCap",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "SetLen",
        name: "SetLen",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "Slice",
        name: "Slice",
        pkg: "",
        typ: $funcType([$Int, $Int], [Value], false),
      },
      {
        prop: "Slice3",
        name: "Slice3",
        pkg: "",
        typ: $funcType([$Int, $Int, $Int], [Value], false),
      },
      { prop: "Close", name: "Close", pkg: "", typ: $funcType([], [], false) },
    ];
    flag.methods = [
      {
        prop: "kind",
        name: "kind",
        pkg: "reflect",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "ro",
        name: "ro",
        pkg: "reflect",
        typ: $funcType([], [flag], false),
      },
      {
        prop: "mustBe",
        name: "mustBe",
        pkg: "reflect",
        typ: $funcType([Kind], [], false),
      },
      {
        prop: "mustBeExported",
        name: "mustBeExported",
        pkg: "reflect",
        typ: $funcType([], [], false),
      },
      {
        prop: "mustBeExportedSlow",
        name: "mustBeExportedSlow",
        pkg: "reflect",
        typ: $funcType([], [], false),
      },
      {
        prop: "mustBeAssignable",
        name: "mustBeAssignable",
        pkg: "reflect",
        typ: $funcType([], [], false),
      },
      {
        prop: "mustBeAssignableSlow",
        name: "mustBeAssignableSlow",
        pkg: "reflect",
        typ: $funcType([], [], false),
      },
    ];
    ptrType$23.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$22.methods = [
      { prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Value], false) },
      {
        prop: "Value",
        name: "Value",
        pkg: "",
        typ: $funcType([], [Value], false),
      },
      {
        prop: "Next",
        name: "Next",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Reset",
        name: "Reset",
        pkg: "",
        typ: $funcType([Value], [], false),
      },
    ];
    Kind.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "textOff",
        name: "textOff",
        pkg: "reflect",
        typ: $funcType([textOff], [$UnsafePointer], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "Bits",
        name: "Bits",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Align",
        name: "Align",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "FieldAlign",
        name: "FieldAlign",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      {
        prop: "common",
        name: "common",
        pkg: "reflect",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "exportedMethods",
        name: "exportedMethods",
        pkg: "reflect",
        typ: $funcType([], [sliceType$11], false),
      },
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "MethodByName",
        name: "MethodByName",
        pkg: "",
        typ: $funcType([$String], [Method, $Bool], false),
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "hasName",
        name: "hasName",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "ChanDir",
        name: "ChanDir",
        pkg: "",
        typ: $funcType([], [ChanDir], false),
      },
      {
        prop: "IsVariadic",
        name: "IsVariadic",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [StructField], false),
      },
      {
        prop: "FieldByIndex",
        name: "FieldByIndex",
        pkg: "",
        typ: $funcType([sliceType$6], [StructField], false),
      },
      {
        prop: "FieldByName",
        name: "FieldByName",
        pkg: "",
        typ: $funcType([$String], [StructField, $Bool], false),
      },
      {
        prop: "FieldByNameFunc",
        name: "FieldByNameFunc",
        pkg: "",
        typ: $funcType([funcType$3], [StructField, $Bool], false),
      },
      {
        prop: "In",
        name: "In",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      { prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false) },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "NumField",
        name: "NumField",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumIn",
        name: "NumIn",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumOut",
        name: "NumOut",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Out",
        name: "Out",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      {
        prop: "Implements",
        name: "Implements",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "AssignableTo",
        name: "AssignableTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "ConvertibleTo",
        name: "ConvertibleTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "gcSlice",
        name: "gcSlice",
        pkg: "reflect",
        typ: $funcType([$Uintptr, $Uintptr], [sliceType$9], false),
      },
      {
        prop: "uncommon",
        name: "uncommon",
        pkg: "reflect",
        typ: $funcType([], [ptrType$9], false),
      },
      {
        prop: "nameOff",
        name: "nameOff",
        pkg: "reflect",
        typ: $funcType([nameOff], [name], false),
      },
      {
        prop: "typeOff",
        name: "typeOff",
        pkg: "reflect",
        typ: $funcType([typeOff], [ptrType$1], false),
      },
      {
        prop: "ptrTo",
        name: "ptrTo",
        pkg: "reflect",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "pointers",
        name: "pointers",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Comparable",
        name: "Comparable",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Method",
        name: "Method",
        pkg: "",
        typ: $funcType([$Int], [Method], false),
      },
    ];
    ChanDir.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$10.methods = [
      {
        prop: "Method",
        name: "Method",
        pkg: "",
        typ: $funcType([$Int], [Method], false),
      },
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "MethodByName",
        name: "MethodByName",
        pkg: "",
        typ: $funcType([$String], [Method, $Bool], false),
      },
    ];
    ptrType$25.methods = [
      {
        prop: "offset",
        name: "offset",
        pkg: "reflect",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "embedded",
        name: "embedded",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$12.methods = [
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [StructField], false),
      },
      {
        prop: "FieldByIndex",
        name: "FieldByIndex",
        pkg: "",
        typ: $funcType([sliceType$6], [StructField], false),
      },
      {
        prop: "FieldByNameFunc",
        name: "FieldByNameFunc",
        pkg: "",
        typ: $funcType([funcType$3], [StructField, $Bool], false),
      },
      {
        prop: "FieldByName",
        name: "FieldByName",
        pkg: "",
        typ: $funcType([$String], [StructField, $Bool], false),
      },
    ];
    Method.methods = [
      {
        prop: "IsExported",
        name: "IsExported",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    StructField.methods = [
      {
        prop: "IsExported",
        name: "IsExported",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    StructTag.methods = [
      {
        prop: "Get",
        name: "Get",
        pkg: "",
        typ: $funcType([$String], [$String], false),
      },
      {
        prop: "Lookup",
        name: "Lookup",
        pkg: "",
        typ: $funcType([$String], [$String, $Bool], false),
      },
    ];
    ptrType$9.methods = [
      {
        prop: "methods",
        name: "methods",
        pkg: "reflect",
        typ: $funcType([], [sliceType$11], false),
      },
      {
        prop: "exportedMethods",
        name: "exportedMethods",
        pkg: "reflect",
        typ: $funcType([], [sliceType$11], false),
      },
    ];
    ptrType$19.methods = [
      {
        prop: "in$",
        name: "in",
        pkg: "reflect",
        typ: $funcType([], [sliceType$2], false),
      },
      {
        prop: "out",
        name: "out",
        pkg: "reflect",
        typ: $funcType([], [sliceType$2], false),
      },
    ];
    name.methods = [
      {
        prop: "data",
        name: "data",
        pkg: "reflect",
        typ: $funcType([$Int, $String], [ptrType$13], false),
      },
      {
        prop: "hasTag",
        name: "hasTag",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "readVarint",
        name: "readVarint",
        pkg: "reflect",
        typ: $funcType([$Int], [$Int, $Int], false),
      },
      {
        prop: "name",
        name: "name",
        pkg: "reflect",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "tag",
        name: "tag",
        pkg: "reflect",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        pkg: "reflect",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "isExported",
        name: "isExported",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$26.methods = [
      {
        prop: "initialized",
        name: "initialized",
        pkg: "reflect",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "skipUntilValidKey",
        name: "skipUntilValidKey",
        pkg: "reflect",
        typ: $funcType([], [], false),
      },
    ];
    Value.init("reflect", [
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "ptr",
        name: "ptr",
        embedded: false,
        exported: false,
        typ: $UnsafePointer,
        tag: "",
      },
      {
        prop: "flag",
        name: "flag",
        embedded: true,
        exported: false,
        typ: flag,
        tag: "",
      },
    ]);
    ValueError.init("", [
      {
        prop: "Method",
        name: "Method",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Kind",
        name: "Kind",
        embedded: false,
        exported: true,
        typ: Kind,
        tag: "",
      },
    ]);
    MapIter.init("reflect", [
      {
        prop: "m",
        name: "m",
        embedded: false,
        exported: false,
        typ: Value,
        tag: "",
      },
      {
        prop: "hiter",
        name: "hiter",
        embedded: false,
        exported: false,
        typ: hiter,
        tag: "",
      },
    ]);
    Type.init([
      {
        prop: "Align",
        name: "Align",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "AssignableTo",
        name: "AssignableTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Bits",
        name: "Bits",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "ChanDir",
        name: "ChanDir",
        pkg: "",
        typ: $funcType([], [ChanDir], false),
      },
      {
        prop: "Comparable",
        name: "Comparable",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "ConvertibleTo",
        name: "ConvertibleTo",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "Elem",
        name: "Elem",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "Field",
        name: "Field",
        pkg: "",
        typ: $funcType([$Int], [StructField], false),
      },
      {
        prop: "FieldAlign",
        name: "FieldAlign",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "FieldByIndex",
        name: "FieldByIndex",
        pkg: "",
        typ: $funcType([sliceType$6], [StructField], false),
      },
      {
        prop: "FieldByName",
        name: "FieldByName",
        pkg: "",
        typ: $funcType([$String], [StructField, $Bool], false),
      },
      {
        prop: "FieldByNameFunc",
        name: "FieldByNameFunc",
        pkg: "",
        typ: $funcType([funcType$3], [StructField, $Bool], false),
      },
      {
        prop: "Implements",
        name: "Implements",
        pkg: "",
        typ: $funcType([Type], [$Bool], false),
      },
      {
        prop: "In",
        name: "In",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      {
        prop: "IsVariadic",
        name: "IsVariadic",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      { prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false) },
      {
        prop: "Kind",
        name: "Kind",
        pkg: "",
        typ: $funcType([], [Kind], false),
      },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Method",
        name: "Method",
        pkg: "",
        typ: $funcType([$Int], [Method], false),
      },
      {
        prop: "MethodByName",
        name: "MethodByName",
        pkg: "",
        typ: $funcType([$String], [Method, $Bool], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "NumField",
        name: "NumField",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumIn",
        name: "NumIn",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumMethod",
        name: "NumMethod",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "NumOut",
        name: "NumOut",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Out",
        name: "Out",
        pkg: "",
        typ: $funcType([$Int], [Type], false),
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "common",
        name: "common",
        pkg: "reflect",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "uncommon",
        name: "uncommon",
        pkg: "reflect",
        typ: $funcType([], [ptrType$9], false),
      },
    ]);
    rtype.init("reflect", [
      {
        prop: "size",
        name: "size",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "ptrdata",
        name: "ptrdata",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "hash",
        name: "hash",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "tflag",
        name: "tflag",
        embedded: false,
        exported: false,
        typ: tflag,
        tag: "",
      },
      {
        prop: "align",
        name: "align",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "fieldAlign",
        name: "fieldAlign",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "kind",
        name: "kind",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "equal",
        name: "equal",
        embedded: false,
        exported: false,
        typ: funcType$4,
        tag: "",
      },
      {
        prop: "gcdata",
        name: "gcdata",
        embedded: false,
        exported: false,
        typ: ptrType$13,
        tag: "",
      },
      {
        prop: "str",
        name: "str",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "ptrToThis",
        name: "ptrToThis",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
    ]);
    method.init("reflect", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "mtyp",
        name: "mtyp",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
      {
        prop: "ifn",
        name: "ifn",
        embedded: false,
        exported: false,
        typ: textOff,
        tag: "",
      },
      {
        prop: "tfn",
        name: "tfn",
        embedded: false,
        exported: false,
        typ: textOff,
        tag: "",
      },
    ]);
    arrayType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "slice",
        name: "slice",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "len",
        name: "len",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    chanType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "dir",
        name: "dir",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    imethod.init("reflect", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: typeOff,
        tag: "",
      },
    ]);
    interfaceType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "methods",
        name: "methods",
        embedded: false,
        exported: false,
        typ: sliceType$14,
        tag: "",
      },
    ]);
    mapType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "key",
        name: "key",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "bucket",
        name: "bucket",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "hasher",
        name: "hasher",
        embedded: false,
        exported: false,
        typ: funcType$5,
        tag: "",
      },
      {
        prop: "keysize",
        name: "keysize",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "valuesize",
        name: "valuesize",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "bucketsize",
        name: "bucketsize",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "flags",
        name: "flags",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
    ]);
    ptrType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
    ]);
    sliceType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "elem",
        name: "elem",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
    ]);
    structField.init("reflect", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "offsetEmbed",
        name: "offsetEmbed",
        embedded: false,
        exported: false,
        typ: $Uintptr,
        tag: "",
      },
    ]);
    structType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: "",
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: name,
        tag: "",
      },
      {
        prop: "fields",
        name: "fields",
        embedded: false,
        exported: false,
        typ: sliceType$15,
        tag: "",
      },
    ]);
    Method.init("", [
      {
        prop: "Name",
        name: "Name",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Type",
        name: "Type",
        embedded: false,
        exported: true,
        typ: Type,
        tag: "",
      },
      {
        prop: "Func",
        name: "Func",
        embedded: false,
        exported: true,
        typ: Value,
        tag: "",
      },
      {
        prop: "Index",
        name: "Index",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    StructField.init("", [
      {
        prop: "Name",
        name: "Name",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "PkgPath",
        name: "PkgPath",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Type",
        name: "Type",
        embedded: false,
        exported: true,
        typ: Type,
        tag: "",
      },
      {
        prop: "Tag",
        name: "Tag",
        embedded: false,
        exported: true,
        typ: StructTag,
        tag: "",
      },
      {
        prop: "Offset",
        name: "Offset",
        embedded: false,
        exported: true,
        typ: $Uintptr,
        tag: "",
      },
      {
        prop: "Index",
        name: "Index",
        embedded: false,
        exported: true,
        typ: sliceType$6,
        tag: "",
      },
      {
        prop: "Anonymous",
        name: "Anonymous",
        embedded: false,
        exported: true,
        typ: $Bool,
        tag: "",
      },
    ]);
    fieldScan.init("reflect", [
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: ptrType$12,
        tag: "",
      },
      {
        prop: "index",
        name: "index",
        embedded: false,
        exported: false,
        typ: sliceType$6,
        tag: "",
      },
    ]);
    uncommonType.init("reflect", [
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: nameOff,
        tag: "",
      },
      {
        prop: "mcount",
        name: "mcount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "xcount",
        name: "xcount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "moff",
        name: "moff",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "_methods",
        name: "_methods",
        embedded: false,
        exported: false,
        typ: sliceType$11,
        tag: "",
      },
    ]);
    funcType.init("reflect", [
      {
        prop: "rtype",
        name: "rtype",
        embedded: true,
        exported: false,
        typ: rtype,
        tag: 'reflect:"func"',
      },
      {
        prop: "inCount",
        name: "inCount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "outCount",
        name: "outCount",
        embedded: false,
        exported: false,
        typ: $Uint16,
        tag: "",
      },
      {
        prop: "_in",
        name: "_in",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
      {
        prop: "_out",
        name: "_out",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
    ]);
    name.init("reflect", [
      {
        prop: "bytes",
        name: "bytes",
        embedded: false,
        exported: false,
        typ: ptrType$13,
        tag: "",
      },
    ]);
    nameData.init("reflect", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "tag",
        name: "tag",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "exported",
        name: "exported",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "pkgPath",
        name: "pkgPath",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    hiter.init("reflect", [
      {
        prop: "t",
        name: "t",
        embedded: false,
        exported: false,
        typ: Type,
        tag: "",
      },
      {
        prop: "m",
        name: "m",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
      {
        prop: "keys",
        name: "keys",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
      {
        prop: "i",
        name: "i",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "last",
        name: "last",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = abi.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bytealg.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = goarch.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = goexperiment.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = itoa.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unsafeheader.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = math.$init();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strconv.$init();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unicode.$init();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            nameOffList = sliceType$1.nil;
            typeOffList = sliceType$2.nil;
            kindNames = new sliceType$3([
              "invalid",
              "bool",
              "int",
              "int8",
              "int16",
              "int32",
              "int64",
              "uint",
              "uint8",
              "uint16",
              "uint32",
              "uint64",
              "uintptr",
              "float32",
              "float64",
              "complex64",
              "complex128",
              "array",
              "chan",
              "func",
              "interface",
              "map",
              "ptr",
              "slice",
              "string",
              "struct",
              "unsafe.Pointer",
            ]);
            initialized = false;
            nameMap = new $global.Map();
            uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
            callHelper = $assertType(
              $internalize($call, $emptyInterface),
              funcType$1
            );
            jsObjectPtr = reflectType($jsObjectPtr);
            selectHelper = $assertType(
              $internalize($select, $emptyInterface),
              funcType$1
            );
            $r = init();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["sort"] = (function () {
    var $pkg = {},
      $init,
      reflectlite,
      insertionSort,
      swapRange,
      Stable,
      stable,
      symMerge,
      rotate,
      Search;
    reflectlite = $packages["internal/reflectlite"];
    insertionSort = function (data, a, b) {
      var { _r, _v, a, b, data, i, j, $s, $r, $c } = $restore(this, {
        data,
        a,
        b,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            i = (a + 1) >> 0;
          /* while (true) { */ case 1:
            /* if (!(i < b)) { break; } */ if (!(i < b)) {
              $s = 2;
              continue;
            }
            j = i;
          /* while (true) { */ case 3:
            if (!(j > a)) {
              _v = false;
              $s = 5;
              continue s;
            }
            _r = data.Less(j, (j - 1) >> 0);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 5:
            /* if (!(_v)) { break; } */ if (!_v) {
              $s = 4;
              continue;
            }
            $r = data.Swap(j, (j - 1) >> 0);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            j = (j - 1) >> 0;
            $s = 3;
            continue;
          case 4:
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: insertionSort,
        $c: true,
        $r,
        _r,
        _v,
        a,
        b,
        data,
        i,
        j,
        $s,
      };
      return $f;
    };
    swapRange = function (data, a, b, n) {
      var { a, b, data, i, n, $s, $r, $c } = $restore(this, { data, a, b, n });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < n)) { break; } */ if (!(i < n)) {
              $s = 2;
              continue;
            }
            $r = data.Swap((a + i) >> 0, (b + i) >> 0);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: swapRange, $c: true, $r, a, b, data, i, n, $s };
      return $f;
    };
    Stable = function (data) {
      var { _arg, _arg$1, _r, data, $s, $r, $c } = $restore(this, { data });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _arg = data;
            _r = data.Len();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r;
            $r = stable(_arg, _arg$1);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: Stable, $c: true, $r, _arg, _arg$1, _r, data, $s };
      return $f;
    };
    $pkg.Stable = Stable;
    stable = function (data, n) {
      var {
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        a,
        b,
        blockSize,
        data,
        m,
        n,
        $s,
        $r,
        $c,
      } = $restore(this, { data, n });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            blockSize = 20;
            _tmp = 0;
            _tmp$1 = blockSize;
            a = _tmp;
            b = _tmp$1;
          /* while (true) { */ case 1:
            /* if (!(b <= n)) { break; } */ if (!(b <= n)) {
              $s = 2;
              continue;
            }
            $r = insertionSort(data, a, b);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            a = b;
            b = (b + blockSize) >> 0;
            $s = 1;
            continue;
          case 2:
            $r = insertionSort(data, a, n);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* while (true) { */ case 5:
            /* if (!(blockSize < n)) { break; } */ if (!(blockSize < n)) {
              $s = 6;
              continue;
            }
            _tmp$2 = 0;
            _tmp$3 = $imul(2, blockSize);
            a = _tmp$2;
            b = _tmp$3;
          /* while (true) { */ case 7:
            /* if (!(b <= n)) { break; } */ if (!(b <= n)) {
              $s = 8;
              continue;
            }
            $r = symMerge(data, a, (a + blockSize) >> 0, b);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            a = b;
            b = (b + $imul(2, blockSize)) >> 0;
            $s = 7;
            continue;
          case 8:
            m = (a + blockSize) >> 0;
            /* */ if (m < n) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (m < n) { */ case 10:
            $r = symMerge(data, a, m, n);
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 11:
            blockSize = $imul(blockSize, 2);
            $s = 5;
            continue;
          case 6:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: stable,
        $c: true,
        $r,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        a,
        b,
        blockSize,
        data,
        m,
        n,
        $s,
      };
      return $f;
    };
    symMerge = function (data, a, m, b) {
      var {
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        a,
        b,
        c,
        data,
        end,
        h,
        h$1,
        i,
        i$1,
        j,
        j$1,
        k,
        k$1,
        m,
        mid,
        n,
        p,
        r,
        start,
        $s,
        $r,
        $c,
      } = $restore(this, { data, a, m, b });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            /* */ if ((m - a) >> 0 === 1) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ((m - a >> 0) === 1) { */ case 1:
            i = m;
            j = b;
          /* while (true) { */ case 3:
            /* if (!(i < j)) { break; } */ if (!(i < j)) {
              $s = 4;
              continue;
            }
            h = (((((i + j) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
            _r = data.Less(h, a);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (_r) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (_r) { */ case 5:
            i = (h + 1) >> 0;
            $s = 7;
            continue;
          /* } else { */ case 6:
            j = h;
          /* } */ case 7:
            $s = 3;
            continue;
          case 4:
            k = a;
          /* while (true) { */ case 9:
            /* if (!(k < (i - 1 >> 0))) { break; } */ if (!(k < (i - 1) >> 0)) {
              $s = 10;
              continue;
            }
            $r = data.Swap(k, (k + 1) >> 0);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            k = (k + 1) >> 0;
            $s = 9;
            continue;
          case 10:
            $s = -1;
            return;
          /* } */ case 2:
            /* */ if ((b - m) >> 0 === 1) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if ((b - m >> 0) === 1) { */ case 12:
            i$1 = a;
            j$1 = m;
          /* while (true) { */ case 14:
            /* if (!(i$1 < j$1)) { break; } */ if (!(i$1 < j$1)) {
              $s = 15;
              continue;
            }
            h$1 = (((((i$1 + j$1) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
            _r$1 = data.Less(m, h$1);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$1) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (!_r$1) { */ case 16:
            i$1 = (h$1 + 1) >> 0;
            $s = 18;
            continue;
          /* } else { */ case 17:
            j$1 = h$1;
          /* } */ case 18:
            $s = 14;
            continue;
          case 15:
            k$1 = m;
          /* while (true) { */ case 20:
            /* if (!(k$1 > i$1)) { break; } */ if (!(k$1 > i$1)) {
              $s = 21;
              continue;
            }
            $r = data.Swap(k$1, (k$1 - 1) >> 0);
            /* */ $s = 22;
          case 22:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            k$1 = (k$1 - 1) >> 0;
            $s = 20;
            continue;
          case 21:
            $s = -1;
            return;
          /* } */ case 13:
            mid = (((((a + b) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
            n = (mid + m) >> 0;
            _tmp = 0;
            _tmp$1 = 0;
            start = _tmp;
            r = _tmp$1;
            if (m > mid) {
              start = (n - b) >> 0;
              r = mid;
            } else {
              start = a;
              r = m;
            }
            p = (n - 1) >> 0;
          /* while (true) { */ case 23:
            /* if (!(start < r)) { break; } */ if (!(start < r)) {
              $s = 24;
              continue;
            }
            c = (((((start + r) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
            _r$2 = data.Less((p - c) >> 0, c);
            /* */ $s = 28;
          case 28:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$2) {
              $s = 25;
              continue;
            }
            /* */ $s = 26;
            continue;
          /* if (!_r$2) { */ case 25:
            start = (c + 1) >> 0;
            $s = 27;
            continue;
          /* } else { */ case 26:
            r = c;
          /* } */ case 27:
            $s = 23;
            continue;
          case 24:
            end = (n - start) >> 0;
            /* */ if (start < m && m < end) {
              $s = 29;
              continue;
            }
            /* */ $s = 30;
            continue;
          /* if (start < m && m < end) { */ case 29:
            $r = rotate(data, start, m, end);
            /* */ $s = 31;
          case 31:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 30:
            /* */ if (a < start && start < mid) {
              $s = 32;
              continue;
            }
            /* */ $s = 33;
            continue;
          /* if (a < start && start < mid) { */ case 32:
            $r = symMerge(data, a, start, mid);
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 33:
            /* */ if (mid < end && end < b) {
              $s = 35;
              continue;
            }
            /* */ $s = 36;
            continue;
          /* if (mid < end && end < b) { */ case 35:
            $r = symMerge(data, mid, end, b);
            /* */ $s = 37;
          case 37:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 36:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: symMerge,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        a,
        b,
        c,
        data,
        end,
        h,
        h$1,
        i,
        i$1,
        j,
        j$1,
        k,
        k$1,
        m,
        mid,
        n,
        p,
        r,
        start,
        $s,
      };
      return $f;
    };
    rotate = function (data, a, m, b) {
      var { a, b, data, i, j, m, $s, $r, $c } = $restore(this, {
        data,
        a,
        m,
        b,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            i = (m - a) >> 0;
            j = (b - m) >> 0;
          /* while (true) { */ case 1:
            /* if (!(!((i === j)))) { break; } */ if (!!(i === j)) {
              $s = 2;
              continue;
            }
            /* */ if (i > j) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (i > j) { */ case 3:
            $r = swapRange(data, (m - i) >> 0, m, j);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i = (i - j) >> 0;
            $s = 5;
            continue;
          /* } else { */ case 4:
            $r = swapRange(data, (m - i) >> 0, (((m + j) >> 0) - i) >> 0, i);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            j = (j - i) >> 0;
          /* } */ case 5:
            $s = 1;
            continue;
          case 2:
            $r = swapRange(data, (m - i) >> 0, m, i);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: rotate, $c: true, $r, a, b, data, i, j, m, $s };
      return $f;
    };
    Search = function (n, f) {
      var { _r, _tmp, _tmp$1, f, h, i, j, n, $s, $r, $c } = $restore(this, {
        n,
        f,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tmp = 0;
            _tmp$1 = n;
            i = _tmp;
            j = _tmp$1;
          /* while (true) { */ case 1:
            /* if (!(i < j)) { break; } */ if (!(i < j)) {
              $s = 2;
              continue;
            }
            h = (((((i + j) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
            _r = f(h);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!_r) { */ case 3:
            i = (h + 1) >> 0;
            $s = 5;
            continue;
          /* } else { */ case 4:
            j = h;
          /* } */ case 5:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return i;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Search,
        $c: true,
        $r,
        _r,
        _tmp,
        _tmp$1,
        f,
        h,
        i,
        j,
        n,
        $s,
      };
      return $f;
    };
    $pkg.Search = Search;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = reflectlite.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/fmtsort"] = (function () {
    var $pkg = {},
      $init,
      reflect,
      sort,
      SortedMap,
      ptrType,
      sliceType,
      Sort,
      compare,
      nilCompare,
      floatCompare,
      isNaN;
    reflect = $packages["reflect"];
    sort = $packages["sort"];
    SortedMap = $pkg.SortedMap = $newType(
      0,
      $kindStruct,
      "fmtsort.SortedMap",
      true,
      "internal/fmtsort",
      true,
      function (Key_, Value_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Key = sliceType.nil;
          this.Value = sliceType.nil;
          return;
        }
        this.Key = Key_;
        this.Value = Value_;
      }
    );
    ptrType = $ptrType(SortedMap);
    sliceType = $sliceType(reflect.Value);
    SortedMap.ptr.prototype.Len = function () {
      var o;
      o = this;
      return o.Key.$length;
    };
    SortedMap.prototype.Len = function () {
      return this.$val.Len();
    };
    SortedMap.ptr.prototype.Less = function (i, j) {
      var { $24r, _r, i, j, o, x, x$1, $s, $r, $c } = $restore(this, { i, j });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            o = this;
            _r = compare(
              $clone(
                ((x = o.Key),
                i < 0 || i >= x.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x.$array[x.$offset + i]),
                reflect.Value
              ),
              $clone(
                ((x$1 = o.Key),
                j < 0 || j >= x$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x$1.$array[x$1.$offset + j]),
                reflect.Value
              )
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r < 0;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: SortedMap.ptr.prototype.Less,
        $c: true,
        $r,
        $24r,
        _r,
        i,
        j,
        o,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    SortedMap.prototype.Less = function (i, j) {
      return this.$val.Less(i, j);
    };
    SortedMap.ptr.prototype.Swap = function (i, j) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        i,
        j,
        o,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7;
      o = this;
      _tmp =
        ((x = o.Key),
        j < 0 || j >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + j]);
      _tmp$1 =
        ((x$1 = o.Key),
        i < 0 || i >= x$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$1.$array[x$1.$offset + i]);
      (x$2 = o.Key),
        i < 0 || i >= x$2.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (x$2.$array[x$2.$offset + i] = _tmp);
      (x$3 = o.Key),
        j < 0 || j >= x$3.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (x$3.$array[x$3.$offset + j] = _tmp$1);
      _tmp$2 =
        ((x$4 = o.Value),
        j < 0 || j >= x$4.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$4.$array[x$4.$offset + j]);
      _tmp$3 =
        ((x$5 = o.Value),
        i < 0 || i >= x$5.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$5.$array[x$5.$offset + i]);
      (x$6 = o.Value),
        i < 0 || i >= x$6.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (x$6.$array[x$6.$offset + i] = _tmp$2);
      (x$7 = o.Value),
        j < 0 || j >= x$7.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (x$7.$array[x$7.$offset + j] = _tmp$3);
    };
    SortedMap.prototype.Swap = function (i, j) {
      return this.$val.Swap(i, j);
    };
    Sort = function (mapValue) {
      var {
        _r,
        _r$1,
        _r$2,
        _r$3,
        iter,
        key,
        mapValue,
        n,
        sorted,
        value,
        $s,
        $r,
        $c,
      } = $restore(this, { mapValue });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(mapValue, reflect.Value).Type().Kind();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!(_r === 21)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((_r === 21))) { */ case 1:
            $s = -1;
            return ptrType.nil;
          /* } */ case 2:
            n = $clone(mapValue, reflect.Value).Len();
            key = $makeSlice(sliceType, 0, n);
            value = $makeSlice(sliceType, 0, n);
            iter = $clone(mapValue, reflect.Value).MapRange();
          /* while (true) { */ case 4:
            _r$1 = iter.Next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* if (!(_r$1)) { break; } */ if (!_r$1) {
              $s = 5;
              continue;
            }
            _r$2 = iter.Key();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            key = $append(key, _r$2);
            _r$3 = iter.Value();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            value = $append(value, _r$3);
            $s = 4;
            continue;
          case 5:
            sorted = new SortedMap.ptr(key, value);
            $r = sort.Stable(sorted);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return sorted;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Sort,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        _r$3,
        iter,
        key,
        mapValue,
        n,
        sorted,
        value,
        $s,
      };
      return $f;
    };
    $pkg.Sort = Sort;
    compare = function (aVal, bVal) {
      var {
        $24r,
        _1,
        _arg,
        _arg$1,
        _arg$2,
        _arg$3,
        _arg$4,
        _arg$5,
        _arg$6,
        _arg$7,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        a,
        a$1,
        a$2,
        a$3,
        a$4,
        a$5,
        aType,
        aVal,
        ap,
        b,
        b$1,
        b$2,
        b$3,
        b$4,
        b$5,
        bType,
        bVal,
        bp,
        c,
        c$1,
        c$2,
        c$3,
        c$4,
        c$5,
        i,
        i$1,
        ok,
        ok$1,
        $s,
        $r,
        $c,
      } = $restore(this, { aVal, bVal });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tmp = $clone(aVal, reflect.Value).Type();
            _tmp$1 = $clone(bVal, reflect.Value).Type();
            aType = _tmp;
            bType = _tmp$1;
            if (!$interfaceIsEqual(aType, bType)) {
              $s = -1;
              return -1;
            }
            _1 = $clone(aVal, reflect.Value).Kind();
            /* */ if (
              _1 === 2 ||
              _1 === 3 ||
              _1 === 4 ||
              _1 === 5 ||
              _1 === 6
            ) {
              $s = 2;
              continue;
            }
            /* */ if (
              _1 === 7 ||
              _1 === 8 ||
              _1 === 9 ||
              _1 === 10 ||
              _1 === 11 ||
              _1 === 12
            ) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 13 || _1 === 14) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 15 || _1 === 16) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 1) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 22 || _1 === 26) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 18) {
              $s = 9;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 10;
              continue;
            }
            /* */ if (_1 === 17) {
              $s = 11;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
            _tmp$2 = $clone(aVal, reflect.Value).Int();
            _tmp$3 = $clone(bVal, reflect.Value).Int();
            a = _tmp$2;
            b = _tmp$3;
            if (a.$high < b.$high || (a.$high === b.$high && a.$low < b.$low)) {
              $s = -1;
              return -1;
            } else if (
              a.$high > b.$high ||
              (a.$high === b.$high && a.$low > b.$low)
            ) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return 0;
            }
            $s = 14;
            continue;
          /* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
            _tmp$4 = $clone(aVal, reflect.Value).Uint();
            _tmp$5 = $clone(bVal, reflect.Value).Uint();
            a$1 = _tmp$4;
            b$1 = _tmp$5;
            if (
              a$1.$high < b$1.$high ||
              (a$1.$high === b$1.$high && a$1.$low < b$1.$low)
            ) {
              $s = -1;
              return -1;
            } else if (
              a$1.$high > b$1.$high ||
              (a$1.$high === b$1.$high && a$1.$low > b$1.$low)
            ) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return 0;
            }
            $s = 14;
            continue;
          /* } else if (_1 === (24)) { */ case 4:
            _r = $clone(aVal, reflect.Value).String();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tmp$6 = _r;
            _r$1 = $clone(bVal, reflect.Value).String();
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tmp$7 = _r$1;
            a$2 = _tmp$6;
            b$2 = _tmp$7;
            if (a$2 < b$2) {
              $s = -1;
              return -1;
            } else if (a$2 > b$2) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return 0;
            }
            $s = 14;
            continue;
          /* } else if ((_1 === (13)) || (_1 === (14))) { */ case 5:
            $s = -1;
            return floatCompare(
              $clone(aVal, reflect.Value).Float(),
              $clone(bVal, reflect.Value).Float()
            );
          /* } else if ((_1 === (15)) || (_1 === (16))) { */ case 6:
            _tmp$8 = $clone(aVal, reflect.Value).Complex();
            _tmp$9 = $clone(bVal, reflect.Value).Complex();
            a$3 = _tmp$8;
            b$3 = _tmp$9;
            c = floatCompare(a$3.$real, b$3.$real);
            if (!(c === 0)) {
              $s = -1;
              return c;
            }
            $s = -1;
            return floatCompare(a$3.$imag, b$3.$imag);
          /* } else if (_1 === (1)) { */ case 7:
            _tmp$10 = $clone(aVal, reflect.Value).Bool();
            _tmp$11 = $clone(bVal, reflect.Value).Bool();
            a$4 = _tmp$10;
            b$4 = _tmp$11;
            if (a$4 === b$4) {
              $s = -1;
              return 0;
            } else if (a$4) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return -1;
            }
            $s = 14;
            continue;
          /* } else if ((_1 === (22)) || (_1 === (26))) { */ case 8:
            _tmp$12 = $clone(aVal, reflect.Value).Pointer();
            _tmp$13 = $clone(bVal, reflect.Value).Pointer();
            a$5 = _tmp$12;
            b$5 = _tmp$13;
            if (a$5 < b$5) {
              $s = -1;
              return -1;
            } else if (a$5 > b$5) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return 0;
            }
            $s = 14;
            continue;
          /* } else if (_1 === (18)) { */ case 9:
            _tuple = nilCompare(
              $clone(aVal, reflect.Value),
              $clone(bVal, reflect.Value)
            );
            c$1 = _tuple[0];
            ok = _tuple[1];
            if (ok) {
              $s = -1;
              return c$1;
            }
            _tmp$14 = $clone(aVal, reflect.Value).Pointer();
            _tmp$15 = $clone(bVal, reflect.Value).Pointer();
            ap = _tmp$14;
            bp = _tmp$15;
            if (ap < bp) {
              $s = -1;
              return -1;
            } else if (ap > bp) {
              $s = -1;
              return 1;
            } else {
              $s = -1;
              return 0;
            }
            $s = 14;
            continue;
          /* } else if (_1 === (25)) { */ case 10:
            i = 0;
          /* while (true) { */ case 17:
            /* if (!(i < $clone(aVal, reflect.Value).NumField())) { break; } */ if (
              !(i < $clone(aVal, reflect.Value).NumField())
            ) {
              $s = 18;
              continue;
            }
            _r$2 = $clone(aVal, reflect.Value).Field(i);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _arg = $clone(_r$2, reflect.Value);
            _r$3 = $clone(bVal, reflect.Value).Field(i);
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _arg$1 = $clone(_r$3, reflect.Value);
            _r$4 = compare(_arg, _arg$1);
            /* */ $s = 21;
          case 21:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            c$2 = _r$4;
            if (!(c$2 === 0)) {
              $s = -1;
              return c$2;
            }
            i = (i + 1) >> 0;
            $s = 17;
            continue;
          case 18:
            $s = -1;
            return 0;
          /* } else if (_1 === (17)) { */ case 11:
            i$1 = 0;
          /* while (true) { */ case 22:
            /* if (!(i$1 < $clone(aVal, reflect.Value).Len())) { break; } */ if (
              !(i$1 < $clone(aVal, reflect.Value).Len())
            ) {
              $s = 23;
              continue;
            }
            _r$5 = $clone(aVal, reflect.Value).Index(i$1);
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _arg$2 = $clone(_r$5, reflect.Value);
            _r$6 = $clone(bVal, reflect.Value).Index(i$1);
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _arg$3 = $clone(_r$6, reflect.Value);
            _r$7 = compare(_arg$2, _arg$3);
            /* */ $s = 26;
          case 26:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            c$3 = _r$7;
            if (!(c$3 === 0)) {
              $s = -1;
              return c$3;
            }
            i$1 = (i$1 + 1) >> 0;
            $s = 22;
            continue;
          case 23:
            $s = -1;
            return 0;
          /* } else if (_1 === (20)) { */ case 12:
            _tuple$1 = nilCompare(
              $clone(aVal, reflect.Value),
              $clone(bVal, reflect.Value)
            );
            c$4 = _tuple$1[0];
            ok$1 = _tuple$1[1];
            if (ok$1) {
              $s = -1;
              return c$4;
            }
            _r$8 = $clone(aVal, reflect.Value).Elem();
            /* */ $s = 27;
          case 27:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            _r$9 = $clone(_r$8, reflect.Value).Type();
            /* */ $s = 28;
          case 28:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            _r$10 = reflect.ValueOf(_r$9);
            /* */ $s = 29;
          case 29:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _arg$4 = $clone(_r$10, reflect.Value);
            _r$11 = $clone(bVal, reflect.Value).Elem();
            /* */ $s = 30;
          case 30:
            if ($c) {
              $c = false;
              _r$11 = _r$11.$blk();
            }
            if (_r$11 && _r$11.$blk !== undefined) {
              break s;
            }
            _r$12 = $clone(_r$11, reflect.Value).Type();
            /* */ $s = 31;
          case 31:
            if ($c) {
              $c = false;
              _r$12 = _r$12.$blk();
            }
            if (_r$12 && _r$12.$blk !== undefined) {
              break s;
            }
            _r$13 = reflect.ValueOf(_r$12);
            /* */ $s = 32;
          case 32:
            if ($c) {
              $c = false;
              _r$13 = _r$13.$blk();
            }
            if (_r$13 && _r$13.$blk !== undefined) {
              break s;
            }
            _arg$5 = $clone(_r$13, reflect.Value);
            _r$14 = compare(_arg$4, _arg$5);
            /* */ $s = 33;
          case 33:
            if ($c) {
              $c = false;
              _r$14 = _r$14.$blk();
            }
            if (_r$14 && _r$14.$blk !== undefined) {
              break s;
            }
            c$5 = _r$14;
            if (!(c$5 === 0)) {
              $s = -1;
              return c$5;
            }
            _r$15 = $clone(aVal, reflect.Value).Elem();
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              _r$15 = _r$15.$blk();
            }
            if (_r$15 && _r$15.$blk !== undefined) {
              break s;
            }
            _arg$6 = $clone(_r$15, reflect.Value);
            _r$16 = $clone(bVal, reflect.Value).Elem();
            /* */ $s = 35;
          case 35:
            if ($c) {
              $c = false;
              _r$16 = _r$16.$blk();
            }
            if (_r$16 && _r$16.$blk !== undefined) {
              break s;
            }
            _arg$7 = $clone(_r$16, reflect.Value);
            _r$17 = compare(_arg$6, _arg$7);
            /* */ $s = 36;
          case 36:
            if ($c) {
              $c = false;
              _r$17 = _r$17.$blk();
            }
            if (_r$17 && _r$17.$blk !== undefined) {
              break s;
            }
            $24r = _r$17;
            $s = 37;
          case 37:
            return $24r;
          /* } else { */ case 13:
            _r$18 = aType.String();
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              _r$18 = _r$18.$blk();
            }
            if (_r$18 && _r$18.$blk !== undefined) {
              break s;
            }
            $panic(new $String("bad type in compare: " + _r$18));
          /* } */ case 14:
          case 1:
            $s = -1;
            return 0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: compare,
        $c: true,
        $r,
        $24r,
        _1,
        _arg,
        _arg$1,
        _arg$2,
        _arg$3,
        _arg$4,
        _arg$5,
        _arg$6,
        _arg$7,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        a,
        a$1,
        a$2,
        a$3,
        a$4,
        a$5,
        aType,
        aVal,
        ap,
        b,
        b$1,
        b$2,
        b$3,
        b$4,
        b$5,
        bType,
        bVal,
        bp,
        c,
        c$1,
        c$2,
        c$3,
        c$4,
        c$5,
        i,
        i$1,
        ok,
        ok$1,
        $s,
      };
      return $f;
    };
    nilCompare = function (aVal, bVal) {
      var aVal, bVal;
      if ($clone(aVal, reflect.Value).IsNil()) {
        if ($clone(bVal, reflect.Value).IsNil()) {
          return [0, true];
        }
        return [-1, true];
      }
      if ($clone(bVal, reflect.Value).IsNil()) {
        return [1, true];
      }
      return [0, false];
    };
    floatCompare = function (a, b) {
      var a, b;
      if (isNaN(a)) {
        return -1;
      } else if (isNaN(b)) {
        return 1;
      } else if (a < b) {
        return -1;
      } else if (a > b) {
        return 1;
      }
      return 0;
    };
    isNaN = function (a) {
      var a;
      return !(a === a);
    };
    ptrType.methods = [
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Less",
        name: "Less",
        pkg: "",
        typ: $funcType([$Int, $Int], [$Bool], false),
      },
      {
        prop: "Swap",
        name: "Swap",
        pkg: "",
        typ: $funcType([$Int, $Int], [], false),
      },
    ];
    SortedMap.init("", [
      {
        prop: "Key",
        name: "Key",
        embedded: false,
        exported: true,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "Value",
        name: "Value",
        embedded: false,
        exported: true,
        typ: sliceType,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = reflect.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["io"] = (function () {
    var $pkg = {},
      $init,
      errors,
      sync,
      Reader,
      Writer,
      ReaderFrom,
      WriterTo,
      RuneScanner,
      LimitedReader,
      sliceType,
      sliceType$1,
      ptrType$1,
      ptrType$3,
      errInvalidWrite,
      errWhence,
      errOffset,
      blackHolePool,
      Copy,
      copyBuffer;
    errors = $packages["errors"];
    sync = $packages["sync"];
    Reader = $pkg.Reader = $newType(
      8,
      $kindInterface,
      "io.Reader",
      true,
      "io",
      true,
      null
    );
    Writer = $pkg.Writer = $newType(
      8,
      $kindInterface,
      "io.Writer",
      true,
      "io",
      true,
      null
    );
    ReaderFrom = $pkg.ReaderFrom = $newType(
      8,
      $kindInterface,
      "io.ReaderFrom",
      true,
      "io",
      true,
      null
    );
    WriterTo = $pkg.WriterTo = $newType(
      8,
      $kindInterface,
      "io.WriterTo",
      true,
      "io",
      true,
      null
    );
    RuneScanner = $pkg.RuneScanner = $newType(
      8,
      $kindInterface,
      "io.RuneScanner",
      true,
      "io",
      true,
      null
    );
    LimitedReader = $pkg.LimitedReader = $newType(
      0,
      $kindStruct,
      "io.LimitedReader",
      true,
      "io",
      true,
      function (R_, N_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.R = $ifaceNil;
          this.N = new $Int64(0, 0);
          return;
        }
        this.R = R_;
        this.N = N_;
      }
    );
    sliceType = $sliceType($emptyInterface);
    sliceType$1 = $sliceType($Uint8);
    ptrType$1 = $ptrType(sliceType$1);
    ptrType$3 = $ptrType(LimitedReader);
    Copy = function (dst, src) {
      var { $24r, _r, _tuple, dst, err, src, written, $s, $r, $c } = $restore(
        this,
        { dst, src }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            written = new $Int64(0, 0);
            err = $ifaceNil;
            _r = copyBuffer(dst, src, sliceType$1.nil);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            written = _tuple[0];
            err = _tuple[1];
            $24r = [written, err];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Copy,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        dst,
        err,
        src,
        written,
        $s,
      };
      return $f;
    };
    $pkg.Copy = Copy;
    copyBuffer = function (dst, src, buf) {
      var {
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        buf,
        dst,
        er,
        err,
        ew,
        l,
        nr,
        nw,
        ok,
        ok$1,
        ok$2,
        rt,
        size,
        src,
        written,
        wt,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
        $r,
        $c,
      } = $restore(this, { dst, src, buf });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            written = new $Int64(0, 0);
            err = $ifaceNil;
            _tuple = $assertType(src, WriterTo, true);
            wt = _tuple[0];
            ok = _tuple[1];
            /* */ if (ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (ok) { */ case 1:
            _r = wt.WriteTo(dst);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r;
            written = _tuple$1[0];
            err = _tuple$1[1];
            $24r = [written, err];
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            _tuple$2 = $assertType(dst, ReaderFrom, true);
            rt = _tuple$2[0];
            ok$1 = _tuple$2[1];
            /* */ if (ok$1) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (ok$1) { */ case 5:
            _r$1 = rt.ReadFrom(src);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple$3 = _r$1;
            written = _tuple$3[0];
            err = _tuple$3[1];
            $24r$1 = [written, err];
            $s = 8;
          case 8:
            return $24r$1;
          /* } */ case 6:
            if (buf === sliceType$1.nil) {
              size = 32768;
              _tuple$4 = $assertType(src, ptrType$3, true);
              l = _tuple$4[0];
              ok$2 = _tuple$4[1];
              if (
                ok$2 &&
                ((x$2 = new $Int64(0, size)),
                (x$3 = l.N),
                x$2.$high > x$3.$high ||
                  (x$2.$high === x$3.$high && x$2.$low > x$3.$low))
              ) {
                if (
                  ((x$4 = l.N),
                  x$4.$high < 0 || (x$4.$high === 0 && x$4.$low < 1))
                ) {
                  size = 1;
                } else {
                  size =
                    ((x$5 = l.N), x$5.$low + (x$5.$high >> 31) * 4294967296) >>
                    0;
                }
              }
              buf = $makeSlice(sliceType$1, size);
            }
          /* while (true) { */ case 9:
            _r$2 = src.Read(buf);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple$5 = _r$2;
            nr = _tuple$5[0];
            er = _tuple$5[1];
            /* */ if (nr > 0) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if (nr > 0) { */ case 12:
            _r$3 = dst.Write($subslice(buf, 0, nr));
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple$6 = _r$3;
            nw = _tuple$6[0];
            ew = _tuple$6[1];
            if (nw < 0 || nr < nw) {
              nw = 0;
              if ($interfaceIsEqual(ew, $ifaceNil)) {
                ew = errInvalidWrite;
              }
            }
            written =
              ((x$6 = new $Int64(0, nw)),
              new $Int64(written.$high + x$6.$high, written.$low + x$6.$low));
            if (!$interfaceIsEqual(ew, $ifaceNil)) {
              err = ew;
              /* break; */ $s = 10;
              continue;
            }
            if (!(nr === nw)) {
              err = $pkg.ErrShortWrite;
              /* break; */ $s = 10;
              continue;
            }
          /* } */ case 13:
            if (!$interfaceIsEqual(er, $ifaceNil)) {
              if (!$interfaceIsEqual(er, $pkg.EOF)) {
                err = er;
              }
              /* break; */ $s = 10;
              continue;
            }
            $s = 9;
            continue;
          case 10:
            _tmp = written;
            _tmp$1 = err;
            written = _tmp;
            err = _tmp$1;
            $s = -1;
            return [written, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: copyBuffer,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        buf,
        dst,
        er,
        err,
        ew,
        l,
        nr,
        nw,
        ok,
        ok$1,
        ok$2,
        rt,
        size,
        src,
        written,
        wt,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
      };
      return $f;
    };
    LimitedReader.ptr.prototype.Read = function (p) {
      var {
        _r,
        _tmp,
        _tmp$1,
        _tuple,
        err,
        l,
        n,
        p,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
        $r,
        $c,
      } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            l = this;
            if (
              ((x$2 = l.N), x$2.$high < 0 || (x$2.$high === 0 && x$2.$low <= 0))
            ) {
              _tmp = 0;
              _tmp$1 = $pkg.EOF;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            if (
              ((x$3 = new $Int64(0, p.$length)),
              (x$4 = l.N),
              x$3.$high > x$4.$high ||
                (x$3.$high === x$4.$high && x$3.$low > x$4.$low))
            ) {
              p = $subslice(p, 0, $flatten64(l.N));
            }
            _r = l.R.Read(p);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            n = _tuple[0];
            err = _tuple[1];
            l.N =
              ((x$5 = l.N),
              (x$6 = new $Int64(0, n)),
              new $Int64(x$5.$high - x$6.$high, x$5.$low - x$6.$low));
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: LimitedReader.ptr.prototype.Read,
        $c: true,
        $r,
        _r,
        _tmp,
        _tmp$1,
        _tuple,
        err,
        l,
        n,
        p,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
      };
      return $f;
    };
    LimitedReader.prototype.Read = function (p) {
      return this.$val.Read(p);
    };
    ptrType$3.methods = [
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
    ];
    Reader.init([
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
    ]);
    Writer.init([
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
    ]);
    ReaderFrom.init([
      {
        prop: "ReadFrom",
        name: "ReadFrom",
        pkg: "",
        typ: $funcType([Reader], [$Int64, $error], false),
      },
    ]);
    WriterTo.init([
      {
        prop: "WriteTo",
        name: "WriteTo",
        pkg: "",
        typ: $funcType([Writer], [$Int64, $error], false),
      },
    ]);
    RuneScanner.init([
      {
        prop: "ReadRune",
        name: "ReadRune",
        pkg: "",
        typ: $funcType([], [$Int32, $Int, $error], false),
      },
      {
        prop: "UnreadRune",
        name: "UnreadRune",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
    ]);
    LimitedReader.init("", [
      {
        prop: "R",
        name: "R",
        embedded: false,
        exported: true,
        typ: Reader,
        tag: "",
      },
      {
        prop: "N",
        name: "N",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
            $pkg.ErrShortWrite = errors.New("short write");
            errInvalidWrite = errors.New("invalid write result");
            $pkg.ErrShortBuffer = errors.New("short buffer");
            $pkg.EOF = errors.New("EOF");
            $pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
            $pkg.ErrNoProgress = errors.New(
              "multiple Read calls return no data or error"
            );
            errWhence = errors.New("Seek: invalid whence");
            errOffset = errors.New("Seek: invalid offset");
            blackHolePool = new sync.Pool.ptr(sliceType.nil, function () {
              var b, b$24ptr;
              b = $makeSlice(sliceType$1, 8192);
              return (
                b$24ptr ||
                (b$24ptr = new ptrType$1(
                  function () {
                    return b;
                  },
                  function ($v) {
                    b = $convertSliceType($v, sliceType$1);
                  }
                ))
              );
            });
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/oserror"] = (function () {
    var $pkg = {},
      $init,
      errors;
    errors = $packages["errors"];
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ErrInvalid = errors.New("invalid argument");
            $pkg.ErrPermission = errors.New("permission denied");
            $pkg.ErrExist = errors.New("file already exists");
            $pkg.ErrNotExist = errors.New("file does not exist");
            $pkg.ErrClosed = errors.New("file already closed");
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["syscall/js"] = (function () {
    var $pkg = {},
      $init,
      js,
      Type,
      Func,
      Error,
      Value,
      ValueError,
      sliceType,
      funcType,
      arrayType,
      sliceType$1,
      mapType,
      sliceType$2,
      ptrType,
      sliceType$3,
      ptrType$1,
      ptrType$2,
      typeNames,
      id,
      instanceOf,
      typeOf,
      Global,
      Null,
      Undefined,
      FuncOf,
      objectToValue,
      init,
      getValueType,
      ValueOf,
      convertArgs,
      convertJSError,
      CopyBytesToGo,
      CopyBytesToJS;
    js = $packages["github.com/gopherjs/gopherjs/js"];
    Type = $pkg.Type = $newType(
      4,
      $kindInt,
      "js.Type",
      true,
      "syscall/js",
      true,
      null
    );
    Func = $pkg.Func = $newType(
      0,
      $kindStruct,
      "js.Func",
      true,
      "syscall/js",
      true,
      function (Value_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Value = new Value.ptr(null, false, arrayType.zero());
          return;
        }
        this.Value = Value_;
      }
    );
    Error = $pkg.Error = $newType(
      0,
      $kindStruct,
      "js.Error",
      true,
      "syscall/js",
      true,
      function (Value_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Value = new Value.ptr(null, false, arrayType.zero());
          return;
        }
        this.Value = Value_;
      }
    );
    Value = $pkg.Value = $newType(
      0,
      $kindStruct,
      "js.Value",
      true,
      "syscall/js",
      true,
      function (v_, inited_, _$2_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.v = null;
          this.inited = false;
          this._$2 = arrayType.zero();
          return;
        }
        this.v = v_;
        this.inited = inited_;
        this._$2 = _$2_;
      }
    );
    ValueError = $pkg.ValueError = $newType(
      0,
      $kindStruct,
      "js.ValueError",
      true,
      "syscall/js",
      true,
      function (Method_, Type_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Method = "";
          this.Type = 0;
          return;
        }
        this.Method = Method_;
        this.Type = Type_;
      }
    );
    sliceType = $sliceType($String);
    funcType = $funcType([], [], false);
    arrayType = $arrayType(funcType, 0);
    sliceType$1 = $sliceType(Value);
    mapType = $mapType($String, $emptyInterface);
    sliceType$2 = $sliceType($emptyInterface);
    ptrType = $ptrType(js.Error);
    sliceType$3 = $sliceType($Uint8);
    ptrType$1 = $ptrType(js.Object);
    ptrType$2 = $ptrType(ValueError);
    Type.prototype.String = function () {
      var t;
      t = this.$val;
      if (t >> 0 < 0 || typeNames.$length <= t >> 0) {
        $panic(new $String("bad type"));
      }
      return t < 0 || t >= typeNames.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : typeNames.$array[typeNames.$offset + t];
    };
    $ptrType(Type).prototype.String = function () {
      return new Type(this.$get()).String();
    };
    Type.prototype.isObject = function () {
      var t;
      t = this.$val;
      return t === 6 || t === 7;
    };
    $ptrType(Type).prototype.isObject = function () {
      return new Type(this.$get()).isObject();
    };
    Global = function () {
      return objectToValue($global);
    };
    $pkg.Global = Global;
    Null = function () {
      return objectToValue(null);
    };
    $pkg.Null = Null;
    Undefined = function () {
      return objectToValue(undefined);
    };
    $pkg.Undefined = Undefined;
    Func.ptr.prototype.Release = function () {
      var f;
      f = this;
      $exportedFunctions = (($parseInt($exportedFunctions) >> 0) - 1) >> 0;
      Value.copy(f.Value, Null());
    };
    Func.prototype.Release = function () {
      return this.$val.Release();
    };
    FuncOf = function (fn) {
      var fn;
      $exportedFunctions = (($parseInt($exportedFunctions) >> 0) + 1) >> 0;
      return new Func.ptr(
        $clone(
          objectToValue(
            js.MakeFunc(function $b(this$1, args) {
              var {
                $24r,
                _i,
                _r,
                _ref,
                a,
                args,
                i,
                this$1,
                vargs,
                $s,
                $r,
                $c,
              } = $restore(this, { this$1, args });
              /* */ $s = $s || 0;
              s: while (true) {
                switch ($s) {
                  case 0:
                    vargs = $makeSlice(sliceType$1, args.$length);
                    _ref = args;
                    _i = 0;
                    while (true) {
                      if (!(_i < _ref.$length)) {
                        break;
                      }
                      i = _i;
                      a =
                        _i < 0 || _i >= _ref.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : _ref.$array[_ref.$offset + _i];
                      Value.copy(
                        i < 0 || i >= vargs.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : vargs.$array[vargs.$offset + i],
                        objectToValue(a)
                      );
                      _i++;
                    }
                    _r = fn($clone(objectToValue(this$1), Value), vargs);
                    /* */ $s = 1;
                  case 1:
                    if ($c) {
                      $c = false;
                      _r = _r.$blk();
                    }
                    if (_r && _r.$blk !== undefined) {
                      break s;
                    }
                    $24r = _r;
                    $s = 2;
                  case 2:
                    return $24r;
                  /* */
                }
                return;
              }
              var $f = {
                $blk: $b,
                $c: true,
                $r,
                $24r,
                _i,
                _r,
                _ref,
                a,
                args,
                i,
                this$1,
                vargs,
                $s,
              };
              return $f;
            })
          ),
          Value
        )
      );
    };
    $pkg.FuncOf = FuncOf;
    Error.ptr.prototype.Error = function () {
      var e;
      e = this;
      return (
        "JavaScript error: " +
        $clone($clone(e.Value, Value).Get("message"), Value).String()
      );
    };
    Error.prototype.Error = function () {
      return this.$val.Error();
    };
    objectToValue = function (obj) {
      var obj;
      if (obj === undefined) {
        return new Value.ptr(null, false, arrayType.zero());
      }
      return new Value.ptr(obj, true, arrayType.zero());
    };
    init = function () {
      if (!($global === null)) {
        id = $id;
        instanceOf = $instanceOf;
        typeOf = $typeOf;
      }
    };
    getValueType = function (obj) {
      var _i, _ref, name, name2, obj, type2;
      if (obj === null) {
        return 1;
      }
      name = $internalize(typeOf(obj), $String);
      _ref = typeNames;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        type2 = _i;
        name2 =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (name === name2) {
          return type2 >> 0;
        }
        _i++;
      }
      return 6;
    };
    ValueOf = function (x) {
      var _ref, x, x$1, x$2, x$3, x$4, x$5;
      _ref = x;
      if ($assertType(_ref, Value, true)[1]) {
        x$1 = $clone(_ref.$val, Value);
        return x$1;
      } else if ($assertType(_ref, Func, true)[1]) {
        x$2 = $clone(_ref.$val, Func);
        return x$2.Value;
      } else if (_ref === $ifaceNil) {
        x$3 = _ref;
        return Null();
      } else if (
        $assertType(_ref, $Bool, true)[1] ||
        $assertType(_ref, $Int, true)[1] ||
        $assertType(_ref, $Int8, true)[1] ||
        $assertType(_ref, $Int16, true)[1] ||
        $assertType(_ref, $Int32, true)[1] ||
        $assertType(_ref, $Int64, true)[1] ||
        $assertType(_ref, $Uint, true)[1] ||
        $assertType(_ref, $Uint8, true)[1] ||
        $assertType(_ref, $Uint16, true)[1] ||
        $assertType(_ref, $Uint32, true)[1] ||
        $assertType(_ref, $Uint64, true)[1] ||
        $assertType(_ref, $Float32, true)[1] ||
        $assertType(_ref, $Float64, true)[1] ||
        $assertType(_ref, $UnsafePointer, true)[1] ||
        $assertType(_ref, $String, true)[1] ||
        $assertType(_ref, mapType, true)[1] ||
        $assertType(_ref, sliceType$2, true)[1]
      ) {
        x$4 = _ref;
        return objectToValue(id($externalize(x$4, $emptyInterface)));
      } else {
        x$5 = _ref;
        $panic(new $String("ValueOf: invalid value"));
      }
    };
    $pkg.ValueOf = ValueOf;
    Value.ptr.prototype.internal = function () {
      var v;
      v = this;
      if (!v.inited) {
        return undefined;
      }
      return v.v;
    };
    Value.prototype.internal = function () {
      return this.$val.internal();
    };
    Value.ptr.prototype.Bool = function () {
      var v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!(vType === 2)) {
        $panic(new ValueError.ptr("Value.Bool", vType));
      }
      return !!$clone(v, Value).internal();
    };
    Value.prototype.Bool = function () {
      return this.$val.Bool();
    };
    convertArgs = function (args) {
      var _i, _ref, arg, args, newArgs, v;
      newArgs = new sliceType$2([]);
      _ref = args;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        arg =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        v = $clone(ValueOf(arg), Value);
        newArgs = $append(
          newArgs,
          new $jsObjectPtr($clone(v, Value).internal())
        );
        _i++;
      }
      return newArgs;
    };
    convertJSError = function () {
      var _tuple, err, jsErr, ok, x;
      err = $recover();
      if ($interfaceIsEqual(err, $ifaceNil)) {
        return;
      }
      _tuple = $assertType(err, ptrType, true);
      jsErr = _tuple[0];
      ok = _tuple[1];
      if (ok) {
        $panic(
          ((x = new Error.ptr($clone(objectToValue(jsErr.Object), Value))),
          new x.constructor.elem(x))
        );
      }
      $panic(err);
    };
    Value.ptr.prototype.Call = function (m, args) {
      var { $24r, args, m, obj, propType, v, vType, $s, $deferred, $r, $c } =
        $restore(this, { m, args });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              v = this;
              vType = $clone(v, Value).Type();
              if (!(vType === 6) && !(vType === 7)) {
                $panic(new ValueError.ptr("Value.Call", vType));
              }
              propType = $clone($clone(v, Value).Get(m), Value).Type();
              if (!(propType === 7)) {
                $panic(
                  new $String(
                    "js: Value.Call: property " +
                      m +
                      " is not a function, got " +
                      new Type(propType).String()
                  )
                );
              }
              $deferred.push([convertJSError, []]);
              $24r = objectToValue(
                ((obj = $clone(v, Value).internal()),
                obj[$externalize(m, $String)].apply(
                  obj,
                  $externalize(convertArgs(args), sliceType$2)
                ))
              );
              $s = 1;
            case 1:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return new Value.ptr(null, false, arrayType.zero());
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Value.ptr.prototype.Call,
            $c: true,
            $r,
            $24r,
            args,
            m,
            obj,
            propType,
            v,
            vType,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    Value.prototype.Call = function (m, args) {
      return this.$val.Call(m, args);
    };
    Value.ptr.prototype.Float = function () {
      var v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!(vType === 3)) {
        $panic(new ValueError.ptr("Value.Float", vType));
      }
      return $parseFloat($clone(v, Value).internal());
    };
    Value.prototype.Float = function () {
      return this.$val.Float();
    };
    Value.ptr.prototype.Get = function (p) {
      var p, v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!new Type(vType).isObject()) {
        $panic(new ValueError.ptr("Value.Get", vType));
      }
      return objectToValue(
        $clone(v, Value).internal()[$externalize(p, $String)]
      );
    };
    Value.prototype.Get = function (p) {
      return this.$val.Get(p);
    };
    Value.ptr.prototype.Index = function (i) {
      var i, v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!new Type(vType).isObject()) {
        $panic(new ValueError.ptr("Value.Index", vType));
      }
      return objectToValue($clone(v, Value).internal()[i]);
    };
    Value.prototype.Index = function (i) {
      return this.$val.Index(i);
    };
    Value.ptr.prototype.Int = function () {
      var v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!(vType === 3)) {
        $panic(new ValueError.ptr("Value.Int", vType));
      }
      return $parseInt($clone(v, Value).internal()) >> 0;
    };
    Value.prototype.Int = function () {
      return this.$val.Int();
    };
    Value.ptr.prototype.InstanceOf = function (t) {
      var t, v;
      v = this;
      return !!instanceOf(
        $clone(v, Value).internal(),
        $clone(t, Value).internal()
      );
    };
    Value.prototype.InstanceOf = function (t) {
      return this.$val.InstanceOf(t);
    };
    Value.ptr.prototype.Invoke = function (args) {
      var args, v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!(vType === 7)) {
        $panic(new ValueError.ptr("Value.Invoke", vType));
      }
      return objectToValue(
        $clone(v, Value)
          .internal()
          .apply(undefined, $externalize(convertArgs(args), sliceType$2))
      );
    };
    Value.prototype.Invoke = function (args) {
      return this.$val.Invoke(args);
    };
    Value.ptr.prototype.JSValue = function () {
      var v;
      v = this;
      return v;
    };
    Value.prototype.JSValue = function () {
      return this.$val.JSValue();
    };
    Value.ptr.prototype.Length = function () {
      var v;
      v = this;
      return $parseInt($clone(v, Value).internal().length);
    };
    Value.prototype.Length = function () {
      return this.$val.Length();
    };
    Value.ptr.prototype.New = function (args) {
      var { $24r, args, v, $s, $deferred, $r, $c } = $restore(this, { args });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              v = [v];
              v[0] = this;
              $deferred.push([
                (function (v) {
                  return function () {
                    var _tuple, err, jsErr, ok, vType, x;
                    err = $recover();
                    if ($interfaceIsEqual(err, $ifaceNil)) {
                      return;
                    }
                    vType = $clone(v[0], Value).Type();
                    if (!(vType === 7)) {
                      $panic(new ValueError.ptr("Value.New", vType));
                    }
                    _tuple = $assertType(err, ptrType, true);
                    jsErr = _tuple[0];
                    ok = _tuple[1];
                    if (ok) {
                      $panic(
                        ((x = new Error.ptr(
                          $clone(objectToValue(jsErr.Object), Value)
                        )),
                        new x.constructor.elem(x))
                      );
                    }
                    $panic(err);
                  };
                })(v),
                [],
              ]);
              $24r = objectToValue(
                new ($global.Function.prototype.bind.apply(
                  $clone(v[0], Value).internal(),
                  [undefined].concat(
                    $externalize(convertArgs(args), sliceType$2)
                  )
                ))()
              );
              $s = 1;
            case 1:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return new Value.ptr(null, false, arrayType.zero());
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Value.ptr.prototype.New,
            $c: true,
            $r,
            $24r,
            args,
            v,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    Value.prototype.New = function (args) {
      return this.$val.New(args);
    };
    Value.ptr.prototype.Set = function (p, x) {
      var p, v, vType, x, x$1;
      v = this;
      vType = $clone(v, Value).Type();
      if (!new Type(vType).isObject()) {
        $panic(new ValueError.ptr("Value.Set", vType));
      }
      $clone(v, Value).internal()[$externalize(p, $String)] = $externalize(
        ((x$1 = convertArgs(new sliceType$2([x]))),
        0 >= x$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$1.$array[x$1.$offset + 0]),
        $emptyInterface
      );
    };
    Value.prototype.Set = function (p, x) {
      return this.$val.Set(p, x);
    };
    Value.ptr.prototype.SetIndex = function (i, x) {
      var i, v, vType, x, x$1;
      v = this;
      vType = $clone(v, Value).Type();
      if (!new Type(vType).isObject()) {
        $panic(new ValueError.ptr("Value.SetIndex", vType));
      }
      $clone(v, Value).internal()[i] = $externalize(
        ((x$1 = convertArgs(new sliceType$2([x]))),
        0 >= x$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$1.$array[x$1.$offset + 0]),
        $emptyInterface
      );
    };
    Value.prototype.SetIndex = function (i, x) {
      return this.$val.SetIndex(i, x);
    };
    Value.ptr.prototype.String = function () {
      var _1, v;
      v = this;
      _1 = $clone(v, Value).Type();
      if (_1 === 4) {
        return $internalize($clone(v, Value).internal(), $String);
      } else if (_1 === 0) {
        return "<undefined>";
      } else if (_1 === 1) {
        return "<null>";
      } else if (_1 === 2) {
        return (
          "<boolean: " +
          $internalize($clone(v, Value).internal(), $String) +
          ">"
        );
      } else if (_1 === 3) {
        return (
          "<number: " + $internalize($clone(v, Value).internal(), $String) + ">"
        );
      } else if (_1 === 5) {
        return "<symbol>";
      } else if (_1 === 6) {
        return "<object>";
      } else if (_1 === 7) {
        return "<function>";
      } else {
        $panic(new $String("bad type"));
      }
    };
    Value.prototype.String = function () {
      return this.$val.String();
    };
    Value.ptr.prototype.Truthy = function () {
      var v;
      v = this;
      return !!$clone(v, Value).internal();
    };
    Value.prototype.Truthy = function () {
      return this.$val.Truthy();
    };
    Value.ptr.prototype.Type = function () {
      var v;
      v = this;
      return getValueType($clone(v, Value).internal());
    };
    Value.prototype.Type = function () {
      return this.$val.Type();
    };
    Value.ptr.prototype.IsNull = function () {
      var v;
      v = this;
      return $clone(v, Value).Type() === 1;
    };
    Value.prototype.IsNull = function () {
      return this.$val.IsNull();
    };
    Value.ptr.prototype.IsUndefined = function () {
      var v;
      v = this;
      return !v.inited;
    };
    Value.prototype.IsUndefined = function () {
      return this.$val.IsUndefined();
    };
    Value.ptr.prototype.IsNaN = function () {
      var v;
      v = this;
      return !!$global.isNaN($clone(v, Value).internal());
    };
    Value.prototype.IsNaN = function () {
      return this.$val.IsNaN();
    };
    Value.ptr.prototype.Delete = function (p) {
      var p, v, vType;
      v = this;
      vType = $clone(v, Value).Type();
      if (!new Type(vType).isObject()) {
        $panic(new ValueError.ptr("Value.Delete", vType));
      }
      delete $clone(v, Value).internal()[$externalize(p, $String)];
    };
    Value.prototype.Delete = function (p) {
      return this.$val.Delete(p);
    };
    Value.ptr.prototype.Equal = function (w) {
      var v, w;
      v = this;
      return $clone(v, Value).internal() === $clone(w, Value).internal();
    };
    Value.prototype.Equal = function (w) {
      return this.$val.Equal(w);
    };
    ValueError.ptr.prototype.Error = function () {
      var e;
      e = this;
      return (
        "syscall/js: call of " + e.Method + " on " + new Type(e.Type).String()
      );
    };
    ValueError.prototype.Error = function () {
      return this.$val.Error();
    };
    CopyBytesToGo = function (dst, src) {
      var dlen, dst, src, vlen;
      vlen = $parseInt(src.v.length);
      dlen = dst.$length;
      if (dlen < vlen) {
        vlen = dlen;
      }
      $copySlice(
        dst,
        $assertType($internalize(src.v, $emptyInterface), sliceType$3)
      );
      return vlen;
    };
    $pkg.CopyBytesToGo = CopyBytesToGo;
    CopyBytesToJS = function (dst, src) {
      var _tuple, dst, dt, ok, src;
      _tuple = $assertType(
        $internalize(dst.v, $emptyInterface),
        sliceType$3,
        true
      );
      dt = _tuple[0];
      ok = _tuple[1];
      if (!ok) {
        $panic(
          new $String(
            "syscall/js: CopyBytesToJS: expected dst to be an Uint8Array"
          )
        );
      }
      return $copySlice(dt, src);
    };
    $pkg.CopyBytesToJS = CopyBytesToJS;
    Type.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "isObject",
        name: "isObject",
        pkg: "syscall/js",
        typ: $funcType([], [$Bool], false),
      },
    ];
    Func.methods = [
      {
        prop: "Release",
        name: "Release",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ];
    Error.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Value.methods = [
      {
        prop: "internal",
        name: "internal",
        pkg: "syscall/js",
        typ: $funcType([], [ptrType$1], false),
      },
      {
        prop: "Bool",
        name: "Bool",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Call",
        name: "Call",
        pkg: "",
        typ: $funcType([$String, sliceType$2], [Value], true),
      },
      {
        prop: "Float",
        name: "Float",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "Get",
        name: "Get",
        pkg: "",
        typ: $funcType([$String], [Value], false),
      },
      {
        prop: "Index",
        name: "Index",
        pkg: "",
        typ: $funcType([$Int], [Value], false),
      },
      { prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "InstanceOf",
        name: "InstanceOf",
        pkg: "",
        typ: $funcType([Value], [$Bool], false),
      },
      {
        prop: "Invoke",
        name: "Invoke",
        pkg: "",
        typ: $funcType([sliceType$2], [Value], true),
      },
      {
        prop: "JSValue",
        name: "JSValue",
        pkg: "",
        typ: $funcType([], [Value], false),
      },
      {
        prop: "Length",
        name: "Length",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "New",
        name: "New",
        pkg: "",
        typ: $funcType([sliceType$2], [Value], true),
      },
      {
        prop: "Set",
        name: "Set",
        pkg: "",
        typ: $funcType([$String, $emptyInterface], [], false),
      },
      {
        prop: "SetIndex",
        name: "SetIndex",
        pkg: "",
        typ: $funcType([$Int, $emptyInterface], [], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Truthy",
        name: "Truthy",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [Type], false),
      },
      {
        prop: "IsNull",
        name: "IsNull",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsUndefined",
        name: "IsUndefined",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsNaN",
        name: "IsNaN",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Delete",
        name: "Delete",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Equal",
        name: "Equal",
        pkg: "",
        typ: $funcType([Value], [$Bool], false),
      },
    ];
    ptrType$2.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Func.init("", [
      {
        prop: "Value",
        name: "Value",
        embedded: true,
        exported: true,
        typ: Value,
        tag: "",
      },
    ]);
    Error.init("", [
      {
        prop: "Value",
        name: "Value",
        embedded: true,
        exported: true,
        typ: Value,
        tag: "",
      },
    ]);
    Value.init("syscall/js", [
      {
        prop: "v",
        name: "v",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "inited",
        name: "inited",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "_$2",
        name: "_",
        embedded: false,
        exported: false,
        typ: arrayType,
        tag: "",
      },
    ]);
    ValueError.init("", [
      {
        prop: "Method",
        name: "Method",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Type",
        name: "Type",
        embedded: false,
        exported: true,
        typ: Type,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = js.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            id = null;
            instanceOf = null;
            typeOf = null;
            typeNames = new sliceType([
              "undefined",
              "null",
              "boolean",
              "number",
              "string",
              "symbol",
              "object",
              "function",
            ]);
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["syscall"] = (function () {
    var $pkg = {},
      $init,
      errors,
      itoa,
      oserror,
      runtime,
      sync,
      js,
      Errno,
      Stat_t,
      Iovec,
      Sockaddr,
      SockaddrInet4,
      SockaddrInet6,
      RawConn,
      jsFile,
      callResult,
      sliceType,
      sliceType$2,
      ptrType,
      funcType,
      arrayType$2,
      ptrType$2,
      arrayType$3,
      arrayType$4,
      funcType$1,
      funcType$2,
      errorstr,
      errEAGAIN,
      errEINVAL,
      errENOENT,
      errnoByCode,
      jsProcess,
      jsFS,
      constants,
      uint8Array,
      nodeWRONLY,
      nodeRDWR,
      nodeCREATE,
      nodeTRUNC,
      nodeAPPEND,
      nodeEXCL,
      filesMu,
      files,
      envs,
      _r,
      faketimeWrite,
      errnoErr,
      StopIO,
      Accept,
      Recvfrom,
      Sendto,
      Recvmsg,
      SendmsgN,
      SetReadDeadline,
      SetWriteDeadline,
      Shutdown,
      SetNonblock,
      runtime_envs,
      setStat,
      fsCall,
      fdToFile,
      Close,
      CloseOnExec,
      ReadDirent,
      Lstat,
      Fstat,
      Fchmod,
      Fchown,
      Ftruncate,
      Chdir,
      Fchdir,
      Fsync,
      Read,
      Write,
      Pread,
      Pwrite,
      Seek,
      Dup,
      checkPath,
      recoverErr,
      mapJSError;
    errors = $packages["errors"];
    itoa = $packages["internal/itoa"];
    oserror = $packages["internal/oserror"];
    runtime = $packages["runtime"];
    sync = $packages["sync"];
    js = $packages["syscall/js"];
    Errno = $pkg.Errno = $newType(
      4,
      $kindUintptr,
      "syscall.Errno",
      true,
      "syscall",
      true,
      null
    );
    Stat_t = $pkg.Stat_t = $newType(
      0,
      $kindStruct,
      "syscall.Stat_t",
      true,
      "syscall",
      true,
      function (
        Dev_,
        Ino_,
        Mode_,
        Nlink_,
        Uid_,
        Gid_,
        Rdev_,
        Size_,
        Blksize_,
        Blocks_,
        Atime_,
        AtimeNsec_,
        Mtime_,
        MtimeNsec_,
        Ctime_,
        CtimeNsec_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Dev = new $Int64(0, 0);
          this.Ino = new $Uint64(0, 0);
          this.Mode = 0;
          this.Nlink = 0;
          this.Uid = 0;
          this.Gid = 0;
          this.Rdev = new $Int64(0, 0);
          this.Size = new $Int64(0, 0);
          this.Blksize = 0;
          this.Blocks = 0;
          this.Atime = new $Int64(0, 0);
          this.AtimeNsec = new $Int64(0, 0);
          this.Mtime = new $Int64(0, 0);
          this.MtimeNsec = new $Int64(0, 0);
          this.Ctime = new $Int64(0, 0);
          this.CtimeNsec = new $Int64(0, 0);
          return;
        }
        this.Dev = Dev_;
        this.Ino = Ino_;
        this.Mode = Mode_;
        this.Nlink = Nlink_;
        this.Uid = Uid_;
        this.Gid = Gid_;
        this.Rdev = Rdev_;
        this.Size = Size_;
        this.Blksize = Blksize_;
        this.Blocks = Blocks_;
        this.Atime = Atime_;
        this.AtimeNsec = AtimeNsec_;
        this.Mtime = Mtime_;
        this.MtimeNsec = MtimeNsec_;
        this.Ctime = Ctime_;
        this.CtimeNsec = CtimeNsec_;
      }
    );
    Iovec = $pkg.Iovec = $newType(
      0,
      $kindStruct,
      "syscall.Iovec",
      true,
      "syscall",
      true,
      function () {
        this.$val = this;
        if (arguments.length === 0) {
          return;
        }
      }
    );
    Sockaddr = $pkg.Sockaddr = $newType(
      8,
      $kindInterface,
      "syscall.Sockaddr",
      true,
      "syscall",
      true,
      null
    );
    SockaddrInet4 = $pkg.SockaddrInet4 = $newType(
      0,
      $kindStruct,
      "syscall.SockaddrInet4",
      true,
      "syscall",
      true,
      function (Port_, Addr_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Port = 0;
          this.Addr = arrayType$3.zero();
          return;
        }
        this.Port = Port_;
        this.Addr = Addr_;
      }
    );
    SockaddrInet6 = $pkg.SockaddrInet6 = $newType(
      0,
      $kindStruct,
      "syscall.SockaddrInet6",
      true,
      "syscall",
      true,
      function (Port_, ZoneId_, Addr_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Port = 0;
          this.ZoneId = 0;
          this.Addr = arrayType$4.zero();
          return;
        }
        this.Port = Port_;
        this.ZoneId = ZoneId_;
        this.Addr = Addr_;
      }
    );
    RawConn = $pkg.RawConn = $newType(
      8,
      $kindInterface,
      "syscall.RawConn",
      true,
      "syscall",
      true,
      null
    );
    jsFile = $pkg.jsFile = $newType(
      0,
      $kindStruct,
      "syscall.jsFile",
      true,
      "syscall",
      false,
      function (path_, entries_, dirIdx_, pos_, seeked_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.path = "";
          this.entries = sliceType.nil;
          this.dirIdx = 0;
          this.pos = new $Int64(0, 0);
          this.seeked = false;
          return;
        }
        this.path = path_;
        this.entries = entries_;
        this.dirIdx = dirIdx_;
        this.pos = pos_;
        this.seeked = seeked_;
      }
    );
    callResult = $newType(
      0,
      $kindStruct,
      "syscall.callResult",
      true,
      "syscall",
      false,
      function (val_, err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.val = new js.Value.ptr(null, false, arrayType$2.zero());
          this.err = $ifaceNil;
          return;
        }
        this.val = val_;
        this.err = err_;
      }
    );
    sliceType = $sliceType($String);
    sliceType$2 = $sliceType($emptyInterface);
    ptrType = $ptrType($error);
    funcType = $funcType([], [], false);
    arrayType$2 = $arrayType(funcType, 0);
    ptrType$2 = $ptrType(jsFile);
    arrayType$3 = $arrayType($Uint8, 4);
    arrayType$4 = $arrayType($Uint8, 16);
    funcType$1 = $funcType([$Uintptr], [], false);
    funcType$2 = $funcType([$Uintptr], [$Bool], false);
    faketimeWrite = function (fd, p) {
      var fd, p;
      $panic(new $String("not implemented"));
    };
    errnoErr = function (e) {
      var _1, e;
      _1 = e;
      if (_1 === 0) {
        return $ifaceNil;
      } else if (_1 === 11) {
        return errEAGAIN;
      } else if (_1 === 22) {
        return errEINVAL;
      } else if (_1 === 2) {
        return errENOENT;
      }
      return new Errno(e);
    };
    Errno.prototype.Error = function () {
      var e, s;
      e = this.$val;
      if (0 <= e >> 0 && e >> 0 < 2054) {
        s =
          e < 0 || e >= errorstr.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : errorstr[e];
        if (!(s === "")) {
          return s;
        }
      }
      return "errno " + itoa.Itoa(e >> 0);
    };
    $ptrType(Errno).prototype.Error = function () {
      return new Errno(this.$get()).Error();
    };
    Errno.prototype.Is = function (target) {
      var _1, e, target;
      e = this.$val;
      _1 = target;
      if ($interfaceIsEqual(_1, oserror.ErrPermission)) {
        return e === 13 || e === 1;
      } else if ($interfaceIsEqual(_1, oserror.ErrExist)) {
        return e === 17 || e === 39;
      } else if ($interfaceIsEqual(_1, oserror.ErrNotExist)) {
        return e === 2;
      }
      return false;
    };
    $ptrType(Errno).prototype.Is = function (target) {
      return new Errno(this.$get()).Is(target);
    };
    Errno.prototype.Temporary = function () {
      var e;
      e = this.$val;
      return e === 4 || e === 24 || new Errno(e).Timeout();
    };
    $ptrType(Errno).prototype.Temporary = function () {
      return new Errno(this.$get()).Temporary();
    };
    Errno.prototype.Timeout = function () {
      var e;
      e = this.$val;
      return e === 11 || e === 11 || e === 110;
    };
    $ptrType(Errno).prototype.Timeout = function () {
      return new Errno(this.$get()).Timeout();
    };
    StopIO = function (fd) {
      var fd;
      return new Errno(38);
    };
    $pkg.StopIO = StopIO;
    Accept = function (fd) {
      var _tmp, _tmp$1, _tmp$2, err, fd, newfd, sa;
      newfd = 0;
      sa = $ifaceNil;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = $ifaceNil;
      _tmp$2 = new Errno(38);
      newfd = _tmp;
      sa = _tmp$1;
      err = _tmp$2;
      return [newfd, sa, err];
    };
    $pkg.Accept = Accept;
    Recvfrom = function (fd, p, flags) {
      var _tmp, _tmp$1, _tmp$2, err, fd, flags, from, n, p;
      n = 0;
      from = $ifaceNil;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = $ifaceNil;
      _tmp$2 = new Errno(38);
      n = _tmp;
      from = _tmp$1;
      err = _tmp$2;
      return [n, from, err];
    };
    $pkg.Recvfrom = Recvfrom;
    Sendto = function (fd, p, flags, to) {
      var fd, flags, p, to;
      return new Errno(38);
    };
    $pkg.Sendto = Sendto;
    Recvmsg = function (fd, p, oob, flags) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        err,
        fd,
        flags,
        from,
        n,
        oob,
        oobn,
        p,
        recvflags;
      n = 0;
      oobn = 0;
      recvflags = 0;
      from = $ifaceNil;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = 0;
      _tmp$2 = 0;
      _tmp$3 = $ifaceNil;
      _tmp$4 = new Errno(38);
      n = _tmp;
      oobn = _tmp$1;
      recvflags = _tmp$2;
      from = _tmp$3;
      err = _tmp$4;
      return [n, oobn, recvflags, from, err];
    };
    $pkg.Recvmsg = Recvmsg;
    SendmsgN = function (fd, p, oob, to, flags) {
      var _tmp, _tmp$1, err, fd, flags, n, oob, p, to;
      n = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = new Errno(38);
      n = _tmp;
      err = _tmp$1;
      return [n, err];
    };
    $pkg.SendmsgN = SendmsgN;
    SetReadDeadline = function (fd, t) {
      var fd, t;
      return new Errno(38);
    };
    $pkg.SetReadDeadline = SetReadDeadline;
    SetWriteDeadline = function (fd, t) {
      var fd, t;
      return new Errno(38);
    };
    $pkg.SetWriteDeadline = SetWriteDeadline;
    Shutdown = function (fd, how) {
      var fd, how;
      return new Errno(38);
    };
    $pkg.Shutdown = Shutdown;
    SetNonblock = function (fd, nonblocking) {
      var fd, nonblocking;
      return $ifaceNil;
    };
    $pkg.SetNonblock = SetNonblock;
    runtime_envs = function () {
      var { _r$1, envkeys, envs$1, i, jsEnv, key, process, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            process = $clone(
              $clone(js.Global(), js.Value).Get("process"),
              js.Value
            );
            if ($clone(process, js.Value).IsUndefined()) {
              $s = -1;
              return sliceType.nil;
            }
            jsEnv = $clone($clone(process, js.Value).Get("env"), js.Value);
            _r$1 = $clone(
              $clone(js.Global(), js.Value).Get("Object"),
              js.Value
            ).Call(
              "keys",
              new sliceType$2([new jsEnv.constructor.elem(jsEnv)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            envkeys = $clone(_r$1, js.Value);
            envs$1 = $makeSlice(sliceType, $clone(envkeys, js.Value).Length());
            i = 0;
            while (true) {
              if (!(i < $clone(envkeys, js.Value).Length())) {
                break;
              }
              key = $clone(
                $clone(envkeys, js.Value).Index(i),
                js.Value
              ).String();
              i < 0 || i >= envs$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (envs$1.$array[envs$1.$offset + i] =
                    key +
                    "=" +
                    $clone(
                      $clone(jsEnv, js.Value).Get(key),
                      js.Value
                    ).String());
              i = (i + 1) >> 0;
            }
            $s = -1;
            return envs$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: runtime_envs,
        $c: true,
        $r,
        _r$1,
        envkeys,
        envs$1,
        i,
        jsEnv,
        key,
        process,
        $s,
      };
      return $f;
    };
    setStat = function (st, jsSt) {
      var atime, ctime, jsSt, mtime, st;
      st.Dev = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("dev"), js.Value).Int()
      );
      st.Ino = new $Uint64(
        0,
        $clone($clone(jsSt, js.Value).Get("ino"), js.Value).Int()
      );
      st.Mode =
        $clone($clone(jsSt, js.Value).Get("mode"), js.Value).Int() >>> 0;
      st.Nlink =
        $clone($clone(jsSt, js.Value).Get("nlink"), js.Value).Int() >>> 0;
      st.Uid = $clone($clone(jsSt, js.Value).Get("uid"), js.Value).Int() >>> 0;
      st.Gid = $clone($clone(jsSt, js.Value).Get("gid"), js.Value).Int() >>> 0;
      st.Rdev = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("rdev"), js.Value).Int()
      );
      st.Size = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("size"), js.Value).Int()
      );
      st.Blksize =
        $clone($clone(jsSt, js.Value).Get("blksize"), js.Value).Int() >> 0;
      st.Blocks =
        $clone($clone(jsSt, js.Value).Get("blocks"), js.Value).Int() >> 0;
      atime = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("atimeMs"), js.Value).Float()
      );
      st.Atime = $div64(atime, new $Int64(0, 1000), false);
      st.AtimeNsec = $mul64(
        $div64(atime, new $Int64(0, 1000), true),
        new $Int64(0, 1000000)
      );
      mtime = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("mtimeMs"), js.Value).Float()
      );
      st.Mtime = $div64(mtime, new $Int64(0, 1000), false);
      st.MtimeNsec = $mul64(
        $div64(mtime, new $Int64(0, 1000), true),
        new $Int64(0, 1000000)
      );
      ctime = new $Int64(
        0,
        $clone($clone(jsSt, js.Value).Get("ctimeMs"), js.Value).Float()
      );
      st.Ctime = $div64(ctime, new $Int64(0, 1000), false);
      st.CtimeNsec = $mul64(
        $div64(ctime, new $Int64(0, 1000), true),
        new $Int64(0, 1000000)
      );
    };
    fsCall = function (name, args) {
      var {
        $24r,
        $24r$1,
        _r$1,
        _r$2,
        args,
        c,
        f,
        name,
        res,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { name, args });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              c = [c];
              c[0] = new $Chan(callResult, 1);
              f = $clone(
                js.FuncOf(
                  (function (c) {
                    return function $b(this$1, args$1) {
                      var { args$1, jsErr, res, this$1, $s, $r, $c } = $restore(
                        this,
                        { this$1, args$1 }
                      );
                      /* */ $s = $s || 0;
                      s: while (true) {
                        switch ($s) {
                          case 0:
                            res = new callResult.ptr(
                              new js.Value.ptr(null, false, arrayType$2.zero()),
                              $ifaceNil
                            );
                            if (args$1.$length >= 1) {
                              jsErr = $clone(
                                0 >= args$1.$length
                                  ? ($throwRuntimeError("index out of range"),
                                    undefined)
                                  : args$1.$array[args$1.$offset + 0],
                                js.Value
                              );
                              if (
                                !$clone(jsErr, js.Value).IsUndefined() &&
                                !$clone(jsErr, js.Value).IsNull()
                              ) {
                                res.err = mapJSError($clone(jsErr, js.Value));
                              }
                            }
                            js.Value.copy(res.val, js.Undefined());
                            if (args$1.$length >= 2) {
                              js.Value.copy(
                                res.val,
                                1 >= args$1.$length
                                  ? ($throwRuntimeError("index out of range"),
                                    undefined)
                                  : args$1.$array[args$1.$offset + 1]
                              );
                            }
                            $r = $send(
                              c[0],
                              $clone($clone(res, callResult), callResult)
                            );
                            /* */ $s = 1;
                          case 1:
                            if ($c) {
                              $c = false;
                              $r = $r.$blk();
                            }
                            if ($r && $r.$blk !== undefined) {
                              break s;
                            }
                            $s = -1;
                            return $ifaceNil;
                          /* */
                        }
                        return;
                      }
                      var $f = {
                        $blk: $b,
                        $c: true,
                        $r,
                        args$1,
                        jsErr,
                        res,
                        this$1,
                        $s,
                      };
                      return $f;
                    };
                  })(c)
                ),
                js.Func
              );
              $deferred.push([$methodVal($clone(f, js.Func), "Release"), []]);
              /* */ if (
                $clone($clone(jsFS, js.Value).Get(name), js.Value).IsUndefined()
              ) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if ($clone($clone(jsFS, js.Value).Get(name), js.Value).IsUndefined()) { */ case 1:
              $24r = [js.Undefined(), new Errno(38)];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              _r$1 = $clone(jsFS, js.Value).Call(
                name,
                $append(args, new f.constructor.elem(f))
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _r$1;
              _r$2 = $recv(c[0]);
              /* */ $s = 5;
            case 5:
              if ($c) {
                $c = false;
                _r$2 = _r$2.$blk();
              }
              if (_r$2 && _r$2.$blk !== undefined) {
                break s;
              }
              res = $clone(_r$2[0], callResult);
              $24r$1 = [res.val, res.err];
              $s = 6;
            case 6:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [new js.Value.ptr(null, false, arrayType$2.zero()), $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: fsCall,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r$1,
            _r$2,
            args,
            c,
            f,
            name,
            res,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    fdToFile = function (fd) {
      var { _entry, _tuple, f, fd, ok, $s, $r, $c } = $restore(this, { fd });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            $r = filesMu.Lock();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tuple =
              ((_entry = $mapIndex(files, $Int.keyFor(fd))),
              _entry !== undefined ? [_entry.v, true] : [ptrType$2.nil, false]);
            f = _tuple[0];
            ok = _tuple[1];
            $r = filesMu.Unlock();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (!ok) {
              $s = -1;
              return [ptrType$2.nil, new Errno(9)];
            }
            $s = -1;
            return [f, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = { $blk: fdToFile, $c: true, $r, _entry, _tuple, f, fd, ok, $s };
      return $f;
    };
    Close = function (fd) {
      var { _r$1, _tuple, err, fd, $s, $r, $c } = $restore(this, { fd });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            $r = filesMu.Lock();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $mapDelete(files, $Int.keyFor(fd));
            $r = filesMu.Unlock();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r$1 = fsCall("close", new sliceType$2([new $Int(fd)]));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = { $blk: Close, $c: true, $r, _r$1, _tuple, err, fd, $s };
      return $f;
    };
    $pkg.Close = Close;
    CloseOnExec = function (fd) {
      var fd;
    };
    $pkg.CloseOnExec = CloseOnExec;
    ReadDirent = function (fd, buf) {
      var { _r$1, _tuple, buf, entry, err, f, fd, l, n, x, x$1, $s, $r, $c } =
        $restore(this, { fd, buf });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fdToFile(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            f = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            if (f.entries === sliceType.nil) {
              $s = -1;
              return [0, new Errno(22)];
            }
            n = 0;
            while (true) {
              if (!(f.dirIdx < f.entries.$length)) {
                break;
              }
              entry =
                ((x = f.entries),
                (x$1 = f.dirIdx),
                x$1 < 0 || x$1 >= x.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x.$array[x.$offset + x$1]);
              l = (2 + entry.length) >> 0;
              if (l > buf.$length) {
                break;
              }
              0 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (buf.$array[buf.$offset + 0] = (l << 24) >>> 24);
              1 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (buf.$array[buf.$offset + 1] =
                    (((l >> 8) >> 0) << 24) >>> 24);
              $copyString($subslice(buf, 2), entry);
              buf = $subslice(buf, l);
              n = (n + l) >> 0;
              f.dirIdx = (f.dirIdx + 1) >> 0;
            }
            $s = -1;
            return [n, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: ReadDirent,
        $c: true,
        $r,
        _r$1,
        _tuple,
        buf,
        entry,
        err,
        f,
        fd,
        l,
        n,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    $pkg.ReadDirent = ReadDirent;
    Lstat = function (path, st) {
      var { _r$1, _tuple, err, err$1, jsSt, path, st, $s, $r, $c } = $restore(
        this,
        { path, st }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            err = checkPath(path);
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$1 = fsCall("lstat", new sliceType$2([new $String(path)]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            jsSt = $clone(_tuple[0], js.Value);
            err$1 = _tuple[1];
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              $s = -1;
              return err$1;
            }
            setStat(st, $clone(jsSt, js.Value));
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Lstat,
        $c: true,
        $r,
        _r$1,
        _tuple,
        err,
        err$1,
        jsSt,
        path,
        st,
        $s,
      };
      return $f;
    };
    $pkg.Lstat = Lstat;
    Fstat = function (fd, st) {
      var { _r$1, _tuple, err, fd, jsSt, st, $s, $r, $c } = $restore(this, {
        fd,
        st,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fsCall("fstat", new sliceType$2([new $Int(fd)]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            jsSt = $clone(_tuple[0], js.Value);
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            setStat(st, $clone(jsSt, js.Value));
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Fstat,
        $c: true,
        $r,
        _r$1,
        _tuple,
        err,
        fd,
        jsSt,
        st,
        $s,
      };
      return $f;
    };
    $pkg.Fstat = Fstat;
    Fchmod = function (fd, mode) {
      var { _r$1, _tuple, err, fd, mode, $s, $r, $c } = $restore(this, {
        fd,
        mode,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fsCall(
              "fchmod",
              new sliceType$2([new $Int(fd), new $Uint32(mode)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = { $blk: Fchmod, $c: true, $r, _r$1, _tuple, err, fd, mode, $s };
      return $f;
    };
    $pkg.Fchmod = Fchmod;
    Fchown = function (fd, uid, gid) {
      var { _r$1, _tuple, err, fd, gid, uid, $s, $r, $c } = $restore(this, {
        fd,
        uid,
        gid,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fsCall(
              "fchown",
              new sliceType$2([
                new $Int(fd),
                new $Uint32(uid >>> 0),
                new $Uint32(gid >>> 0),
              ])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Fchown,
        $c: true,
        $r,
        _r$1,
        _tuple,
        err,
        fd,
        gid,
        uid,
        $s,
      };
      return $f;
    };
    $pkg.Fchown = Fchown;
    Ftruncate = function (fd, length) {
      var { _r$1, _tuple, err, fd, length, $s, $r, $c } = $restore(this, {
        fd,
        length,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fsCall("ftruncate", new sliceType$2([new $Int(fd), length]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Ftruncate,
        $c: true,
        $r,
        _r$1,
        _tuple,
        err,
        fd,
        length,
        $s,
      };
      return $f;
    };
    $pkg.Ftruncate = Ftruncate;
    Chdir = function (path) {
      var { $24r, $24r$1, _r$1, err, err$1, path, $s, $deferred, $r, $c } =
        $restore(this, { path });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              err = [err];
              err[0] = $ifaceNil;
              err$1 = checkPath(path);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 1:
              err[0] = err$1;
              $24r = err[0];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([
                recoverErr,
                [
                  err.$ptr ||
                    (err.$ptr = new ptrType(
                      function () {
                        return this.$target[0];
                      },
                      function ($v) {
                        this.$target[0] = $v;
                      },
                      err
                    )),
                ],
              ]);
              _r$1 = $clone(jsProcess, js.Value).Call(
                "chdir",
                new sliceType$2([new $String(path)])
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _r$1;
              $24r$1 = err[0];
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return err[0];
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Chdir,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r$1,
            err,
            err$1,
            path,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    $pkg.Chdir = Chdir;
    Fchdir = function (fd) {
      var { $24r, _r$1, _r$2, _tuple, err, f, fd, $s, $r, $c } = $restore(
        this,
        { fd }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fdToFile(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            f = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$2 = Chdir(f.path);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Fchdir,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        _tuple,
        err,
        f,
        fd,
        $s,
      };
      return $f;
    };
    $pkg.Fchdir = Fchdir;
    Fsync = function (fd) {
      var { _r$1, _tuple, err, fd, $s, $r, $c } = $restore(this, { fd });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fsCall("fsync", new sliceType$2([new $Int(fd)]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = { $blk: Fsync, $c: true, $r, _r$1, _tuple, err, fd, $s };
      return $f;
    };
    $pkg.Fsync = Fsync;
    Read = function (fd, b) {
      var {
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        b,
        buf,
        err,
        err$1,
        f,
        fd,
        n,
        n$1,
        n2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
        $r,
        $c,
      } = $restore(this, { fd, b });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fdToFile(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            f = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            /* */ if (f.seeked) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (f.seeked) { */ case 2:
            _r$2 = Pread(fd, b, f.pos);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r$2;
            n = _tuple$1[0];
            err$1 = _tuple$1[1];
            f.pos =
              ((x = f.pos),
              (x$1 = new $Int64(0, n)),
              new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
            $s = -1;
            return [n, err$1];
          /* } */ case 3:
            _r$3 = $clone(uint8Array, js.Value).New(
              new sliceType$2([new $Int(b.$length)])
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            buf = $clone(_r$3, js.Value);
            _r$4 = fsCall(
              "read",
              new sliceType$2([
                new $Int(fd),
                new buf.constructor.elem(buf),
                new $Int(0),
                new $Int(b.$length),
                $ifaceNil,
              ])
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _tuple$2 = _r$4;
            n$1 = $clone(_tuple$2[0], js.Value);
            err = _tuple$2[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            js.CopyBytesToGo(b, $clone(buf, js.Value));
            n2 = $clone(n$1, js.Value).Int();
            f.pos =
              ((x$2 = f.pos),
              (x$3 = new $Int64(0, n2)),
              new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
            $s = -1;
            return [n2, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Read,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        b,
        buf,
        err,
        err$1,
        f,
        fd,
        n,
        n$1,
        n2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
      };
      return $f;
    };
    $pkg.Read = Read;
    Write = function (fd, b) {
      var {
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        b,
        buf,
        err,
        err$1,
        f,
        fd,
        n,
        n$1,
        n$2,
        n2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
        $r,
        $c,
      } = $restore(this, { fd, b });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = fdToFile(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            f = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            /* */ if (f.seeked) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (f.seeked) { */ case 2:
            _r$2 = Pwrite(fd, b, f.pos);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r$2;
            n = _tuple$1[0];
            err$1 = _tuple$1[1];
            f.pos =
              ((x = f.pos),
              (x$1 = new $Int64(0, n)),
              new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
            $s = -1;
            return [n, err$1];
          /* } */ case 3:
            if (false && (fd === 1 || fd === 2)) {
              n$1 = faketimeWrite(fd, b);
              if (n$1 < 0) {
                $s = -1;
                return [0, errnoErr(-n$1 >>> 0)];
              }
              $s = -1;
              return [n$1, $ifaceNil];
            }
            _r$3 = $clone(uint8Array, js.Value).New(
              new sliceType$2([new $Int(b.$length)])
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            buf = $clone(_r$3, js.Value);
            js.CopyBytesToJS($clone(buf, js.Value), b);
            _r$4 = fsCall(
              "write",
              new sliceType$2([
                new $Int(fd),
                new buf.constructor.elem(buf),
                new $Int(0),
                new $Int(b.$length),
                $ifaceNil,
              ])
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _tuple$2 = _r$4;
            n$2 = $clone(_tuple$2[0], js.Value);
            err = _tuple$2[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            n2 = $clone(n$2, js.Value).Int();
            f.pos =
              ((x$2 = f.pos),
              (x$3 = new $Int64(0, n2)),
              new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
            $s = -1;
            return [n2, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Write,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        b,
        buf,
        err,
        err$1,
        f,
        fd,
        n,
        n$1,
        n$2,
        n2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
      };
      return $f;
    };
    $pkg.Write = Write;
    Pread = function (fd, b, offset) {
      var { _r$1, _r$2, _tuple, b, buf, err, fd, n, offset, $s, $r, $c } =
        $restore(this, { fd, b, offset });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = $clone(uint8Array, js.Value).New(
              new sliceType$2([new $Int(b.$length)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            buf = $clone(_r$1, js.Value);
            _r$2 = fsCall(
              "read",
              new sliceType$2([
                new $Int(fd),
                new buf.constructor.elem(buf),
                new $Int(0),
                new $Int(b.$length),
                offset,
              ])
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            n = $clone(_tuple[0], js.Value);
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            js.CopyBytesToGo(b, $clone(buf, js.Value));
            $s = -1;
            return [$clone(n, js.Value).Int(), $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Pread,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _tuple,
        b,
        buf,
        err,
        fd,
        n,
        offset,
        $s,
      };
      return $f;
    };
    $pkg.Pread = Pread;
    Pwrite = function (fd, b, offset) {
      var { _r$1, _r$2, _tuple, b, buf, err, fd, n, offset, $s, $r, $c } =
        $restore(this, { fd, b, offset });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = $clone(uint8Array, js.Value).New(
              new sliceType$2([new $Int(b.$length)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            buf = $clone(_r$1, js.Value);
            js.CopyBytesToJS($clone(buf, js.Value), b);
            _r$2 = fsCall(
              "write",
              new sliceType$2([
                new $Int(fd),
                new buf.constructor.elem(buf),
                new $Int(0),
                new $Int(b.$length),
                offset,
              ])
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            n = $clone(_tuple[0], js.Value);
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            $s = -1;
            return [$clone(n, js.Value).Int(), $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Pwrite,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _tuple,
        b,
        buf,
        err,
        fd,
        n,
        offset,
        $s,
      };
      return $f;
    };
    $pkg.Pwrite = Pwrite;
    Seek = function (fd, offset, whence) {
      var {
        _1,
        _r$1,
        _r$2,
        _tuple,
        err,
        err$1,
        f,
        fd,
        newPos,
        offset,
        st,
        whence,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { fd, offset, whence });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            st = [st];
            _r$1 = fdToFile(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            f = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [new $Int64(0, 0), err];
            }
            newPos = new $Int64(0, 0);
            _1 = whence;
            /* */ if (_1 === 0) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 1) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 2) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (_1 === (0)) { */ case 3:
            newPos = offset;
            $s = 7;
            continue;
          /* } else if (_1 === (1)) { */ case 4:
            newPos =
              ((x = f.pos),
              new $Int64(x.$high + offset.$high, x.$low + offset.$low));
            $s = 7;
            continue;
          /* } else if (_1 === (2)) { */ case 5:
            st[0] = new Stat_t.ptr(
              new $Int64(0, 0),
              new $Uint64(0, 0),
              0,
              0,
              0,
              0,
              new $Int64(0, 0),
              new $Int64(0, 0),
              0,
              0,
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0)
            );
            _r$2 = Fstat(fd, st[0]);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            err$1 = _r$2;
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              $s = -1;
              return [new $Int64(0, 0), err$1];
            }
            newPos =
              ((x$1 = st[0].Size),
              new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
            $s = 7;
            continue;
          /* } else { */ case 6:
            $s = -1;
            return [new $Int64(0, 0), errnoErr(22)];
          /* } */ case 7:
          case 2:
            if (newPos.$high < 0 || (newPos.$high === 0 && newPos.$low < 0)) {
              $s = -1;
              return [new $Int64(0, 0), errnoErr(22)];
            }
            f.seeked = true;
            f.dirIdx = 0;
            f.pos = newPos;
            $s = -1;
            return [newPos, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Seek,
        $c: true,
        $r,
        _1,
        _r$1,
        _r$2,
        _tuple,
        err,
        err$1,
        f,
        fd,
        newPos,
        offset,
        st,
        whence,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    $pkg.Seek = Seek;
    Dup = function (fd) {
      var fd;
      return [0, new Errno(38)];
    };
    $pkg.Dup = Dup;
    checkPath = function (path) {
      var i, path;
      if (path === "") {
        return new Errno(22);
      }
      i = 0;
      while (true) {
        if (!(i < path.length)) {
          break;
        }
        if (path.charCodeAt(i) === 0) {
          return new Errno(22);
        }
        i = (i + 1) >> 0;
      }
      return $ifaceNil;
    };
    recoverErr = function (errPtr) {
      var _tuple, err, errPtr, jsErr, ok;
      err = $recover();
      if (!$interfaceIsEqual(err, $ifaceNil)) {
        _tuple = $assertType(err, js.Error, true);
        jsErr = $clone(_tuple[0], js.Error);
        ok = _tuple[1];
        if (!ok) {
          $panic(err);
        }
        errPtr.$set(mapJSError($clone(jsErr.Value, js.Value)));
      }
    };
    mapJSError = function (jsErr) {
      var _entry, _tuple, errno, jsErr, ok;
      _tuple =
        ((_entry = $mapIndex(
          errnoByCode,
          $String.keyFor(
            $clone($clone(jsErr, js.Value).Get("code"), js.Value).String()
          )
        )),
        _entry !== undefined ? [_entry.v, true] : [0, false]);
      errno = _tuple[0];
      ok = _tuple[1];
      if (!ok) {
        $panic(new jsErr.constructor.elem(jsErr));
      }
      return errnoErr(errno);
    };
    Errno.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Is",
        name: "Is",
        pkg: "",
        typ: $funcType([$error], [$Bool], false),
      },
      {
        prop: "Temporary",
        name: "Temporary",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    Stat_t.init("", [
      {
        prop: "Dev",
        name: "Dev",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "Ino",
        name: "Ino",
        embedded: false,
        exported: true,
        typ: $Uint64,
        tag: "",
      },
      {
        prop: "Mode",
        name: "Mode",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Nlink",
        name: "Nlink",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Uid",
        name: "Uid",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Gid",
        name: "Gid",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Rdev",
        name: "Rdev",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "Size",
        name: "Size",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "Blksize",
        name: "Blksize",
        embedded: false,
        exported: true,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "Blocks",
        name: "Blocks",
        embedded: false,
        exported: true,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "Atime",
        name: "Atime",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "AtimeNsec",
        name: "AtimeNsec",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "Mtime",
        name: "Mtime",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "MtimeNsec",
        name: "MtimeNsec",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "Ctime",
        name: "Ctime",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "CtimeNsec",
        name: "CtimeNsec",
        embedded: false,
        exported: true,
        typ: $Int64,
        tag: "",
      },
    ]);
    Iovec.init("", []);
    Sockaddr.init([]);
    SockaddrInet4.init("", [
      {
        prop: "Port",
        name: "Port",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Addr",
        name: "Addr",
        embedded: false,
        exported: true,
        typ: arrayType$3,
        tag: "",
      },
    ]);
    SockaddrInet6.init("", [
      {
        prop: "Port",
        name: "Port",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "ZoneId",
        name: "ZoneId",
        embedded: false,
        exported: true,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "Addr",
        name: "Addr",
        embedded: false,
        exported: true,
        typ: arrayType$4,
        tag: "",
      },
    ]);
    RawConn.init([
      {
        prop: "Control",
        name: "Control",
        pkg: "",
        typ: $funcType([funcType$1], [$error], false),
      },
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([funcType$2], [$error], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([funcType$2], [$error], false),
      },
    ]);
    jsFile.init("syscall", [
      {
        prop: "path",
        name: "path",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "entries",
        name: "entries",
        embedded: false,
        exported: false,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "dirIdx",
        name: "dirIdx",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "pos",
        name: "pos",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "seeked",
        name: "seeked",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    callResult.init("syscall", [
      {
        prop: "val",
        name: "val",
        embedded: false,
        exported: false,
        typ: js.Value,
        tag: "",
      },
      {
        prop: "err",
        name: "err",
        embedded: false,
        exported: false,
        typ: $error,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = itoa.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = oserror.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ForkLock = new sync.RWMutex.ptr(
              new sync.Mutex.ptr(0, 0),
              0,
              0,
              0,
              0
            );
            filesMu = new sync.Mutex.ptr(0, 0);
            errorstr = $toNativeArray($kindString, [
              "",
              "Operation not permitted",
              "No such file or directory",
              "No such process",
              "Interrupted system call",
              "I/O error",
              "No such device or address",
              "Argument list too long",
              "Exec format error",
              "Bad file number",
              "No child processes",
              "Try again",
              "Out of memory",
              "Permission denied",
              "Bad address",
              "",
              "Device or resource busy",
              "File exists",
              "Cross-device link",
              "No such device",
              "Not a directory",
              "Is a directory",
              "Invalid argument",
              "File table overflow",
              "Too many open files",
              "Not a typewriter",
              "",
              "File too large",
              "No space left on device",
              "Illegal seek",
              "Read-only file system",
              "Too many links",
              "Broken pipe",
              "Math arg out of domain of func",
              "Math result not representable",
              "Deadlock condition",
              "File name too long",
              "No record locks available",
              "not implemented on js",
              "Directory not empty",
              "Too many symbolic links",
              "",
              "No message of desired type",
              "Identifier removed",
              "Channel number out of range",
              "Level 2 not synchronized",
              "Level 3 halted",
              "Level 3 reset",
              "Link number out of range",
              "Protocol driver not attached",
              "No CSI structure available",
              "Level 2 halted",
              "Invalid exchange",
              "Invalid request descriptor",
              "Exchange full",
              "No anode",
              "Invalid request code",
              "Invalid slot",
              "",
              "Bad font file fmt",
              "Device not a stream",
              "No data (for no delay io)",
              "Timer expired",
              "Out of streams resources",
              "Machine is not on the network",
              "Package not installed",
              "The object is remote",
              "The link has been severed",
              "Advertise error",
              "Srmount error",
              "Communication error on send",
              "Protocol error",
              "Multihop attempted",
              "Cross mount point (not really error)",
              "Trying to read unreadable message",
              "Value too large for defined data type",
              "Given log. name not unique",
              "f.d. invalid for this operation",
              "Remote address changed",
              "Can't access a needed shared lib",
              "Accessing a corrupted shared lib",
              ".lib section in a.out corrupted",
              "Attempting to link in too many libs",
              "Attempting to exec a shared library",
              "",
              "",
              "",
              "",
              "Socket operation on non-socket",
              "Destination address required",
              "Message too long",
              "Protocol wrong type for socket",
              "Protocol not available",
              "Unknown protocol",
              "Socket type not supported",
              "Operation not supported on transport endpoint",
              "Protocol family not supported",
              "Address family not supported by protocol family",
              "Address already in use",
              "Address not available",
              "Network interface is not configured",
              "Network is unreachable",
              "",
              "Connection aborted",
              "Connection reset by peer",
              "No buffer space available",
              "Socket is already connected",
              "Socket is not connected",
              "Can't send after socket shutdown",
              "",
              "Connection timed out",
              "Connection refused",
              "Host is down",
              "Host is unreachable",
              "Socket already connected",
              "Connection already in progress",
              "",
              "",
              "",
              "",
              "",
              "",
              "Quota exceeded",
              "No medium (in tape drive)",
              "",
              "Operation canceled.",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "",
              "Inode is remote (not really error)",
              "Inappropriate file type or format",
              "No more files",
              "",
              "No such host or network path",
              "Filename exists with different case",
            ]);
            errEAGAIN = new Errno(11);
            errEINVAL = new Errno(22);
            errENOENT = new Errno(2);
            errnoByCode = $makeMap($String.keyFor, [
              { k: "EPERM", v: 1 },
              { k: "ENOENT", v: 2 },
              { k: "ESRCH", v: 3 },
              { k: "EINTR", v: 4 },
              { k: "EIO", v: 5 },
              { k: "ENXIO", v: 6 },
              { k: "E2BIG", v: 7 },
              { k: "ENOEXEC", v: 8 },
              { k: "EBADF", v: 9 },
              { k: "ECHILD", v: 10 },
              { k: "EAGAIN", v: 11 },
              { k: "ENOMEM", v: 12 },
              { k: "EACCES", v: 13 },
              { k: "EFAULT", v: 14 },
              { k: "EBUSY", v: 16 },
              { k: "EEXIST", v: 17 },
              { k: "EXDEV", v: 18 },
              { k: "ENODEV", v: 19 },
              { k: "ENOTDIR", v: 20 },
              { k: "EISDIR", v: 21 },
              { k: "EINVAL", v: 22 },
              { k: "ENFILE", v: 23 },
              { k: "EMFILE", v: 24 },
              { k: "ENOTTY", v: 25 },
              { k: "EFBIG", v: 27 },
              { k: "ENOSPC", v: 28 },
              { k: "ESPIPE", v: 29 },
              { k: "EROFS", v: 30 },
              { k: "EMLINK", v: 31 },
              { k: "EPIPE", v: 32 },
              { k: "ENAMETOOLONG", v: 36 },
              { k: "ENOSYS", v: 38 },
              { k: "EDQUOT", v: 122 },
              { k: "EDOM", v: 33 },
              { k: "ERANGE", v: 34 },
              { k: "EDEADLK", v: 35 },
              { k: "ENOLCK", v: 37 },
              { k: "ENOTEMPTY", v: 39 },
              { k: "ELOOP", v: 40 },
              { k: "ENOMSG", v: 42 },
              { k: "EIDRM", v: 43 },
              { k: "ECHRNG", v: 44 },
              { k: "EL2NSYNC", v: 45 },
              { k: "EL3HLT", v: 46 },
              { k: "EL3RST", v: 47 },
              { k: "ELNRNG", v: 48 },
              { k: "EUNATCH", v: 49 },
              { k: "ENOCSI", v: 50 },
              { k: "EL2HLT", v: 51 },
              { k: "EBADE", v: 52 },
              { k: "EBADR", v: 53 },
              { k: "EXFULL", v: 54 },
              { k: "ENOANO", v: 55 },
              { k: "EBADRQC", v: 56 },
              { k: "EBADSLT", v: 57 },
              { k: "EDEADLOCK", v: 35 },
              { k: "EBFONT", v: 59 },
              { k: "ENOSTR", v: 60 },
              { k: "ENODATA", v: 61 },
              { k: "ETIME", v: 62 },
              { k: "ENOSR", v: 63 },
              { k: "ENONET", v: 64 },
              { k: "ENOPKG", v: 65 },
              { k: "EREMOTE", v: 66 },
              { k: "ENOLINK", v: 67 },
              { k: "EADV", v: 68 },
              { k: "ESRMNT", v: 69 },
              { k: "ECOMM", v: 70 },
              { k: "EPROTO", v: 71 },
              { k: "EMULTIHOP", v: 72 },
              { k: "EDOTDOT", v: 73 },
              { k: "EBADMSG", v: 74 },
              { k: "EOVERFLOW", v: 75 },
              { k: "ENOTUNIQ", v: 76 },
              { k: "EBADFD", v: 77 },
              { k: "EREMCHG", v: 78 },
              { k: "ELIBACC", v: 79 },
              { k: "ELIBBAD", v: 80 },
              { k: "ELIBSCN", v: 81 },
              { k: "ELIBMAX", v: 82 },
              { k: "ELIBEXEC", v: 83 },
              { k: "EILSEQ", v: 84 },
              { k: "EUSERS", v: 87 },
              { k: "ENOTSOCK", v: 88 },
              { k: "EDESTADDRREQ", v: 89 },
              { k: "EMSGSIZE", v: 90 },
              { k: "EPROTOTYPE", v: 91 },
              { k: "ENOPROTOOPT", v: 92 },
              { k: "EPROTONOSUPPORT", v: 93 },
              { k: "ESOCKTNOSUPPORT", v: 94 },
              { k: "EOPNOTSUPP", v: 95 },
              { k: "EPFNOSUPPORT", v: 96 },
              { k: "EAFNOSUPPORT", v: 97 },
              { k: "EADDRINUSE", v: 98 },
              { k: "EADDRNOTAVAIL", v: 99 },
              { k: "ENETDOWN", v: 100 },
              { k: "ENETUNREACH", v: 101 },
              { k: "ENETRESET", v: 102 },
              { k: "ECONNABORTED", v: 103 },
              { k: "ECONNRESET", v: 104 },
              { k: "ENOBUFS", v: 105 },
              { k: "EISCONN", v: 106 },
              { k: "ENOTCONN", v: 107 },
              { k: "ESHUTDOWN", v: 108 },
              { k: "ETOOMANYREFS", v: 109 },
              { k: "ETIMEDOUT", v: 110 },
              { k: "ECONNREFUSED", v: 111 },
              { k: "EHOSTDOWN", v: 112 },
              { k: "EHOSTUNREACH", v: 113 },
              { k: "EALREADY", v: 114 },
              { k: "EINPROGRESS", v: 115 },
              { k: "ESTALE", v: 116 },
              { k: "ENOTSUP", v: 95 },
              { k: "ENOMEDIUM", v: 123 },
              { k: "ECANCELED", v: 125 },
              { k: "ELBIN", v: 2048 },
              { k: "EFTYPE", v: 2049 },
              { k: "ENMFILE", v: 2050 },
              { k: "EPROCLIM", v: 2051 },
              { k: "ENOSHARE", v: 2052 },
              { k: "ECASECLASH", v: 2053 },
              { k: "EWOULDBLOCK", v: 11 },
            ]);
            jsProcess = $clone(
              $clone(js.Global(), js.Value).Get("process"),
              js.Value
            );
            jsFS = $clone($clone(js.Global(), js.Value).Get("fs"), js.Value);
            constants = $clone(
              $clone(jsFS, js.Value).Get("constants"),
              js.Value
            );
            uint8Array = $clone(
              $clone(js.Global(), js.Value).Get("Uint8Array"),
              js.Value
            );
            nodeWRONLY = $clone(
              $clone(constants, js.Value).Get("O_WRONLY"),
              js.Value
            ).Int();
            nodeRDWR = $clone(
              $clone(constants, js.Value).Get("O_RDWR"),
              js.Value
            ).Int();
            nodeCREATE = $clone(
              $clone(constants, js.Value).Get("O_CREAT"),
              js.Value
            ).Int();
            nodeTRUNC = $clone(
              $clone(constants, js.Value).Get("O_TRUNC"),
              js.Value
            ).Int();
            nodeAPPEND = $clone(
              $clone(constants, js.Value).Get("O_APPEND"),
              js.Value
            ).Int();
            nodeEXCL = $clone(
              $clone(constants, js.Value).Get("O_EXCL"),
              js.Value
            ).Int();
            files = $makeMap($Int.keyFor, [
              {
                k: 0,
                v: new jsFile.ptr(
                  "",
                  sliceType.nil,
                  0,
                  new $Int64(0, 0),
                  false
                ),
              },
              {
                k: 1,
                v: new jsFile.ptr(
                  "",
                  sliceType.nil,
                  0,
                  new $Int64(0, 0),
                  false
                ),
              },
              {
                k: 2,
                v: new jsFile.ptr(
                  "",
                  sliceType.nil,
                  0,
                  new $Int64(0, 0),
                  false
                ),
              },
            ]);
            _r = runtime_envs();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            envs = _r;
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/syscall/unix"] = (function () {
    var $pkg = {},
      $init,
      syscall,
      IsNonblock,
      RecvfromInet4,
      RecvfromInet6,
      SendtoInet4,
      SendtoInet6,
      SendmsgNInet4,
      SendmsgNInet6,
      RecvmsgInet4,
      RecvmsgInet6;
    syscall = $packages["syscall"];
    IsNonblock = function (fd) {
      var _tmp, _tmp$1, err, fd, nonblocking;
      nonblocking = false;
      err = $ifaceNil;
      _tmp = false;
      _tmp$1 = $ifaceNil;
      nonblocking = _tmp;
      err = _tmp$1;
      return [nonblocking, err];
    };
    $pkg.IsNonblock = IsNonblock;
    RecvfromInet4 = function (fd, p, flags, from) {
      var fd, flags, from, p;
      return [0, new syscall.Errno(38)];
    };
    $pkg.RecvfromInet4 = RecvfromInet4;
    RecvfromInet6 = function (fd, p, flags, from) {
      var _tmp, _tmp$1, err, fd, flags, from, n, p;
      n = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = new syscall.Errno(38);
      n = _tmp;
      err = _tmp$1;
      return [n, err];
    };
    $pkg.RecvfromInet6 = RecvfromInet6;
    SendtoInet4 = function (fd, p, flags, to) {
      var err, fd, flags, p, to;
      err = $ifaceNil;
      err = new syscall.Errno(38);
      return err;
    };
    $pkg.SendtoInet4 = SendtoInet4;
    SendtoInet6 = function (fd, p, flags, to) {
      var err, fd, flags, p, to;
      err = $ifaceNil;
      err = new syscall.Errno(38);
      return err;
    };
    $pkg.SendtoInet6 = SendtoInet6;
    SendmsgNInet4 = function (fd, p, oob, to, flags) {
      var _tmp, _tmp$1, err, fd, flags, n, oob, p, to;
      n = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = new syscall.Errno(38);
      n = _tmp;
      err = _tmp$1;
      return [n, err];
    };
    $pkg.SendmsgNInet4 = SendmsgNInet4;
    SendmsgNInet6 = function (fd, p, oob, to, flags) {
      var _tmp, _tmp$1, err, fd, flags, n, oob, p, to;
      n = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = new syscall.Errno(38);
      n = _tmp;
      err = _tmp$1;
      return [n, err];
    };
    $pkg.SendmsgNInet6 = SendmsgNInet6;
    RecvmsgInet4 = function (fd, p, oob, flags, from) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        err,
        fd,
        flags,
        from,
        n,
        oob,
        oobn,
        p,
        recvflags;
      n = 0;
      oobn = 0;
      recvflags = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = 0;
      _tmp$2 = 0;
      _tmp$3 = new syscall.Errno(38);
      n = _tmp;
      oobn = _tmp$1;
      recvflags = _tmp$2;
      err = _tmp$3;
      return [n, oobn, recvflags, err];
    };
    $pkg.RecvmsgInet4 = RecvmsgInet4;
    RecvmsgInet6 = function (fd, p, oob, flags, from) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        err,
        fd,
        flags,
        from,
        n,
        oob,
        oobn,
        p,
        recvflags;
      n = 0;
      oobn = 0;
      recvflags = 0;
      err = $ifaceNil;
      _tmp = 0;
      _tmp$1 = 0;
      _tmp$2 = 0;
      _tmp$3 = new syscall.Errno(38);
      n = _tmp;
      oobn = _tmp$1;
      recvflags = _tmp$2;
      err = _tmp$3;
      return [n, oobn, recvflags, err];
    };
    $pkg.RecvmsgInet6 = RecvmsgInet6;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = syscall.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["github.com/gopherjs/gopherjs/nosync"] = (function () {
    var $pkg = {},
      $init,
      Once,
      Mutex,
      RWMutex,
      funcType$1,
      ptrType$1,
      ptrType$2,
      ptrType$3;
    Once = $pkg.Once = $newType(
      0,
      $kindStruct,
      "nosync.Once",
      true,
      "github.com/gopherjs/gopherjs/nosync",
      true,
      function (doing_, done_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.doing = false;
          this.done = false;
          return;
        }
        this.doing = doing_;
        this.done = done_;
      }
    );
    Mutex = $pkg.Mutex = $newType(
      0,
      $kindStruct,
      "nosync.Mutex",
      true,
      "github.com/gopherjs/gopherjs/nosync",
      true,
      function (locked_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.locked = false;
          return;
        }
        this.locked = locked_;
      }
    );
    RWMutex = $pkg.RWMutex = $newType(
      0,
      $kindStruct,
      "nosync.RWMutex",
      true,
      "github.com/gopherjs/gopherjs/nosync",
      true,
      function (writeLocked_, readLockCounter_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.writeLocked = false;
          this.readLockCounter = 0;
          return;
        }
        this.writeLocked = writeLocked_;
        this.readLockCounter = readLockCounter_;
      }
    );
    funcType$1 = $funcType([], [], false);
    ptrType$1 = $ptrType(Once);
    ptrType$2 = $ptrType(Mutex);
    ptrType$3 = $ptrType(RWMutex);
    Once.ptr.prototype.Do = function (f) {
      var { f, o, $s, $deferred, $r, $c } = $restore(this, { f });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              o = [o];
              o[0] = this;
              /* */ if (o[0].done) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (o[0].done) { */ case 1:
              $s = 3;
            case 3:
              return;
            /* } */ case 2:
              if (o[0].doing) {
                $panic(new $String("nosync: Do called within f"));
              }
              o[0].doing = true;
              $deferred.push([
                (function (o) {
                  return function () {
                    o[0].doing = false;
                    o[0].done = true;
                  };
                })(o),
                [],
              ]);
              $r = f();
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $s = -1;
              return;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Once.ptr.prototype.Do,
            $c: true,
            $r,
            f,
            o,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    Once.prototype.Do = function (f) {
      return this.$val.Do(f);
    };
    Mutex.ptr.prototype.Lock = function () {
      var m;
      m = this;
      if (m.locked) {
        $panic(new $String("nosync: mutex is already locked"));
      }
      m.locked = true;
    };
    Mutex.prototype.Lock = function () {
      return this.$val.Lock();
    };
    Mutex.ptr.prototype.Unlock = function () {
      var m;
      m = this;
      if (!m.locked) {
        $panic(new $String("nosync: unlock of unlocked mutex"));
      }
      m.locked = false;
    };
    Mutex.prototype.Unlock = function () {
      return this.$val.Unlock();
    };
    RWMutex.ptr.prototype.Lock = function () {
      var rw;
      rw = this;
      if (!(rw.readLockCounter === 0) || rw.writeLocked) {
        $panic(new $String("nosync: mutex is already locked"));
      }
      rw.writeLocked = true;
    };
    RWMutex.prototype.Lock = function () {
      return this.$val.Lock();
    };
    RWMutex.ptr.prototype.Unlock = function () {
      var rw;
      rw = this;
      if (!rw.writeLocked) {
        $panic(new $String("nosync: unlock of unlocked mutex"));
      }
      rw.writeLocked = false;
    };
    RWMutex.prototype.Unlock = function () {
      return this.$val.Unlock();
    };
    RWMutex.ptr.prototype.RLock = function () {
      var rw;
      rw = this;
      if (rw.writeLocked) {
        $panic(new $String("nosync: mutex is already locked"));
      }
      rw.readLockCounter = (rw.readLockCounter + 1) >> 0;
    };
    RWMutex.prototype.RLock = function () {
      return this.$val.RLock();
    };
    RWMutex.ptr.prototype.RUnlock = function () {
      var rw;
      rw = this;
      if (rw.readLockCounter === 0) {
        $panic(new $String("nosync: unlock of unlocked mutex"));
      }
      rw.readLockCounter = (rw.readLockCounter - 1) >> 0;
    };
    RWMutex.prototype.RUnlock = function () {
      return this.$val.RUnlock();
    };
    ptrType$1.methods = [
      {
        prop: "Do",
        name: "Do",
        pkg: "",
        typ: $funcType([funcType$1], [], false),
      },
    ];
    ptrType$2.methods = [
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ];
    ptrType$3.methods = [
      { prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "Unlock",
        name: "Unlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
      { prop: "RLock", name: "RLock", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "RUnlock",
        name: "RUnlock",
        pkg: "",
        typ: $funcType([], [], false),
      },
    ];
    Once.init("github.com/gopherjs/gopherjs/nosync", [
      {
        prop: "doing",
        name: "doing",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "done",
        name: "done",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    Mutex.init("github.com/gopherjs/gopherjs/nosync", [
      {
        prop: "locked",
        name: "locked",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    RWMutex.init("github.com/gopherjs/gopherjs/nosync", [
      {
        prop: "writeLocked",
        name: "writeLocked",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "readLockCounter",
        name: "readLockCounter",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["time"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js$1,
      nosync,
      runtime,
      syscall,
      js,
      Location,
      zone,
      zoneTrans,
      ruleKind,
      rule,
      Time,
      Month,
      Weekday,
      Duration,
      ParseError,
      sliceType,
      sliceType$1,
      ptrType,
      sliceType$2,
      sliceType$3,
      ptrType$2,
      arrayType$2,
      arrayType$3,
      arrayType$4,
      arrayType$5,
      ptrType$4,
      ptrType$8,
      badData,
      utcLoc,
      utcLoc$24ptr,
      localLoc,
      localLoc$24ptr,
      localOnce,
      errLocation,
      daysBefore,
      startNano,
      zoneSources,
      std0x,
      longDayNames,
      shortDayNames,
      shortMonthNames,
      longMonthNames,
      atoiError,
      errBad,
      errLeadingInt,
      x,
      _r,
      FixedZone,
      tzset,
      tzsetName,
      tzsetOffset,
      tzsetRule,
      tzsetNum,
      tzruleTime,
      absWeekday,
      absClock,
      fmtFrac,
      fmtInt,
      lessThanHalf,
      absDate,
      daysIn,
      daysSinceEpoch,
      runtimeNano,
      unixTime,
      Unix,
      isLeap,
      norm,
      Date,
      div,
      initLocal,
      itoa,
      init,
      startsWithLowerCase,
      nextStdChunk,
      match,
      lookup,
      appendInt,
      atoi,
      stdFracSecond,
      digitsLen,
      separator,
      formatNano,
      quote,
      isDigit,
      getnum,
      getnum3,
      cutspace,
      skip,
      Parse,
      parse,
      parseTimeZone,
      parseGMT,
      parseSignedOffset,
      commaOrPeriod,
      parseNanoseconds,
      leadingInt;
    errors = $packages["errors"];
    js$1 = $packages["github.com/gopherjs/gopherjs/js"];
    nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
    runtime = $packages["runtime"];
    syscall = $packages["syscall"];
    js = $packages["syscall/js"];
    Location = $pkg.Location = $newType(
      0,
      $kindStruct,
      "time.Location",
      true,
      "time",
      true,
      function (
        name_,
        zone_,
        tx_,
        extend_,
        cacheStart_,
        cacheEnd_,
        cacheZone_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.zone = sliceType.nil;
          this.tx = sliceType$1.nil;
          this.extend = "";
          this.cacheStart = new $Int64(0, 0);
          this.cacheEnd = new $Int64(0, 0);
          this.cacheZone = ptrType.nil;
          return;
        }
        this.name = name_;
        this.zone = zone_;
        this.tx = tx_;
        this.extend = extend_;
        this.cacheStart = cacheStart_;
        this.cacheEnd = cacheEnd_;
        this.cacheZone = cacheZone_;
      }
    );
    zone = $pkg.zone = $newType(
      0,
      $kindStruct,
      "time.zone",
      true,
      "time",
      false,
      function (name_, offset_, isDST_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.offset = 0;
          this.isDST = false;
          return;
        }
        this.name = name_;
        this.offset = offset_;
        this.isDST = isDST_;
      }
    );
    zoneTrans = $pkg.zoneTrans = $newType(
      0,
      $kindStruct,
      "time.zoneTrans",
      true,
      "time",
      false,
      function (when_, index_, isstd_, isutc_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.when = new $Int64(0, 0);
          this.index = 0;
          this.isstd = false;
          this.isutc = false;
          return;
        }
        this.when = when_;
        this.index = index_;
        this.isstd = isstd_;
        this.isutc = isutc_;
      }
    );
    ruleKind = $pkg.ruleKind = $newType(
      4,
      $kindInt,
      "time.ruleKind",
      true,
      "time",
      false,
      null
    );
    rule = $pkg.rule = $newType(
      0,
      $kindStruct,
      "time.rule",
      true,
      "time",
      false,
      function (kind_, day_, week_, mon_, time_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.kind = 0;
          this.day = 0;
          this.week = 0;
          this.mon = 0;
          this.time = 0;
          return;
        }
        this.kind = kind_;
        this.day = day_;
        this.week = week_;
        this.mon = mon_;
        this.time = time_;
      }
    );
    Time = $pkg.Time = $newType(
      0,
      $kindStruct,
      "time.Time",
      true,
      "time",
      true,
      function (wall_, ext_, loc_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.wall = new $Uint64(0, 0);
          this.ext = new $Int64(0, 0);
          this.loc = ptrType$2.nil;
          return;
        }
        this.wall = wall_;
        this.ext = ext_;
        this.loc = loc_;
      }
    );
    Month = $pkg.Month = $newType(
      4,
      $kindInt,
      "time.Month",
      true,
      "time",
      true,
      null
    );
    Weekday = $pkg.Weekday = $newType(
      4,
      $kindInt,
      "time.Weekday",
      true,
      "time",
      true,
      null
    );
    Duration = $pkg.Duration = $newType(
      8,
      $kindInt64,
      "time.Duration",
      true,
      "time",
      true,
      null
    );
    ParseError = $pkg.ParseError = $newType(
      0,
      $kindStruct,
      "time.ParseError",
      true,
      "time",
      true,
      function (Layout_, Value_, LayoutElem_, ValueElem_, Message_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Layout = "";
          this.Value = "";
          this.LayoutElem = "";
          this.ValueElem = "";
          this.Message = "";
          return;
        }
        this.Layout = Layout_;
        this.Value = Value_;
        this.LayoutElem = LayoutElem_;
        this.ValueElem = ValueElem_;
        this.Message = Message_;
      }
    );
    sliceType = $sliceType(zone);
    sliceType$1 = $sliceType(zoneTrans);
    ptrType = $ptrType(zone);
    sliceType$2 = $sliceType($String);
    sliceType$3 = $sliceType($Uint8);
    ptrType$2 = $ptrType(Location);
    arrayType$2 = $arrayType($Uint8, 32);
    arrayType$3 = $arrayType($Uint8, 20);
    arrayType$4 = $arrayType($Uint8, 9);
    arrayType$5 = $arrayType($Uint8, 64);
    ptrType$4 = $ptrType(Time);
    ptrType$8 = $ptrType(ParseError);
    Location.ptr.prototype.get = function () {
      var { l, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            l = this;
            if (l === ptrType$2.nil) {
              $s = -1;
              return utcLoc;
            }
            /* */ if (l === localLoc) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (l === localLoc) { */ case 1:
            $r = localOnce.Do(initLocal);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            $s = -1;
            return l;
          /* */
        }
        return;
      }
      var $f = { $blk: Location.ptr.prototype.get, $c: true, $r, l, $s };
      return $f;
    };
    Location.prototype.get = function () {
      return this.$val.get();
    };
    Location.ptr.prototype.String = function () {
      var { $24r, _r$1, l, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            l = this;
            _r$1 = l.get();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1.name;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Location.ptr.prototype.String,
        $c: true,
        $r,
        $24r,
        _r$1,
        l,
        $s,
      };
      return $f;
    };
    Location.prototype.String = function () {
      return this.$val.String();
    };
    FixedZone = function (name, offset) {
      var l, name, offset, x$1;
      l = new Location.ptr(
        name,
        new sliceType([new zone.ptr(name, offset, false)]),
        new sliceType$1([
          new zoneTrans.ptr(new $Int64(-2147483648, 0), 0, false, false),
        ]),
        "",
        new $Int64(-2147483648, 0),
        new $Int64(2147483647, 4294967295),
        ptrType.nil
      );
      l.cacheZone =
        ((x$1 = l.zone),
        0 >= x$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$1.$array[x$1.$offset + 0]);
      return l;
    };
    $pkg.FixedZone = FixedZone;
    Location.ptr.prototype.lookup = function (sec) {
      var {
        _q,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tuple,
        eend,
        eisDST,
        ename,
        end,
        eoffset,
        estart,
        hi,
        isDST,
        l,
        lim,
        lo,
        m,
        name,
        offset,
        ok,
        sec,
        start,
        tx,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        zone$1,
        zone$2,
        zone$3,
        $s,
        $r,
        $c,
      } = $restore(this, { sec });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            name = "";
            offset = 0;
            start = new $Int64(0, 0);
            end = new $Int64(0, 0);
            isDST = false;
            l = this;
            _r$1 = l.get();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            l = _r$1;
            if (l.zone.$length === 0) {
              name = "UTC";
              offset = 0;
              start = new $Int64(-2147483648, 0);
              end = new $Int64(2147483647, 4294967295);
              isDST = false;
              $s = -1;
              return [name, offset, start, end, isDST];
            }
            zone$1 = l.cacheZone;
            if (
              !(zone$1 === ptrType.nil) &&
              ((x$1 = l.cacheStart),
              x$1.$high < sec.$high ||
                (x$1.$high === sec.$high && x$1.$low <= sec.$low)) &&
              ((x$2 = l.cacheEnd),
              sec.$high < x$2.$high ||
                (sec.$high === x$2.$high && sec.$low < x$2.$low))
            ) {
              name = zone$1.name;
              offset = zone$1.offset;
              start = l.cacheStart;
              end = l.cacheEnd;
              isDST = zone$1.isDST;
              $s = -1;
              return [name, offset, start, end, isDST];
            }
            if (
              l.tx.$length === 0 ||
              ((x$3 = ((x$4 = l.tx),
              0 >= x$4.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$4.$array[x$4.$offset + 0]).when),
              sec.$high < x$3.$high ||
                (sec.$high === x$3.$high && sec.$low < x$3.$low))
            ) {
              zone$2 =
                ((x$5 = l.zone),
                (x$6 = l.lookupFirstZone()),
                x$6 < 0 || x$6 >= x$5.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x$5.$array[x$5.$offset + x$6]);
              name = zone$2.name;
              offset = zone$2.offset;
              start = new $Int64(-2147483648, 0);
              if (l.tx.$length > 0) {
                end = ((x$7 = l.tx),
                0 >= x$7.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x$7.$array[x$7.$offset + 0]).when;
              } else {
                end = new $Int64(2147483647, 4294967295);
              }
              isDST = zone$2.isDST;
              $s = -1;
              return [name, offset, start, end, isDST];
            }
            tx = l.tx;
            end = new $Int64(2147483647, 4294967295);
            lo = 0;
            hi = tx.$length;
            while (true) {
              if (!((hi - lo) >> 0 > 1)) {
                break;
              }
              m =
                (lo +
                  ((_q = ((hi - lo) >> 0) / 2),
                  _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                    ? _q >> 0
                    : $throwRuntimeError("integer divide by zero"))) >>
                0;
              lim = (
                m < 0 || m >= tx.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : tx.$array[tx.$offset + m]
              ).when;
              if (
                sec.$high < lim.$high ||
                (sec.$high === lim.$high && sec.$low < lim.$low)
              ) {
                end = lim;
                hi = m;
              } else {
                lo = m;
              }
            }
            zone$3 =
              ((x$8 = l.zone),
              (x$9 = (
                lo < 0 || lo >= tx.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : tx.$array[tx.$offset + lo]
              ).index),
              x$9 < 0 || x$9 >= x$8.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$8.$array[x$8.$offset + x$9]);
            name = zone$3.name;
            offset = zone$3.offset;
            start = (
              lo < 0 || lo >= tx.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : tx.$array[tx.$offset + lo]
            ).when;
            isDST = zone$3.isDST;
            if (lo === (tx.$length - 1) >> 0 && !(l.extend === "")) {
              _tuple = tzset(l.extend, end, sec);
              ename = _tuple[0];
              eoffset = _tuple[1];
              estart = _tuple[2];
              eend = _tuple[3];
              eisDST = _tuple[4];
              ok = _tuple[5];
              if (ok) {
                _tmp = ename;
                _tmp$1 = eoffset;
                _tmp$2 = estart;
                _tmp$3 = eend;
                _tmp$4 = eisDST;
                name = _tmp;
                offset = _tmp$1;
                start = _tmp$2;
                end = _tmp$3;
                isDST = _tmp$4;
                $s = -1;
                return [name, offset, start, end, isDST];
              }
            }
            $s = -1;
            return [name, offset, start, end, isDST];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Location.ptr.prototype.lookup,
        $c: true,
        $r,
        _q,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tuple,
        eend,
        eisDST,
        ename,
        end,
        eoffset,
        estart,
        hi,
        isDST,
        l,
        lim,
        lo,
        m,
        name,
        offset,
        ok,
        sec,
        start,
        tx,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        zone$1,
        zone$2,
        zone$3,
        $s,
      };
      return $f;
    };
    Location.prototype.lookup = function (sec) {
      return this.$val.lookup(sec);
    };
    Location.ptr.prototype.lookupFirstZone = function () {
      var _i, _ref, l, x$1, x$2, x$3, x$4, x$5, x$6, zi, zi$1;
      l = this;
      if (!l.firstZoneUsed()) {
        return 0;
      }
      if (
        l.tx.$length > 0 &&
        ((x$1 = l.zone),
        (x$2 = ((x$3 = l.tx),
        0 >= x$3.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$3.$array[x$3.$offset + 0]).index),
        x$2 < 0 || x$2 >= x$1.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x$1.$array[x$1.$offset + x$2]).isDST
      ) {
        zi =
          ((((x$4 = l.tx),
          0 >= x$4.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x$4.$array[x$4.$offset + 0]).index >>
            0) -
            1) >>
          0;
        while (true) {
          if (!(zi >= 0)) {
            break;
          }
          if (
            !((x$5 = l.zone),
            zi < 0 || zi >= x$5.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : x$5.$array[x$5.$offset + zi]).isDST
          ) {
            return zi;
          }
          zi = (zi - 1) >> 0;
        }
      }
      _ref = l.zone;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        zi$1 = _i;
        if (
          !((x$6 = l.zone),
          zi$1 < 0 || zi$1 >= x$6.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x$6.$array[x$6.$offset + zi$1]).isDST
        ) {
          return zi$1;
        }
        _i++;
      }
      return 0;
    };
    Location.prototype.lookupFirstZone = function () {
      return this.$val.lookupFirstZone();
    };
    Location.ptr.prototype.firstZoneUsed = function () {
      var _i, _ref, l, tx;
      l = this;
      _ref = l.tx;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        tx = $clone(
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i],
          zoneTrans
        );
        if (tx.index === 0) {
          return true;
        }
        _i++;
      }
      return false;
    };
    Location.prototype.firstZoneUsed = function () {
      return this.$val.firstZoneUsed();
    };
    tzset = function (s, initEnd, sec) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$24,
        _tmp$25,
        _tmp$26,
        _tmp$27,
        _tmp$28,
        _tmp$29,
        _tmp$3,
        _tmp$30,
        _tmp$31,
        _tmp$32,
        _tmp$33,
        _tmp$34,
        _tmp$35,
        _tmp$36,
        _tmp$37,
        _tmp$38,
        _tmp$39,
        _tmp$4,
        _tmp$40,
        _tmp$41,
        _tmp$42,
        _tmp$43,
        _tmp$44,
        _tmp$45,
        _tmp$46,
        _tmp$47,
        _tmp$48,
        _tmp$49,
        _tmp$5,
        _tmp$50,
        _tmp$51,
        _tmp$52,
        _tmp$53,
        _tmp$54,
        _tmp$55,
        _tmp$56,
        _tmp$57,
        _tmp$58,
        _tmp$59,
        _tmp$6,
        _tmp$60,
        _tmp$61,
        _tmp$62,
        _tmp$63,
        _tmp$64,
        _tmp$65,
        _tmp$66,
        _tmp$67,
        _tmp$68,
        _tmp$69,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        abs,
        d,
        dstIsDST,
        dstName,
        dstOffset,
        end,
        endRule,
        endSec,
        initEnd,
        isDST,
        name,
        offset,
        ok,
        s,
        sec,
        start,
        startRule,
        startSec,
        stdIsDST,
        stdName,
        stdOffset,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        yday,
        year,
        ysec;
      name = "";
      offset = 0;
      start = new $Int64(0, 0);
      end = new $Int64(0, 0);
      isDST = false;
      ok = false;
      _tmp = "";
      _tmp$1 = "";
      stdName = _tmp;
      dstName = _tmp$1;
      _tmp$2 = 0;
      _tmp$3 = 0;
      stdOffset = _tmp$2;
      dstOffset = _tmp$3;
      _tuple = tzsetName(s);
      stdName = _tuple[0];
      s = _tuple[1];
      ok = _tuple[2];
      if (ok) {
        _tuple$1 = tzsetOffset(s);
        stdOffset = _tuple$1[0];
        s = _tuple$1[1];
        ok = _tuple$1[2];
      }
      if (!ok) {
        _tmp$4 = "";
        _tmp$5 = 0;
        _tmp$6 = new $Int64(0, 0);
        _tmp$7 = new $Int64(0, 0);
        _tmp$8 = false;
        _tmp$9 = false;
        name = _tmp$4;
        offset = _tmp$5;
        start = _tmp$6;
        end = _tmp$7;
        isDST = _tmp$8;
        ok = _tmp$9;
        return [name, offset, start, end, isDST, ok];
      }
      stdOffset = -stdOffset;
      if (s.length === 0 || s.charCodeAt(0) === 44) {
        _tmp$10 = stdName;
        _tmp$11 = stdOffset;
        _tmp$12 = initEnd;
        _tmp$13 = new $Int64(2147483647, 4294967295);
        _tmp$14 = false;
        _tmp$15 = true;
        name = _tmp$10;
        offset = _tmp$11;
        start = _tmp$12;
        end = _tmp$13;
        isDST = _tmp$14;
        ok = _tmp$15;
        return [name, offset, start, end, isDST, ok];
      }
      _tuple$2 = tzsetName(s);
      dstName = _tuple$2[0];
      s = _tuple$2[1];
      ok = _tuple$2[2];
      if (ok) {
        if (s.length === 0 || s.charCodeAt(0) === 44) {
          dstOffset = (stdOffset + 3600) >> 0;
        } else {
          _tuple$3 = tzsetOffset(s);
          dstOffset = _tuple$3[0];
          s = _tuple$3[1];
          ok = _tuple$3[2];
          dstOffset = -dstOffset;
        }
      }
      if (!ok) {
        _tmp$16 = "";
        _tmp$17 = 0;
        _tmp$18 = new $Int64(0, 0);
        _tmp$19 = new $Int64(0, 0);
        _tmp$20 = false;
        _tmp$21 = false;
        name = _tmp$16;
        offset = _tmp$17;
        start = _tmp$18;
        end = _tmp$19;
        isDST = _tmp$20;
        ok = _tmp$21;
        return [name, offset, start, end, isDST, ok];
      }
      if (s.length === 0) {
        s = ",M3.2.0,M11.1.0";
      }
      if (!(s.charCodeAt(0) === 44) && !(s.charCodeAt(0) === 59)) {
        _tmp$22 = "";
        _tmp$23 = 0;
        _tmp$24 = new $Int64(0, 0);
        _tmp$25 = new $Int64(0, 0);
        _tmp$26 = false;
        _tmp$27 = false;
        name = _tmp$22;
        offset = _tmp$23;
        start = _tmp$24;
        end = _tmp$25;
        isDST = _tmp$26;
        ok = _tmp$27;
        return [name, offset, start, end, isDST, ok];
      }
      s = $substring(s, 1);
      _tmp$28 = new rule.ptr(0, 0, 0, 0, 0);
      _tmp$29 = new rule.ptr(0, 0, 0, 0, 0);
      startRule = $clone(_tmp$28, rule);
      endRule = $clone(_tmp$29, rule);
      _tuple$4 = tzsetRule(s);
      rule.copy(startRule, _tuple$4[0]);
      s = _tuple$4[1];
      ok = _tuple$4[2];
      if (!ok || s.length === 0 || !(s.charCodeAt(0) === 44)) {
        _tmp$30 = "";
        _tmp$31 = 0;
        _tmp$32 = new $Int64(0, 0);
        _tmp$33 = new $Int64(0, 0);
        _tmp$34 = false;
        _tmp$35 = false;
        name = _tmp$30;
        offset = _tmp$31;
        start = _tmp$32;
        end = _tmp$33;
        isDST = _tmp$34;
        ok = _tmp$35;
        return [name, offset, start, end, isDST, ok];
      }
      s = $substring(s, 1);
      _tuple$5 = tzsetRule(s);
      rule.copy(endRule, _tuple$5[0]);
      s = _tuple$5[1];
      ok = _tuple$5[2];
      if (!ok || s.length > 0) {
        _tmp$36 = "";
        _tmp$37 = 0;
        _tmp$38 = new $Int64(0, 0);
        _tmp$39 = new $Int64(0, 0);
        _tmp$40 = false;
        _tmp$41 = false;
        name = _tmp$36;
        offset = _tmp$37;
        start = _tmp$38;
        end = _tmp$39;
        isDST = _tmp$40;
        ok = _tmp$41;
        return [name, offset, start, end, isDST, ok];
      }
      _tuple$6 = absDate(
        ((x$1 =
          ((x$2 = new $Int64(sec.$high + 14, sec.$low + 2006054656)),
          new $Int64(x$2.$high + 2147483631, x$2.$low + 2739393024))),
        new $Uint64(x$1.$high, x$1.$low)),
        false
      );
      year = _tuple$6[0];
      yday = _tuple$6[3];
      ysec =
        ((x$3 = new $Int64(0, $imul(yday, 86400))),
        (x$4 = $div64(sec, new $Int64(0, 86400), true)),
        new $Int64(x$3.$high + x$4.$high, x$3.$low + x$4.$low));
      d = daysSinceEpoch(year);
      abs =
        ((x$5 = $mul64(d, new $Uint64(0, 86400))),
        new $Int64(x$5.$high, x$5.$low));
      abs =
        ((x$6 = new $Int64(-2147483647, 3844486912)),
        new $Int64(abs.$high + x$6.$high, abs.$low + x$6.$low));
      startSec = new $Int64(
        0,
        tzruleTime(year, $clone(startRule, rule), stdOffset)
      );
      endSec = new $Int64(
        0,
        tzruleTime(year, $clone(endRule, rule), dstOffset)
      );
      _tmp$42 = true;
      _tmp$43 = false;
      dstIsDST = _tmp$42;
      stdIsDST = _tmp$43;
      if (
        endSec.$high < startSec.$high ||
        (endSec.$high === startSec.$high && endSec.$low < startSec.$low)
      ) {
        _tmp$44 = endSec;
        _tmp$45 = startSec;
        startSec = _tmp$44;
        endSec = _tmp$45;
        _tmp$46 = dstName;
        _tmp$47 = stdName;
        stdName = _tmp$46;
        dstName = _tmp$47;
        _tmp$48 = dstOffset;
        _tmp$49 = stdOffset;
        stdOffset = _tmp$48;
        dstOffset = _tmp$49;
        _tmp$50 = dstIsDST;
        _tmp$51 = stdIsDST;
        stdIsDST = _tmp$50;
        dstIsDST = _tmp$51;
      }
      if (
        ysec.$high < startSec.$high ||
        (ysec.$high === startSec.$high && ysec.$low < startSec.$low)
      ) {
        _tmp$52 = stdName;
        _tmp$53 = stdOffset;
        _tmp$54 = abs;
        _tmp$55 = new $Int64(
          startSec.$high + abs.$high,
          startSec.$low + abs.$low
        );
        _tmp$56 = stdIsDST;
        _tmp$57 = true;
        name = _tmp$52;
        offset = _tmp$53;
        start = _tmp$54;
        end = _tmp$55;
        isDST = _tmp$56;
        ok = _tmp$57;
        return [name, offset, start, end, isDST, ok];
      } else if (
        ysec.$high > endSec.$high ||
        (ysec.$high === endSec.$high && ysec.$low >= endSec.$low)
      ) {
        _tmp$58 = stdName;
        _tmp$59 = stdOffset;
        _tmp$60 = new $Int64(endSec.$high + abs.$high, endSec.$low + abs.$low);
        _tmp$61 = new $Int64(abs.$high + 0, abs.$low + 31536000);
        _tmp$62 = stdIsDST;
        _tmp$63 = true;
        name = _tmp$58;
        offset = _tmp$59;
        start = _tmp$60;
        end = _tmp$61;
        isDST = _tmp$62;
        ok = _tmp$63;
        return [name, offset, start, end, isDST, ok];
      } else {
        _tmp$64 = dstName;
        _tmp$65 = dstOffset;
        _tmp$66 = new $Int64(
          startSec.$high + abs.$high,
          startSec.$low + abs.$low
        );
        _tmp$67 = new $Int64(endSec.$high + abs.$high, endSec.$low + abs.$low);
        _tmp$68 = dstIsDST;
        _tmp$69 = true;
        name = _tmp$64;
        offset = _tmp$65;
        start = _tmp$66;
        end = _tmp$67;
        isDST = _tmp$68;
        ok = _tmp$69;
        return [name, offset, start, end, isDST, ok];
      }
    };
    tzsetName = function (s) {
      var _1, _i, _i$1, _ref, _ref$1, _rune, _rune$1, i, i$1, r, r$1, s;
      if (s.length === 0) {
        return ["", "", false];
      }
      if (!(s.charCodeAt(0) === 60)) {
        _ref = s;
        _i = 0;
        while (true) {
          if (!(_i < _ref.length)) {
            break;
          }
          _rune = $decodeRune(_ref, _i);
          i = _i;
          r = _rune[0];
          _1 = r;
          if (
            _1 === 48 ||
            _1 === 49 ||
            _1 === 50 ||
            _1 === 51 ||
            _1 === 52 ||
            _1 === 53 ||
            _1 === 54 ||
            _1 === 55 ||
            _1 === 56 ||
            _1 === 57 ||
            _1 === 44 ||
            _1 === 45 ||
            _1 === 43
          ) {
            if (i < 3) {
              return ["", "", false];
            }
            return [$substring(s, 0, i), $substring(s, i), true];
          }
          _i += _rune[1];
        }
        if (s.length < 3) {
          return ["", "", false];
        }
        return [s, "", true];
      } else {
        _ref$1 = s;
        _i$1 = 0;
        while (true) {
          if (!(_i$1 < _ref$1.length)) {
            break;
          }
          _rune$1 = $decodeRune(_ref$1, _i$1);
          i$1 = _i$1;
          r$1 = _rune$1[0];
          if (r$1 === 62) {
            return [$substring(s, 1, i$1), $substring(s, (i$1 + 1) >> 0), true];
          }
          _i$1 += _rune$1[1];
        }
        return ["", "", false];
      }
    };
    tzsetOffset = function (s) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        hours,
        mins,
        neg,
        off,
        offset,
        ok,
        rest,
        s,
        secs;
      offset = 0;
      rest = "";
      ok = false;
      if (s.length === 0) {
        _tmp = 0;
        _tmp$1 = "";
        _tmp$2 = false;
        offset = _tmp;
        rest = _tmp$1;
        ok = _tmp$2;
        return [offset, rest, ok];
      }
      neg = false;
      if (s.charCodeAt(0) === 43) {
        s = $substring(s, 1);
      } else if (s.charCodeAt(0) === 45) {
        s = $substring(s, 1);
        neg = true;
      }
      hours = 0;
      _tuple = tzsetNum(s, 0, 168);
      hours = _tuple[0];
      s = _tuple[1];
      ok = _tuple[2];
      if (!ok) {
        _tmp$3 = 0;
        _tmp$4 = "";
        _tmp$5 = false;
        offset = _tmp$3;
        rest = _tmp$4;
        ok = _tmp$5;
        return [offset, rest, ok];
      }
      off = $imul(hours, 3600);
      if (s.length === 0 || !(s.charCodeAt(0) === 58)) {
        if (neg) {
          off = -off;
        }
        _tmp$6 = off;
        _tmp$7 = s;
        _tmp$8 = true;
        offset = _tmp$6;
        rest = _tmp$7;
        ok = _tmp$8;
        return [offset, rest, ok];
      }
      mins = 0;
      _tuple$1 = tzsetNum($substring(s, 1), 0, 59);
      mins = _tuple$1[0];
      s = _tuple$1[1];
      ok = _tuple$1[2];
      if (!ok) {
        _tmp$9 = 0;
        _tmp$10 = "";
        _tmp$11 = false;
        offset = _tmp$9;
        rest = _tmp$10;
        ok = _tmp$11;
        return [offset, rest, ok];
      }
      off = (off + $imul(mins, 60)) >> 0;
      if (s.length === 0 || !(s.charCodeAt(0) === 58)) {
        if (neg) {
          off = -off;
        }
        _tmp$12 = off;
        _tmp$13 = s;
        _tmp$14 = true;
        offset = _tmp$12;
        rest = _tmp$13;
        ok = _tmp$14;
        return [offset, rest, ok];
      }
      secs = 0;
      _tuple$2 = tzsetNum($substring(s, 1), 0, 59);
      secs = _tuple$2[0];
      s = _tuple$2[1];
      ok = _tuple$2[2];
      if (!ok) {
        _tmp$15 = 0;
        _tmp$16 = "";
        _tmp$17 = false;
        offset = _tmp$15;
        rest = _tmp$16;
        ok = _tmp$17;
        return [offset, rest, ok];
      }
      off = (off + secs) >> 0;
      if (neg) {
        off = -off;
      }
      _tmp$18 = off;
      _tmp$19 = s;
      _tmp$20 = true;
      offset = _tmp$18;
      rest = _tmp$19;
      ok = _tmp$20;
      return [offset, rest, ok];
    };
    tzsetRule = function (s) {
      var _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        day,
        day$1,
        jday,
        mon,
        offset,
        ok,
        r,
        s,
        week;
      r = new rule.ptr(0, 0, 0, 0, 0);
      if (s.length === 0) {
        return [new rule.ptr(0, 0, 0, 0, 0), "", false];
      }
      ok = false;
      if (s.charCodeAt(0) === 74) {
        jday = 0;
        _tuple = tzsetNum($substring(s, 1), 1, 365);
        jday = _tuple[0];
        s = _tuple[1];
        ok = _tuple[2];
        if (!ok) {
          return [new rule.ptr(0, 0, 0, 0, 0), "", false];
        }
        r.kind = 0;
        r.day = jday;
      } else if (s.charCodeAt(0) === 77) {
        mon = 0;
        _tuple$1 = tzsetNum($substring(s, 1), 1, 12);
        mon = _tuple$1[0];
        s = _tuple$1[1];
        ok = _tuple$1[2];
        if (!ok || s.length === 0 || !(s.charCodeAt(0) === 46)) {
          return [new rule.ptr(0, 0, 0, 0, 0), "", false];
        }
        week = 0;
        _tuple$2 = tzsetNum($substring(s, 1), 1, 5);
        week = _tuple$2[0];
        s = _tuple$2[1];
        ok = _tuple$2[2];
        if (!ok || s.length === 0 || !(s.charCodeAt(0) === 46)) {
          return [new rule.ptr(0, 0, 0, 0, 0), "", false];
        }
        day = 0;
        _tuple$3 = tzsetNum($substring(s, 1), 0, 6);
        day = _tuple$3[0];
        s = _tuple$3[1];
        ok = _tuple$3[2];
        if (!ok) {
          return [new rule.ptr(0, 0, 0, 0, 0), "", false];
        }
        r.kind = 2;
        r.day = day;
        r.week = week;
        r.mon = mon;
      } else {
        day$1 = 0;
        _tuple$4 = tzsetNum(s, 0, 365);
        day$1 = _tuple$4[0];
        s = _tuple$4[1];
        ok = _tuple$4[2];
        if (!ok) {
          return [new rule.ptr(0, 0, 0, 0, 0), "", false];
        }
        r.kind = 1;
        r.day = day$1;
      }
      if (s.length === 0 || !(s.charCodeAt(0) === 47)) {
        r.time = 7200;
        return [r, s, true];
      }
      _tuple$5 = tzsetOffset($substring(s, 1));
      offset = _tuple$5[0];
      s = _tuple$5[1];
      ok = _tuple$5[2];
      if (!ok) {
        return [new rule.ptr(0, 0, 0, 0, 0), "", false];
      }
      r.time = offset;
      return [r, s, true];
    };
    tzsetNum = function (s, min, max) {
      var _i,
        _ref,
        _rune,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        i,
        max,
        min,
        num,
        ok,
        r,
        rest,
        s;
      num = 0;
      rest = "";
      ok = false;
      if (s.length === 0) {
        _tmp = 0;
        _tmp$1 = "";
        _tmp$2 = false;
        num = _tmp;
        rest = _tmp$1;
        ok = _tmp$2;
        return [num, rest, ok];
      }
      num = 0;
      _ref = s;
      _i = 0;
      while (true) {
        if (!(_i < _ref.length)) {
          break;
        }
        _rune = $decodeRune(_ref, _i);
        i = _i;
        r = _rune[0];
        if (r < 48 || r > 57) {
          if (i === 0 || num < min) {
            _tmp$3 = 0;
            _tmp$4 = "";
            _tmp$5 = false;
            num = _tmp$3;
            rest = _tmp$4;
            ok = _tmp$5;
            return [num, rest, ok];
          }
          _tmp$6 = num;
          _tmp$7 = $substring(s, i);
          _tmp$8 = true;
          num = _tmp$6;
          rest = _tmp$7;
          ok = _tmp$8;
          return [num, rest, ok];
        }
        num = $imul(num, 10);
        num = (num + (((r >> 0) - 48) >> 0)) >> 0;
        if (num > max) {
          _tmp$9 = 0;
          _tmp$10 = "";
          _tmp$11 = false;
          num = _tmp$9;
          rest = _tmp$10;
          ok = _tmp$11;
          return [num, rest, ok];
        }
        _i += _rune[1];
      }
      if (num < min) {
        _tmp$12 = 0;
        _tmp$13 = "";
        _tmp$14 = false;
        num = _tmp$12;
        rest = _tmp$13;
        ok = _tmp$14;
        return [num, rest, ok];
      }
      _tmp$15 = num;
      _tmp$16 = "";
      _tmp$17 = true;
      num = _tmp$15;
      rest = _tmp$16;
      ok = _tmp$17;
      return [num, rest, ok];
    };
    tzruleTime = function (year, r, off) {
      var _1,
        _q,
        _q$1,
        _q$2,
        _q$3,
        _r$1,
        _r$2,
        _r$3,
        d,
        dow,
        i,
        m1,
        off,
        r,
        s,
        x$1,
        year,
        yy0,
        yy1,
        yy2;
      s = 0;
      _1 = r.kind;
      if (_1 === 0) {
        s = $imul((r.day - 1) >> 0, 86400);
        if (isLeap(year) && r.day >= 60) {
          s = (s + 86400) >> 0;
        }
      } else if (_1 === 1) {
        s = $imul(r.day, 86400);
      } else if (_1 === 2) {
        m1 =
          (((_r$1 = ((r.mon + 9) >> 0) % 12),
          _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) +
            1) >>
          0;
        yy0 = year;
        if (r.mon <= 2) {
          yy0 = (yy0 - 1) >> 0;
        }
        yy1 =
          ((_q = yy0 / 100),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero"));
        yy2 =
          ((_r$2 = yy0 % 100),
          _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero"));
        dow =
          ((_r$3 =
            ((((((((((((_q$1 = (($imul(26, m1) - 2) >> 0) / 10),
            _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
              ? _q$1 >> 0
              : $throwRuntimeError("integer divide by zero")) +
              1) >>
              0) +
              yy2) >>
              0) +
              ((_q$2 = yy2 / 4),
              _q$2 === _q$2 && _q$2 !== 1 / 0 && _q$2 !== -1 / 0
                ? _q$2 >> 0
                : $throwRuntimeError("integer divide by zero"))) >>
              0) +
              ((_q$3 = yy1 / 4),
              _q$3 === _q$3 && _q$3 !== 1 / 0 && _q$3 !== -1 / 0
                ? _q$3 >> 0
                : $throwRuntimeError("integer divide by zero"))) >>
              0) -
              $imul(2, yy1)) >>
              0) %
            7),
          _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero"));
        if (dow < 0) {
          dow = (dow + 7) >> 0;
        }
        d = (r.day - dow) >> 0;
        if (d < 0) {
          d = (d + 7) >> 0;
        }
        i = 1;
        while (true) {
          if (!(i < r.week)) {
            break;
          }
          if ((d + 7) >> 0 >= daysIn(r.mon >> 0, year)) {
            break;
          }
          d = (d + 7) >> 0;
          i = (i + 1) >> 0;
        }
        d =
          (d +
            (((x$1 = (r.mon - 1) >> 0),
            x$1 < 0 || x$1 >= daysBefore.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : daysBefore[x$1]) >>
              0)) >>
          0;
        if (isLeap(year) && r.mon > 2) {
          d = (d + 1) >> 0;
        }
        s = $imul(d, 86400);
      }
      return (((s + r.time) >> 0) - off) >> 0;
    };
    Location.ptr.prototype.lookupName = function (name, unix) {
      var {
        _i,
        _i$1,
        _r$1,
        _r$2,
        _ref,
        _ref$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        i,
        i$1,
        l,
        nam,
        name,
        offset,
        offset$1,
        ok,
        unix,
        x$1,
        x$2,
        x$3,
        zone$1,
        zone$2,
        $s,
        $r,
        $c,
      } = $restore(this, { name, unix });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            offset = 0;
            ok = false;
            l = this;
            _r$1 = l.get();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            l = _r$1;
            _ref = l.zone;
            _i = 0;
          /* while (true) { */ case 2:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 3;
              continue;
            }
            i = _i;
            zone$1 =
              ((x$1 = l.zone),
              i < 0 || i >= x$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x$1.$array[x$1.$offset + i]);
            /* */ if (zone$1.name === name) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (zone$1.name === name) { */ case 4:
            _r$2 = l.lookup(
              ((x$2 = new $Int64(0, zone$1.offset)),
              new $Int64(unix.$high - x$2.$high, unix.$low - x$2.$low))
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            nam = _tuple[0];
            offset$1 = _tuple[1];
            if (nam === zone$1.name) {
              _tmp = offset$1;
              _tmp$1 = true;
              offset = _tmp;
              ok = _tmp$1;
              $s = -1;
              return [offset, ok];
            }
          /* } */ case 5:
            _i++;
            $s = 2;
            continue;
          case 3:
            _ref$1 = l.zone;
            _i$1 = 0;
            while (true) {
              if (!(_i$1 < _ref$1.$length)) {
                break;
              }
              i$1 = _i$1;
              zone$2 =
                ((x$3 = l.zone),
                i$1 < 0 || i$1 >= x$3.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x$3.$array[x$3.$offset + i$1]);
              if (zone$2.name === name) {
                _tmp$2 = zone$2.offset;
                _tmp$3 = true;
                offset = _tmp$2;
                ok = _tmp$3;
                $s = -1;
                return [offset, ok];
              }
              _i$1++;
            }
            $s = -1;
            return [offset, ok];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Location.ptr.prototype.lookupName,
        $c: true,
        $r,
        _i,
        _i$1,
        _r$1,
        _r$2,
        _ref,
        _ref$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        i,
        i$1,
        l,
        nam,
        name,
        offset,
        offset$1,
        ok,
        unix,
        x$1,
        x$2,
        x$3,
        zone$1,
        zone$2,
        $s,
      };
      return $f;
    };
    Location.prototype.lookupName = function (name, unix) {
      return this.$val.lookupName(name, unix);
    };
    Time.ptr.prototype.nsec = function () {
      var t, x$1;
      t = this;
      return (
        ((x$1 = t.wall),
        new $Uint64(x$1.$high & 0, (x$1.$low & 1073741823) >>> 0)).$low >> 0
      );
    };
    Time.prototype.nsec = function () {
      return this.$val.nsec();
    };
    Time.ptr.prototype.sec = function () {
      var t, x$1, x$2, x$3, x$4;
      t = this;
      if (
        !((x$1 =
          ((x$2 = t.wall),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        return (
          (x$3 =
            ((x$4 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31)),
            new $Int64(x$4.$high, x$4.$low))),
          new $Int64(13 + x$3.$high, 3618733952 + x$3.$low)
        );
      }
      return t.ext;
    };
    Time.prototype.sec = function () {
      return this.$val.sec();
    };
    Time.ptr.prototype.unixSec = function () {
      var t, x$1;
      t = this;
      return (
        (x$1 = t.sec()), new $Int64(x$1.$high + -15, x$1.$low + 2288912640)
      );
    };
    Time.prototype.unixSec = function () {
      return this.$val.unixSec();
    };
    Time.ptr.prototype.addSec = function (d) {
      var d, dsec, sec, sum, t, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
      t = this;
      if (
        !((x$1 =
          ((x$2 = t.wall),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        sec =
          ((x$3 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31)),
          new $Int64(x$3.$high, x$3.$low));
        dsec = new $Int64(sec.$high + d.$high, sec.$low + d.$low);
        if (
          (0 < dsec.$high || (0 === dsec.$high && 0 <= dsec.$low)) &&
          (dsec.$high < 1 || (dsec.$high === 1 && dsec.$low <= 4294967295))
        ) {
          t.wall =
            ((x$4 =
              ((x$5 =
                ((x$6 = t.wall),
                new $Uint64(x$6.$high & 0, (x$6.$low & 1073741823) >>> 0))),
              (x$7 = $shiftLeft64(new $Uint64(dsec.$high, dsec.$low), 30)),
              new $Uint64(x$5.$high | x$7.$high, (x$5.$low | x$7.$low) >>> 0))),
            new $Uint64(x$4.$high | 2147483648, (x$4.$low | 0) >>> 0));
          return;
        }
        t.stripMono();
      }
      sum = ((x$8 = t.ext), new $Int64(x$8.$high + d.$high, x$8.$low + d.$low));
      if (
        ((x$9 = t.ext),
        sum.$high > x$9.$high ||
          (sum.$high === x$9.$high && sum.$low > x$9.$low)) ===
        (d.$high > 0 || (d.$high === 0 && d.$low > 0))
      ) {
        t.ext = sum;
      } else if (d.$high > 0 || (d.$high === 0 && d.$low > 0)) {
        t.ext = new $Int64(2147483647, 4294967295);
      } else {
        t.ext = new $Int64(-2147483648, 1);
      }
    };
    Time.prototype.addSec = function (d) {
      return this.$val.addSec(d);
    };
    Time.ptr.prototype.setLoc = function (loc) {
      var loc, t;
      t = this;
      if (loc === utcLoc) {
        loc = ptrType$2.nil;
      }
      t.stripMono();
      t.loc = loc;
    };
    Time.prototype.setLoc = function (loc) {
      return this.$val.setLoc(loc);
    };
    Time.ptr.prototype.stripMono = function () {
      var t, x$1, x$2, x$3, x$4;
      t = this;
      if (
        !((x$1 =
          ((x$2 = t.wall),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        t.ext = t.sec();
        t.wall =
          ((x$3 = t.wall),
          (x$4 = new $Uint64(0, 1073741823)),
          new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0));
      }
    };
    Time.prototype.stripMono = function () {
      return this.$val.stripMono();
    };
    Time.ptr.prototype.After = function (u) {
      var t, ts, u, us, x$1, x$2, x$3, x$4, x$5, x$6;
      t = this;
      if (
        !((x$1 =
          ((x$2 =
            ((x$3 = t.wall),
            (x$4 = u.wall),
            new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0))),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        return (
          (x$5 = t.ext),
          (x$6 = u.ext),
          x$5.$high > x$6.$high ||
            (x$5.$high === x$6.$high && x$5.$low > x$6.$low)
        );
      }
      ts = t.sec();
      us = u.sec();
      return (
        ts.$high > us.$high ||
        (ts.$high === us.$high && ts.$low > us.$low) ||
        (ts.$high === us.$high && ts.$low === us.$low && t.nsec() > u.nsec())
      );
    };
    Time.prototype.After = function (u) {
      return this.$val.After(u);
    };
    Time.ptr.prototype.Before = function (u) {
      var t, ts, u, us, x$1, x$2, x$3, x$4, x$5, x$6;
      t = this;
      if (
        !((x$1 =
          ((x$2 =
            ((x$3 = t.wall),
            (x$4 = u.wall),
            new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0))),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        return (
          (x$5 = t.ext),
          (x$6 = u.ext),
          x$5.$high < x$6.$high ||
            (x$5.$high === x$6.$high && x$5.$low < x$6.$low)
        );
      }
      ts = t.sec();
      us = u.sec();
      return (
        ts.$high < us.$high ||
        (ts.$high === us.$high && ts.$low < us.$low) ||
        (ts.$high === us.$high && ts.$low === us.$low && t.nsec() < u.nsec())
      );
    };
    Time.prototype.Before = function (u) {
      return this.$val.Before(u);
    };
    Time.ptr.prototype.Equal = function (u) {
      var t, u, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
      t = this;
      if (
        !((x$1 =
          ((x$2 =
            ((x$3 = t.wall),
            (x$4 = u.wall),
            new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0))),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        return (
          (x$5 = t.ext),
          (x$6 = u.ext),
          x$5.$high === x$6.$high && x$5.$low === x$6.$low
        );
      }
      return (
        ((x$7 = t.sec()),
        (x$8 = u.sec()),
        x$7.$high === x$8.$high && x$7.$low === x$8.$low) &&
        t.nsec() === u.nsec()
      );
    };
    Time.prototype.Equal = function (u) {
      return this.$val.Equal(u);
    };
    Month.prototype.String = function () {
      var buf, m, n, x$1;
      m = this.$val;
      if (1 <= m && m <= 12) {
        return (
          (x$1 = (m - 1) >> 0),
          x$1 < 0 || x$1 >= longMonthNames.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : longMonthNames.$array[longMonthNames.$offset + x$1]
        );
      }
      buf = $makeSlice(sliceType$3, 20);
      n = fmtInt(buf, new $Uint64(0, m));
      return "%!Month(" + $bytesToString($subslice(buf, n)) + ")";
    };
    $ptrType(Month).prototype.String = function () {
      return new Month(this.$get()).String();
    };
    Weekday.prototype.String = function () {
      var buf, d, n;
      d = this.$val;
      if (0 <= d && d <= 6) {
        return d < 0 || d >= longDayNames.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : longDayNames.$array[longDayNames.$offset + d];
      }
      buf = $makeSlice(sliceType$3, 20);
      n = fmtInt(buf, new $Uint64(0, d));
      return "%!Weekday(" + $bytesToString($subslice(buf, n)) + ")";
    };
    $ptrType(Weekday).prototype.String = function () {
      return new Weekday(this.$get()).String();
    };
    Time.ptr.prototype.IsZero = function () {
      var t, x$1;
      t = this;
      return (
        ((x$1 = t.sec()), x$1.$high === 0 && x$1.$low === 0) && t.nsec() === 0
      );
    };
    Time.prototype.IsZero = function () {
      return this.$val.IsZero();
    };
    Time.ptr.prototype.abs = function () {
      var {
        _r$1,
        _r$2,
        _tuple,
        l,
        offset,
        sec,
        t,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            l = t.loc;
            /* */ if (l === ptrType$2.nil || l === localLoc) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
            _r$1 = l.get();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            l = _r$1;
          /* } */ case 2:
            sec = t.unixSec();
            /* */ if (!(l === utcLoc)) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (!(l === utcLoc)) { */ case 4:
            /* */ if (
              !(l.cacheZone === ptrType.nil) &&
              ((x$1 = l.cacheStart),
              x$1.$high < sec.$high ||
                (x$1.$high === sec.$high && x$1.$low <= sec.$low)) &&
              ((x$2 = l.cacheEnd),
              sec.$high < x$2.$high ||
                (sec.$high === x$2.$high && sec.$low < x$2.$low))
            ) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 6:
            sec =
              ((x$3 = new $Int64(0, l.cacheZone.offset)),
              new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));
            $s = 8;
            continue;
          /* } else { */ case 7:
            _r$2 = l.lookup(sec);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            offset = _tuple[1];
            sec =
              ((x$4 = new $Int64(0, offset)),
              new $Int64(sec.$high + x$4.$high, sec.$low + x$4.$low));
          /* } */ case 8:
          /* } */ case 5:
            $s = -1;
            return (
              (x$5 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384)),
              new $Uint64(x$5.$high, x$5.$low)
            );
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.abs,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _tuple,
        l,
        offset,
        sec,
        t,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        $s,
      };
      return $f;
    };
    Time.prototype.abs = function () {
      return this.$val.abs();
    };
    Time.ptr.prototype.locabs = function () {
      var {
        _r$1,
        _r$2,
        _tuple,
        abs,
        l,
        name,
        offset,
        sec,
        t,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            name = "";
            offset = 0;
            abs = new $Uint64(0, 0);
            t = this;
            l = t.loc;
            /* */ if (l === ptrType$2.nil || l === localLoc) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
            _r$1 = l.get();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            l = _r$1;
          /* } */ case 2:
            sec = t.unixSec();
            /* */ if (!(l === utcLoc)) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (!(l === utcLoc)) { */ case 4:
            /* */ if (
              !(l.cacheZone === ptrType.nil) &&
              ((x$1 = l.cacheStart),
              x$1.$high < sec.$high ||
                (x$1.$high === sec.$high && x$1.$low <= sec.$low)) &&
              ((x$2 = l.cacheEnd),
              sec.$high < x$2.$high ||
                (sec.$high === x$2.$high && sec.$low < x$2.$low))
            ) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 7:
            name = l.cacheZone.name;
            offset = l.cacheZone.offset;
            $s = 9;
            continue;
          /* } else { */ case 8:
            _r$2 = l.lookup(sec);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            name = _tuple[0];
            offset = _tuple[1];
          /* } */ case 9:
            sec =
              ((x$3 = new $Int64(0, offset)),
              new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));
            $s = 6;
            continue;
          /* } else { */ case 5:
            name = "UTC";
          /* } */ case 6:
            abs =
              ((x$4 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384)),
              new $Uint64(x$4.$high, x$4.$low));
            $s = -1;
            return [name, offset, abs];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.locabs,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _tuple,
        abs,
        l,
        name,
        offset,
        sec,
        t,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
      };
      return $f;
    };
    Time.prototype.locabs = function () {
      return this.$val.locabs();
    };
    Time.ptr.prototype.Date = function () {
      var { _r$1, _tuple, day, month, t, year, $s, $r, $c } = $restore(
        this,
        {}
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            year = 0;
            month = 0;
            day = 0;
            t = this;
            _r$1 = $clone(t, Time).date(true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            year = _tuple[0];
            month = _tuple[1];
            day = _tuple[2];
            $s = -1;
            return [year, month, day];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Date,
        $c: true,
        $r,
        _r$1,
        _tuple,
        day,
        month,
        t,
        year,
        $s,
      };
      return $f;
    };
    Time.prototype.Date = function () {
      return this.$val.Date();
    };
    Time.ptr.prototype.Year = function () {
      var { _r$1, _tuple, t, year, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).date(false);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            year = _tuple[0];
            $s = -1;
            return year;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Year,
        $c: true,
        $r,
        _r$1,
        _tuple,
        t,
        year,
        $s,
      };
      return $f;
    };
    Time.prototype.Year = function () {
      return this.$val.Year();
    };
    Time.ptr.prototype.Month = function () {
      var { _r$1, _tuple, month, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).date(true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            month = _tuple[1];
            $s = -1;
            return month;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Month,
        $c: true,
        $r,
        _r$1,
        _tuple,
        month,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Month = function () {
      return this.$val.Month();
    };
    Time.ptr.prototype.Day = function () {
      var { _r$1, _tuple, day, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).date(true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            day = _tuple[2];
            $s = -1;
            return day;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Day,
        $c: true,
        $r,
        _r$1,
        _tuple,
        day,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Day = function () {
      return this.$val.Day();
    };
    Time.ptr.prototype.Weekday = function () {
      var { $24r, _r$1, _r$2, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = absWeekday(_r$1);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = _r$2;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Weekday,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Weekday = function () {
      return this.$val.Weekday();
    };
    absWeekday = function (abs) {
      var _q, abs, sec;
      sec = $div64(
        new $Uint64(abs.$high + 0, abs.$low + 86400),
        new $Uint64(0, 604800),
        true
      );
      return (
        ((_q = (sec.$low >> 0) / 86400),
        _q === _q && _q !== 1 / 0 && _q !== -1 / 0
          ? _q >> 0
          : $throwRuntimeError("integer divide by zero")) >> 0
      );
    };
    Time.ptr.prototype.ISOWeek = function () {
      var {
        _q,
        _r$1,
        _tmp,
        _tmp$1,
        _tuple,
        abs,
        d,
        t,
        week,
        x$1,
        yday,
        year,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            year = 0;
            week = 0;
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            abs = _r$1;
            d = (4 - absWeekday(abs)) >> 0;
            if (d === 4) {
              d = -3;
            }
            abs =
              ((x$1 = $mul64(new $Uint64(0, d), new $Uint64(0, 86400))),
              new $Uint64(abs.$high + x$1.$high, abs.$low + x$1.$low));
            _tuple = absDate(abs, false);
            year = _tuple[0];
            yday = _tuple[3];
            _tmp = year;
            _tmp$1 =
              (((_q = yday / 7),
              _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                ? _q >> 0
                : $throwRuntimeError("integer divide by zero")) +
                1) >>
              0;
            year = _tmp;
            week = _tmp$1;
            $s = -1;
            return [year, week];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.ISOWeek,
        $c: true,
        $r,
        _q,
        _r$1,
        _tmp,
        _tmp$1,
        _tuple,
        abs,
        d,
        t,
        week,
        x$1,
        yday,
        year,
        $s,
      };
      return $f;
    };
    Time.prototype.ISOWeek = function () {
      return this.$val.ISOWeek();
    };
    Time.ptr.prototype.Clock = function () {
      var { $24r, _r$1, _r$2, _tuple, hour, min, sec, t, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            hour = 0;
            min = 0;
            sec = 0;
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = absClock(_r$1);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            hour = _tuple[0];
            min = _tuple[1];
            sec = _tuple[2];
            $24r = [hour, min, sec];
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Clock,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        _tuple,
        hour,
        min,
        sec,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Clock = function () {
      return this.$val.Clock();
    };
    absClock = function (abs) {
      var _q, _q$1, abs, hour, min, sec;
      hour = 0;
      min = 0;
      sec = 0;
      sec = $div64(abs, new $Uint64(0, 86400), true).$low >> 0;
      hour =
        ((_q = sec / 3600),
        _q === _q && _q !== 1 / 0 && _q !== -1 / 0
          ? _q >> 0
          : $throwRuntimeError("integer divide by zero"));
      sec = (sec - $imul(hour, 3600)) >> 0;
      min =
        ((_q$1 = sec / 60),
        _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
          ? _q$1 >> 0
          : $throwRuntimeError("integer divide by zero"));
      sec = (sec - $imul(min, 60)) >> 0;
      return [hour, min, sec];
    };
    Time.ptr.prototype.Hour = function () {
      var { $24r, _q, _r$1, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r =
              ((_q =
                ($div64(_r$1, new $Uint64(0, 86400), true).$low >> 0) / 3600),
              _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                ? _q >> 0
                : $throwRuntimeError("integer divide by zero"));
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Hour,
        $c: true,
        $r,
        $24r,
        _q,
        _r$1,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Hour = function () {
      return this.$val.Hour();
    };
    Time.ptr.prototype.Minute = function () {
      var { $24r, _q, _r$1, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r =
              ((_q = ($div64(_r$1, new $Uint64(0, 3600), true).$low >> 0) / 60),
              _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                ? _q >> 0
                : $throwRuntimeError("integer divide by zero"));
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Minute,
        $c: true,
        $r,
        $24r,
        _q,
        _r$1,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Minute = function () {
      return this.$val.Minute();
    };
    Time.ptr.prototype.Second = function () {
      var { $24r, _r$1, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = $div64(_r$1, new $Uint64(0, 60), true).$low >> 0;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Second,
        $c: true,
        $r,
        $24r,
        _r$1,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Second = function () {
      return this.$val.Second();
    };
    Time.ptr.prototype.Nanosecond = function () {
      var t;
      t = this;
      return t.nsec() >> 0;
    };
    Time.prototype.Nanosecond = function () {
      return this.$val.Nanosecond();
    };
    Time.ptr.prototype.YearDay = function () {
      var { _r$1, _tuple, t, yday, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).date(false);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            yday = _tuple[3];
            $s = -1;
            return (yday + 1) >> 0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.YearDay,
        $c: true,
        $r,
        _r$1,
        _tuple,
        t,
        yday,
        $s,
      };
      return $f;
    };
    Time.prototype.YearDay = function () {
      return this.$val.YearDay();
    };
    Duration.prototype.String = function () {
      var _tuple, _tuple$1, buf, d, neg, prec, u, w;
      d = this;
      buf = arrayType$2.zero();
      w = 32;
      u = new $Uint64(d.$high, d.$low);
      neg = d.$high < 0 || (d.$high === 0 && d.$low < 0);
      if (neg) {
        u = new $Uint64(-u.$high, -u.$low);
      }
      if (u.$high < 0 || (u.$high === 0 && u.$low < 1000000000)) {
        prec = 0;
        w = (w - 1) >> 0;
        w < 0 || w >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[w] = 115);
        w = (w - 1) >> 0;
        if (u.$high === 0 && u.$low === 0) {
          return "0s";
        } else if (u.$high < 0 || (u.$high === 0 && u.$low < 1000)) {
          prec = 0;
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = 110);
        } else if (u.$high < 0 || (u.$high === 0 && u.$low < 1000000)) {
          prec = 3;
          w = (w - 1) >> 0;
          $copyString($subslice(new sliceType$3(buf), w), "\xC2\xB5");
        } else {
          prec = 6;
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = 109);
        }
        _tuple = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, prec);
        w = _tuple[0];
        u = _tuple[1];
        w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
      } else {
        w = (w - 1) >> 0;
        w < 0 || w >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[w] = 115);
        _tuple$1 = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, 9);
        w = _tuple$1[0];
        u = _tuple$1[1];
        w = fmtInt(
          $subslice(new sliceType$3(buf), 0, w),
          $div64(u, new $Uint64(0, 60), true)
        );
        u = $div64(u, new $Uint64(0, 60), false);
        if (u.$high > 0 || (u.$high === 0 && u.$low > 0)) {
          w = (w - 1) >> 0;
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = 109);
          w = fmtInt(
            $subslice(new sliceType$3(buf), 0, w),
            $div64(u, new $Uint64(0, 60), true)
          );
          u = $div64(u, new $Uint64(0, 60), false);
          if (u.$high > 0 || (u.$high === 0 && u.$low > 0)) {
            w = (w - 1) >> 0;
            w < 0 || w >= buf.length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (buf[w] = 104);
            w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
          }
        }
      }
      if (neg) {
        w = (w - 1) >> 0;
        w < 0 || w >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[w] = 45);
      }
      return $bytesToString($subslice(new sliceType$3(buf), w));
    };
    $ptrType(Duration).prototype.String = function () {
      return this.$get().String();
    };
    fmtFrac = function (buf, v, prec) {
      var _tmp, _tmp$1, buf, digit, i, nv, nw, prec, print, v, w;
      nw = 0;
      nv = new $Uint64(0, 0);
      w = buf.$length;
      print = false;
      i = 0;
      while (true) {
        if (!(i < prec)) {
          break;
        }
        digit = $div64(v, new $Uint64(0, 10), true);
        print = print || !(digit.$high === 0 && digit.$low === 0);
        if (print) {
          w = (w - 1) >> 0;
          w < 0 || w >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + w] =
                ((((digit.$low << 24) >>> 24) + 48) << 24) >>> 24);
        }
        v = $div64(v, new $Uint64(0, 10), false);
        i = (i + 1) >> 0;
      }
      if (print) {
        w = (w - 1) >> 0;
        w < 0 || w >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + w] = 46);
      }
      _tmp = w;
      _tmp$1 = v;
      nw = _tmp;
      nv = _tmp$1;
      return [nw, nv];
    };
    fmtInt = function (buf, v) {
      var buf, v, w;
      w = buf.$length;
      if (v.$high === 0 && v.$low === 0) {
        w = (w - 1) >> 0;
        w < 0 || w >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + w] = 48);
      } else {
        while (true) {
          if (!(v.$high > 0 || (v.$high === 0 && v.$low > 0))) {
            break;
          }
          w = (w - 1) >> 0;
          w < 0 || w >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + w] =
                (((($div64(v, new $Uint64(0, 10), true).$low << 24) >>> 24) +
                  48) <<
                  24) >>>
                24);
          v = $div64(v, new $Uint64(0, 10), false);
        }
      }
      return w;
    };
    Duration.prototype.Nanoseconds = function () {
      var d;
      d = this;
      return new $Int64(d.$high, d.$low);
    };
    $ptrType(Duration).prototype.Nanoseconds = function () {
      return this.$get().Nanoseconds();
    };
    Duration.prototype.Microseconds = function () {
      var d;
      d = this;
      return $div64(new $Int64(d.$high, d.$low), new $Int64(0, 1000), false);
    };
    $ptrType(Duration).prototype.Microseconds = function () {
      return this.$get().Microseconds();
    };
    Duration.prototype.Milliseconds = function () {
      var d;
      d = this;
      return $div64(new $Int64(d.$high, d.$low), new $Int64(0, 1000000), false);
    };
    $ptrType(Duration).prototype.Milliseconds = function () {
      return this.$get().Milliseconds();
    };
    Duration.prototype.Seconds = function () {
      var d, nsec, sec;
      d = this;
      sec = $div64(d, new Duration(0, 1000000000), false);
      nsec = $div64(d, new Duration(0, 1000000000), true);
      return $flatten64(sec) + $flatten64(nsec) / 1e9;
    };
    $ptrType(Duration).prototype.Seconds = function () {
      return this.$get().Seconds();
    };
    Duration.prototype.Minutes = function () {
      var d, min, nsec;
      d = this;
      min = $div64(d, new Duration(13, 4165425152), false);
      nsec = $div64(d, new Duration(13, 4165425152), true);
      return $flatten64(min) + $flatten64(nsec) / 6e10;
    };
    $ptrType(Duration).prototype.Minutes = function () {
      return this.$get().Minutes();
    };
    Duration.prototype.Hours = function () {
      var d, hour, nsec;
      d = this;
      hour = $div64(d, new Duration(838, 817405952), false);
      nsec = $div64(d, new Duration(838, 817405952), true);
      return $flatten64(hour) + $flatten64(nsec) / 3.6e12;
    };
    $ptrType(Duration).prototype.Hours = function () {
      return this.$get().Hours();
    };
    Duration.prototype.Truncate = function (m) {
      var d, m, x$1;
      d = this;
      if (m.$high < 0 || (m.$high === 0 && m.$low <= 0)) {
        return d;
      }
      return (
        (x$1 = $div64(d, m, true)),
        new Duration(d.$high - x$1.$high, d.$low - x$1.$low)
      );
    };
    $ptrType(Duration).prototype.Truncate = function (m) {
      return this.$get().Truncate(m);
    };
    lessThanHalf = function (x$1, y) {
      var x$1, x$2, x$3, x$4, x$5, y;
      return (
        (x$2 =
          ((x$3 = new $Uint64(x$1.$high, x$1.$low)),
          (x$4 = new $Uint64(x$1.$high, x$1.$low)),
          new $Uint64(x$3.$high + x$4.$high, x$3.$low + x$4.$low))),
        (x$5 = new $Uint64(y.$high, y.$low)),
        x$2.$high < x$5.$high ||
          (x$2.$high === x$5.$high && x$2.$low < x$5.$low)
      );
    };
    Duration.prototype.Round = function (m) {
      var d, d1, d1$1, m, r, x$1, x$2;
      d = this;
      if (m.$high < 0 || (m.$high === 0 && m.$low <= 0)) {
        return d;
      }
      r = $div64(d, m, true);
      if (d.$high < 0 || (d.$high === 0 && d.$low < 0)) {
        r = new Duration(-r.$high, -r.$low);
        if (lessThanHalf(r, m)) {
          return new Duration(d.$high + r.$high, d.$low + r.$low);
        }
        d1 =
          ((x$1 = new Duration(d.$high - m.$high, d.$low - m.$low)),
          new Duration(x$1.$high + r.$high, x$1.$low + r.$low));
        if (d1.$high < d.$high || (d1.$high === d.$high && d1.$low < d.$low)) {
          return d1;
        }
        return new Duration(-2147483648, 0);
      }
      if (lessThanHalf(r, m)) {
        return new Duration(d.$high - r.$high, d.$low - r.$low);
      }
      d1$1 =
        ((x$2 = new Duration(d.$high + m.$high, d.$low + m.$low)),
        new Duration(x$2.$high - r.$high, x$2.$low - r.$low));
      if (
        d1$1.$high > d.$high ||
        (d1$1.$high === d.$high && d1$1.$low > d.$low)
      ) {
        return d1$1;
      }
      return new Duration(2147483647, 4294967295);
    };
    $ptrType(Duration).prototype.Round = function (m) {
      return this.$get().Round(m);
    };
    Time.ptr.prototype.Add = function (d) {
      var d,
        dsec,
        nsec,
        t,
        te,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      t = this;
      dsec =
        ((x$1 = $div64(d, new Duration(0, 1000000000), false)),
        new $Int64(x$1.$high, x$1.$low));
      nsec =
        (t.nsec() +
          (((x$2 = $div64(d, new Duration(0, 1000000000), true)),
          x$2.$low + (x$2.$high >> 31) * 4294967296) >>
            0)) >>
        0;
      if (nsec >= 1000000000) {
        dsec =
          ((x$3 = new $Int64(0, 1)),
          new $Int64(dsec.$high + x$3.$high, dsec.$low + x$3.$low));
        nsec = (nsec - 1000000000) >> 0;
      } else if (nsec < 0) {
        dsec =
          ((x$4 = new $Int64(0, 1)),
          new $Int64(dsec.$high - x$4.$high, dsec.$low - x$4.$low));
        nsec = (nsec + 1000000000) >> 0;
      }
      t.wall =
        ((x$5 =
          ((x$6 = t.wall),
          new $Uint64(x$6.$high & ~0, (x$6.$low & ~1073741823) >>> 0))),
        (x$7 = new $Uint64(0, nsec)),
        new $Uint64(x$5.$high | x$7.$high, (x$5.$low | x$7.$low) >>> 0));
      t.addSec(dsec);
      if (
        !((x$8 =
          ((x$9 = t.wall),
          new $Uint64(x$9.$high & 2147483648, (x$9.$low & 0) >>> 0))),
        x$8.$high === 0 && x$8.$low === 0)
      ) {
        te =
          ((x$10 = t.ext),
          (x$11 = new $Int64(d.$high, d.$low)),
          new $Int64(x$10.$high + x$11.$high, x$10.$low + x$11.$low));
        if (
          ((d.$high < 0 || (d.$high === 0 && d.$low < 0)) &&
            ((x$12 = t.ext),
            te.$high > x$12.$high ||
              (te.$high === x$12.$high && te.$low > x$12.$low))) ||
          ((d.$high > 0 || (d.$high === 0 && d.$low > 0)) &&
            ((x$13 = t.ext),
            te.$high < x$13.$high ||
              (te.$high === x$13.$high && te.$low < x$13.$low)))
        ) {
          t.stripMono();
        } else {
          t.ext = te;
        }
      }
      return t;
    };
    Time.prototype.Add = function (d) {
      return this.$val.Add(d);
    };
    Time.ptr.prototype.Sub = function (u) {
      var d,
        d$1,
        t,
        te,
        u,
        ue,
        x$1,
        x$10,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      t = this;
      if (
        !((x$1 =
          ((x$2 =
            ((x$3 = t.wall),
            (x$4 = u.wall),
            new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0))),
          new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
        x$1.$high === 0 && x$1.$low === 0)
      ) {
        te = t.ext;
        ue = u.ext;
        d =
          ((x$5 = new $Int64(te.$high - ue.$high, te.$low - ue.$low)),
          new Duration(x$5.$high, x$5.$low));
        if (
          (d.$high < 0 || (d.$high === 0 && d.$low < 0)) &&
          (te.$high > ue.$high || (te.$high === ue.$high && te.$low > ue.$low))
        ) {
          return new Duration(2147483647, 4294967295);
        }
        if (
          (d.$high > 0 || (d.$high === 0 && d.$low > 0)) &&
          (te.$high < ue.$high || (te.$high === ue.$high && te.$low < ue.$low))
        ) {
          return new Duration(-2147483648, 0);
        }
        return d;
      }
      d$1 =
        ((x$6 = $mul64(
          ((x$7 =
            ((x$8 = t.sec()),
            (x$9 = u.sec()),
            new $Int64(x$8.$high - x$9.$high, x$8.$low - x$9.$low))),
          new Duration(x$7.$high, x$7.$low)),
          new Duration(0, 1000000000)
        )),
        (x$10 = new Duration(0, (t.nsec() - u.nsec()) >> 0)),
        new Duration(x$6.$high + x$10.$high, x$6.$low + x$10.$low));
      if ($clone($clone(u, Time).Add(d$1), Time).Equal($clone(t, Time))) {
        return d$1;
      } else if ($clone(t, Time).Before($clone(u, Time))) {
        return new Duration(-2147483648, 0);
      } else {
        return new Duration(2147483647, 4294967295);
      }
    };
    Time.prototype.Sub = function (u) {
      return this.$val.Sub(u);
    };
    Time.ptr.prototype.AddDate = function (years, months, days) {
      var {
        $24r,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        _tuple$1,
        day,
        days,
        hour,
        min,
        month,
        months,
        sec,
        t,
        year,
        years,
        $s,
        $r,
        $c,
      } = $restore(this, { years, months, days });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).Date();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            year = _tuple[0];
            month = _tuple[1];
            day = _tuple[2];
            _r$2 = $clone(t, Time).Clock();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r$2;
            hour = _tuple$1[0];
            min = _tuple$1[1];
            sec = _tuple$1[2];
            _r$3 = Date(
              (year + years) >> 0,
              (month + (months >> 0)) >> 0,
              (day + days) >> 0,
              hour,
              min,
              sec,
              t.nsec() >> 0,
              $clone(t, Time).Location()
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 4;
          case 4:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.AddDate,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        _tuple$1,
        day,
        days,
        hour,
        min,
        month,
        months,
        sec,
        t,
        year,
        years,
        $s,
      };
      return $f;
    };
    Time.prototype.AddDate = function (years, months, days) {
      return this.$val.AddDate(years, months, days);
    };
    Time.ptr.prototype.date = function (full) {
      var {
        $24r,
        _r$1,
        _r$2,
        _tuple,
        day,
        full,
        month,
        t,
        yday,
        year,
        $s,
        $r,
        $c,
      } = $restore(this, { full });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            year = 0;
            month = 0;
            day = 0;
            yday = 0;
            t = this;
            _r$1 = $clone(t, Time).abs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$2 = absDate(_r$1, full);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            year = _tuple[0];
            month = _tuple[1];
            day = _tuple[2];
            yday = _tuple[3];
            $24r = [year, month, day, yday];
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.date,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        _tuple,
        day,
        full,
        month,
        t,
        yday,
        year,
        $s,
      };
      return $f;
    };
    Time.prototype.date = function (full) {
      return this.$val.date(full);
    };
    absDate = function (abs, full) {
      var _q,
        abs,
        begin,
        d,
        day,
        end,
        full,
        month,
        n,
        x$1,
        x$10,
        x$11,
        x$12,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        y,
        yday,
        year;
      year = 0;
      month = 0;
      day = 0;
      yday = 0;
      d = $div64(abs, new $Uint64(0, 86400), false);
      n = $div64(d, new $Uint64(0, 146097), false);
      y = $mul64(new $Uint64(0, 400), n);
      d =
        ((x$1 = $mul64(new $Uint64(0, 146097), n)),
        new $Uint64(d.$high - x$1.$high, d.$low - x$1.$low));
      n = $div64(d, new $Uint64(0, 36524), false);
      n =
        ((x$2 = $shiftRightUint64(n, 2)),
        new $Uint64(n.$high - x$2.$high, n.$low - x$2.$low));
      y =
        ((x$3 = $mul64(new $Uint64(0, 100), n)),
        new $Uint64(y.$high + x$3.$high, y.$low + x$3.$low));
      d =
        ((x$4 = $mul64(new $Uint64(0, 36524), n)),
        new $Uint64(d.$high - x$4.$high, d.$low - x$4.$low));
      n = $div64(d, new $Uint64(0, 1461), false);
      y =
        ((x$5 = $mul64(new $Uint64(0, 4), n)),
        new $Uint64(y.$high + x$5.$high, y.$low + x$5.$low));
      d =
        ((x$6 = $mul64(new $Uint64(0, 1461), n)),
        new $Uint64(d.$high - x$6.$high, d.$low - x$6.$low));
      n = $div64(d, new $Uint64(0, 365), false);
      n =
        ((x$7 = $shiftRightUint64(n, 2)),
        new $Uint64(n.$high - x$7.$high, n.$low - x$7.$low));
      y = ((x$8 = n), new $Uint64(y.$high + x$8.$high, y.$low + x$8.$low));
      d =
        ((x$9 = $mul64(new $Uint64(0, 365), n)),
        new $Uint64(d.$high - x$9.$high, d.$low - x$9.$low));
      year =
        ((x$10 =
          ((x$11 = new $Int64(y.$high, y.$low)),
          new $Int64(x$11.$high + -69, x$11.$low + 4075721025))),
        x$10.$low + (x$10.$high >> 31) * 4294967296) >> 0;
      yday = d.$low >> 0;
      if (!full) {
        return [year, month, day, yday];
      }
      day = yday;
      if (isLeap(year)) {
        if (day > 59) {
          day = (day - 1) >> 0;
        } else if (day === 59) {
          month = 2;
          day = 29;
          return [year, month, day, yday];
        }
      }
      month =
        ((_q = day / 31),
        _q === _q && _q !== 1 / 0 && _q !== -1 / 0
          ? _q >> 0
          : $throwRuntimeError("integer divide by zero")) >> 0;
      end =
        ((x$12 = (month + 1) >> 0),
        x$12 < 0 || x$12 >= daysBefore.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : daysBefore[x$12]) >> 0;
      begin = 0;
      if (day >= end) {
        month = (month + 1) >> 0;
        begin = end;
      } else {
        begin =
          (month < 0 || month >= daysBefore.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : daysBefore[month]) >> 0;
      }
      month = (month + 1) >> 0;
      day = (((day - begin) >> 0) + 1) >> 0;
      return [year, month, day, yday];
    };
    daysIn = function (m, year) {
      var m, x$1, year;
      if (m === 2 && isLeap(year)) {
        return 29;
      }
      return (
        (((m < 0 || m >= daysBefore.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : daysBefore[m]) -
          ((x$1 = (m - 1) >> 0),
          x$1 < 0 || x$1 >= daysBefore.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : daysBefore[x$1])) >>
          0) >>
        0
      );
    };
    daysSinceEpoch = function (year) {
      var d, n, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y, year;
      y =
        ((x$1 =
          ((x$2 = new $Int64(0, year)),
          new $Int64(x$2.$high - -69, x$2.$low - 4075721025))),
        new $Uint64(x$1.$high, x$1.$low));
      n = $div64(y, new $Uint64(0, 400), false);
      y =
        ((x$3 = $mul64(new $Uint64(0, 400), n)),
        new $Uint64(y.$high - x$3.$high, y.$low - x$3.$low));
      d = $mul64(new $Uint64(0, 146097), n);
      n = $div64(y, new $Uint64(0, 100), false);
      y =
        ((x$4 = $mul64(new $Uint64(0, 100), n)),
        new $Uint64(y.$high - x$4.$high, y.$low - x$4.$low));
      d =
        ((x$5 = $mul64(new $Uint64(0, 36524), n)),
        new $Uint64(d.$high + x$5.$high, d.$low + x$5.$low));
      n = $div64(y, new $Uint64(0, 4), false);
      y =
        ((x$6 = $mul64(new $Uint64(0, 4), n)),
        new $Uint64(y.$high - x$6.$high, y.$low - x$6.$low));
      d =
        ((x$7 = $mul64(new $Uint64(0, 1461), n)),
        new $Uint64(d.$high + x$7.$high, d.$low + x$7.$low));
      n = y;
      d =
        ((x$8 = $mul64(new $Uint64(0, 365), n)),
        new $Uint64(d.$high + x$8.$high, d.$low + x$8.$low));
      return d;
    };
    runtimeNano = function () {
      $throwRuntimeError("native function not implemented: time.runtimeNano");
    };
    unixTime = function (sec, nsec) {
      var nsec, sec;
      return new Time.ptr(
        new $Uint64(0, nsec),
        new $Int64(sec.$high + 14, sec.$low + 2006054656),
        $pkg.Local
      );
    };
    Time.ptr.prototype.UTC = function () {
      var t;
      t = this;
      t.setLoc(utcLoc);
      return t;
    };
    Time.prototype.UTC = function () {
      return this.$val.UTC();
    };
    Time.ptr.prototype.Local = function () {
      var t;
      t = this;
      t.setLoc($pkg.Local);
      return t;
    };
    Time.prototype.Local = function () {
      return this.$val.Local();
    };
    Time.ptr.prototype.In = function (loc) {
      var loc, t;
      t = this;
      if (loc === ptrType$2.nil) {
        $panic(new $String("time: missing Location in call to Time.In"));
      }
      t.setLoc(loc);
      return t;
    };
    Time.prototype.In = function (loc) {
      return this.$val.In(loc);
    };
    Time.ptr.prototype.Location = function () {
      var l, t;
      t = this;
      l = t.loc;
      if (l === ptrType$2.nil) {
        l = $pkg.UTC;
      }
      return l;
    };
    Time.prototype.Location = function () {
      return this.$val.Location();
    };
    Time.ptr.prototype.Zone = function () {
      var { _r$1, _tuple, name, offset, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            name = "";
            offset = 0;
            t = this;
            _r$1 = t.loc.lookup(t.unixSec());
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            name = _tuple[0];
            offset = _tuple[1];
            $s = -1;
            return [name, offset];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Zone,
        $c: true,
        $r,
        _r$1,
        _tuple,
        name,
        offset,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Zone = function () {
      return this.$val.Zone();
    };
    Time.ptr.prototype.Unix = function () {
      var t;
      t = this;
      return t.unixSec();
    };
    Time.prototype.Unix = function () {
      return this.$val.Unix();
    };
    Time.ptr.prototype.UnixMilli = function () {
      var t, x$1, x$2;
      t = this;
      return (
        (x$1 = $mul64(t.unixSec(), new $Int64(0, 1000))),
        (x$2 = $div64(new $Int64(0, t.nsec()), new $Int64(0, 1000000), false)),
        new $Int64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)
      );
    };
    Time.prototype.UnixMilli = function () {
      return this.$val.UnixMilli();
    };
    Time.ptr.prototype.UnixMicro = function () {
      var t, x$1, x$2;
      t = this;
      return (
        (x$1 = $mul64(t.unixSec(), new $Int64(0, 1000000))),
        (x$2 = $div64(new $Int64(0, t.nsec()), new $Int64(0, 1000), false)),
        new $Int64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)
      );
    };
    Time.prototype.UnixMicro = function () {
      return this.$val.UnixMicro();
    };
    Time.ptr.prototype.UnixNano = function () {
      var t, x$1, x$2;
      t = this;
      return (
        (x$1 = $mul64(t.unixSec(), new $Int64(0, 1000000000))),
        (x$2 = new $Int64(0, t.nsec())),
        new $Int64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)
      );
    };
    Time.prototype.UnixNano = function () {
      return this.$val.UnixNano();
    };
    Time.ptr.prototype.MarshalBinary = function () {
      var {
        _q,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        enc,
        nsec,
        offset,
        offsetMin,
        offsetSec,
        sec,
        t,
        version,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            offsetMin = 0;
            offsetSec = 0;
            version = 1;
            /* */ if ($clone(t, Time).Location() === $pkg.UTC) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ($clone(t, Time).Location() === $pkg.UTC) { */ case 1:
            offsetMin = -1;
            $s = 3;
            continue;
          /* } else { */ case 2:
            _r$1 = $clone(t, Time).Zone();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            offset = _tuple[1];
            if (
              !(
                ((_r$2 = offset % 60),
                _r$2 === _r$2
                  ? _r$2
                  : $throwRuntimeError("integer divide by zero")) === 0
              )
            ) {
              version = 2;
              offsetSec =
                (((_r$3 = offset % 60),
                _r$3 === _r$3
                  ? _r$3
                  : $throwRuntimeError("integer divide by zero")) <<
                  24) >>
                24;
            }
            offset =
              ((_q = offset / 60),
              _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                ? _q >> 0
                : $throwRuntimeError("integer divide by zero"));
            if (offset < -32768 || offset === -1 || offset > 32767) {
              $s = -1;
              return [
                sliceType$3.nil,
                errors.New("Time.MarshalBinary: unexpected zone offset"),
              ];
            }
            offsetMin = (offset << 16) >> 16;
          /* } */ case 3:
            sec = t.sec();
            nsec = t.nsec();
            enc = new sliceType$3([
              version,
              ($shiftRightInt64(sec, 56).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 48).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 40).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 32).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 24).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 16).$low << 24) >>> 24,
              ($shiftRightInt64(sec, 8).$low << 24) >>> 24,
              (sec.$low << 24) >>> 24,
              (((nsec >> 24) >> 0) << 24) >>> 24,
              (((nsec >> 16) >> 0) << 24) >>> 24,
              (((nsec >> 8) >> 0) << 24) >>> 24,
              (nsec << 24) >>> 24,
              ((((offsetMin >> 8) << 16) >> 16) << 24) >>> 24,
              (offsetMin << 24) >>> 24,
            ]);
            if (version === 2) {
              enc = $append(enc, (offsetSec << 24) >>> 24);
            }
            $s = -1;
            return [enc, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.MarshalBinary,
        $c: true,
        $r,
        _q,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        enc,
        nsec,
        offset,
        offsetMin,
        offsetSec,
        sec,
        t,
        version,
        $s,
      };
      return $f;
    };
    Time.prototype.MarshalBinary = function () {
      return this.$val.MarshalBinary();
    };
    Time.ptr.prototype.UnmarshalBinary = function (data) {
      var {
        _r$1,
        _tuple,
        buf,
        data,
        localoff,
        nsec,
        offset,
        sec,
        t,
        version,
        wantLen,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
        $r,
        $c,
      } = $restore(this, { data });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            buf = data;
            if (buf.$length === 0) {
              $s = -1;
              return errors.New("Time.UnmarshalBinary: no data");
            }
            version =
              0 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 0];
            if (!(version === 1) && !(version === 2)) {
              $s = -1;
              return errors.New("Time.UnmarshalBinary: unsupported version");
            }
            wantLen = 15;
            if (version === 2) {
              wantLen = (wantLen + 1) >> 0;
            }
            if (!(buf.$length === wantLen)) {
              $s = -1;
              return errors.New("Time.UnmarshalBinary: invalid length");
            }
            buf = $subslice(buf, 1);
            sec =
              ((x$1 =
                ((x$2 =
                  ((x$3 =
                    ((x$4 =
                      ((x$5 =
                        ((x$6 =
                          ((x$7 = new $Int64(
                            0,
                            7 >= buf.$length
                              ? ($throwRuntimeError("index out of range"),
                                undefined)
                              : buf.$array[buf.$offset + 7]
                          )),
                          (x$8 = $shiftLeft64(
                            new $Int64(
                              0,
                              6 >= buf.$length
                                ? ($throwRuntimeError("index out of range"),
                                  undefined)
                                : buf.$array[buf.$offset + 6]
                            ),
                            8
                          )),
                          new $Int64(
                            x$7.$high | x$8.$high,
                            (x$7.$low | x$8.$low) >>> 0
                          ))),
                        (x$9 = $shiftLeft64(
                          new $Int64(
                            0,
                            5 >= buf.$length
                              ? ($throwRuntimeError("index out of range"),
                                undefined)
                              : buf.$array[buf.$offset + 5]
                          ),
                          16
                        )),
                        new $Int64(
                          x$6.$high | x$9.$high,
                          (x$6.$low | x$9.$low) >>> 0
                        ))),
                      (x$10 = $shiftLeft64(
                        new $Int64(
                          0,
                          4 >= buf.$length
                            ? ($throwRuntimeError("index out of range"),
                              undefined)
                            : buf.$array[buf.$offset + 4]
                        ),
                        24
                      )),
                      new $Int64(
                        x$5.$high | x$10.$high,
                        (x$5.$low | x$10.$low) >>> 0
                      ))),
                    (x$11 = $shiftLeft64(
                      new $Int64(
                        0,
                        3 >= buf.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : buf.$array[buf.$offset + 3]
                      ),
                      32
                    )),
                    new $Int64(
                      x$4.$high | x$11.$high,
                      (x$4.$low | x$11.$low) >>> 0
                    ))),
                  (x$12 = $shiftLeft64(
                    new $Int64(
                      0,
                      2 >= buf.$length
                        ? ($throwRuntimeError("index out of range"), undefined)
                        : buf.$array[buf.$offset + 2]
                    ),
                    40
                  )),
                  new $Int64(
                    x$3.$high | x$12.$high,
                    (x$3.$low | x$12.$low) >>> 0
                  ))),
                (x$13 = $shiftLeft64(
                  new $Int64(
                    0,
                    1 >= buf.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : buf.$array[buf.$offset + 1]
                  ),
                  48
                )),
                new $Int64(
                  x$2.$high | x$13.$high,
                  (x$2.$low | x$13.$low) >>> 0
                ))),
              (x$14 = $shiftLeft64(
                new $Int64(
                  0,
                  0 >= buf.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : buf.$array[buf.$offset + 0]
                ),
                56
              )),
              new $Int64(x$1.$high | x$14.$high, (x$1.$low | x$14.$low) >>> 0));
            buf = $subslice(buf, 8);
            nsec =
              ((3 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 3]) >>
                0) |
              ((((2 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 2]) >>
                0) <<
                8) >>
                0) |
              ((((1 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 1]) >>
                0) <<
                16) >>
                0) |
              ((((0 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 0]) >>
                0) <<
                24) >>
                0);
            buf = $subslice(buf, 4);
            offset = $imul(
              ((((1 >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + 1]) <<
                16) >>
                16) |
                ((((((0 >= buf.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : buf.$array[buf.$offset + 0]) <<
                  16) >>
                  16) <<
                  8) <<
                  16) >>
                  16)) >>
                0,
              60
            );
            if (version === 2) {
              offset =
                (offset +
                  ((2 >= buf.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : buf.$array[buf.$offset + 2]) >>
                    0)) >>
                0;
            }
            Time.copy(
              t,
              new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil)
            );
            t.wall = new $Uint64(0, nsec);
            t.ext = sec;
            /* */ if (offset === -60) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (offset === -60) { */ case 1:
            t.setLoc(utcLoc);
            $s = 3;
            continue;
          /* } else { */ case 2:
            _r$1 = $pkg.Local.lookup(t.unixSec());
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            localoff = _tuple[1];
            if (offset === localoff) {
              t.setLoc($pkg.Local);
            } else {
              t.setLoc(FixedZone("", offset));
            }
          /* } */ case 3:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.UnmarshalBinary,
        $c: true,
        $r,
        _r$1,
        _tuple,
        buf,
        data,
        localoff,
        nsec,
        offset,
        sec,
        t,
        version,
        wantLen,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9,
        $s,
      };
      return $f;
    };
    Time.prototype.UnmarshalBinary = function (data) {
      return this.$val.UnmarshalBinary(data);
    };
    Time.ptr.prototype.GobEncode = function () {
      var { $24r, _r$1, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).MarshalBinary();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.GobEncode,
        $c: true,
        $r,
        $24r,
        _r$1,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.GobEncode = function () {
      return this.$val.GobEncode();
    };
    Time.ptr.prototype.GobDecode = function (data) {
      var { $24r, _r$1, data, t, $s, $r, $c } = $restore(this, { data });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = t.UnmarshalBinary(data);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.GobDecode,
        $c: true,
        $r,
        $24r,
        _r$1,
        data,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.GobDecode = function (data) {
      return this.$val.GobDecode(data);
    };
    Time.ptr.prototype.MarshalJSON = function () {
      var { _r$1, _r$2, b, t, y, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).Year();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            y = _r$1;
            if (y < 0 || y >= 10000) {
              $s = -1;
              return [
                sliceType$3.nil,
                errors.New("Time.MarshalJSON: year outside of range [0,9999]"),
              ];
            }
            b = $makeSlice(sliceType$3, 0, 37);
            b = $append(b, 34);
            _r$2 = $clone(t, Time).AppendFormat(
              b,
              "2006-01-02T15:04:05.999999999Z07:00"
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            b = _r$2;
            b = $append(b, 34);
            $s = -1;
            return [b, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.MarshalJSON,
        $c: true,
        $r,
        _r$1,
        _r$2,
        b,
        t,
        y,
        $s,
      };
      return $f;
    };
    Time.prototype.MarshalJSON = function () {
      return this.$val.MarshalJSON();
    };
    Time.ptr.prototype.UnmarshalJSON = function (data) {
      var { _r$1, _tuple, data, err, t, $s, $r, $c } = $restore(this, { data });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            if ($bytesToString(data) === "null") {
              $s = -1;
              return $ifaceNil;
            }
            err = $ifaceNil;
            _r$1 = Parse('"2006-01-02T15:04:05Z07:00"', $bytesToString(data));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            Time.copy(t, _tuple[0]);
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.UnmarshalJSON,
        $c: true,
        $r,
        _r$1,
        _tuple,
        data,
        err,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.UnmarshalJSON = function (data) {
      return this.$val.UnmarshalJSON(data);
    };
    Time.ptr.prototype.MarshalText = function () {
      var { $24r, _r$1, _r$2, b, t, y, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).Year();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            y = _r$1;
            if (y < 0 || y >= 10000) {
              $s = -1;
              return [
                sliceType$3.nil,
                errors.New("Time.MarshalText: year outside of range [0,9999]"),
              ];
            }
            b = $makeSlice(sliceType$3, 0, 35);
            _r$2 = $clone(t, Time).AppendFormat(
              b,
              "2006-01-02T15:04:05.999999999Z07:00"
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $24r = [_r$2, $ifaceNil];
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.MarshalText,
        $c: true,
        $r,
        $24r,
        _r$1,
        _r$2,
        b,
        t,
        y,
        $s,
      };
      return $f;
    };
    Time.prototype.MarshalText = function () {
      return this.$val.MarshalText();
    };
    Time.ptr.prototype.UnmarshalText = function (data) {
      var { _r$1, _tuple, data, err, t, $s, $r, $c } = $restore(this, { data });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            err = $ifaceNil;
            _r$1 = Parse("2006-01-02T15:04:05Z07:00", $bytesToString(data));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            Time.copy(t, _tuple[0]);
            err = _tuple[1];
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.UnmarshalText,
        $c: true,
        $r,
        _r$1,
        _tuple,
        data,
        err,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.UnmarshalText = function (data) {
      return this.$val.UnmarshalText(data);
    };
    Unix = function (sec, nsec) {
      var n, nsec, sec, x$1, x$2, x$3, x$4;
      if (
        nsec.$high < 0 ||
        (nsec.$high === 0 && nsec.$low < 0) ||
        nsec.$high > 0 ||
        (nsec.$high === 0 && nsec.$low >= 1000000000)
      ) {
        n = $div64(nsec, new $Int64(0, 1000000000), false);
        sec =
          ((x$1 = n), new $Int64(sec.$high + x$1.$high, sec.$low + x$1.$low));
        nsec =
          ((x$2 = $mul64(n, new $Int64(0, 1000000000))),
          new $Int64(nsec.$high - x$2.$high, nsec.$low - x$2.$low));
        if (nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0)) {
          nsec =
            ((x$3 = new $Int64(0, 1000000000)),
            new $Int64(nsec.$high + x$3.$high, nsec.$low + x$3.$low));
          sec =
            ((x$4 = new $Int64(0, 1)),
            new $Int64(sec.$high - x$4.$high, sec.$low - x$4.$low));
        }
      }
      return unixTime(sec, (nsec.$low + (nsec.$high >> 31) * 4294967296) >> 0);
    };
    $pkg.Unix = Unix;
    Time.ptr.prototype.IsDST = function () {
      var { _r$1, _tuple, isDST, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = t.loc.lookup($clone(t, Time).Unix());
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            isDST = _tuple[4];
            $s = -1;
            return isDST;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.IsDST,
        $c: true,
        $r,
        _r$1,
        _tuple,
        isDST,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.IsDST = function () {
      return this.$val.IsDST();
    };
    isLeap = function (year) {
      var _r$1, _r$2, _r$3, year;
      return (
        ((_r$1 = year % 4),
        _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) ===
          0 &&
        (!(
          ((_r$2 = year % 100),
          _r$2 === _r$2
            ? _r$2
            : $throwRuntimeError("integer divide by zero")) === 0
        ) ||
          ((_r$3 = year % 400),
          _r$3 === _r$3
            ? _r$3
            : $throwRuntimeError("integer divide by zero")) === 0)
      );
    };
    norm = function (hi, lo, base) {
      var _q, _q$1, _tmp, _tmp$1, base, hi, lo, n, n$1, nhi, nlo;
      nhi = 0;
      nlo = 0;
      if (lo < 0) {
        n =
          (((_q = ((-lo - 1) >> 0) / base),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero")) +
            1) >>
          0;
        hi = (hi - n) >> 0;
        lo = (lo + $imul(n, base)) >> 0;
      }
      if (lo >= base) {
        n$1 =
          ((_q$1 = lo / base),
          _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
            ? _q$1 >> 0
            : $throwRuntimeError("integer divide by zero"));
        hi = (hi + n$1) >> 0;
        lo = (lo - $imul(n$1, base)) >> 0;
      }
      _tmp = hi;
      _tmp$1 = lo;
      nhi = _tmp;
      nlo = _tmp$1;
      return [nhi, nlo];
    };
    Date = function (year, month, day, hour, min, sec, nsec, loc) {
      var {
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        abs,
        d,
        day,
        end,
        hour,
        loc,
        m,
        min,
        month,
        nsec,
        offset,
        sec,
        start,
        t,
        unix,
        utc,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        year,
        $s,
        $r,
        $c,
      } = $restore(this, { year, month, day, hour, min, sec, nsec, loc });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (loc === ptrType$2.nil) {
              $panic(new $String("time: missing Location in call to Date"));
            }
            m = ((month >> 0) - 1) >> 0;
            _tuple = norm(year, m, 12);
            year = _tuple[0];
            m = _tuple[1];
            month = ((m >> 0) + 1) >> 0;
            _tuple$1 = norm(sec, nsec, 1000000000);
            sec = _tuple$1[0];
            nsec = _tuple$1[1];
            _tuple$2 = norm(min, sec, 60);
            min = _tuple$2[0];
            sec = _tuple$2[1];
            _tuple$3 = norm(hour, min, 60);
            hour = _tuple$3[0];
            min = _tuple$3[1];
            _tuple$4 = norm(day, hour, 24);
            day = _tuple$4[0];
            hour = _tuple$4[1];
            d = daysSinceEpoch(year);
            d =
              ((x$1 = new $Uint64(
                0,
                ((x$2 = (month - 1) >> 0),
                x$2 < 0 || x$2 >= daysBefore.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : daysBefore[x$2])
              )),
              new $Uint64(d.$high + x$1.$high, d.$low + x$1.$low));
            if (isLeap(year) && month >= 3) {
              d =
                ((x$3 = new $Uint64(0, 1)),
                new $Uint64(d.$high + x$3.$high, d.$low + x$3.$low));
            }
            d =
              ((x$4 = new $Uint64(0, (day - 1) >> 0)),
              new $Uint64(d.$high + x$4.$high, d.$low + x$4.$low));
            abs = $mul64(d, new $Uint64(0, 86400));
            abs =
              ((x$5 = new $Uint64(
                0,
                ((($imul(hour, 3600) + $imul(min, 60)) >> 0) + sec) >> 0
              )),
              new $Uint64(abs.$high + x$5.$high, abs.$low + x$5.$low));
            unix =
              ((x$6 = new $Int64(abs.$high, abs.$low)),
              new $Int64(x$6.$high + -2147483647, x$6.$low + 3844486912));
            _r$1 = loc.lookup(unix);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple$5 = _r$1;
            offset = _tuple$5[1];
            start = _tuple$5[2];
            end = _tuple$5[3];
            /* */ if (!(offset === 0)) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!((offset === 0))) { */ case 2:
            utc =
              ((x$7 = new $Int64(0, offset)),
              new $Int64(unix.$high - x$7.$high, unix.$low - x$7.$low));
            /* */ if (
              utc.$high < start.$high ||
              (utc.$high === start.$high && utc.$low < start.$low) ||
              utc.$high > end.$high ||
              (utc.$high === end.$high && utc.$low >= end.$low)
            ) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low)) || (utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { */ case 4:
            _r$2 = loc.lookup(utc);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple$6 = _r$2;
            offset = _tuple$6[1];
          /* } */ case 5:
            unix =
              ((x$8 = new $Int64(0, offset)),
              new $Int64(unix.$high - x$8.$high, unix.$low - x$8.$low));
          /* } */ case 3:
            t = $clone(unixTime(unix, nsec >> 0), Time);
            t.setLoc(loc);
            $s = -1;
            return t;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Date,
        $c: true,
        $r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        abs,
        d,
        day,
        end,
        hour,
        loc,
        m,
        min,
        month,
        nsec,
        offset,
        sec,
        start,
        t,
        unix,
        utc,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        year,
        $s,
      };
      return $f;
    };
    $pkg.Date = Date;
    Time.ptr.prototype.Truncate = function (d) {
      var _tuple, d, r, t;
      t = this;
      t.stripMono();
      if (d.$high < 0 || (d.$high === 0 && d.$low <= 0)) {
        return t;
      }
      _tuple = div($clone(t, Time), d);
      r = _tuple[1];
      return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
    };
    Time.prototype.Truncate = function (d) {
      return this.$val.Truncate(d);
    };
    Time.ptr.prototype.Round = function (d) {
      var _tuple, d, r, t;
      t = this;
      t.stripMono();
      if (d.$high < 0 || (d.$high === 0 && d.$low <= 0)) {
        return t;
      }
      _tuple = div($clone(t, Time), d);
      r = _tuple[1];
      if (lessThanHalf(r, d)) {
        return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
      }
      return $clone(t, Time).Add(
        new Duration(d.$high - r.$high, d.$low - r.$low)
      );
    };
    Time.prototype.Round = function (d) {
      return this.$val.Round(d);
    };
    div = function (t, d) {
      var _q,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        d,
        d0,
        d1,
        d1$1,
        neg,
        nsec,
        qmod2,
        r,
        sec,
        sec$1,
        t,
        tmp,
        u0,
        u0x,
        u1,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$15,
        x$16,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      qmod2 = 0;
      r = new Duration(0, 0);
      neg = false;
      nsec = t.nsec();
      sec = t.sec();
      if (sec.$high < 0 || (sec.$high === 0 && sec.$low < 0)) {
        neg = true;
        sec = new $Int64(-sec.$high, -sec.$low);
        nsec = -nsec;
        if (nsec < 0) {
          nsec = (nsec + 1000000000) >> 0;
          sec =
            ((x$1 = new $Int64(0, 1)),
            new $Int64(sec.$high - x$1.$high, sec.$low - x$1.$low));
        }
      }
      if (
        (d.$high < 0 || (d.$high === 0 && d.$low < 1000000000)) &&
        ((x$2 = $div64(
          new Duration(0, 1000000000),
          new Duration(d.$high + d.$high, d.$low + d.$low),
          true
        )),
        x$2.$high === 0 && x$2.$low === 0)
      ) {
        qmod2 =
          (((_q = nsec / ((d.$low + (d.$high >> 31) * 4294967296) >> 0)),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero")) >>
            0) &
          1;
        r = new Duration(
          0,
          ((_r$1 = nsec % ((d.$low + (d.$high >> 31) * 4294967296) >> 0)),
          _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"))
        );
      } else if (
        ((x$3 = $div64(d, new Duration(0, 1000000000), true)),
        x$3.$high === 0 && x$3.$low === 0)
      ) {
        d1 =
          ((x$4 = $div64(d, new Duration(0, 1000000000), false)),
          new $Int64(x$4.$high, x$4.$low));
        qmod2 =
          (((x$5 = $div64(sec, d1, false)),
          x$5.$low + (x$5.$high >> 31) * 4294967296) >>
            0) &
          1;
        r =
          ((x$6 = $mul64(
            ((x$7 = $div64(sec, d1, true)), new Duration(x$7.$high, x$7.$low)),
            new Duration(0, 1000000000)
          )),
          (x$8 = new Duration(0, nsec)),
          new Duration(x$6.$high + x$8.$high, x$6.$low + x$8.$low));
      } else {
        sec$1 = new $Uint64(sec.$high, sec.$low);
        tmp = $mul64($shiftRightUint64(sec$1, 32), new $Uint64(0, 1000000000));
        u1 = $shiftRightUint64(tmp, 32);
        u0 = $shiftLeft64(tmp, 32);
        tmp = $mul64(
          new $Uint64(sec$1.$high & 0, (sec$1.$low & 4294967295) >>> 0),
          new $Uint64(0, 1000000000)
        );
        _tmp = u0;
        _tmp$1 = new $Uint64(u0.$high + tmp.$high, u0.$low + tmp.$low);
        u0x = _tmp;
        u0 = _tmp$1;
        if (
          u0.$high < u0x.$high ||
          (u0.$high === u0x.$high && u0.$low < u0x.$low)
        ) {
          u1 =
            ((x$9 = new $Uint64(0, 1)),
            new $Uint64(u1.$high + x$9.$high, u1.$low + x$9.$low));
        }
        _tmp$2 = u0;
        _tmp$3 =
          ((x$10 = new $Uint64(0, nsec)),
          new $Uint64(u0.$high + x$10.$high, u0.$low + x$10.$low));
        u0x = _tmp$2;
        u0 = _tmp$3;
        if (
          u0.$high < u0x.$high ||
          (u0.$high === u0x.$high && u0.$low < u0x.$low)
        ) {
          u1 =
            ((x$11 = new $Uint64(0, 1)),
            new $Uint64(u1.$high + x$11.$high, u1.$low + x$11.$low));
        }
        d1$1 = new $Uint64(d.$high, d.$low);
        while (true) {
          if (
            !!((x$12 = $shiftRightUint64(d1$1, 63)),
            x$12.$high === 0 && x$12.$low === 1)
          ) {
            break;
          }
          d1$1 = $shiftLeft64(d1$1, 1);
        }
        d0 = new $Uint64(0, 0);
        while (true) {
          qmod2 = 0;
          if (
            u1.$high > d1$1.$high ||
            (u1.$high === d1$1.$high && u1.$low > d1$1.$low) ||
            (u1.$high === d1$1.$high &&
              u1.$low === d1$1.$low &&
              (u0.$high > d0.$high ||
                (u0.$high === d0.$high && u0.$low >= d0.$low)))
          ) {
            qmod2 = 1;
            _tmp$4 = u0;
            _tmp$5 = new $Uint64(u0.$high - d0.$high, u0.$low - d0.$low);
            u0x = _tmp$4;
            u0 = _tmp$5;
            if (
              u0.$high > u0x.$high ||
              (u0.$high === u0x.$high && u0.$low > u0x.$low)
            ) {
              u1 =
                ((x$13 = new $Uint64(0, 1)),
                new $Uint64(u1.$high - x$13.$high, u1.$low - x$13.$low));
            }
            u1 =
              ((x$14 = d1$1),
              new $Uint64(u1.$high - x$14.$high, u1.$low - x$14.$low));
          }
          if (
            d1$1.$high === 0 &&
            d1$1.$low === 0 &&
            ((x$15 = new $Uint64(d.$high, d.$low)),
            d0.$high === x$15.$high && d0.$low === x$15.$low)
          ) {
            break;
          }
          d0 = $shiftRightUint64(d0, 1);
          d0 =
            ((x$16 = $shiftLeft64(
              new $Uint64(d1$1.$high & 0, (d1$1.$low & 1) >>> 0),
              63
            )),
            new $Uint64(d0.$high | x$16.$high, (d0.$low | x$16.$low) >>> 0));
          d1$1 = $shiftRightUint64(d1$1, 1);
        }
        r = new Duration(u0.$high, u0.$low);
      }
      if (neg && !(r.$high === 0 && r.$low === 0)) {
        qmod2 = (qmod2 ^ 1) >> 0;
        r = new Duration(d.$high - r.$high, d.$low - r.$low);
      }
      return [qmod2, r];
    };
    initLocal = function () {
      var _q, _r$1, d, min, offset, z;
      localLoc.name = "Local";
      z = new zone.ptr("", 0, false);
      d = new $global.Date();
      offset = $imul($parseInt(d.getTimezoneOffset()) >> 0, -1);
      z.offset = $imul(offset, 60);
      z.name = "UTC";
      if (offset < 0) {
        z.name = z.name + "-";
        offset = $imul(offset, -1);
      } else {
        z.name = z.name + "+";
      }
      z.name =
        z.name +
        itoa(
          ((_q = offset / 60),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >> 0
            : $throwRuntimeError("integer divide by zero"))
        );
      min =
        ((_r$1 = offset % 60),
        _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
      if (!(min === 0)) {
        z.name = z.name + (":" + itoa(min));
      }
      localLoc.zone = new sliceType([$clone(z, zone)]);
    };
    itoa = function (i) {
      var i;
      if (i < 10) {
        return $substring("0123456789", i, (i + 1) >> 0);
      }
      return $substring(
        "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899",
        $imul(i, 2),
        ($imul(i, 2) + 2) >> 0
      );
    };
    init = function () {
      $unused(Unix(new $Int64(0, 0), new $Int64(0, 0)));
    };
    startsWithLowerCase = function (str) {
      var c, str;
      if (str.length === 0) {
        return false;
      }
      c = str.charCodeAt(0);
      return 97 <= c && c <= 122;
    };
    nextStdChunk = function (layout) {
      var _1,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$24,
        _tmp$25,
        _tmp$26,
        _tmp$27,
        _tmp$28,
        _tmp$29,
        _tmp$3,
        _tmp$30,
        _tmp$31,
        _tmp$32,
        _tmp$33,
        _tmp$34,
        _tmp$35,
        _tmp$36,
        _tmp$37,
        _tmp$38,
        _tmp$39,
        _tmp$4,
        _tmp$40,
        _tmp$41,
        _tmp$42,
        _tmp$43,
        _tmp$44,
        _tmp$45,
        _tmp$46,
        _tmp$47,
        _tmp$48,
        _tmp$49,
        _tmp$5,
        _tmp$50,
        _tmp$51,
        _tmp$52,
        _tmp$53,
        _tmp$54,
        _tmp$55,
        _tmp$56,
        _tmp$57,
        _tmp$58,
        _tmp$59,
        _tmp$6,
        _tmp$60,
        _tmp$61,
        _tmp$62,
        _tmp$63,
        _tmp$64,
        _tmp$65,
        _tmp$66,
        _tmp$67,
        _tmp$68,
        _tmp$69,
        _tmp$7,
        _tmp$70,
        _tmp$71,
        _tmp$72,
        _tmp$73,
        _tmp$74,
        _tmp$75,
        _tmp$76,
        _tmp$77,
        _tmp$78,
        _tmp$79,
        _tmp$8,
        _tmp$80,
        _tmp$81,
        _tmp$82,
        _tmp$83,
        _tmp$84,
        _tmp$85,
        _tmp$86,
        _tmp$87,
        _tmp$88,
        _tmp$89,
        _tmp$9,
        _tmp$90,
        _tmp$91,
        _tmp$92,
        c,
        ch,
        code,
        i,
        j,
        layout,
        prefix,
        std,
        std$1,
        suffix,
        x$1;
      prefix = "";
      std = 0;
      suffix = "";
      i = 0;
      while (true) {
        if (!(i < layout.length)) {
          break;
        }
        c = layout.charCodeAt(i) >> 0;
        _1 = c;
        if (_1 === 74) {
          if (
            layout.length >= (i + 3) >> 0 &&
            $substring(layout, i, (i + 3) >> 0) === "Jan"
          ) {
            if (
              layout.length >= (i + 7) >> 0 &&
              $substring(layout, i, (i + 7) >> 0) === "January"
            ) {
              _tmp = $substring(layout, 0, i);
              _tmp$1 = 257;
              _tmp$2 = $substring(layout, (i + 7) >> 0);
              prefix = _tmp;
              std = _tmp$1;
              suffix = _tmp$2;
              return [prefix, std, suffix];
            }
            if (!startsWithLowerCase($substring(layout, (i + 3) >> 0))) {
              _tmp$3 = $substring(layout, 0, i);
              _tmp$4 = 258;
              _tmp$5 = $substring(layout, (i + 3) >> 0);
              prefix = _tmp$3;
              std = _tmp$4;
              suffix = _tmp$5;
              return [prefix, std, suffix];
            }
          }
        } else if (_1 === 77) {
          if (layout.length >= (i + 3) >> 0) {
            if ($substring(layout, i, (i + 3) >> 0) === "Mon") {
              if (
                layout.length >= (i + 6) >> 0 &&
                $substring(layout, i, (i + 6) >> 0) === "Monday"
              ) {
                _tmp$6 = $substring(layout, 0, i);
                _tmp$7 = 261;
                _tmp$8 = $substring(layout, (i + 6) >> 0);
                prefix = _tmp$6;
                std = _tmp$7;
                suffix = _tmp$8;
                return [prefix, std, suffix];
              }
              if (!startsWithLowerCase($substring(layout, (i + 3) >> 0))) {
                _tmp$9 = $substring(layout, 0, i);
                _tmp$10 = 262;
                _tmp$11 = $substring(layout, (i + 3) >> 0);
                prefix = _tmp$9;
                std = _tmp$10;
                suffix = _tmp$11;
                return [prefix, std, suffix];
              }
            }
            if ($substring(layout, i, (i + 3) >> 0) === "MST") {
              _tmp$12 = $substring(layout, 0, i);
              _tmp$13 = 23;
              _tmp$14 = $substring(layout, (i + 3) >> 0);
              prefix = _tmp$12;
              std = _tmp$13;
              suffix = _tmp$14;
              return [prefix, std, suffix];
            }
          }
        } else if (_1 === 48) {
          if (
            layout.length >= (i + 2) >> 0 &&
            49 <= layout.charCodeAt((i + 1) >> 0) &&
            layout.charCodeAt((i + 1) >> 0) <= 54
          ) {
            _tmp$15 = $substring(layout, 0, i);
            _tmp$16 =
              ((x$1 = ((layout.charCodeAt((i + 1) >> 0) - 49) << 24) >>> 24),
              x$1 < 0 || x$1 >= std0x.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : std0x[x$1]);
            _tmp$17 = $substring(layout, (i + 2) >> 0);
            prefix = _tmp$15;
            std = _tmp$16;
            suffix = _tmp$17;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 3) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 48 &&
            layout.charCodeAt((i + 2) >> 0) === 50
          ) {
            _tmp$18 = $substring(layout, 0, i);
            _tmp$19 = 267;
            _tmp$20 = $substring(layout, (i + 3) >> 0);
            prefix = _tmp$18;
            std = _tmp$19;
            suffix = _tmp$20;
            return [prefix, std, suffix];
          }
        } else if (_1 === 49) {
          if (
            layout.length >= (i + 2) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 53
          ) {
            _tmp$21 = $substring(layout, 0, i);
            _tmp$22 = 524;
            _tmp$23 = $substring(layout, (i + 2) >> 0);
            prefix = _tmp$21;
            std = _tmp$22;
            suffix = _tmp$23;
            return [prefix, std, suffix];
          }
          _tmp$24 = $substring(layout, 0, i);
          _tmp$25 = 259;
          _tmp$26 = $substring(layout, (i + 1) >> 0);
          prefix = _tmp$24;
          std = _tmp$25;
          suffix = _tmp$26;
          return [prefix, std, suffix];
        } else if (_1 === 50) {
          if (
            layout.length >= (i + 4) >> 0 &&
            $substring(layout, i, (i + 4) >> 0) === "2006"
          ) {
            _tmp$27 = $substring(layout, 0, i);
            _tmp$28 = 275;
            _tmp$29 = $substring(layout, (i + 4) >> 0);
            prefix = _tmp$27;
            std = _tmp$28;
            suffix = _tmp$29;
            return [prefix, std, suffix];
          }
          _tmp$30 = $substring(layout, 0, i);
          _tmp$31 = 263;
          _tmp$32 = $substring(layout, (i + 1) >> 0);
          prefix = _tmp$30;
          std = _tmp$31;
          suffix = _tmp$32;
          return [prefix, std, suffix];
        } else if (_1 === 95) {
          if (
            layout.length >= (i + 2) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 50
          ) {
            if (
              layout.length >= (i + 5) >> 0 &&
              $substring(layout, (i + 1) >> 0, (i + 5) >> 0) === "2006"
            ) {
              _tmp$33 = $substring(layout, 0, (i + 1) >> 0);
              _tmp$34 = 275;
              _tmp$35 = $substring(layout, (i + 5) >> 0);
              prefix = _tmp$33;
              std = _tmp$34;
              suffix = _tmp$35;
              return [prefix, std, suffix];
            }
            _tmp$36 = $substring(layout, 0, i);
            _tmp$37 = 264;
            _tmp$38 = $substring(layout, (i + 2) >> 0);
            prefix = _tmp$36;
            std = _tmp$37;
            suffix = _tmp$38;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 3) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 95 &&
            layout.charCodeAt((i + 2) >> 0) === 50
          ) {
            _tmp$39 = $substring(layout, 0, i);
            _tmp$40 = 266;
            _tmp$41 = $substring(layout, (i + 3) >> 0);
            prefix = _tmp$39;
            std = _tmp$40;
            suffix = _tmp$41;
            return [prefix, std, suffix];
          }
        } else if (_1 === 51) {
          _tmp$42 = $substring(layout, 0, i);
          _tmp$43 = 525;
          _tmp$44 = $substring(layout, (i + 1) >> 0);
          prefix = _tmp$42;
          std = _tmp$43;
          suffix = _tmp$44;
          return [prefix, std, suffix];
        } else if (_1 === 52) {
          _tmp$45 = $substring(layout, 0, i);
          _tmp$46 = 527;
          _tmp$47 = $substring(layout, (i + 1) >> 0);
          prefix = _tmp$45;
          std = _tmp$46;
          suffix = _tmp$47;
          return [prefix, std, suffix];
        } else if (_1 === 53) {
          _tmp$48 = $substring(layout, 0, i);
          _tmp$49 = 529;
          _tmp$50 = $substring(layout, (i + 1) >> 0);
          prefix = _tmp$48;
          std = _tmp$49;
          suffix = _tmp$50;
          return [prefix, std, suffix];
        } else if (_1 === 80) {
          if (
            layout.length >= (i + 2) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 77
          ) {
            _tmp$51 = $substring(layout, 0, i);
            _tmp$52 = 533;
            _tmp$53 = $substring(layout, (i + 2) >> 0);
            prefix = _tmp$51;
            std = _tmp$52;
            suffix = _tmp$53;
            return [prefix, std, suffix];
          }
        } else if (_1 === 112) {
          if (
            layout.length >= (i + 2) >> 0 &&
            layout.charCodeAt((i + 1) >> 0) === 109
          ) {
            _tmp$54 = $substring(layout, 0, i);
            _tmp$55 = 534;
            _tmp$56 = $substring(layout, (i + 2) >> 0);
            prefix = _tmp$54;
            std = _tmp$55;
            suffix = _tmp$56;
            return [prefix, std, suffix];
          }
        } else if (_1 === 45) {
          if (
            layout.length >= (i + 7) >> 0 &&
            $substring(layout, i, (i + 7) >> 0) === "-070000"
          ) {
            _tmp$57 = $substring(layout, 0, i);
            _tmp$58 = 30;
            _tmp$59 = $substring(layout, (i + 7) >> 0);
            prefix = _tmp$57;
            std = _tmp$58;
            suffix = _tmp$59;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 9) >> 0 &&
            $substring(layout, i, (i + 9) >> 0) === "-07:00:00"
          ) {
            _tmp$60 = $substring(layout, 0, i);
            _tmp$61 = 33;
            _tmp$62 = $substring(layout, (i + 9) >> 0);
            prefix = _tmp$60;
            std = _tmp$61;
            suffix = _tmp$62;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 5) >> 0 &&
            $substring(layout, i, (i + 5) >> 0) === "-0700"
          ) {
            _tmp$63 = $substring(layout, 0, i);
            _tmp$64 = 29;
            _tmp$65 = $substring(layout, (i + 5) >> 0);
            prefix = _tmp$63;
            std = _tmp$64;
            suffix = _tmp$65;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 6) >> 0 &&
            $substring(layout, i, (i + 6) >> 0) === "-07:00"
          ) {
            _tmp$66 = $substring(layout, 0, i);
            _tmp$67 = 32;
            _tmp$68 = $substring(layout, (i + 6) >> 0);
            prefix = _tmp$66;
            std = _tmp$67;
            suffix = _tmp$68;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 3) >> 0 &&
            $substring(layout, i, (i + 3) >> 0) === "-07"
          ) {
            _tmp$69 = $substring(layout, 0, i);
            _tmp$70 = 31;
            _tmp$71 = $substring(layout, (i + 3) >> 0);
            prefix = _tmp$69;
            std = _tmp$70;
            suffix = _tmp$71;
            return [prefix, std, suffix];
          }
        } else if (_1 === 90) {
          if (
            layout.length >= (i + 7) >> 0 &&
            $substring(layout, i, (i + 7) >> 0) === "Z070000"
          ) {
            _tmp$72 = $substring(layout, 0, i);
            _tmp$73 = 25;
            _tmp$74 = $substring(layout, (i + 7) >> 0);
            prefix = _tmp$72;
            std = _tmp$73;
            suffix = _tmp$74;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 9) >> 0 &&
            $substring(layout, i, (i + 9) >> 0) === "Z07:00:00"
          ) {
            _tmp$75 = $substring(layout, 0, i);
            _tmp$76 = 28;
            _tmp$77 = $substring(layout, (i + 9) >> 0);
            prefix = _tmp$75;
            std = _tmp$76;
            suffix = _tmp$77;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 5) >> 0 &&
            $substring(layout, i, (i + 5) >> 0) === "Z0700"
          ) {
            _tmp$78 = $substring(layout, 0, i);
            _tmp$79 = 24;
            _tmp$80 = $substring(layout, (i + 5) >> 0);
            prefix = _tmp$78;
            std = _tmp$79;
            suffix = _tmp$80;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 6) >> 0 &&
            $substring(layout, i, (i + 6) >> 0) === "Z07:00"
          ) {
            _tmp$81 = $substring(layout, 0, i);
            _tmp$82 = 27;
            _tmp$83 = $substring(layout, (i + 6) >> 0);
            prefix = _tmp$81;
            std = _tmp$82;
            suffix = _tmp$83;
            return [prefix, std, suffix];
          }
          if (
            layout.length >= (i + 3) >> 0 &&
            $substring(layout, i, (i + 3) >> 0) === "Z07"
          ) {
            _tmp$84 = $substring(layout, 0, i);
            _tmp$85 = 26;
            _tmp$86 = $substring(layout, (i + 3) >> 0);
            prefix = _tmp$84;
            std = _tmp$85;
            suffix = _tmp$86;
            return [prefix, std, suffix];
          }
        } else if (_1 === 46 || _1 === 44) {
          if (
            (i + 1) >> 0 < layout.length &&
            (layout.charCodeAt((i + 1) >> 0) === 48 ||
              layout.charCodeAt((i + 1) >> 0) === 57)
          ) {
            ch = layout.charCodeAt((i + 1) >> 0);
            j = (i + 1) >> 0;
            while (true) {
              if (!(j < layout.length && layout.charCodeAt(j) === ch)) {
                break;
              }
              j = (j + 1) >> 0;
            }
            if (!isDigit(layout, j)) {
              code = 34;
              if (layout.charCodeAt((i + 1) >> 0) === 57) {
                code = 35;
              }
              std$1 = stdFracSecond(code, (j - ((i + 1) >> 0)) >> 0, c);
              _tmp$87 = $substring(layout, 0, i);
              _tmp$88 = std$1;
              _tmp$89 = $substring(layout, j);
              prefix = _tmp$87;
              std = _tmp$88;
              suffix = _tmp$89;
              return [prefix, std, suffix];
            }
          }
        }
        i = (i + 1) >> 0;
      }
      _tmp$90 = layout;
      _tmp$91 = 0;
      _tmp$92 = "";
      prefix = _tmp$90;
      std = _tmp$91;
      suffix = _tmp$92;
      return [prefix, std, suffix];
    };
    match = function (s1, s2) {
      var c1, c2, i, s1, s2;
      i = 0;
      while (true) {
        if (!(i < s1.length)) {
          break;
        }
        c1 = s1.charCodeAt(i);
        c2 = s2.charCodeAt(i);
        if (!(c1 === c2)) {
          c1 = (c1 | 32) >>> 0;
          c2 = (c2 | 32) >>> 0;
          if (!(c1 === c2) || c1 < 97 || c1 > 122) {
            return false;
          }
        }
        i = (i + 1) >> 0;
      }
      return true;
    };
    lookup = function (tab, val) {
      var _i, _ref, i, tab, v, val;
      _ref = tab;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        v =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (val.length >= v.length && match($substring(val, 0, v.length), v)) {
          return [i, $substring(val, v.length), $ifaceNil];
        }
        _i++;
      }
      return [-1, val, errBad];
    };
    appendInt = function (b, x$1, width) {
      var _q, b, buf, i, q, u, w, width, x$1;
      u = x$1 >>> 0;
      if (x$1 < 0) {
        b = $append(b, 45);
        u = -x$1 >>> 0;
      }
      buf = arrayType$3.zero();
      i = 20;
      while (true) {
        if (!(u >= 10)) {
          break;
        }
        i = (i - 1) >> 0;
        q =
          ((_q = u / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >>> 0
            : $throwRuntimeError("integer divide by zero"));
        i < 0 || i >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[i] =
              (((((48 + u) >>> 0) - ((q * 10) >>> 0)) >>> 0) << 24) >>> 24);
        u = q;
      }
      i = (i - 1) >> 0;
      i < 0 || i >= buf.length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf[i] = (((48 + u) >>> 0) << 24) >>> 24);
      w = (20 - i) >> 0;
      while (true) {
        if (!(w < width)) {
          break;
        }
        b = $append(b, 48);
        w = (w + 1) >> 0;
      }
      return $appendSlice(b, $subslice(new sliceType$3(buf), i));
    };
    atoi = function (s) {
      var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, neg, q, rem, s, x$1;
      x$1 = 0;
      err = $ifaceNil;
      neg = false;
      if (!(s === "") && (s.charCodeAt(0) === 45 || s.charCodeAt(0) === 43)) {
        neg = s.charCodeAt(0) === 45;
        s = $substring(s, 1);
      }
      _tuple = leadingInt(s);
      q = _tuple[0];
      rem = _tuple[1];
      err = _tuple[2];
      x$1 = q.$low >> 0;
      if (!$interfaceIsEqual(err, $ifaceNil) || !(rem === "")) {
        _tmp = 0;
        _tmp$1 = atoiError;
        x$1 = _tmp;
        err = _tmp$1;
        return [x$1, err];
      }
      if (neg) {
        x$1 = -x$1;
      }
      _tmp$2 = x$1;
      _tmp$3 = $ifaceNil;
      x$1 = _tmp$2;
      err = _tmp$3;
      return [x$1, err];
    };
    stdFracSecond = function (code, n, c) {
      var c, code, n;
      if (c === 46) {
        return code | (((n & 4095) << 16) >> 0);
      }
      return code | (((n & 4095) << 16) >> 0) | 268435456;
    };
    digitsLen = function (std) {
      var std;
      return ((std >> 16) >> 0) & 4095;
    };
    separator = function (std) {
      var std;
      if ((std >> 28) >> 0 === 0) {
        return 46;
      }
      return 44;
    };
    formatNano = function (b, nanosec, std) {
      var _q, _r$1, b, buf, n, nanosec, separator$1, start, std, trim, u, x$1;
      n = digitsLen(std);
      separator$1 = separator(std);
      trim = (std & 65535) === 35;
      u = nanosec;
      buf = arrayType$4.zero();
      start = 9;
      while (true) {
        if (!(start > 0)) {
          break;
        }
        start = (start - 1) >> 0;
        start < 0 || start >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[start] =
              (((((_r$1 = u % 10),
              _r$1 === _r$1
                ? _r$1
                : $throwRuntimeError("integer divide by zero")) +
                48) >>>
                0) <<
                24) >>>
              24);
        u =
          ((_q = u / 10),
          _q === _q && _q !== 1 / 0 && _q !== -1 / 0
            ? _q >>> 0
            : $throwRuntimeError("integer divide by zero"));
      }
      if (n > 9) {
        n = 9;
      }
      if (trim) {
        while (true) {
          if (
            !(
              n > 0 &&
              ((x$1 = (n - 1) >> 0),
              x$1 < 0 || x$1 >= buf.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf[x$1]) === 48
            )
          ) {
            break;
          }
          n = (n - 1) >> 0;
        }
        if (n === 0) {
          return b;
        }
      }
      b = $append(b, separator$1);
      return $appendSlice(b, $subslice(new sliceType$3(buf), 0, n));
    };
    Time.ptr.prototype.String = function () {
      var {
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        buf,
        m0,
        m1,
        m2,
        s,
        sign,
        t,
        wid,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).Format(
              "2006-01-02 15:04:05.999999999 -0700 MST"
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            s = _r$1;
            if (
              !((x$1 =
                ((x$2 = t.wall),
                new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0))),
              x$1.$high === 0 && x$1.$low === 0)
            ) {
              m2 = ((x$3 = t.ext), new $Uint64(x$3.$high, x$3.$low));
              sign = 43;
              if (
                ((x$4 = t.ext),
                x$4.$high < 0 || (x$4.$high === 0 && x$4.$low < 0))
              ) {
                sign = 45;
                m2 = new $Uint64(-m2.$high, -m2.$low);
              }
              _tmp = $div64(m2, new $Uint64(0, 1000000000), false);
              _tmp$1 = $div64(m2, new $Uint64(0, 1000000000), true);
              m1 = _tmp;
              m2 = _tmp$1;
              _tmp$2 = $div64(m1, new $Uint64(0, 1000000000), false);
              _tmp$3 = $div64(m1, new $Uint64(0, 1000000000), true);
              m0 = _tmp$2;
              m1 = _tmp$3;
              buf = $makeSlice(sliceType$3, 0, 24);
              buf = $appendSlice(buf, " m=");
              buf = $append(buf, sign);
              wid = 0;
              if (!(m0.$high === 0 && m0.$low === 0)) {
                buf = appendInt(buf, m0.$low >> 0, 0);
                wid = 9;
              }
              buf = appendInt(buf, m1.$low >> 0, wid);
              buf = $append(buf, 46);
              buf = appendInt(buf, m2.$low >> 0, 9);
              s = s + $bytesToString(buf);
            }
            $s = -1;
            return s;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.String,
        $c: true,
        $r,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        buf,
        m0,
        m1,
        m2,
        s,
        sign,
        t,
        wid,
        x$1,
        x$2,
        x$3,
        x$4,
        $s,
      };
      return $f;
    };
    Time.prototype.String = function () {
      return this.$val.String();
    };
    Time.ptr.prototype.GoString = function () {
      var {
        _1,
        _arg,
        _arg$1,
        _arg$10,
        _arg$11,
        _arg$2,
        _arg$3,
        _arg$4,
        _arg$5,
        _arg$6,
        _arg$7,
        _arg$8,
        _arg$9,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        buf,
        loc,
        month,
        t,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            buf = $makeSlice(sliceType$3, 0, 70);
            buf = $appendSlice(buf, "time.Date(");
            _arg = buf;
            _r$1 = $clone(t, Time).Year();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r$1;
            _r$2 = appendInt(_arg, _arg$1, 0);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            buf = _r$2;
            _r$3 = $clone(t, Time).Month();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            month = _r$3;
            /* */ if (1 <= month && month <= 12) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (1 <= month && month <= 12) { */ case 4:
            buf = $appendSlice(buf, ", time.");
            _arg$2 = buf;
            _r$4 = $clone(t, Time).Month();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _r$5 = new Month(_r$4).String();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _arg$3 = _r$5;
            buf = $appendSlice(_arg$2, _arg$3);
            $s = 6;
            continue;
          /* } else { */ case 5:
            buf = appendInt(buf, month >> 0, 0);
          /* } */ case 6:
            buf = $appendSlice(buf, ", ");
            _arg$4 = buf;
            _r$6 = $clone(t, Time).Day();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _arg$5 = _r$6;
            _r$7 = appendInt(_arg$4, _arg$5, 0);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            buf = _r$7;
            buf = $appendSlice(buf, ", ");
            _arg$6 = buf;
            _r$8 = $clone(t, Time).Hour();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            _arg$7 = _r$8;
            _r$9 = appendInt(_arg$6, _arg$7, 0);
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            buf = _r$9;
            buf = $appendSlice(buf, ", ");
            _arg$8 = buf;
            _r$10 = $clone(t, Time).Minute();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _arg$9 = _r$10;
            _r$11 = appendInt(_arg$8, _arg$9, 0);
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$11 = _r$11.$blk();
            }
            if (_r$11 && _r$11.$blk !== undefined) {
              break s;
            }
            buf = _r$11;
            buf = $appendSlice(buf, ", ");
            _arg$10 = buf;
            _r$12 = $clone(t, Time).Second();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r$12 = _r$12.$blk();
            }
            if (_r$12 && _r$12.$blk !== undefined) {
              break s;
            }
            _arg$11 = _r$12;
            _r$13 = appendInt(_arg$10, _arg$11, 0);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$13 = _r$13.$blk();
            }
            if (_r$13 && _r$13.$blk !== undefined) {
              break s;
            }
            buf = _r$13;
            buf = $appendSlice(buf, ", ");
            buf = appendInt(buf, $clone(t, Time).Nanosecond(), 0);
            buf = $appendSlice(buf, ", ");
            loc = $clone(t, Time).Location();
            _1 = loc;
            if (_1 === $pkg.UTC || _1 === ptrType$2.nil) {
              buf = $appendSlice(buf, "time.UTC");
            } else if (_1 === $pkg.Local) {
              buf = $appendSlice(buf, "time.Local");
            } else {
              buf = $appendSlice(buf, "time.Location(");
              buf = $appendSlice(
                buf,
                new sliceType$3($stringToBytes(quote(loc.name)))
              );
              buf = $appendSlice(buf, ")");
            }
            buf = $append(buf, 41);
            $s = -1;
            return $bytesToString(buf);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.GoString,
        $c: true,
        $r,
        _1,
        _arg,
        _arg$1,
        _arg$10,
        _arg$11,
        _arg$2,
        _arg$3,
        _arg$4,
        _arg$5,
        _arg$6,
        _arg$7,
        _arg$8,
        _arg$9,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        buf,
        loc,
        month,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.GoString = function () {
      return this.$val.GoString();
    };
    Time.ptr.prototype.Format = function (layout) {
      var { _r$1, b, buf, layout, max, t, $s, $r, $c } = $restore(this, {
        layout,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            b = sliceType$3.nil;
            max = (layout.length + 10) >> 0;
            if (max < 64) {
              buf = arrayType$5.zero();
              b = $subslice(new sliceType$3(buf), 0, 0);
            } else {
              b = $makeSlice(sliceType$3, 0, max);
            }
            _r$1 = $clone(t, Time).AppendFormat(b, layout);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            b = _r$1;
            $s = -1;
            return $bytesToString(b);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.Format,
        $c: true,
        $r,
        _r$1,
        b,
        buf,
        layout,
        max,
        t,
        $s,
      };
      return $f;
    };
    Time.prototype.Format = function (layout) {
      return this.$val.Format(layout);
    };
    Time.ptr.prototype.AppendFormat = function (b, layout) {
      var {
        _1,
        _q,
        _q$1,
        _q$2,
        _q$3,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        abs,
        absoffset,
        b,
        day,
        hour,
        hr,
        hr$1,
        layout,
        m,
        min,
        month,
        name,
        offset,
        prefix,
        s,
        sec,
        std,
        suffix,
        t,
        y,
        yday,
        year,
        zone$1,
        zone$2,
        $s,
        $r,
        $c,
      } = $restore(this, { b, layout });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            t = this;
            _r$1 = $clone(t, Time).locabs();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            name = _tuple[0];
            offset = _tuple[1];
            abs = _tuple[2];
            year = -1;
            month = 0;
            day = 0;
            yday = 0;
            hour = -1;
            min = 0;
            sec = 0;
            while (true) {
              if (!!(layout === "")) {
                break;
              }
              _tuple$1 = nextStdChunk(layout);
              prefix = _tuple$1[0];
              std = _tuple$1[1];
              suffix = _tuple$1[2];
              if (!(prefix === "")) {
                b = $appendSlice(b, prefix);
              }
              if (std === 0) {
                break;
              }
              layout = suffix;
              if (year < 0 && !((std & 256) === 0)) {
                _tuple$2 = absDate(abs, true);
                year = _tuple$2[0];
                month = _tuple$2[1];
                day = _tuple$2[2];
                yday = _tuple$2[3];
                yday = (yday + 1) >> 0;
              }
              if (hour < 0 && !((std & 512) === 0)) {
                _tuple$3 = absClock(abs);
                hour = _tuple$3[0];
                min = _tuple$3[1];
                sec = _tuple$3[2];
              }
              switch (0) {
                default:
                  _1 = std & 65535;
                  if (_1 === 276) {
                    y = year;
                    if (y < 0) {
                      y = -y;
                    }
                    b = appendInt(
                      b,
                      ((_r$2 = y % 100),
                      _r$2 === _r$2
                        ? _r$2
                        : $throwRuntimeError("integer divide by zero")),
                      2
                    );
                  } else if (_1 === 275) {
                    b = appendInt(b, year, 4);
                  } else if (_1 === 258) {
                    b = $appendSlice(
                      b,
                      $substring(new Month(month).String(), 0, 3)
                    );
                  } else if (_1 === 257) {
                    m = new Month(month).String();
                    b = $appendSlice(b, m);
                  } else if (_1 === 259) {
                    b = appendInt(b, month >> 0, 0);
                  } else if (_1 === 260) {
                    b = appendInt(b, month >> 0, 2);
                  } else if (_1 === 262) {
                    b = $appendSlice(
                      b,
                      $substring(new Weekday(absWeekday(abs)).String(), 0, 3)
                    );
                  } else if (_1 === 261) {
                    s = new Weekday(absWeekday(abs)).String();
                    b = $appendSlice(b, s);
                  } else if (_1 === 263) {
                    b = appendInt(b, day, 0);
                  } else if (_1 === 264) {
                    if (day < 10) {
                      b = $append(b, 32);
                    }
                    b = appendInt(b, day, 0);
                  } else if (_1 === 265) {
                    b = appendInt(b, day, 2);
                  } else if (_1 === 266) {
                    if (yday < 100) {
                      b = $append(b, 32);
                      if (yday < 10) {
                        b = $append(b, 32);
                      }
                    }
                    b = appendInt(b, yday, 0);
                  } else if (_1 === 267) {
                    b = appendInt(b, yday, 3);
                  } else if (_1 === 524) {
                    b = appendInt(b, hour, 2);
                  } else if (_1 === 525) {
                    hr =
                      ((_r$3 = hour % 12),
                      _r$3 === _r$3
                        ? _r$3
                        : $throwRuntimeError("integer divide by zero"));
                    if (hr === 0) {
                      hr = 12;
                    }
                    b = appendInt(b, hr, 0);
                  } else if (_1 === 526) {
                    hr$1 =
                      ((_r$4 = hour % 12),
                      _r$4 === _r$4
                        ? _r$4
                        : $throwRuntimeError("integer divide by zero"));
                    if (hr$1 === 0) {
                      hr$1 = 12;
                    }
                    b = appendInt(b, hr$1, 2);
                  } else if (_1 === 527) {
                    b = appendInt(b, min, 0);
                  } else if (_1 === 528) {
                    b = appendInt(b, min, 2);
                  } else if (_1 === 529) {
                    b = appendInt(b, sec, 0);
                  } else if (_1 === 530) {
                    b = appendInt(b, sec, 2);
                  } else if (_1 === 533) {
                    if (hour >= 12) {
                      b = $appendSlice(b, "PM");
                    } else {
                      b = $appendSlice(b, "AM");
                    }
                  } else if (_1 === 534) {
                    if (hour >= 12) {
                      b = $appendSlice(b, "pm");
                    } else {
                      b = $appendSlice(b, "am");
                    }
                  } else if (
                    _1 === 24 ||
                    _1 === 27 ||
                    _1 === 25 ||
                    _1 === 26 ||
                    _1 === 28 ||
                    _1 === 29 ||
                    _1 === 32 ||
                    _1 === 30 ||
                    _1 === 31 ||
                    _1 === 33
                  ) {
                    if (
                      offset === 0 &&
                      (std === 24 ||
                        std === 27 ||
                        std === 25 ||
                        std === 26 ||
                        std === 28)
                    ) {
                      b = $append(b, 90);
                      break;
                    }
                    zone$1 =
                      ((_q = offset / 60),
                      _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                        ? _q >> 0
                        : $throwRuntimeError("integer divide by zero"));
                    absoffset = offset;
                    if (zone$1 < 0) {
                      b = $append(b, 45);
                      zone$1 = -zone$1;
                      absoffset = -absoffset;
                    } else {
                      b = $append(b, 43);
                    }
                    b = appendInt(
                      b,
                      ((_q$1 = zone$1 / 60),
                      _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
                        ? _q$1 >> 0
                        : $throwRuntimeError("integer divide by zero")),
                      2
                    );
                    if (std === 27 || std === 32 || std === 28 || std === 33) {
                      b = $append(b, 58);
                    }
                    if (!(std === 31) && !(std === 26)) {
                      b = appendInt(
                        b,
                        ((_r$5 = zone$1 % 60),
                        _r$5 === _r$5
                          ? _r$5
                          : $throwRuntimeError("integer divide by zero")),
                        2
                      );
                    }
                    if (std === 25 || std === 30 || std === 33 || std === 28) {
                      if (std === 33 || std === 28) {
                        b = $append(b, 58);
                      }
                      b = appendInt(
                        b,
                        ((_r$6 = absoffset % 60),
                        _r$6 === _r$6
                          ? _r$6
                          : $throwRuntimeError("integer divide by zero")),
                        2
                      );
                    }
                  } else if (_1 === 23) {
                    if (!(name === "")) {
                      b = $appendSlice(b, name);
                      break;
                    }
                    zone$2 =
                      ((_q$2 = offset / 60),
                      _q$2 === _q$2 && _q$2 !== 1 / 0 && _q$2 !== -1 / 0
                        ? _q$2 >> 0
                        : $throwRuntimeError("integer divide by zero"));
                    if (zone$2 < 0) {
                      b = $append(b, 45);
                      zone$2 = -zone$2;
                    } else {
                      b = $append(b, 43);
                    }
                    b = appendInt(
                      b,
                      ((_q$3 = zone$2 / 60),
                      _q$3 === _q$3 && _q$3 !== 1 / 0 && _q$3 !== -1 / 0
                        ? _q$3 >> 0
                        : $throwRuntimeError("integer divide by zero")),
                      2
                    );
                    b = appendInt(
                      b,
                      ((_r$7 = zone$2 % 60),
                      _r$7 === _r$7
                        ? _r$7
                        : $throwRuntimeError("integer divide by zero")),
                      2
                    );
                  } else if (_1 === 34 || _1 === 35) {
                    b = formatNano(b, $clone(t, Time).Nanosecond() >>> 0, std);
                  }
              }
            }
            $s = -1;
            return b;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Time.ptr.prototype.AppendFormat,
        $c: true,
        $r,
        _1,
        _q,
        _q$1,
        _q$2,
        _q$3,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        abs,
        absoffset,
        b,
        day,
        hour,
        hr,
        hr$1,
        layout,
        m,
        min,
        month,
        name,
        offset,
        prefix,
        s,
        sec,
        std,
        suffix,
        t,
        y,
        yday,
        year,
        zone$1,
        zone$2,
        $s,
      };
      return $f;
    };
    Time.prototype.AppendFormat = function (b, layout) {
      return this.$val.AppendFormat(b, layout);
    };
    quote = function (s) {
      var _i, _ref, _rune, buf, c, i, j, s, width;
      buf = $makeSlice(sliceType$3, 1, (s.length + 2) >> 0);
      0 >= buf.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf.$array[buf.$offset + 0] = 34);
      _ref = s;
      _i = 0;
      while (true) {
        if (!(_i < _ref.length)) {
          break;
        }
        _rune = $decodeRune(_ref, _i);
        i = _i;
        c = _rune[0];
        if (c >= 128 || c < 32) {
          width = 0;
          if (c === 65533) {
            width = 1;
            if (
              (i + 2) >> 0 < s.length &&
              $substring(s, i, (i + 3) >> 0) === "\xEF\xBF\xBD"
            ) {
              width = 3;
            }
          } else {
            width = $encodeRune(c).length;
          }
          j = 0;
          while (true) {
            if (!(j < width)) {
              break;
            }
            buf = $appendSlice(buf, "\\x");
            buf = $append(
              buf,
              "0123456789abcdef".charCodeAt(
                ((s.charCodeAt((i + j) >> 0) >>> 4) << 24) >>> 24
              )
            );
            buf = $append(
              buf,
              "0123456789abcdef".charCodeAt(
                (s.charCodeAt((i + j) >> 0) & 15) >>> 0
              )
            );
            j = (j + 1) >> 0;
          }
        } else {
          if (c === 34 || c === 92) {
            buf = $append(buf, 92);
          }
          buf = $appendSlice(buf, $encodeRune(c));
        }
        _i += _rune[1];
      }
      buf = $append(buf, 34);
      return $bytesToString(buf);
    };
    ParseError.ptr.prototype.Error = function () {
      var e;
      e = this;
      if (e.Message === "") {
        return (
          "parsing time " +
          quote(e.Value) +
          " as " +
          quote(e.Layout) +
          ": cannot parse " +
          quote(e.ValueElem) +
          " as " +
          quote(e.LayoutElem)
        );
      }
      return "parsing time " + quote(e.Value) + e.Message;
    };
    ParseError.prototype.Error = function () {
      return this.$val.Error();
    };
    isDigit = function (s, i) {
      var c, i, s;
      if (s.length <= i) {
        return false;
      }
      c = s.charCodeAt(i);
      return 48 <= c && c <= 57;
    };
    getnum = function (s, fixed) {
      var fixed, s;
      if (!isDigit(s, 0)) {
        return [0, s, errBad];
      }
      if (!isDigit(s, 1)) {
        if (fixed) {
          return [0, s, errBad];
        }
        return [
          (((s.charCodeAt(0) - 48) << 24) >>> 24) >> 0,
          $substring(s, 1),
          $ifaceNil,
        ];
      }
      return [
        ($imul((((s.charCodeAt(0) - 48) << 24) >>> 24) >> 0, 10) +
          ((((s.charCodeAt(1) - 48) << 24) >>> 24) >> 0)) >>
          0,
        $substring(s, 2),
        $ifaceNil,
      ];
    };
    getnum3 = function (s, fixed) {
      var _tmp, _tmp$1, fixed, i, n, s;
      _tmp = 0;
      _tmp$1 = 0;
      n = _tmp;
      i = _tmp$1;
      i = 0;
      while (true) {
        if (!(i < 3 && isDigit(s, i))) {
          break;
        }
        n =
          ($imul(n, 10) + ((((s.charCodeAt(i) - 48) << 24) >>> 24) >> 0)) >> 0;
        i = (i + 1) >> 0;
      }
      if (i === 0 || (fixed && !(i === 3))) {
        return [0, s, errBad];
      }
      return [n, $substring(s, i), $ifaceNil];
    };
    cutspace = function (s) {
      var s;
      while (true) {
        if (!(s.length > 0 && s.charCodeAt(0) === 32)) {
          break;
        }
        s = $substring(s, 1);
      }
      return s;
    };
    skip = function (value, prefix) {
      var prefix, value;
      while (true) {
        if (!(prefix.length > 0)) {
          break;
        }
        if (prefix.charCodeAt(0) === 32) {
          if (value.length > 0 && !(value.charCodeAt(0) === 32)) {
            return [value, errBad];
          }
          prefix = cutspace(prefix);
          value = cutspace(value);
          continue;
        }
        if (
          value.length === 0 ||
          !(value.charCodeAt(0) === prefix.charCodeAt(0))
        ) {
          return [value, errBad];
        }
        prefix = $substring(prefix, 1);
        value = $substring(value, 1);
      }
      return [value, $ifaceNil];
    };
    Parse = function (layout, value) {
      var { $24r, _r$1, layout, value, $s, $r, $c } = $restore(this, {
        layout,
        value,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$1 = parse(layout, value, $pkg.UTC, $pkg.Local);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = _r$1;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: Parse, $c: true, $r, $24r, _r$1, layout, value, $s };
      return $f;
    };
    $pkg.Parse = Parse;
    parse = function (layout, value, defaultLocation, local) {
      var {
        $24r,
        $24r$1,
        _1,
        _2,
        _3,
        _4,
        _q,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$24,
        _tmp$25,
        _tmp$26,
        _tmp$27,
        _tmp$28,
        _tmp$29,
        _tmp$3,
        _tmp$30,
        _tmp$31,
        _tmp$32,
        _tmp$33,
        _tmp$34,
        _tmp$35,
        _tmp$36,
        _tmp$37,
        _tmp$38,
        _tmp$39,
        _tmp$4,
        _tmp$40,
        _tmp$41,
        _tmp$42,
        _tmp$43,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$10,
        _tuple$11,
        _tuple$12,
        _tuple$13,
        _tuple$14,
        _tuple$15,
        _tuple$16,
        _tuple$17,
        _tuple$18,
        _tuple$19,
        _tuple$2,
        _tuple$20,
        _tuple$21,
        _tuple$22,
        _tuple$23,
        _tuple$24,
        _tuple$25,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        _tuple$8,
        _tuple$9,
        alayout,
        amSet,
        avalue,
        d,
        day,
        defaultLocation,
        err,
        hold,
        hour,
        hour$1,
        hr,
        i,
        i$1,
        layout,
        local,
        m,
        min,
        min$1,
        mm,
        month,
        n,
        n$1,
        name,
        ndigit,
        nsec,
        offset,
        offset$1,
        ok,
        ok$1,
        p,
        pmSet,
        prefix,
        rangeErrString,
        sec,
        seconds,
        sign,
        ss,
        std,
        stdstr,
        suffix,
        t,
        t$1,
        value,
        x$1,
        x$2,
        x$3,
        yday,
        year,
        z,
        zoneName,
        zoneOffset,
        $s,
        $r,
        $c,
      } = $restore(this, { layout, value, defaultLocation, local });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tmp = layout;
            _tmp$1 = value;
            alayout = _tmp;
            avalue = _tmp$1;
            rangeErrString = "";
            amSet = false;
            pmSet = false;
            year = 0;
            month = -1;
            day = -1;
            yday = -1;
            hour = 0;
            min = 0;
            sec = 0;
            nsec = 0;
            z = ptrType$2.nil;
            zoneOffset = -1;
            zoneName = "";
            while (true) {
              err = $ifaceNil;
              _tuple = nextStdChunk(layout);
              prefix = _tuple[0];
              std = _tuple[1];
              suffix = _tuple[2];
              stdstr = $substring(
                layout,
                prefix.length,
                (layout.length - suffix.length) >> 0
              );
              _tuple$1 = skip(value, prefix);
              value = _tuple$1[0];
              err = _tuple$1[1];
              if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(alayout, avalue, prefix, value, ""),
                ];
              }
              if (std === 0) {
                if (!(value.length === 0)) {
                  $s = -1;
                  return [
                    new Time.ptr(
                      new $Uint64(0, 0),
                      new $Int64(0, 0),
                      ptrType$2.nil
                    ),
                    new ParseError.ptr(
                      alayout,
                      avalue,
                      "",
                      value,
                      ": extra text: " + quote(value)
                    ),
                  ];
                }
                break;
              }
              layout = suffix;
              p = "";
              switch (0) {
                default:
                  _1 = std & 65535;
                  if (_1 === 276) {
                    if (value.length < 2) {
                      err = errBad;
                      break;
                    }
                    hold = value;
                    _tmp$2 = $substring(value, 0, 2);
                    _tmp$3 = $substring(value, 2);
                    p = _tmp$2;
                    value = _tmp$3;
                    _tuple$2 = atoi(p);
                    year = _tuple$2[0];
                    err = _tuple$2[1];
                    if (!$interfaceIsEqual(err, $ifaceNil)) {
                      value = hold;
                    } else if (year >= 69) {
                      year = (year + 1900) >> 0;
                    } else {
                      year = (year + 2000) >> 0;
                    }
                  } else if (_1 === 275) {
                    if (value.length < 4 || !isDigit(value, 0)) {
                      err = errBad;
                      break;
                    }
                    _tmp$4 = $substring(value, 0, 4);
                    _tmp$5 = $substring(value, 4);
                    p = _tmp$4;
                    value = _tmp$5;
                    _tuple$3 = atoi(p);
                    year = _tuple$3[0];
                    err = _tuple$3[1];
                  } else if (_1 === 258) {
                    _tuple$4 = lookup(shortMonthNames, value);
                    month = _tuple$4[0];
                    value = _tuple$4[1];
                    err = _tuple$4[2];
                    month = (month + 1) >> 0;
                  } else if (_1 === 257) {
                    _tuple$5 = lookup(longMonthNames, value);
                    month = _tuple$5[0];
                    value = _tuple$5[1];
                    err = _tuple$5[2];
                    month = (month + 1) >> 0;
                  } else if (_1 === 259 || _1 === 260) {
                    _tuple$6 = getnum(value, std === 260);
                    month = _tuple$6[0];
                    value = _tuple$6[1];
                    err = _tuple$6[2];
                    if (
                      $interfaceIsEqual(err, $ifaceNil) &&
                      (month <= 0 || 12 < month)
                    ) {
                      rangeErrString = "month";
                    }
                  } else if (_1 === 262) {
                    _tuple$7 = lookup(shortDayNames, value);
                    value = _tuple$7[1];
                    err = _tuple$7[2];
                  } else if (_1 === 261) {
                    _tuple$8 = lookup(longDayNames, value);
                    value = _tuple$8[1];
                    err = _tuple$8[2];
                  } else if (_1 === 263 || _1 === 264 || _1 === 265) {
                    if (
                      std === 264 &&
                      value.length > 0 &&
                      value.charCodeAt(0) === 32
                    ) {
                      value = $substring(value, 1);
                    }
                    _tuple$9 = getnum(value, std === 265);
                    day = _tuple$9[0];
                    value = _tuple$9[1];
                    err = _tuple$9[2];
                  } else if (_1 === 266 || _1 === 267) {
                    i = 0;
                    while (true) {
                      if (!(i < 2)) {
                        break;
                      }
                      if (
                        std === 266 &&
                        value.length > 0 &&
                        value.charCodeAt(0) === 32
                      ) {
                        value = $substring(value, 1);
                      }
                      i = (i + 1) >> 0;
                    }
                    _tuple$10 = getnum3(value, std === 267);
                    yday = _tuple$10[0];
                    value = _tuple$10[1];
                    err = _tuple$10[2];
                  } else if (_1 === 524) {
                    _tuple$11 = getnum(value, false);
                    hour = _tuple$11[0];
                    value = _tuple$11[1];
                    err = _tuple$11[2];
                    if (hour < 0 || 24 <= hour) {
                      rangeErrString = "hour";
                    }
                  } else if (_1 === 525 || _1 === 526) {
                    _tuple$12 = getnum(value, std === 526);
                    hour = _tuple$12[0];
                    value = _tuple$12[1];
                    err = _tuple$12[2];
                    if (hour < 0 || 12 < hour) {
                      rangeErrString = "hour";
                    }
                  } else if (_1 === 527 || _1 === 528) {
                    _tuple$13 = getnum(value, std === 528);
                    min = _tuple$13[0];
                    value = _tuple$13[1];
                    err = _tuple$13[2];
                    if (min < 0 || 60 <= min) {
                      rangeErrString = "minute";
                    }
                  } else if (_1 === 529 || _1 === 530) {
                    _tuple$14 = getnum(value, std === 530);
                    sec = _tuple$14[0];
                    value = _tuple$14[1];
                    err = _tuple$14[2];
                    if (sec < 0 || 60 <= sec) {
                      rangeErrString = "second";
                      break;
                    }
                    if (
                      value.length >= 2 &&
                      commaOrPeriod(value.charCodeAt(0)) &&
                      isDigit(value, 1)
                    ) {
                      _tuple$15 = nextStdChunk(layout);
                      std = _tuple$15[1];
                      std = std & 65535;
                      if (std === 34 || std === 35) {
                        break;
                      }
                      n = 2;
                      while (true) {
                        if (!(n < value.length && isDigit(value, n))) {
                          break;
                        }
                        n = (n + 1) >> 0;
                      }
                      _tuple$16 = parseNanoseconds(value, n);
                      nsec = _tuple$16[0];
                      rangeErrString = _tuple$16[1];
                      err = _tuple$16[2];
                      value = $substring(value, n);
                    }
                  } else if (_1 === 533) {
                    if (value.length < 2) {
                      err = errBad;
                      break;
                    }
                    _tmp$6 = $substring(value, 0, 2);
                    _tmp$7 = $substring(value, 2);
                    p = _tmp$6;
                    value = _tmp$7;
                    _2 = p;
                    if (_2 === "PM") {
                      pmSet = true;
                    } else if (_2 === "AM") {
                      amSet = true;
                    } else {
                      err = errBad;
                    }
                  } else if (_1 === 534) {
                    if (value.length < 2) {
                      err = errBad;
                      break;
                    }
                    _tmp$8 = $substring(value, 0, 2);
                    _tmp$9 = $substring(value, 2);
                    p = _tmp$8;
                    value = _tmp$9;
                    _3 = p;
                    if (_3 === "pm") {
                      pmSet = true;
                    } else if (_3 === "am") {
                      amSet = true;
                    } else {
                      err = errBad;
                    }
                  } else if (
                    _1 === 24 ||
                    _1 === 27 ||
                    _1 === 25 ||
                    _1 === 26 ||
                    _1 === 28 ||
                    _1 === 29 ||
                    _1 === 31 ||
                    _1 === 32 ||
                    _1 === 30 ||
                    _1 === 33
                  ) {
                    if (
                      (std === 24 || std === 26 || std === 27) &&
                      value.length >= 1 &&
                      value.charCodeAt(0) === 90
                    ) {
                      value = $substring(value, 1);
                      z = $pkg.UTC;
                      break;
                    }
                    _tmp$10 = "";
                    _tmp$11 = "";
                    _tmp$12 = "";
                    _tmp$13 = "";
                    sign = _tmp$10;
                    hour$1 = _tmp$11;
                    min$1 = _tmp$12;
                    seconds = _tmp$13;
                    if (std === 27 || std === 32) {
                      if (value.length < 6) {
                        err = errBad;
                        break;
                      }
                      if (!(value.charCodeAt(3) === 58)) {
                        err = errBad;
                        break;
                      }
                      _tmp$14 = $substring(value, 0, 1);
                      _tmp$15 = $substring(value, 1, 3);
                      _tmp$16 = $substring(value, 4, 6);
                      _tmp$17 = "00";
                      _tmp$18 = $substring(value, 6);
                      sign = _tmp$14;
                      hour$1 = _tmp$15;
                      min$1 = _tmp$16;
                      seconds = _tmp$17;
                      value = _tmp$18;
                    } else if (std === 31 || std === 26) {
                      if (value.length < 3) {
                        err = errBad;
                        break;
                      }
                      _tmp$19 = $substring(value, 0, 1);
                      _tmp$20 = $substring(value, 1, 3);
                      _tmp$21 = "00";
                      _tmp$22 = "00";
                      _tmp$23 = $substring(value, 3);
                      sign = _tmp$19;
                      hour$1 = _tmp$20;
                      min$1 = _tmp$21;
                      seconds = _tmp$22;
                      value = _tmp$23;
                    } else if (std === 28 || std === 33) {
                      if (value.length < 9) {
                        err = errBad;
                        break;
                      }
                      if (
                        !(value.charCodeAt(3) === 58) ||
                        !(value.charCodeAt(6) === 58)
                      ) {
                        err = errBad;
                        break;
                      }
                      _tmp$24 = $substring(value, 0, 1);
                      _tmp$25 = $substring(value, 1, 3);
                      _tmp$26 = $substring(value, 4, 6);
                      _tmp$27 = $substring(value, 7, 9);
                      _tmp$28 = $substring(value, 9);
                      sign = _tmp$24;
                      hour$1 = _tmp$25;
                      min$1 = _tmp$26;
                      seconds = _tmp$27;
                      value = _tmp$28;
                    } else if (std === 25 || std === 30) {
                      if (value.length < 7) {
                        err = errBad;
                        break;
                      }
                      _tmp$29 = $substring(value, 0, 1);
                      _tmp$30 = $substring(value, 1, 3);
                      _tmp$31 = $substring(value, 3, 5);
                      _tmp$32 = $substring(value, 5, 7);
                      _tmp$33 = $substring(value, 7);
                      sign = _tmp$29;
                      hour$1 = _tmp$30;
                      min$1 = _tmp$31;
                      seconds = _tmp$32;
                      value = _tmp$33;
                    } else {
                      if (value.length < 5) {
                        err = errBad;
                        break;
                      }
                      _tmp$34 = $substring(value, 0, 1);
                      _tmp$35 = $substring(value, 1, 3);
                      _tmp$36 = $substring(value, 3, 5);
                      _tmp$37 = "00";
                      _tmp$38 = $substring(value, 5);
                      sign = _tmp$34;
                      hour$1 = _tmp$35;
                      min$1 = _tmp$36;
                      seconds = _tmp$37;
                      value = _tmp$38;
                    }
                    _tmp$39 = 0;
                    _tmp$40 = 0;
                    _tmp$41 = 0;
                    hr = _tmp$39;
                    mm = _tmp$40;
                    ss = _tmp$41;
                    _tuple$17 = atoi(hour$1);
                    hr = _tuple$17[0];
                    err = _tuple$17[1];
                    if ($interfaceIsEqual(err, $ifaceNil)) {
                      _tuple$18 = atoi(min$1);
                      mm = _tuple$18[0];
                      err = _tuple$18[1];
                    }
                    if ($interfaceIsEqual(err, $ifaceNil)) {
                      _tuple$19 = atoi(seconds);
                      ss = _tuple$19[0];
                      err = _tuple$19[1];
                    }
                    zoneOffset =
                      ($imul(($imul(hr, 60) + mm) >> 0, 60) + ss) >> 0;
                    _4 = sign.charCodeAt(0);
                    if (_4 === 43) {
                    } else if (_4 === 45) {
                      zoneOffset = -zoneOffset;
                    } else {
                      err = errBad;
                    }
                  } else if (_1 === 23) {
                    if (
                      value.length >= 3 &&
                      $substring(value, 0, 3) === "UTC"
                    ) {
                      z = $pkg.UTC;
                      value = $substring(value, 3);
                      break;
                    }
                    _tuple$20 = parseTimeZone(value);
                    n$1 = _tuple$20[0];
                    ok = _tuple$20[1];
                    if (!ok) {
                      err = errBad;
                      break;
                    }
                    _tmp$42 = $substring(value, 0, n$1);
                    _tmp$43 = $substring(value, n$1);
                    zoneName = _tmp$42;
                    value = _tmp$43;
                  } else if (_1 === 34) {
                    ndigit = (1 + digitsLen(std)) >> 0;
                    if (value.length < ndigit) {
                      err = errBad;
                      break;
                    }
                    _tuple$21 = parseNanoseconds(value, ndigit);
                    nsec = _tuple$21[0];
                    rangeErrString = _tuple$21[1];
                    err = _tuple$21[2];
                    value = $substring(value, ndigit);
                  } else if (_1 === 35) {
                    if (
                      value.length < 2 ||
                      !commaOrPeriod(value.charCodeAt(0)) ||
                      value.charCodeAt(1) < 48 ||
                      57 < value.charCodeAt(1)
                    ) {
                      break;
                    }
                    i$1 = 0;
                    while (true) {
                      if (
                        !(
                          i$1 < 9 &&
                          (i$1 + 1) >> 0 < value.length &&
                          48 <= value.charCodeAt((i$1 + 1) >> 0) &&
                          value.charCodeAt((i$1 + 1) >> 0) <= 57
                        )
                      ) {
                        break;
                      }
                      i$1 = (i$1 + 1) >> 0;
                    }
                    _tuple$22 = parseNanoseconds(value, (1 + i$1) >> 0);
                    nsec = _tuple$22[0];
                    rangeErrString = _tuple$22[1];
                    err = _tuple$22[2];
                    value = $substring(value, (1 + i$1) >> 0);
                  }
              }
              if (!(rangeErrString === "")) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(
                    alayout,
                    avalue,
                    stdstr,
                    value,
                    ": " + rangeErrString + " out of range"
                  ),
                ];
              }
              if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(alayout, avalue, stdstr, value, ""),
                ];
              }
            }
            if (pmSet && hour < 12) {
              hour = (hour + 12) >> 0;
            } else if (amSet && hour === 12) {
              hour = 0;
            }
            if (yday >= 0) {
              d = 0;
              m = 0;
              if (isLeap(year)) {
                if (yday === 60) {
                  m = 2;
                  d = 29;
                } else if (yday > 60) {
                  yday = (yday - 1) >> 0;
                }
              }
              if (yday < 1 || yday > 365) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(
                    alayout,
                    avalue,
                    "",
                    value,
                    ": day-of-year out of range"
                  ),
                ];
              }
              if (m === 0) {
                m =
                  (((_q = ((yday - 1) >> 0) / 31),
                  _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                    ? _q >> 0
                    : $throwRuntimeError("integer divide by zero")) +
                    1) >>
                  0;
                if (
                  (m < 0 || m >= daysBefore.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : daysBefore[m]) >>
                    0 <
                  yday
                ) {
                  m = (m + 1) >> 0;
                }
                d =
                  (yday -
                    (((x$1 = (m - 1) >> 0),
                    x$1 < 0 || x$1 >= daysBefore.length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : daysBefore[x$1]) >>
                      0)) >>
                  0;
              }
              if (month >= 0 && !(month === m)) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(
                    alayout,
                    avalue,
                    "",
                    value,
                    ": day-of-year does not match month"
                  ),
                ];
              }
              month = m;
              if (day >= 0 && !(day === d)) {
                $s = -1;
                return [
                  new Time.ptr(
                    new $Uint64(0, 0),
                    new $Int64(0, 0),
                    ptrType$2.nil
                  ),
                  new ParseError.ptr(
                    alayout,
                    avalue,
                    "",
                    value,
                    ": day-of-year does not match day"
                  ),
                ];
              }
              day = d;
            } else {
              if (month < 0) {
                month = 1;
              }
              if (day < 0) {
                day = 1;
              }
            }
            if (day < 1 || day > daysIn(month >> 0, year)) {
              $s = -1;
              return [
                new Time.ptr(
                  new $Uint64(0, 0),
                  new $Int64(0, 0),
                  ptrType$2.nil
                ),
                new ParseError.ptr(
                  alayout,
                  avalue,
                  "",
                  value,
                  ": day out of range"
                ),
              ];
            }
            /* */ if (!(z === ptrType$2.nil)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!(z === ptrType$2.nil)) { */ case 1:
            _r$1 = Date(year, month >> 0, day, hour, min, sec, nsec, z);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = [_r$1, $ifaceNil];
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            /* */ if (!(zoneOffset === -1)) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (!((zoneOffset === -1))) { */ case 5:
            _r$2 = Date(year, month >> 0, day, hour, min, sec, nsec, $pkg.UTC);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            t = $clone(_r$2, Time);
            t.addSec(
              ((x$2 = new $Int64(0, zoneOffset)),
              new $Int64(-x$2.$high, -x$2.$low))
            );
            _r$3 = local.lookup(t.unixSec());
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple$23 = _r$3;
            name = _tuple$23[0];
            offset = _tuple$23[1];
            if (
              offset === zoneOffset &&
              (zoneName === "" || name === zoneName)
            ) {
              t.setLoc(local);
              $s = -1;
              return [t, $ifaceNil];
            }
            t.setLoc(FixedZone(zoneName, zoneOffset));
            $s = -1;
            return [t, $ifaceNil];
          /* } */ case 6:
            /* */ if (!(zoneName === "")) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (!(zoneName === "")) { */ case 9:
            _r$4 = Date(year, month >> 0, day, hour, min, sec, nsec, $pkg.UTC);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            t$1 = $clone(_r$4, Time);
            _r$5 = local.lookupName(zoneName, t$1.unixSec());
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _tuple$24 = _r$5;
            offset$1 = _tuple$24[0];
            ok$1 = _tuple$24[1];
            if (ok$1) {
              t$1.addSec(
                ((x$3 = new $Int64(0, offset$1)),
                new $Int64(-x$3.$high, -x$3.$low))
              );
              t$1.setLoc(local);
              $s = -1;
              return [t$1, $ifaceNil];
            }
            if (zoneName.length > 3 && $substring(zoneName, 0, 3) === "GMT") {
              _tuple$25 = atoi($substring(zoneName, 3));
              offset$1 = _tuple$25[0];
              offset$1 = $imul(offset$1, 3600);
            }
            t$1.setLoc(FixedZone(zoneName, offset$1));
            $s = -1;
            return [t$1, $ifaceNil];
          /* } */ case 10:
            _r$6 = Date(
              year,
              month >> 0,
              day,
              hour,
              min,
              sec,
              nsec,
              defaultLocation
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            $24r$1 = [_r$6, $ifaceNil];
            $s = 14;
          case 14:
            return $24r$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: parse,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _1,
        _2,
        _3,
        _4,
        _q,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$20,
        _tmp$21,
        _tmp$22,
        _tmp$23,
        _tmp$24,
        _tmp$25,
        _tmp$26,
        _tmp$27,
        _tmp$28,
        _tmp$29,
        _tmp$3,
        _tmp$30,
        _tmp$31,
        _tmp$32,
        _tmp$33,
        _tmp$34,
        _tmp$35,
        _tmp$36,
        _tmp$37,
        _tmp$38,
        _tmp$39,
        _tmp$4,
        _tmp$40,
        _tmp$41,
        _tmp$42,
        _tmp$43,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$10,
        _tuple$11,
        _tuple$12,
        _tuple$13,
        _tuple$14,
        _tuple$15,
        _tuple$16,
        _tuple$17,
        _tuple$18,
        _tuple$19,
        _tuple$2,
        _tuple$20,
        _tuple$21,
        _tuple$22,
        _tuple$23,
        _tuple$24,
        _tuple$25,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        _tuple$8,
        _tuple$9,
        alayout,
        amSet,
        avalue,
        d,
        day,
        defaultLocation,
        err,
        hold,
        hour,
        hour$1,
        hr,
        i,
        i$1,
        layout,
        local,
        m,
        min,
        min$1,
        mm,
        month,
        n,
        n$1,
        name,
        ndigit,
        nsec,
        offset,
        offset$1,
        ok,
        ok$1,
        p,
        pmSet,
        prefix,
        rangeErrString,
        sec,
        seconds,
        sign,
        ss,
        std,
        stdstr,
        suffix,
        t,
        t$1,
        value,
        x$1,
        x$2,
        x$3,
        yday,
        year,
        z,
        zoneName,
        zoneOffset,
        $s,
      };
      return $f;
    };
    parseTimeZone = function (value) {
      var _1,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        c,
        length,
        nUpper,
        ok,
        ok$1,
        value;
      length = 0;
      ok = false;
      if (value.length < 3) {
        _tmp = 0;
        _tmp$1 = false;
        length = _tmp;
        ok = _tmp$1;
        return [length, ok];
      }
      if (
        value.length >= 4 &&
        ($substring(value, 0, 4) === "ChST" ||
          $substring(value, 0, 4) === "MeST")
      ) {
        _tmp$2 = 4;
        _tmp$3 = true;
        length = _tmp$2;
        ok = _tmp$3;
        return [length, ok];
      }
      if ($substring(value, 0, 3) === "GMT") {
        length = parseGMT(value);
        _tmp$4 = length;
        _tmp$5 = true;
        length = _tmp$4;
        ok = _tmp$5;
        return [length, ok];
      }
      if (value.charCodeAt(0) === 43 || value.charCodeAt(0) === 45) {
        length = parseSignedOffset(value);
        ok$1 = length > 0;
        _tmp$6 = length;
        _tmp$7 = ok$1;
        length = _tmp$6;
        ok = _tmp$7;
        return [length, ok];
      }
      nUpper = 0;
      nUpper = 0;
      while (true) {
        if (!(nUpper < 6)) {
          break;
        }
        if (nUpper >= value.length) {
          break;
        }
        c = value.charCodeAt(nUpper);
        if (c < 65 || 90 < c) {
          break;
        }
        nUpper = (nUpper + 1) >> 0;
      }
      _1 = nUpper;
      if (_1 === 0 || _1 === 1 || _1 === 2 || _1 === 6) {
        _tmp$8 = 0;
        _tmp$9 = false;
        length = _tmp$8;
        ok = _tmp$9;
        return [length, ok];
      } else if (_1 === 5) {
        if (value.charCodeAt(4) === 84) {
          _tmp$10 = 5;
          _tmp$11 = true;
          length = _tmp$10;
          ok = _tmp$11;
          return [length, ok];
        }
      } else if (_1 === 4) {
        if (value.charCodeAt(3) === 84 || $substring(value, 0, 4) === "WITA") {
          _tmp$12 = 4;
          _tmp$13 = true;
          length = _tmp$12;
          ok = _tmp$13;
          return [length, ok];
        }
      } else if (_1 === 3) {
        _tmp$14 = 3;
        _tmp$15 = true;
        length = _tmp$14;
        ok = _tmp$15;
        return [length, ok];
      }
      _tmp$16 = 0;
      _tmp$17 = false;
      length = _tmp$16;
      ok = _tmp$17;
      return [length, ok];
    };
    parseGMT = function (value) {
      var value;
      value = $substring(value, 3);
      if (value.length === 0) {
        return 3;
      }
      return (3 + parseSignedOffset(value)) >> 0;
    };
    parseSignedOffset = function (value) {
      var _tuple, err, rem, sign, value, x$1;
      sign = value.charCodeAt(0);
      if (!(sign === 45) && !(sign === 43)) {
        return 0;
      }
      _tuple = leadingInt($substring(value, 1));
      x$1 = _tuple[0];
      rem = _tuple[1];
      err = _tuple[2];
      if (!$interfaceIsEqual(err, $ifaceNil) || $substring(value, 1) === rem) {
        return 0;
      }
      if (x$1.$high > 0 || (x$1.$high === 0 && x$1.$low > 23)) {
        return 0;
      }
      return (value.length - rem.length) >> 0;
    };
    commaOrPeriod = function (b) {
      var b;
      return b === 46 || b === 44;
    };
    parseNanoseconds = function (value, nbytes) {
      var _tuple, err, i, nbytes, ns, rangeErrString, scaleDigits, value;
      ns = 0;
      rangeErrString = "";
      err = $ifaceNil;
      if (!commaOrPeriod(value.charCodeAt(0))) {
        err = errBad;
        return [ns, rangeErrString, err];
      }
      if (nbytes > 10) {
        value = $substring(value, 0, 10);
        nbytes = 10;
      }
      _tuple = atoi($substring(value, 1, nbytes));
      ns = _tuple[0];
      err = _tuple[1];
      if (!$interfaceIsEqual(err, $ifaceNil)) {
        return [ns, rangeErrString, err];
      }
      if (ns < 0) {
        rangeErrString = "fractional second";
        return [ns, rangeErrString, err];
      }
      scaleDigits = (10 - nbytes) >> 0;
      i = 0;
      while (true) {
        if (!(i < scaleDigits)) {
          break;
        }
        ns = $imul(ns, 10);
        i = (i + 1) >> 0;
      }
      return [ns, rangeErrString, err];
    };
    leadingInt = function (s) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        c,
        err,
        i,
        rem,
        s,
        x$1,
        x$2,
        x$3,
        x$4;
      x$1 = new $Uint64(0, 0);
      rem = "";
      err = $ifaceNil;
      i = 0;
      while (true) {
        if (!(i < s.length)) {
          break;
        }
        c = s.charCodeAt(i);
        if (c < 48 || c > 57) {
          break;
        }
        if (
          x$1.$high > 214748364 ||
          (x$1.$high === 214748364 && x$1.$low > 3435973836)
        ) {
          _tmp = new $Uint64(0, 0);
          _tmp$1 = "";
          _tmp$2 = errLeadingInt;
          x$1 = _tmp;
          rem = _tmp$1;
          err = _tmp$2;
          return [x$1, rem, err];
        }
        x$1 =
          ((x$2 =
            ((x$3 = $mul64(x$1, new $Uint64(0, 10))),
            (x$4 = new $Uint64(0, c)),
            new $Uint64(x$3.$high + x$4.$high, x$3.$low + x$4.$low))),
          new $Uint64(x$2.$high - 0, x$2.$low - 48));
        if (
          x$1.$high > 2147483648 ||
          (x$1.$high === 2147483648 && x$1.$low > 0)
        ) {
          _tmp$3 = new $Uint64(0, 0);
          _tmp$4 = "";
          _tmp$5 = errLeadingInt;
          x$1 = _tmp$3;
          rem = _tmp$4;
          err = _tmp$5;
          return [x$1, rem, err];
        }
        i = (i + 1) >> 0;
      }
      _tmp$6 = x$1;
      _tmp$7 = $substring(s, i);
      _tmp$8 = $ifaceNil;
      x$1 = _tmp$6;
      rem = _tmp$7;
      err = _tmp$8;
      return [x$1, rem, err];
    };
    ptrType$2.methods = [
      {
        prop: "get",
        name: "get",
        pkg: "time",
        typ: $funcType([], [ptrType$2], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "lookup",
        name: "lookup",
        pkg: "time",
        typ: $funcType([$Int64], [$String, $Int, $Int64, $Int64, $Bool], false),
      },
      {
        prop: "lookupFirstZone",
        name: "lookupFirstZone",
        pkg: "time",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "firstZoneUsed",
        name: "firstZoneUsed",
        pkg: "time",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "lookupName",
        name: "lookupName",
        pkg: "time",
        typ: $funcType([$String, $Int64], [$Int, $Bool], false),
      },
    ];
    Time.methods = [
      {
        prop: "After",
        name: "After",
        pkg: "",
        typ: $funcType([Time], [$Bool], false),
      },
      {
        prop: "Before",
        name: "Before",
        pkg: "",
        typ: $funcType([Time], [$Bool], false),
      },
      {
        prop: "Equal",
        name: "Equal",
        pkg: "",
        typ: $funcType([Time], [$Bool], false),
      },
      {
        prop: "IsZero",
        name: "IsZero",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "abs",
        name: "abs",
        pkg: "time",
        typ: $funcType([], [$Uint64], false),
      },
      {
        prop: "locabs",
        name: "locabs",
        pkg: "time",
        typ: $funcType([], [$String, $Int, $Uint64], false),
      },
      {
        prop: "Date",
        name: "Date",
        pkg: "",
        typ: $funcType([], [$Int, Month, $Int], false),
      },
      {
        prop: "Year",
        name: "Year",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Month",
        name: "Month",
        pkg: "",
        typ: $funcType([], [Month], false),
      },
      { prop: "Day", name: "Day", pkg: "", typ: $funcType([], [$Int], false) },
      {
        prop: "Weekday",
        name: "Weekday",
        pkg: "",
        typ: $funcType([], [Weekday], false),
      },
      {
        prop: "ISOWeek",
        name: "ISOWeek",
        pkg: "",
        typ: $funcType([], [$Int, $Int], false),
      },
      {
        prop: "Clock",
        name: "Clock",
        pkg: "",
        typ: $funcType([], [$Int, $Int, $Int], false),
      },
      {
        prop: "Hour",
        name: "Hour",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Minute",
        name: "Minute",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Second",
        name: "Second",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Nanosecond",
        name: "Nanosecond",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "YearDay",
        name: "YearDay",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Add",
        name: "Add",
        pkg: "",
        typ: $funcType([Duration], [Time], false),
      },
      {
        prop: "Sub",
        name: "Sub",
        pkg: "",
        typ: $funcType([Time], [Duration], false),
      },
      {
        prop: "AddDate",
        name: "AddDate",
        pkg: "",
        typ: $funcType([$Int, $Int, $Int], [Time], false),
      },
      {
        prop: "date",
        name: "date",
        pkg: "time",
        typ: $funcType([$Bool], [$Int, Month, $Int, $Int], false),
      },
      { prop: "UTC", name: "UTC", pkg: "", typ: $funcType([], [Time], false) },
      {
        prop: "Local",
        name: "Local",
        pkg: "",
        typ: $funcType([], [Time], false),
      },
      {
        prop: "In",
        name: "In",
        pkg: "",
        typ: $funcType([ptrType$2], [Time], false),
      },
      {
        prop: "Location",
        name: "Location",
        pkg: "",
        typ: $funcType([], [ptrType$2], false),
      },
      {
        prop: "Zone",
        name: "Zone",
        pkg: "",
        typ: $funcType([], [$String, $Int], false),
      },
      {
        prop: "Unix",
        name: "Unix",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "UnixMilli",
        name: "UnixMilli",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "UnixMicro",
        name: "UnixMicro",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "UnixNano",
        name: "UnixNano",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "MarshalBinary",
        name: "MarshalBinary",
        pkg: "",
        typ: $funcType([], [sliceType$3, $error], false),
      },
      {
        prop: "GobEncode",
        name: "GobEncode",
        pkg: "",
        typ: $funcType([], [sliceType$3, $error], false),
      },
      {
        prop: "MarshalJSON",
        name: "MarshalJSON",
        pkg: "",
        typ: $funcType([], [sliceType$3, $error], false),
      },
      {
        prop: "MarshalText",
        name: "MarshalText",
        pkg: "",
        typ: $funcType([], [sliceType$3, $error], false),
      },
      {
        prop: "IsDST",
        name: "IsDST",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Truncate",
        name: "Truncate",
        pkg: "",
        typ: $funcType([Duration], [Time], false),
      },
      {
        prop: "Round",
        name: "Round",
        pkg: "",
        typ: $funcType([Duration], [Time], false),
      },
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "GoString",
        name: "GoString",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Format",
        name: "Format",
        pkg: "",
        typ: $funcType([$String], [$String], false),
      },
      {
        prop: "AppendFormat",
        name: "AppendFormat",
        pkg: "",
        typ: $funcType([sliceType$3, $String], [sliceType$3], false),
      },
    ];
    ptrType$4.methods = [
      {
        prop: "nsec",
        name: "nsec",
        pkg: "time",
        typ: $funcType([], [$Int32], false),
      },
      {
        prop: "sec",
        name: "sec",
        pkg: "time",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "unixSec",
        name: "unixSec",
        pkg: "time",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "addSec",
        name: "addSec",
        pkg: "time",
        typ: $funcType([$Int64], [], false),
      },
      {
        prop: "setLoc",
        name: "setLoc",
        pkg: "time",
        typ: $funcType([ptrType$2], [], false),
      },
      {
        prop: "stripMono",
        name: "stripMono",
        pkg: "time",
        typ: $funcType([], [], false),
      },
      {
        prop: "setMono",
        name: "setMono",
        pkg: "time",
        typ: $funcType([$Int64], [], false),
      },
      {
        prop: "mono",
        name: "mono",
        pkg: "time",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "UnmarshalBinary",
        name: "UnmarshalBinary",
        pkg: "",
        typ: $funcType([sliceType$3], [$error], false),
      },
      {
        prop: "GobDecode",
        name: "GobDecode",
        pkg: "",
        typ: $funcType([sliceType$3], [$error], false),
      },
      {
        prop: "UnmarshalJSON",
        name: "UnmarshalJSON",
        pkg: "",
        typ: $funcType([sliceType$3], [$error], false),
      },
      {
        prop: "UnmarshalText",
        name: "UnmarshalText",
        pkg: "",
        typ: $funcType([sliceType$3], [$error], false),
      },
    ];
    Month.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Weekday.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Duration.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Nanoseconds",
        name: "Nanoseconds",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Microseconds",
        name: "Microseconds",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Milliseconds",
        name: "Milliseconds",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Seconds",
        name: "Seconds",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "Minutes",
        name: "Minutes",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "Hours",
        name: "Hours",
        pkg: "",
        typ: $funcType([], [$Float64], false),
      },
      {
        prop: "Truncate",
        name: "Truncate",
        pkg: "",
        typ: $funcType([Duration], [Duration], false),
      },
      {
        prop: "Round",
        name: "Round",
        pkg: "",
        typ: $funcType([Duration], [Duration], false),
      },
    ];
    ptrType$8.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    Location.init("time", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "zone",
        name: "zone",
        embedded: false,
        exported: false,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "tx",
        name: "tx",
        embedded: false,
        exported: false,
        typ: sliceType$1,
        tag: "",
      },
      {
        prop: "extend",
        name: "extend",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "cacheStart",
        name: "cacheStart",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "cacheEnd",
        name: "cacheEnd",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "cacheZone",
        name: "cacheZone",
        embedded: false,
        exported: false,
        typ: ptrType,
        tag: "",
      },
    ]);
    zone.init("time", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "offset",
        name: "offset",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "isDST",
        name: "isDST",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    zoneTrans.init("time", [
      {
        prop: "when",
        name: "when",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "index",
        name: "index",
        embedded: false,
        exported: false,
        typ: $Uint8,
        tag: "",
      },
      {
        prop: "isstd",
        name: "isstd",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "isutc",
        name: "isutc",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    rule.init("time", [
      {
        prop: "kind",
        name: "kind",
        embedded: false,
        exported: false,
        typ: ruleKind,
        tag: "",
      },
      {
        prop: "day",
        name: "day",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "week",
        name: "week",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "mon",
        name: "mon",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "time",
        name: "time",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    Time.init("time", [
      {
        prop: "wall",
        name: "wall",
        embedded: false,
        exported: false,
        typ: $Uint64,
        tag: "",
      },
      {
        prop: "ext",
        name: "ext",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "loc",
        name: "loc",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
    ]);
    ParseError.init("", [
      {
        prop: "Layout",
        name: "Layout",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Value",
        name: "Value",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "LayoutElem",
        name: "LayoutElem",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "ValueElem",
        name: "ValueElem",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Message",
        name: "Message",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
    ]);
    $pkg.$initLinknames = function () {
      runtimeNano = $linknames["runtime.nanotime"];
    };
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js$1.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = nosync.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = syscall.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            localLoc = new Location.ptr(
              "",
              sliceType.nil,
              sliceType$1.nil,
              "",
              new $Int64(0, 0),
              new $Int64(0, 0),
              ptrType.nil
            );
            localOnce = new nosync.Once.ptr(false, false);
            badData = errors.New("malformed time zone information");
            $unused(
              new sliceType$2([
                "/usr/share/zoneinfo/",
                "/usr/share/lib/zoneinfo/",
                "/usr/lib/locale/TZ/",
                runtime.GOROOT() + "/lib/time/zoneinfo.zip",
              ])
            );
            utcLoc = new Location.ptr(
              "UTC",
              sliceType.nil,
              sliceType$1.nil,
              "",
              new $Int64(0, 0),
              new $Int64(0, 0),
              ptrType.nil
            );
            $pkg.UTC = utcLoc;
            $pkg.Local = localLoc;
            errLocation = errors.New("time: invalid location name");
            daysBefore = $toNativeArray(
              $kindInt32,
              [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]
            );
            _r = runtimeNano();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            startNano = ((x = _r), new $Int64(x.$high - 0, x.$low - 1));
            zoneSources = new sliceType$2([
              runtime.GOROOT() + "/lib/time/zoneinfo.zip",
            ]);
            std0x = $toNativeArray($kindInt, [260, 265, 526, 528, 530, 276]);
            longDayNames = new sliceType$2([
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday",
            ]);
            shortDayNames = new sliceType$2([
              "Sun",
              "Mon",
              "Tue",
              "Wed",
              "Thu",
              "Fri",
              "Sat",
            ]);
            shortMonthNames = new sliceType$2([
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec",
            ]);
            longMonthNames = new sliceType$2([
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ]);
            atoiError = errors.New("time: invalid number");
            errBad = errors.New("bad value for field");
            errLeadingInt = errors.New("time: bad [0-9]*");
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/poll"] = (function () {
    var $pkg = {},
      $init,
      errors,
      unix,
      io,
      atomic,
      syscall,
      time,
      FD,
      pollDesc,
      fdMutex,
      errNetClosing,
      DeadlineExceededError,
      ptrType,
      ptrType$1,
      ptrType$2,
      ptrType$3,
      sliceType,
      ptrType$4,
      sliceType$1,
      ptrType$5,
      ptrType$6,
      ptrType$7,
      funcType,
      funcType$1,
      ptrType$8,
      ptrType$9,
      ptrType$10,
      tryDupCloexec,
      tryDupCloexec$24ptr,
      accept,
      runtime_Semacquire,
      runtime_Semrelease,
      DupCloseOnExec,
      dupCloseOnExecOld,
      ignoringEINTRIO,
      ignoringEINTR,
      setDeadlineImpl,
      errClosing,
      fcntl;
    errors = $packages["errors"];
    unix = $packages["internal/syscall/unix"];
    io = $packages["io"];
    atomic = $packages["sync/atomic"];
    syscall = $packages["syscall"];
    time = $packages["time"];
    FD = $pkg.FD = $newType(
      0,
      $kindStruct,
      "poll.FD",
      true,
      "internal/poll",
      true,
      function (
        fdmu_,
        Sysfd_,
        pd_,
        iovecs_,
        csema_,
        isBlocking_,
        IsStream_,
        ZeroReadIsEOF_,
        isFile_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.fdmu = new fdMutex.ptr(new $Uint64(0, 0), 0, 0);
          this.Sysfd = 0;
          this.pd = new pollDesc.ptr(ptrType$2.nil, false);
          this.iovecs = ptrType$4.nil;
          this.csema = 0;
          this.isBlocking = 0;
          this.IsStream = false;
          this.ZeroReadIsEOF = false;
          this.isFile = false;
          return;
        }
        this.fdmu = fdmu_;
        this.Sysfd = Sysfd_;
        this.pd = pd_;
        this.iovecs = iovecs_;
        this.csema = csema_;
        this.isBlocking = isBlocking_;
        this.IsStream = IsStream_;
        this.ZeroReadIsEOF = ZeroReadIsEOF_;
        this.isFile = isFile_;
      }
    );
    pollDesc = $pkg.pollDesc = $newType(
      0,
      $kindStruct,
      "poll.pollDesc",
      true,
      "internal/poll",
      false,
      function (fd_, closing_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.fd = ptrType$2.nil;
          this.closing = false;
          return;
        }
        this.fd = fd_;
        this.closing = closing_;
      }
    );
    fdMutex = $pkg.fdMutex = $newType(
      0,
      $kindStruct,
      "poll.fdMutex",
      true,
      "internal/poll",
      false,
      function (state_, rsema_, wsema_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.state = new $Uint64(0, 0);
          this.rsema = 0;
          this.wsema = 0;
          return;
        }
        this.state = state_;
        this.rsema = rsema_;
        this.wsema = wsema_;
      }
    );
    errNetClosing = $pkg.errNetClosing = $newType(
      0,
      $kindStruct,
      "poll.errNetClosing",
      true,
      "internal/poll",
      false,
      function () {
        this.$val = this;
        if (arguments.length === 0) {
          return;
        }
      }
    );
    DeadlineExceededError = $pkg.DeadlineExceededError = $newType(
      0,
      $kindStruct,
      "poll.DeadlineExceededError",
      true,
      "internal/poll",
      true,
      function () {
        this.$val = this;
        if (arguments.length === 0) {
          return;
        }
      }
    );
    ptrType = $ptrType($Uint32);
    ptrType$1 = $ptrType($Int32);
    ptrType$2 = $ptrType(FD);
    ptrType$3 = $ptrType($Uint64);
    sliceType = $sliceType(syscall.Iovec);
    ptrType$4 = $ptrType(sliceType);
    sliceType$1 = $sliceType($Uint8);
    ptrType$5 = $ptrType(syscall.SockaddrInet4);
    ptrType$6 = $ptrType(syscall.SockaddrInet6);
    ptrType$7 = $ptrType(syscall.Stat_t);
    funcType = $funcType([$Uintptr], [$Bool], false);
    funcType$1 = $funcType([$Uintptr], [], false);
    ptrType$8 = $ptrType(pollDesc);
    ptrType$9 = $ptrType(fdMutex);
    ptrType$10 = $ptrType(DeadlineExceededError);
    accept = function (s) {
      var { _r, _r$1, _tuple, err, ns, s, sa, $s, $r, $c } = $restore(this, {
        s,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $pkg.AcceptFunc(s);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            ns = _tuple[0];
            sa = _tuple[1];
            err = _tuple[2];
            if ($interfaceIsEqual(err, $ifaceNil)) {
              syscall.CloseOnExec(ns);
            }
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [-1, $ifaceNil, "accept", err];
            }
            err = syscall.SetNonblock(ns, true);
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
            _r$1 = $pkg.CloseFunc(ns);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$1;
            $s = -1;
            return [-1, $ifaceNil, "setnonblock", err];
          /* } */ case 3:
            $s = -1;
            return [ns, sa, "", $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: accept,
        $c: true,
        $r,
        _r,
        _r$1,
        _tuple,
        err,
        ns,
        s,
        sa,
        $s,
      };
      return $f;
    };
    runtime_Semacquire = function () {
      $throwRuntimeError(
        "native function not implemented: internal/poll.runtime_Semacquire"
      );
    };
    runtime_Semrelease = function () {
      $throwRuntimeError(
        "native function not implemented: internal/poll.runtime_Semrelease"
      );
    };
    FD.ptr.prototype.Init = function (net, pollable) {
      var err, fd, net, pollable;
      fd = this;
      if (net === "file") {
        fd.isFile = true;
      }
      if (!pollable) {
        fd.isBlocking = 1;
        return $ifaceNil;
      }
      err = fd.pd.init(fd);
      if (!$interfaceIsEqual(err, $ifaceNil)) {
        fd.isBlocking = 1;
      }
      return err;
    };
    FD.prototype.Init = function (net, pollable) {
      return this.$val.Init(net, pollable);
    };
    FD.ptr.prototype.destroy = function () {
      var { _r, err, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            fd.pd.close();
            _r = $pkg.CloseFunc(fd.Sysfd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            err = _r;
            fd.Sysfd = -1;
            $r = runtime_Semrelease(
              fd.$ptr_csema ||
                (fd.$ptr_csema = new ptrType(
                  function () {
                    return this.$target.csema;
                  },
                  function ($v) {
                    this.$target.csema = $v;
                  },
                  fd
                ))
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.destroy,
        $c: true,
        $r,
        _r,
        err,
        fd,
        $s,
      };
      return $f;
    };
    FD.prototype.destroy = function () {
      return this.$val.destroy();
    };
    FD.ptr.prototype.Close = function () {
      var { _r, _r$1, err, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = fd.fdmu.increfAndClose();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!_r) { */ case 1:
            $s = -1;
            return errClosing(fd.isFile);
          /* } */ case 2:
            fd.pd.evict();
            _r$1 = fd.decref();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            err = _r$1;
            /* */ if (fd.isBlocking === 0) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (fd.isBlocking === 0) { */ case 5:
            $r = runtime_Semacquire(
              fd.$ptr_csema ||
                (fd.$ptr_csema = new ptrType(
                  function () {
                    return this.$target.csema;
                  },
                  function ($v) {
                    this.$target.csema = $v;
                  },
                  fd
                ))
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 6:
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.Close,
        $c: true,
        $r,
        _r,
        _r$1,
        err,
        fd,
        $s,
      };
      return $f;
    };
    FD.prototype.Close = function () {
      return this.$val.Close();
    };
    FD.ptr.prototype.SetBlocking = function () {
      var { $24r, $24r$1, err, fd, $s, $deferred, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              atomic.StoreUint32(
                fd.$ptr_isBlocking ||
                  (fd.$ptr_isBlocking = new ptrType(
                    function () {
                      return this.$target.isBlocking;
                    },
                    function ($v) {
                      this.$target.isBlocking = $v;
                    },
                    fd
                  )),
                1
              );
              $24r$1 = syscall.SetNonblock(fd.Sysfd, false);
              $s = 4;
            case 4:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.SetBlocking,
            $c: true,
            $r,
            $24r,
            $24r$1,
            err,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.SetBlocking = function () {
      return this.$val.SetBlocking();
    };
    FD.ptr.prototype.Read = function (p) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _r$1,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        n,
        p,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              /* */ if (p.$length === 0) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (p.$length === 0) { */ case 5:
              $24r$1 = [0, $ifaceNil];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 8;
                continue;
              }
              /* */ $s = 9;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 8:
              $24r$2 = [0, err$1];
              $s = 10;
            case 10:
              return $24r$2;
            /* } */ case 9:
              if (fd.IsStream && p.$length > 1073741824) {
                p = $subslice(p, 0, 1073741824);
              }
            /* while (true) { */ case 11:
              _r$1 = ignoringEINTRIO(syscall.Read, fd.Sysfd, p);
              /* */ $s = 13;
            case 13:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _tuple = _r$1;
              n = _tuple[0];
              err$2 = _tuple[1];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                n = 0;
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 11;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$3 = [n, err$2];
              $s = 14;
            case 14:
              return $24r$3;
            case 12:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Read,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _r$1,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            n,
            p,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Read = function (p) {
      return this.$val.Read(p);
    };
    FD.ptr.prototype.Pread = function (p, off) {
      var { _r, _r$1, _tuple, err, err$1, fd, n, off, p, $s, $r, $c } =
        $restore(this, { p, off });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            err = fd.incref();
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [0, err];
            }
            if (fd.IsStream && p.$length > 1073741824) {
              p = $subslice(p, 0, 1073741824);
            }
            n = 0;
            err$1 = $ifaceNil;
          /* while (true) { */ case 1:
            _r = syscall.Pread(fd.Sysfd, p, off);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            n = _tuple[0];
            err$1 = _tuple[1];
            if (!$interfaceIsEqual(err$1, new syscall.Errno(4))) {
              /* break; */ $s = 2;
              continue;
            }
            $s = 1;
            continue;
          case 2:
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              n = 0;
            }
            _r$1 = fd.decref();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$1;
            err$1 = fd.eofError(n, err$1);
            $s = -1;
            return [n, err$1];
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.Pread,
        $c: true,
        $r,
        _r,
        _r$1,
        _tuple,
        err,
        err$1,
        fd,
        n,
        off,
        p,
        $s,
      };
      return $f;
    };
    FD.prototype.Pread = function (p, off) {
      return this.$val.Pread(p, off);
    };
    FD.ptr.prototype.ReadFrom = function (p) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        n,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, $ifaceNil, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, $ifaceNil, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = syscall.Recvfrom(fd.Sysfd, p, 0);
              n = _tuple[0];
              sa = _tuple[1];
              err$2 = _tuple[2];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                n = 0;
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, sa, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, $ifaceNil, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadFrom,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            n,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadFrom = function (p) {
      return this.$val.ReadFrom(p);
    };
    FD.ptr.prototype.ReadFromInet4 = function (p, from) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        from,
        n,
        p,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, from });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.RecvfromInet4(fd.Sysfd, p, 0, from);
              n = _tuple[0];
              err$2 = _tuple[1];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                n = 0;
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadFromInet4,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            from,
            n,
            p,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadFromInet4 = function (p, from) {
      return this.$val.ReadFromInet4(p, from);
    };
    FD.ptr.prototype.ReadFromInet6 = function (p, from) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        from,
        n,
        p,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, from });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.RecvfromInet6(fd.Sysfd, p, 0, from);
              n = _tuple[0];
              err$2 = _tuple[1];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                n = 0;
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadFromInet6,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            from,
            n,
            p,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadFromInet6 = function (p, from) {
      return this.$val.ReadFromInet6(p, from);
    };
    FD.ptr.prototype.ReadMsg = function (p, oob, flags) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        flags,
        n,
        oob,
        oobn,
        p,
        sa,
        sysflags,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, flags });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, 0, $ifaceNil, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, 0, $ifaceNil, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = syscall.Recvmsg(fd.Sysfd, p, oob, flags);
              n = _tuple[0];
              oobn = _tuple[1];
              sysflags = _tuple[2];
              sa = _tuple[3];
              err$2 = _tuple[4];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, oobn, sysflags, sa, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, 0, 0, $ifaceNil, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, 0, $ifaceNil, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadMsg,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            flags,
            n,
            oob,
            oobn,
            p,
            sa,
            sysflags,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadMsg = function (p, oob, flags) {
      return this.$val.ReadMsg(p, oob, flags);
    };
    FD.ptr.prototype.ReadMsgInet4 = function (p, oob, flags, sa4) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        flags,
        n,
        oob,
        oobn,
        p,
        sa4,
        sysflags,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, flags, sa4 });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, 0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, 0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.RecvmsgInet4(fd.Sysfd, p, oob, flags, sa4);
              n = _tuple[0];
              oobn = _tuple[1];
              sysflags = _tuple[2];
              err$2 = _tuple[3];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, oobn, sysflags, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, 0, 0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, 0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadMsgInet4,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            flags,
            n,
            oob,
            oobn,
            p,
            sa4,
            sysflags,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadMsgInet4 = function (p, oob, flags, sa4) {
      return this.$val.ReadMsgInet4(p, oob, flags, sa4);
    };
    FD.ptr.prototype.ReadMsgInet6 = function (p, oob, flags, sa6) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        flags,
        n,
        oob,
        oobn,
        p,
        sa6,
        sysflags,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, flags, sa6 });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, 0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, 0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.RecvmsgInet6(fd.Sysfd, p, oob, flags, sa6);
              n = _tuple[0];
              oobn = _tuple[1];
              sysflags = _tuple[2];
              err$2 = _tuple[3];
              if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                  /* continue; */ $s = 8;
                  continue;
                }
                if (
                  $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              }
              err$2 = fd.eofError(n, err$2);
              $24r$2 = [n, oobn, sysflags, err$2];
              $s = 10;
            case 10:
              return $24r$2;
            case 9:
              $s = -1;
              return [0, 0, 0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, 0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadMsgInet6,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            flags,
            n,
            oob,
            oobn,
            p,
            sa6,
            sysflags,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadMsgInet6 = function (p, oob, flags, sa6) {
      return this.$val.ReadMsgInet6(p, oob, flags, sa6);
    };
    FD.ptr.prototype.Write = function (p) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        $24r$4,
        _r,
        _r$1,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        max,
        n,
        nn,
        p,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
              nn = 0;
            /* while (true) { */ case 8:
              max = p.$length;
              if (fd.IsStream && (max - nn) >> 0 > 1073741824) {
                max = (nn + 1073741824) >> 0;
              }
              _r$1 = ignoringEINTRIO(
                syscall.Write,
                fd.Sysfd,
                $subslice(p, nn, max)
              );
              /* */ $s = 10;
            case 10:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _tuple = _r$1;
              n = _tuple[0];
              err$2 = _tuple[1];
              if (n > 0) {
                nn = (nn + n) >> 0;
              }
              /* */ if (nn === p.$length) {
                $s = 11;
                continue;
              }
              /* */ $s = 12;
              continue;
            /* if (nn === p.$length) { */ case 11:
              $24r$2 = [nn, err$2];
              $s = 13;
            case 13:
              return $24r$2;
            /* } */ case 12:
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 14;
                continue;
              }
              /* */ $s = 15;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 14:
              $24r$3 = [nn, err$2];
              $s = 16;
            case 16:
              return $24r$3;
            /* } */ case 15:
              /* */ if (n === 0) {
                $s = 17;
                continue;
              }
              /* */ $s = 18;
              continue;
            /* if (n === 0) { */ case 17:
              $24r$4 = [nn, io.ErrUnexpectedEOF];
              $s = 19;
            case 19:
              return $24r$4;
            /* } */ case 18:
              $s = 8;
              continue;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Write,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            $24r$4,
            _r,
            _r$1,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            max,
            n,
            nn,
            p,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Write = function (p) {
      return this.$val.Write(p);
    };
    FD.ptr.prototype.Pwrite = function (p, off) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _tuple,
        err,
        err$1,
        fd,
        max,
        n,
        nn,
        off,
        p,
        x,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, off });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = [0, err];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              nn = 0;
            /* while (true) { */ case 4:
              max = p.$length;
              if (fd.IsStream && (max - nn) >> 0 > 1073741824) {
                max = (nn + 1073741824) >> 0;
              }
              _r = syscall.Pwrite(
                fd.Sysfd,
                $subslice(p, nn, max),
                ((x = new $Int64(0, nn)),
                new $Int64(off.$high + x.$high, off.$low + x.$low))
              );
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              _tuple = _r;
              n = _tuple[0];
              err$1 = _tuple[1];
              if ($interfaceIsEqual(err$1, new syscall.Errno(4))) {
                /* continue; */ $s = 4;
                continue;
              }
              if (n > 0) {
                nn = (nn + n) >> 0;
              }
              /* */ if (nn === p.$length) {
                $s = 7;
                continue;
              }
              /* */ $s = 8;
              continue;
            /* if (nn === p.$length) { */ case 7:
              $24r$1 = [nn, err$1];
              $s = 9;
            case 9:
              return $24r$1;
            /* } */ case 8:
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 10:
              $24r$2 = [nn, err$1];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              /* */ if (n === 0) {
                $s = 13;
                continue;
              }
              /* */ $s = 14;
              continue;
            /* if (n === 0) { */ case 13:
              $24r$3 = [nn, io.ErrUnexpectedEOF];
              $s = 15;
            case 15:
              return $24r$3;
            /* } */ case 14:
              $s = 4;
              continue;
            case 5:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Pwrite,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _tuple,
            err,
            err$1,
            fd,
            max,
            n,
            nn,
            off,
            p,
            x,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Pwrite = function (p, off) {
      return this.$val.Pwrite(p, off);
    };
    FD.ptr.prototype.WriteToInet4 = function (p, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        err,
        err$1,
        err$2,
        fd,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              err$2 = unix.SendtoInet4(fd.Sysfd, p, 0, sa);
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [p.$length, $ifaceNil];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteToInet4,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            err,
            err$1,
            err$2,
            fd,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteToInet4 = function (p, sa) {
      return this.$val.WriteToInet4(p, sa);
    };
    FD.ptr.prototype.WriteToInet6 = function (p, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        err,
        err$1,
        err$2,
        fd,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              err$2 = unix.SendtoInet6(fd.Sysfd, p, 0, sa);
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [p.$length, $ifaceNil];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteToInet6,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            err,
            err$1,
            err$2,
            fd,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteToInet6 = function (p, sa) {
      return this.$val.WriteToInet6(p, sa);
    };
    FD.ptr.prototype.WriteTo = function (p, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        err,
        err$1,
        err$2,
        fd,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              err$2 = syscall.Sendto(fd.Sysfd, p, 0, sa);
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [p.$length, $ifaceNil];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteTo,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            err,
            err$1,
            err$2,
            fd,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteTo = function (p, sa) {
      return this.$val.WriteTo(p, sa);
    };
    FD.ptr.prototype.WriteMsg = function (p, oob, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        n,
        oob,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = syscall.SendmsgN(fd.Sysfd, p, oob, sa, 0);
              n = _tuple[0];
              err$2 = _tuple[1];
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [n, 0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [n, oob.$length, err$2];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, 0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteMsg,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            n,
            oob,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteMsg = function (p, oob, sa) {
      return this.$val.WriteMsg(p, oob, sa);
    };
    FD.ptr.prototype.WriteMsgInet4 = function (p, oob, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        n,
        oob,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.SendmsgNInet4(fd.Sysfd, p, oob, sa, 0);
              n = _tuple[0];
              err$2 = _tuple[1];
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [n, 0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [n, oob.$length, err$2];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, 0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteMsgInet4,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            n,
            oob,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteMsgInet4 = function (p, oob, sa) {
      return this.$val.WriteMsgInet4(p, oob, sa);
    };
    FD.ptr.prototype.WriteMsgInet6 = function (p, oob, sa) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _tuple,
        err,
        err$1,
        err$2,
        fd,
        n,
        oob,
        p,
        sa,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { p, oob, sa });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, 0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [0, 0, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _tuple = unix.SendmsgNInet6(fd.Sysfd, p, oob, sa, 0);
              n = _tuple[0];
              err$2 = _tuple[1];
              if ($interfaceIsEqual(err$2, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              }
              if (
                $interfaceIsEqual(err$2, new syscall.Errno(11)) &&
                fd.pd.pollable()
              ) {
                err$2 = fd.pd.waitWrite(fd.isFile);
                if ($interfaceIsEqual(err$2, $ifaceNil)) {
                  /* continue; */ $s = 8;
                  continue;
                }
              }
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 10:
              $24r$2 = [n, 0, err$2];
              $s = 12;
            case 12:
              return $24r$2;
            /* } */ case 11:
              $24r$3 = [n, oob.$length, err$2];
              $s = 13;
            case 13:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, 0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, 0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteMsgInet6,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _tuple,
            err,
            err$1,
            err$2,
            fd,
            n,
            oob,
            p,
            sa,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteMsgInet6 = function (p, oob, sa) {
      return this.$val.WriteMsgInet6(p, oob, sa);
    };
    FD.ptr.prototype.Accept = function () {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _1,
        _r,
        _r$1,
        _tuple,
        err,
        err$1,
        err$2,
        errcall,
        fd,
        rsa,
        s,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [-1, $ifaceNil, "", err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = [-1, $ifaceNil, "", err$1];
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _r$1 = accept(fd.Sysfd);
              /* */ $s = 10;
            case 10:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _tuple = _r$1;
              s = _tuple[0];
              rsa = _tuple[1];
              errcall = _tuple[2];
              err$2 = _tuple[3];
              /* */ if ($interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 11;
                continue;
              }
              /* */ $s = 12;
              continue;
            /* if ($interfaceIsEqual(err$2, $ifaceNil)) { */ case 11:
              $24r$2 = [s, rsa, "", err$2];
              $s = 13;
            case 13:
              return $24r$2;
            /* } */ case 12:
              _1 = err$2;
              if ($interfaceIsEqual(_1, new syscall.Errno(4))) {
                /* continue; */ $s = 8;
                continue;
              } else if ($interfaceIsEqual(_1, new syscall.Errno(11))) {
                if (fd.pd.pollable()) {
                  err$2 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$2, $ifaceNil)) {
                    /* continue; */ $s = 8;
                    continue;
                  }
                }
              } else if ($interfaceIsEqual(_1, new syscall.Errno(103))) {
                /* continue; */ $s = 8;
                continue;
              }
              $24r$3 = [-1, $ifaceNil, errcall, err$2];
              $s = 14;
            case 14:
              return $24r$3;
            case 9:
              $s = -1;
              return [0, $ifaceNil, "", $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil, "", $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Accept,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _1,
            _r,
            _r$1,
            _tuple,
            err,
            err$1,
            err$2,
            errcall,
            fd,
            rsa,
            s,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Accept = function () {
      return this.$val.Accept();
    };
    FD.ptr.prototype.Seek = function (offset, whence) {
      var { $24r, $24r$1, _r, err, fd, offset, whence, $s, $deferred, $r, $c } =
        $restore(this, { offset, whence });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = [new $Int64(0, 0), err];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              _r = syscall.Seek(fd.Sysfd, offset, whence);
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [new $Int64(0, 0), $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Seek,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            offset,
            whence,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Seek = function (offset, whence) {
      return this.$val.Seek(offset, whence);
    };
    FD.ptr.prototype.ReadDirent = function (buf) {
      var {
        $24r,
        $24r$1,
        _r,
        _tuple,
        buf,
        err,
        err$1,
        fd,
        n,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { buf });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = [0, err];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
            /* while (true) { */ case 4:
              _r = ignoringEINTRIO(syscall.ReadDirent, fd.Sysfd, buf);
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              _tuple = _r;
              n = _tuple[0];
              err$1 = _tuple[1];
              if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                n = 0;
                if (
                  $interfaceIsEqual(err$1, new syscall.Errno(11)) &&
                  fd.pd.pollable()
                ) {
                  err$1 = fd.pd.waitRead(fd.isFile);
                  if ($interfaceIsEqual(err$1, $ifaceNil)) {
                    /* continue; */ $s = 4;
                    continue;
                  }
                }
              }
              $24r$1 = [n, err$1];
              $s = 7;
            case 7:
              return $24r$1;
            case 5:
              $s = -1;
              return [0, $ifaceNil];
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.ReadDirent,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            _tuple,
            buf,
            err,
            err$1,
            fd,
            n,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.ReadDirent = function (buf) {
      return this.$val.ReadDirent(buf);
    };
    FD.ptr.prototype.Fchmod = function (mode) {
      var { $24r, $24r$1, _r, err, fd, mode, $s, $deferred, $r, $c } = $restore(
        this,
        { mode }
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = [fd];
              mode = [mode];
              fd[0] = this;
              err = fd[0].incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd[0], "decref"), []]);
              _r = ignoringEINTR(
                (function (fd, mode) {
                  return function $b() {
                    var { $24r$1, _r, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r = syscall.Fchmod(fd[0].Sysfd, mode[0]);
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          $24r$1 = _r;
                          $s = 2;
                        case 2:
                          return $24r$1;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r$1, _r, $s };
                    return $f;
                  };
                })(fd, mode)
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Fchmod,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            mode,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Fchmod = function (mode) {
      return this.$val.Fchmod(mode);
    };
    FD.ptr.prototype.Fchdir = function () {
      var { $24r, $24r$1, _r, err, fd, $s, $deferred, $r, $c } = $restore(
        this,
        {}
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              _r = syscall.Fchdir(fd.Sysfd);
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Fchdir,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Fchdir = function () {
      return this.$val.Fchdir();
    };
    FD.ptr.prototype.Fstat = function (s) {
      var { $24r, $24r$1, _r, err, fd, s, $s, $deferred, $r, $c } = $restore(
        this,
        { s }
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = [fd];
              s = [s];
              fd[0] = this;
              err = fd[0].incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd[0], "decref"), []]);
              _r = ignoringEINTR(
                (function (fd, s) {
                  return function $b() {
                    var { $24r$1, _r, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r = syscall.Fstat(fd[0].Sysfd, s[0]);
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          $24r$1 = _r;
                          $s = 2;
                        case 2:
                          return $24r$1;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r$1, _r, $s };
                    return $f;
                  };
                })(fd, s)
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Fstat,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            s,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Fstat = function (s) {
      return this.$val.Fstat(s);
    };
    DupCloseOnExec = function (fd) {
      var { $24r, _1, _r, _tuple, e1, fd, r0, $s, $r, $c } = $restore(this, {
        fd,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (
              true &&
              atomic.LoadInt32(
                tryDupCloexec$24ptr ||
                  (tryDupCloexec$24ptr = new ptrType$1(
                    function () {
                      return tryDupCloexec;
                    },
                    function ($v) {
                      tryDupCloexec = $v;
                    }
                  ))
              ) === 1
            ) {
              _tuple = fcntl(fd, 1, 0);
              r0 = _tuple[0];
              e1 = _tuple[1];
              if ($interfaceIsEqual(e1, $ifaceNil)) {
                $s = -1;
                return [r0, "", $ifaceNil];
              }
              _1 = $assertType(e1, syscall.Errno);
              if (_1 === 22 || _1 === 38) {
                atomic.StoreInt32(
                  tryDupCloexec$24ptr ||
                    (tryDupCloexec$24ptr = new ptrType$1(
                      function () {
                        return tryDupCloexec;
                      },
                      function ($v) {
                        tryDupCloexec = $v;
                      }
                    )),
                  0
                );
              } else {
                $s = -1;
                return [-1, "fcntl", e1];
              }
            }
            _r = dupCloseOnExecOld(fd);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: DupCloseOnExec,
        $c: true,
        $r,
        $24r,
        _1,
        _r,
        _tuple,
        e1,
        fd,
        r0,
        $s,
      };
      return $f;
    };
    $pkg.DupCloseOnExec = DupCloseOnExec;
    dupCloseOnExecOld = function (fd) {
      var { $24r, $24r$1, _tuple, err, fd, newfd, $s, $deferred, $r, $c } =
        $restore(this, { fd });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              $r = syscall.ForkLock.RLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $deferred.push([$methodVal(syscall.ForkLock, "RUnlock"), []]);
              _tuple = syscall.Dup(fd);
              newfd = _tuple[0];
              err = _tuple[1];
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [-1, "dup", err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              syscall.CloseOnExec(newfd);
              $24r$1 = [newfd, "", $ifaceNil];
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, "", $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: dupCloseOnExecOld,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _tuple,
            err,
            fd,
            newfd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.ptr.prototype.Dup = function () {
      var { $24r, $24r$1, _r, err, fd, $s, $deferred, $r, $c } = $restore(
        this,
        {}
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = [-1, "", err];
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              _r = DupCloseOnExec(fd.Sysfd);
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, "", $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Dup,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Dup = function () {
      return this.$val.Dup();
    };
    FD.ptr.prototype.WaitWrite = function () {
      var fd;
      fd = this;
      return fd.pd.waitWrite(fd.isFile);
    };
    FD.prototype.WaitWrite = function () {
      return this.$val.WaitWrite();
    };
    FD.ptr.prototype.WriteOnce = function (p) {
      var { $24r, $24r$1, _r, _r$1, err, fd, p, $s, $deferred, $r, $c } =
        $restore(this, { p });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = [0, err];
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              _r$1 = ignoringEINTRIO(syscall.Write, fd.Sysfd, p);
              /* */ $s = 5;
            case 5:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r$1;
              $s = 6;
            case 6:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return [0, $ifaceNil];
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.WriteOnce,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            _r$1,
            err,
            fd,
            p,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.WriteOnce = function (p) {
      return this.$val.WriteOnce(p);
    };
    FD.ptr.prototype.RawRead = function (f) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _r$1,
        err,
        err$1,
        err$2,
        f,
        fd,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { f });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.readLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = err;
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "readUnlock"), []]);
              err$1 = fd.pd.prepareRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = err$1;
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _r$1 = f(fd.Sysfd >>> 0);
              /* */ $s = 12;
            case 12:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              /* */ if (_r$1) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (_r$1) { */ case 10:
              $24r$2 = $ifaceNil;
              $s = 13;
            case 13:
              return $24r$2;
            /* } */ case 11:
              err$2 = fd.pd.waitRead(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 14;
                continue;
              }
              /* */ $s = 15;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 14:
              $24r$3 = err$2;
              $s = 16;
            case 16:
              return $24r$3;
            /* } */ case 15:
              $s = 8;
              continue;
            case 9:
              $s = -1;
              return $ifaceNil;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.RawRead,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _r$1,
            err,
            err$1,
            err$2,
            f,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.RawRead = function (f) {
      return this.$val.RawRead(f);
    };
    FD.ptr.prototype.RawWrite = function (f) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        _r,
        _r$1,
        err,
        err$1,
        err$2,
        f,
        fd,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { f });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              _r = fd.writeLock();
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              err = _r;
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 2;
                continue;
              }
              /* */ $s = 3;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
              $24r = err;
              $s = 4;
            case 4:
              return $24r;
            /* } */ case 3:
              $deferred.push([$methodVal(fd, "writeUnlock"), []]);
              err$1 = fd.pd.prepareWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$1, $ifaceNil)) {
                $s = 5;
                continue;
              }
              /* */ $s = 6;
              continue;
            /* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 5:
              $24r$1 = err$1;
              $s = 7;
            case 7:
              return $24r$1;
            /* } */ case 6:
            /* while (true) { */ case 8:
              _r$1 = f(fd.Sysfd >>> 0);
              /* */ $s = 12;
            case 12:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              /* */ if (_r$1) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (_r$1) { */ case 10:
              $24r$2 = $ifaceNil;
              $s = 13;
            case 13:
              return $24r$2;
            /* } */ case 11:
              err$2 = fd.pd.waitWrite(fd.isFile);
              /* */ if (!$interfaceIsEqual(err$2, $ifaceNil)) {
                $s = 14;
                continue;
              }
              /* */ $s = 15;
              continue;
            /* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 14:
              $24r$3 = err$2;
              $s = 16;
            case 16:
              return $24r$3;
            /* } */ case 15:
              $s = 8;
              continue;
            case 9:
              $s = -1;
              return $ifaceNil;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.RawWrite,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            _r,
            _r$1,
            err,
            err$1,
            err$2,
            f,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.RawWrite = function (f) {
      return this.$val.RawWrite(f);
    };
    ignoringEINTRIO = function (fn, fd, p) {
      var { _r, _tuple, err, fd, fn, n, p, $s, $r, $c } = $restore(this, {
        fn,
        fd,
        p,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
          /* while (true) { */ case 1:
            _r = fn(fd, p);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            n = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, new syscall.Errno(4))) {
              $s = -1;
              return [n, err];
            }
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return [0, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: ignoringEINTRIO,
        $c: true,
        $r,
        _r,
        _tuple,
        err,
        fd,
        fn,
        n,
        p,
        $s,
      };
      return $f;
    };
    FD.ptr.prototype.eofError = function (n, err) {
      var err, fd, n;
      fd = this;
      if (n === 0 && $interfaceIsEqual(err, $ifaceNil) && fd.ZeroReadIsEOF) {
        return io.EOF;
      }
      return err;
    };
    FD.prototype.eofError = function (n, err) {
      return this.$val.eofError(n, err);
    };
    FD.ptr.prototype.Shutdown = function (how) {
      var { $24r, $24r$1, err, fd, how, $s, $deferred, $r, $c } = $restore(
        this,
        { how }
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              $24r$1 = syscall.Shutdown(fd.Sysfd, how);
              $s = 4;
            case 4:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Shutdown,
            $c: true,
            $r,
            $24r,
            $24r$1,
            err,
            fd,
            how,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Shutdown = function (how) {
      return this.$val.Shutdown(how);
    };
    FD.ptr.prototype.Fchown = function (uid, gid) {
      var { $24r, $24r$1, _r, err, fd, gid, uid, $s, $deferred, $r, $c } =
        $restore(this, { uid, gid });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = [fd];
              gid = [gid];
              uid = [uid];
              fd[0] = this;
              err = fd[0].incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd[0], "decref"), []]);
              _r = ignoringEINTR(
                (function (fd, gid, uid) {
                  return function $b() {
                    var { $24r$1, _r, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r = syscall.Fchown(fd[0].Sysfd, uid[0], gid[0]);
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          $24r$1 = _r;
                          $s = 2;
                        case 2:
                          return $24r$1;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r$1, _r, $s };
                    return $f;
                  };
                })(fd, gid, uid)
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Fchown,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            gid,
            uid,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Fchown = function (uid, gid) {
      return this.$val.Fchown(uid, gid);
    };
    FD.ptr.prototype.Ftruncate = function (size) {
      var { $24r, $24r$1, _r, err, fd, size, $s, $deferred, $r, $c } = $restore(
        this,
        { size }
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = [fd];
              size = [size];
              fd[0] = this;
              err = fd[0].incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd[0], "decref"), []]);
              _r = ignoringEINTR(
                (function (fd, size) {
                  return function $b() {
                    var { $24r$1, _r, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r = syscall.Ftruncate(fd[0].Sysfd, size[0]);
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          $24r$1 = _r;
                          $s = 2;
                        case 2:
                          return $24r$1;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r$1, _r, $s };
                    return $f;
                  };
                })(fd, size)
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Ftruncate,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            size,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Ftruncate = function (size) {
      return this.$val.Ftruncate(size);
    };
    FD.ptr.prototype.RawControl = function (f) {
      var { $24r, $24r$1, err, f, fd, $s, $deferred, $r, $c } = $restore(this, {
        f,
      });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = this;
              err = fd.incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd, "decref"), []]);
              $r = f(fd.Sysfd >>> 0);
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $24r$1 = $ifaceNil;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.RawControl,
            $c: true,
            $r,
            $24r,
            $24r$1,
            err,
            f,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.RawControl = function (f) {
      return this.$val.RawControl(f);
    };
    ignoringEINTR = function (fn) {
      var { _r, err, fn, $s, $r, $c } = $restore(this, { fn });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
          /* while (true) { */ case 1:
            _r = fn();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            err = _r;
            if (!$interfaceIsEqual(err, new syscall.Errno(4))) {
              $s = -1;
              return err;
            }
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = { $blk: ignoringEINTR, $c: true, $r, _r, err, fn, $s };
      return $f;
    };
    pollDesc.ptr.prototype.init = function (fd) {
      var fd, pd;
      pd = this;
      pd.fd = fd;
      return $ifaceNil;
    };
    pollDesc.prototype.init = function (fd) {
      return this.$val.init(fd);
    };
    pollDesc.ptr.prototype.close = function () {
      var pd;
      pd = this;
    };
    pollDesc.prototype.close = function () {
      return this.$val.close();
    };
    pollDesc.ptr.prototype.evict = function () {
      var pd;
      pd = this;
      pd.closing = true;
      if (!(pd.fd === ptrType$2.nil)) {
        syscall.StopIO(pd.fd.Sysfd);
      }
    };
    pollDesc.prototype.evict = function () {
      return this.$val.evict();
    };
    pollDesc.ptr.prototype.prepare = function (mode, isFile) {
      var isFile, mode, pd;
      pd = this;
      if (pd.closing) {
        return errClosing(isFile);
      }
      return $ifaceNil;
    };
    pollDesc.prototype.prepare = function (mode, isFile) {
      return this.$val.prepare(mode, isFile);
    };
    pollDesc.ptr.prototype.prepareRead = function (isFile) {
      var isFile, pd;
      pd = this;
      return pd.prepare(114, isFile);
    };
    pollDesc.prototype.prepareRead = function (isFile) {
      return this.$val.prepareRead(isFile);
    };
    pollDesc.ptr.prototype.prepareWrite = function (isFile) {
      var isFile, pd;
      pd = this;
      return pd.prepare(119, isFile);
    };
    pollDesc.prototype.prepareWrite = function (isFile) {
      return this.$val.prepareWrite(isFile);
    };
    pollDesc.ptr.prototype.wait = function (mode, isFile) {
      var isFile, mode, pd;
      pd = this;
      if (pd.closing) {
        return errClosing(isFile);
      }
      if (isFile) {
        return $ifaceNil;
      }
      return $pkg.ErrDeadlineExceeded;
    };
    pollDesc.prototype.wait = function (mode, isFile) {
      return this.$val.wait(mode, isFile);
    };
    pollDesc.ptr.prototype.waitRead = function (isFile) {
      var isFile, pd;
      pd = this;
      return pd.wait(114, isFile);
    };
    pollDesc.prototype.waitRead = function (isFile) {
      return this.$val.waitRead(isFile);
    };
    pollDesc.ptr.prototype.waitWrite = function (isFile) {
      var isFile, pd;
      pd = this;
      return pd.wait(119, isFile);
    };
    pollDesc.prototype.waitWrite = function (isFile) {
      return this.$val.waitWrite(isFile);
    };
    pollDesc.ptr.prototype.pollable = function () {
      var pd;
      pd = this;
      return true;
    };
    pollDesc.prototype.pollable = function () {
      return this.$val.pollable();
    };
    FD.ptr.prototype.SetDeadline = function (t) {
      var { $24r, _r, fd, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = setDeadlineImpl(fd, $clone(t, time.Time), 233);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.SetDeadline,
        $c: true,
        $r,
        $24r,
        _r,
        fd,
        t,
        $s,
      };
      return $f;
    };
    FD.prototype.SetDeadline = function (t) {
      return this.$val.SetDeadline(t);
    };
    FD.ptr.prototype.SetReadDeadline = function (t) {
      var { $24r, _r, fd, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = setDeadlineImpl(fd, $clone(t, time.Time), 114);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.SetReadDeadline,
        $c: true,
        $r,
        $24r,
        _r,
        fd,
        t,
        $s,
      };
      return $f;
    };
    FD.prototype.SetReadDeadline = function (t) {
      return this.$val.SetReadDeadline(t);
    };
    FD.ptr.prototype.SetWriteDeadline = function (t) {
      var { $24r, _r, fd, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = setDeadlineImpl(fd, $clone(t, time.Time), 119);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.SetWriteDeadline,
        $c: true,
        $r,
        $24r,
        _r,
        fd,
        t,
        $s,
      };
      return $f;
    };
    FD.prototype.SetWriteDeadline = function (t) {
      return this.$val.SetWriteDeadline(t);
    };
    setDeadlineImpl = function (fd, t, mode) {
      var { _1, _r, d, err, fd, mode, t, $s, $r, $c } = $restore(this, {
        fd,
        t,
        mode,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            d = $clone(t, time.Time).UnixNano();
            if ($clone(t, time.Time).IsZero()) {
              d = new $Int64(0, 0);
            }
            err = fd.incref();
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _1 = mode;
            if (_1 === 114) {
              syscall.SetReadDeadline(fd.Sysfd, d);
            } else if (_1 === 119) {
              syscall.SetWriteDeadline(fd.Sysfd, d);
            } else if (_1 === 233) {
              syscall.SetReadDeadline(fd.Sysfd, d);
              syscall.SetWriteDeadline(fd.Sysfd, d);
            }
            _r = fd.decref();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r;
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: setDeadlineImpl,
        $c: true,
        $r,
        _1,
        _r,
        d,
        err,
        fd,
        mode,
        t,
        $s,
      };
      return $f;
    };
    fdMutex.ptr.prototype.incref = function () {
      var mu, new$1, old, x, x$1;
      mu = this;
      while (true) {
        old = atomic.LoadUint64(
          mu.$ptr_state ||
            (mu.$ptr_state = new ptrType$3(
              function () {
                return this.$target.state;
              },
              function ($v) {
                this.$target.state = $v;
              },
              mu
            ))
        );
        if (
          !((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0)),
          x.$high === 0 && x.$low === 0)
        ) {
          return false;
        }
        new$1 = new $Uint64(old.$high + 0, old.$low + 8);
        if (
          ((x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0)),
          x$1.$high === 0 && x$1.$low === 0)
        ) {
          $panic(
            new $String(
              "too many concurrent operations on a single file or socket (max 1048575)"
            )
          );
        }
        if (
          atomic.CompareAndSwapUint64(
            mu.$ptr_state ||
              (mu.$ptr_state = new ptrType$3(
                function () {
                  return this.$target.state;
                },
                function ($v) {
                  this.$target.state = $v;
                },
                mu
              )),
            old,
            new$1
          )
        ) {
          return true;
        }
      }
    };
    fdMutex.prototype.incref = function () {
      return this.$val.incref();
    };
    fdMutex.ptr.prototype.increfAndClose = function () {
      var { mu, new$1, old, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r, $c } =
        $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            mu = this;
          /* while (true) { */ case 1:
            old = atomic.LoadUint64(
              mu.$ptr_state ||
                (mu.$ptr_state = new ptrType$3(
                  function () {
                    return this.$target.state;
                  },
                  function ($v) {
                    this.$target.state = $v;
                  },
                  mu
                ))
            );
            if (
              !((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0)),
              x.$high === 0 && x.$low === 0)
            ) {
              $s = -1;
              return false;
            }
            new$1 =
              ((x$1 = new $Uint64(old.$high | 0, (old.$low | 1) >>> 0)),
              new $Uint64(x$1.$high + 0, x$1.$low + 8));
            if (
              ((x$2 = new $Uint64(
                new$1.$high & 0,
                (new$1.$low & 8388600) >>> 0
              )),
              x$2.$high === 0 && x$2.$low === 0)
            ) {
              $panic(
                new $String(
                  "too many concurrent operations on a single file or socket (max 1048575)"
                )
              );
            }
            new$1 =
              ((x$3 = new $Uint64(2147483647, 4286578688)),
              new $Uint64(
                new$1.$high & ~x$3.$high,
                (new$1.$low & ~x$3.$low) >>> 0
              ));
            /* */ if (
              atomic.CompareAndSwapUint64(
                mu.$ptr_state ||
                  (mu.$ptr_state = new ptrType$3(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    mu
                  )),
                old,
                new$1
              )
            ) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
          /* while (true) { */ case 5:
            /* if (!(!((x$4 = new $Uint64(old.$high & 2047, (old.$low & 4286578688) >>> 0), (x$4.$high === 0 && x$4.$low === 0))))) { break; } */ if (
              !!((x$4 = new $Uint64(
                old.$high & 2047,
                (old.$low & 4286578688) >>> 0
              )),
              x$4.$high === 0 && x$4.$low === 0)
            ) {
              $s = 6;
              continue;
            }
            old =
              ((x$5 = new $Uint64(0, 8388608)),
              new $Uint64(old.$high - x$5.$high, old.$low - x$5.$low));
            $r = runtime_Semrelease(
              mu.$ptr_rsema ||
                (mu.$ptr_rsema = new ptrType(
                  function () {
                    return this.$target.rsema;
                  },
                  function ($v) {
                    this.$target.rsema = $v;
                  },
                  mu
                ))
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 5;
            continue;
          case 6:
          /* while (true) { */ case 8:
            /* if (!(!((x$6 = new $Uint64(old.$high & 2147481600, (old.$low & 0) >>> 0), (x$6.$high === 0 && x$6.$low === 0))))) { break; } */ if (
              !!((x$6 = new $Uint64(
                old.$high & 2147481600,
                (old.$low & 0) >>> 0
              )),
              x$6.$high === 0 && x$6.$low === 0)
            ) {
              $s = 9;
              continue;
            }
            old =
              ((x$7 = new $Uint64(2048, 0)),
              new $Uint64(old.$high - x$7.$high, old.$low - x$7.$low));
            $r = runtime_Semrelease(
              mu.$ptr_wsema ||
                (mu.$ptr_wsema = new ptrType(
                  function () {
                    return this.$target.wsema;
                  },
                  function ($v) {
                    this.$target.wsema = $v;
                  },
                  mu
                ))
            );
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 8;
            continue;
          case 9:
            $s = -1;
            return true;
          /* } */ case 4:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: fdMutex.ptr.prototype.increfAndClose,
        $c: true,
        $r,
        mu,
        new$1,
        old,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        $s,
      };
      return $f;
    };
    fdMutex.prototype.increfAndClose = function () {
      return this.$val.increfAndClose();
    };
    fdMutex.ptr.prototype.decref = function () {
      var mu, new$1, old, x, x$1;
      mu = this;
      while (true) {
        old = atomic.LoadUint64(
          mu.$ptr_state ||
            (mu.$ptr_state = new ptrType$3(
              function () {
                return this.$target.state;
              },
              function ($v) {
                this.$target.state = $v;
              },
              mu
            ))
        );
        if (
          ((x = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0)),
          x.$high === 0 && x.$low === 0)
        ) {
          $panic(new $String("inconsistent poll.fdMutex"));
        }
        new$1 = new $Uint64(old.$high - 0, old.$low - 8);
        if (
          atomic.CompareAndSwapUint64(
            mu.$ptr_state ||
              (mu.$ptr_state = new ptrType$3(
                function () {
                  return this.$target.state;
                },
                function ($v) {
                  this.$target.state = $v;
                },
                mu
              )),
            old,
            new$1
          )
        ) {
          return (
            (x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388601) >>> 0)),
            x$1.$high === 0 && x$1.$low === 1
          );
        }
      }
    };
    fdMutex.prototype.decref = function () {
      return this.$val.decref();
    };
    fdMutex.ptr.prototype.rwlock = function (read) {
      var {
        _tmp,
        _tmp$1,
        _tmp$2,
        mu,
        mutexBit,
        mutexMask,
        mutexSema,
        mutexWait,
        new$1,
        old,
        read,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        $s,
        $r,
        $c,
      } = $restore(this, { read });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            mu = this;
            _tmp = new $Uint64(0, 0);
            _tmp$1 = new $Uint64(0, 0);
            _tmp$2 = new $Uint64(0, 0);
            mutexBit = _tmp;
            mutexWait = _tmp$1;
            mutexMask = _tmp$2;
            mutexSema = ptrType.nil;
            if (read) {
              mutexBit = new $Uint64(0, 2);
              mutexWait = new $Uint64(0, 8388608);
              mutexMask = new $Uint64(2047, 4286578688);
              mutexSema =
                mu.$ptr_rsema ||
                (mu.$ptr_rsema = new ptrType(
                  function () {
                    return this.$target.rsema;
                  },
                  function ($v) {
                    this.$target.rsema = $v;
                  },
                  mu
                ));
            } else {
              mutexBit = new $Uint64(0, 4);
              mutexWait = new $Uint64(2048, 0);
              mutexMask = new $Uint64(2147481600, 0);
              mutexSema =
                mu.$ptr_wsema ||
                (mu.$ptr_wsema = new ptrType(
                  function () {
                    return this.$target.wsema;
                  },
                  function ($v) {
                    this.$target.wsema = $v;
                  },
                  mu
                ));
            }
          /* while (true) { */ case 1:
            old = atomic.LoadUint64(
              mu.$ptr_state ||
                (mu.$ptr_state = new ptrType$3(
                  function () {
                    return this.$target.state;
                  },
                  function ($v) {
                    this.$target.state = $v;
                  },
                  mu
                ))
            );
            if (
              !((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0)),
              x.$high === 0 && x.$low === 0)
            ) {
              $s = -1;
              return false;
            }
            new$1 = new $Uint64(0, 0);
            if (
              ((x$1 = new $Uint64(
                old.$high & mutexBit.$high,
                (old.$low & mutexBit.$low) >>> 0
              )),
              x$1.$high === 0 && x$1.$low === 0)
            ) {
              new$1 =
                ((x$2 = new $Uint64(
                  old.$high | mutexBit.$high,
                  (old.$low | mutexBit.$low) >>> 0
                )),
                new $Uint64(x$2.$high + 0, x$2.$low + 8));
              if (
                ((x$3 = new $Uint64(
                  new$1.$high & 0,
                  (new$1.$low & 8388600) >>> 0
                )),
                x$3.$high === 0 && x$3.$low === 0)
              ) {
                $panic(
                  new $String(
                    "too many concurrent operations on a single file or socket (max 1048575)"
                  )
                );
              }
            } else {
              new$1 = new $Uint64(
                old.$high + mutexWait.$high,
                old.$low + mutexWait.$low
              );
              if (
                ((x$4 = new $Uint64(
                  new$1.$high & mutexMask.$high,
                  (new$1.$low & mutexMask.$low) >>> 0
                )),
                x$4.$high === 0 && x$4.$low === 0)
              ) {
                $panic(
                  new $String(
                    "too many concurrent operations on a single file or socket (max 1048575)"
                  )
                );
              }
            }
            /* */ if (
              atomic.CompareAndSwapUint64(
                mu.$ptr_state ||
                  (mu.$ptr_state = new ptrType$3(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    mu
                  )),
                old,
                new$1
              )
            ) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
            if (
              ((x$5 = new $Uint64(
                old.$high & mutexBit.$high,
                (old.$low & mutexBit.$low) >>> 0
              )),
              x$5.$high === 0 && x$5.$low === 0)
            ) {
              $s = -1;
              return true;
            }
            $r = runtime_Semacquire(mutexSema);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 4:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: fdMutex.ptr.prototype.rwlock,
        $c: true,
        $r,
        _tmp,
        _tmp$1,
        _tmp$2,
        mu,
        mutexBit,
        mutexMask,
        mutexSema,
        mutexWait,
        new$1,
        old,
        read,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        $s,
      };
      return $f;
    };
    fdMutex.prototype.rwlock = function (read) {
      return this.$val.rwlock(read);
    };
    fdMutex.ptr.prototype.rwunlock = function (read) {
      var {
        _tmp,
        _tmp$1,
        _tmp$2,
        mu,
        mutexBit,
        mutexMask,
        mutexSema,
        mutexWait,
        new$1,
        old,
        read,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
        $r,
        $c,
      } = $restore(this, { read });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            mu = this;
            _tmp = new $Uint64(0, 0);
            _tmp$1 = new $Uint64(0, 0);
            _tmp$2 = new $Uint64(0, 0);
            mutexBit = _tmp;
            mutexWait = _tmp$1;
            mutexMask = _tmp$2;
            mutexSema = ptrType.nil;
            if (read) {
              mutexBit = new $Uint64(0, 2);
              mutexWait = new $Uint64(0, 8388608);
              mutexMask = new $Uint64(2047, 4286578688);
              mutexSema =
                mu.$ptr_rsema ||
                (mu.$ptr_rsema = new ptrType(
                  function () {
                    return this.$target.rsema;
                  },
                  function ($v) {
                    this.$target.rsema = $v;
                  },
                  mu
                ));
            } else {
              mutexBit = new $Uint64(0, 4);
              mutexWait = new $Uint64(2048, 0);
              mutexMask = new $Uint64(2147481600, 0);
              mutexSema =
                mu.$ptr_wsema ||
                (mu.$ptr_wsema = new ptrType(
                  function () {
                    return this.$target.wsema;
                  },
                  function ($v) {
                    this.$target.wsema = $v;
                  },
                  mu
                ));
            }
          /* while (true) { */ case 1:
            old = atomic.LoadUint64(
              mu.$ptr_state ||
                (mu.$ptr_state = new ptrType$3(
                  function () {
                    return this.$target.state;
                  },
                  function ($v) {
                    this.$target.state = $v;
                  },
                  mu
                ))
            );
            if (
              ((x = new $Uint64(
                old.$high & mutexBit.$high,
                (old.$low & mutexBit.$low) >>> 0
              )),
              x.$high === 0 && x.$low === 0) ||
              ((x$1 = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0)),
              x$1.$high === 0 && x$1.$low === 0)
            ) {
              $panic(new $String("inconsistent poll.fdMutex"));
            }
            new$1 =
              ((x$2 = new $Uint64(
                old.$high & ~mutexBit.$high,
                (old.$low & ~mutexBit.$low) >>> 0
              )),
              new $Uint64(x$2.$high - 0, x$2.$low - 8));
            if (
              !((x$3 = new $Uint64(
                old.$high & mutexMask.$high,
                (old.$low & mutexMask.$low) >>> 0
              )),
              x$3.$high === 0 && x$3.$low === 0)
            ) {
              new$1 =
                ((x$4 = mutexWait),
                new $Uint64(new$1.$high - x$4.$high, new$1.$low - x$4.$low));
            }
            /* */ if (
              atomic.CompareAndSwapUint64(
                mu.$ptr_state ||
                  (mu.$ptr_state = new ptrType$3(
                    function () {
                      return this.$target.state;
                    },
                    function ($v) {
                      this.$target.state = $v;
                    },
                    mu
                  )),
                old,
                new$1
              )
            ) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
            /* */ if (
              !((x$5 = new $Uint64(
                old.$high & mutexMask.$high,
                (old.$low & mutexMask.$low) >>> 0
              )),
              x$5.$high === 0 && x$5.$low === 0)
            ) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (!((x$5 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0)))) { */ case 5:
            $r = runtime_Semrelease(mutexSema);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 6:
            $s = -1;
            return (
              (x$6 = new $Uint64(
                new$1.$high & 0,
                (new$1.$low & 8388601) >>> 0
              )),
              x$6.$high === 0 && x$6.$low === 1
            );
          /* } */ case 4:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: fdMutex.ptr.prototype.rwunlock,
        $c: true,
        $r,
        _tmp,
        _tmp$1,
        _tmp$2,
        mu,
        mutexBit,
        mutexMask,
        mutexSema,
        mutexWait,
        new$1,
        old,
        read,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        $s,
      };
      return $f;
    };
    fdMutex.prototype.rwunlock = function (read) {
      return this.$val.rwunlock(read);
    };
    FD.ptr.prototype.incref = function () {
      var fd;
      fd = this;
      if (!fd.fdmu.incref()) {
        return errClosing(fd.isFile);
      }
      return $ifaceNil;
    };
    FD.prototype.incref = function () {
      return this.$val.incref();
    };
    FD.ptr.prototype.decref = function () {
      var { $24r, _r, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            /* */ if (fd.fdmu.decref()) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (fd.fdmu.decref()) { */ case 1:
            _r = fd.destroy();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.decref,
        $c: true,
        $r,
        $24r,
        _r,
        fd,
        $s,
      };
      return $f;
    };
    FD.prototype.decref = function () {
      return this.$val.decref();
    };
    FD.ptr.prototype.readLock = function () {
      var { _r, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = fd.fdmu.rwlock(true);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!_r) { */ case 1:
            $s = -1;
            return errClosing(fd.isFile);
          /* } */ case 2:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = { $blk: FD.ptr.prototype.readLock, $c: true, $r, _r, fd, $s };
      return $f;
    };
    FD.prototype.readLock = function () {
      return this.$val.readLock();
    };
    FD.ptr.prototype.readUnlock = function () {
      var { _r, _r$1, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = fd.fdmu.rwunlock(true);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_r) { */ case 1:
            _r$1 = fd.destroy();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$1;
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.readUnlock,
        $c: true,
        $r,
        _r,
        _r$1,
        fd,
        $s,
      };
      return $f;
    };
    FD.prototype.readUnlock = function () {
      return this.$val.readUnlock();
    };
    FD.ptr.prototype.writeLock = function () {
      var { _r, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = fd.fdmu.rwlock(false);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!_r) { */ case 1:
            $s = -1;
            return errClosing(fd.isFile);
          /* } */ case 2:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = { $blk: FD.ptr.prototype.writeLock, $c: true, $r, _r, fd, $s };
      return $f;
    };
    FD.prototype.writeLock = function () {
      return this.$val.writeLock();
    };
    FD.ptr.prototype.writeUnlock = function () {
      var { _r, _r$1, fd, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fd = this;
            _r = fd.fdmu.rwunlock(false);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (_r) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (_r) { */ case 1:
            _r$1 = fd.destroy();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$1;
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FD.ptr.prototype.writeUnlock,
        $c: true,
        $r,
        _r,
        _r$1,
        fd,
        $s,
      };
      return $f;
    };
    FD.prototype.writeUnlock = function () {
      return this.$val.writeUnlock();
    };
    FD.ptr.prototype.Fsync = function () {
      var { $24r, $24r$1, _r, err, fd, $s, $deferred, $r, $c } = $restore(
        this,
        {}
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              fd = [fd];
              fd[0] = this;
              err = fd[0].incref();
              /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
              $24r = err;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              $deferred.push([$methodVal(fd[0], "decref"), []]);
              _r = ignoringEINTR(
                (function (fd) {
                  return function $b() {
                    var { $24r$1, _r, $s, $r, $c } = $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          _r = syscall.Fsync(fd[0].Sysfd);
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          $24r$1 = _r;
                          $s = 2;
                        case 2:
                          return $24r$1;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, $24r$1, _r, $s };
                    return $f;
                  };
                })(fd)
              );
              /* */ $s = 4;
            case 4:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $24r$1 = _r;
              $s = 5;
            case 5:
              return $24r$1;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return $ifaceNil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FD.ptr.prototype.Fsync,
            $c: true,
            $r,
            $24r,
            $24r$1,
            _r,
            err,
            fd,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FD.prototype.Fsync = function () {
      return this.$val.Fsync();
    };
    errNetClosing.ptr.prototype.Error = function () {
      var e;
      e = this;
      return "use of closed network connection";
    };
    errNetClosing.prototype.Error = function () {
      return this.$val.Error();
    };
    errNetClosing.ptr.prototype.Timeout = function () {
      var e;
      e = this;
      return false;
    };
    errNetClosing.prototype.Timeout = function () {
      return this.$val.Timeout();
    };
    errNetClosing.ptr.prototype.Temporary = function () {
      var e;
      e = this;
      return false;
    };
    errNetClosing.prototype.Temporary = function () {
      return this.$val.Temporary();
    };
    errClosing = function (isFile) {
      var isFile;
      if (isFile) {
        return $pkg.ErrFileClosing;
      }
      return new $pkg.ErrNetClosing.constructor.elem($pkg.ErrNetClosing);
    };
    DeadlineExceededError.ptr.prototype.Error = function () {
      var e;
      e = this;
      return "i/o timeout";
    };
    DeadlineExceededError.prototype.Error = function () {
      return this.$val.Error();
    };
    DeadlineExceededError.ptr.prototype.Timeout = function () {
      var e;
      e = this;
      return true;
    };
    DeadlineExceededError.prototype.Timeout = function () {
      return this.$val.Timeout();
    };
    DeadlineExceededError.ptr.prototype.Temporary = function () {
      var e;
      e = this;
      return true;
    };
    DeadlineExceededError.prototype.Temporary = function () {
      return this.$val.Temporary();
    };
    fcntl = function (fd, cmd, arg) {
      var arg, cmd, fd;
      return [0, new syscall.Errno(38)];
    };
    ptrType$2.methods = [
      {
        prop: "Init",
        name: "Init",
        pkg: "",
        typ: $funcType([$String, $Bool], [$error], false),
      },
      {
        prop: "destroy",
        name: "destroy",
        pkg: "internal/poll",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Close",
        name: "Close",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "SetBlocking",
        name: "SetBlocking",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
      {
        prop: "Pread",
        name: "Pread",
        pkg: "",
        typ: $funcType([sliceType$1, $Int64], [$Int, $error], false),
      },
      {
        prop: "ReadFrom",
        name: "ReadFrom",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, syscall.Sockaddr, $error], false),
      },
      {
        prop: "ReadFromInet4",
        name: "ReadFromInet4",
        pkg: "",
        typ: $funcType([sliceType$1, ptrType$5], [$Int, $error], false),
      },
      {
        prop: "ReadFromInet6",
        name: "ReadFromInet6",
        pkg: "",
        typ: $funcType([sliceType$1, ptrType$6], [$Int, $error], false),
      },
      {
        prop: "ReadMsg",
        name: "ReadMsg",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, $Int],
          [$Int, $Int, $Int, syscall.Sockaddr, $error],
          false
        ),
      },
      {
        prop: "ReadMsgInet4",
        name: "ReadMsgInet4",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, $Int, ptrType$5],
          [$Int, $Int, $Int, $error],
          false
        ),
      },
      {
        prop: "ReadMsgInet6",
        name: "ReadMsgInet6",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, $Int, ptrType$6],
          [$Int, $Int, $Int, $error],
          false
        ),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
      {
        prop: "Pwrite",
        name: "Pwrite",
        pkg: "",
        typ: $funcType([sliceType$1, $Int64], [$Int, $error], false),
      },
      {
        prop: "WriteToInet4",
        name: "WriteToInet4",
        pkg: "",
        typ: $funcType([sliceType$1, ptrType$5], [$Int, $error], false),
      },
      {
        prop: "WriteToInet6",
        name: "WriteToInet6",
        pkg: "",
        typ: $funcType([sliceType$1, ptrType$6], [$Int, $error], false),
      },
      {
        prop: "WriteTo",
        name: "WriteTo",
        pkg: "",
        typ: $funcType([sliceType$1, syscall.Sockaddr], [$Int, $error], false),
      },
      {
        prop: "WriteMsg",
        name: "WriteMsg",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, syscall.Sockaddr],
          [$Int, $Int, $error],
          false
        ),
      },
      {
        prop: "WriteMsgInet4",
        name: "WriteMsgInet4",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, ptrType$5],
          [$Int, $Int, $error],
          false
        ),
      },
      {
        prop: "WriteMsgInet6",
        name: "WriteMsgInet6",
        pkg: "",
        typ: $funcType(
          [sliceType$1, sliceType$1, ptrType$6],
          [$Int, $Int, $error],
          false
        ),
      },
      {
        prop: "Accept",
        name: "Accept",
        pkg: "",
        typ: $funcType([], [$Int, syscall.Sockaddr, $String, $error], false),
      },
      {
        prop: "Seek",
        name: "Seek",
        pkg: "",
        typ: $funcType([$Int64, $Int], [$Int64, $error], false),
      },
      {
        prop: "ReadDirent",
        name: "ReadDirent",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
      {
        prop: "Fchmod",
        name: "Fchmod",
        pkg: "",
        typ: $funcType([$Uint32], [$error], false),
      },
      {
        prop: "Fchdir",
        name: "Fchdir",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Fstat",
        name: "Fstat",
        pkg: "",
        typ: $funcType([ptrType$7], [$error], false),
      },
      {
        prop: "Dup",
        name: "Dup",
        pkg: "",
        typ: $funcType([], [$Int, $String, $error], false),
      },
      {
        prop: "WaitWrite",
        name: "WaitWrite",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "WriteOnce",
        name: "WriteOnce",
        pkg: "",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
      {
        prop: "RawRead",
        name: "RawRead",
        pkg: "",
        typ: $funcType([funcType], [$error], false),
      },
      {
        prop: "RawWrite",
        name: "RawWrite",
        pkg: "",
        typ: $funcType([funcType], [$error], false),
      },
      {
        prop: "eofError",
        name: "eofError",
        pkg: "internal/poll",
        typ: $funcType([$Int, $error], [$error], false),
      },
      {
        prop: "Shutdown",
        name: "Shutdown",
        pkg: "",
        typ: $funcType([$Int], [$error], false),
      },
      {
        prop: "Fchown",
        name: "Fchown",
        pkg: "",
        typ: $funcType([$Int, $Int], [$error], false),
      },
      {
        prop: "Ftruncate",
        name: "Ftruncate",
        pkg: "",
        typ: $funcType([$Int64], [$error], false),
      },
      {
        prop: "RawControl",
        name: "RawControl",
        pkg: "",
        typ: $funcType([funcType$1], [$error], false),
      },
      {
        prop: "SetDeadline",
        name: "SetDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "SetReadDeadline",
        name: "SetReadDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "SetWriteDeadline",
        name: "SetWriteDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "incref",
        name: "incref",
        pkg: "internal/poll",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "decref",
        name: "decref",
        pkg: "internal/poll",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "readLock",
        name: "readLock",
        pkg: "internal/poll",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "readUnlock",
        name: "readUnlock",
        pkg: "internal/poll",
        typ: $funcType([], [], false),
      },
      {
        prop: "writeLock",
        name: "writeLock",
        pkg: "internal/poll",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "writeUnlock",
        name: "writeUnlock",
        pkg: "internal/poll",
        typ: $funcType([], [], false),
      },
      {
        prop: "Fsync",
        name: "Fsync",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
    ];
    ptrType$8.methods = [
      {
        prop: "init",
        name: "init",
        pkg: "internal/poll",
        typ: $funcType([ptrType$2], [$error], false),
      },
      {
        prop: "close",
        name: "close",
        pkg: "internal/poll",
        typ: $funcType([], [], false),
      },
      {
        prop: "evict",
        name: "evict",
        pkg: "internal/poll",
        typ: $funcType([], [], false),
      },
      {
        prop: "prepare",
        name: "prepare",
        pkg: "internal/poll",
        typ: $funcType([$Int, $Bool], [$error], false),
      },
      {
        prop: "prepareRead",
        name: "prepareRead",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$error], false),
      },
      {
        prop: "prepareWrite",
        name: "prepareWrite",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$error], false),
      },
      {
        prop: "wait",
        name: "wait",
        pkg: "internal/poll",
        typ: $funcType([$Int, $Bool], [$error], false),
      },
      {
        prop: "waitRead",
        name: "waitRead",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$error], false),
      },
      {
        prop: "waitWrite",
        name: "waitWrite",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$error], false),
      },
      {
        prop: "waitCanceled",
        name: "waitCanceled",
        pkg: "internal/poll",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "pollable",
        name: "pollable",
        pkg: "internal/poll",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$9.methods = [
      {
        prop: "incref",
        name: "incref",
        pkg: "internal/poll",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "increfAndClose",
        name: "increfAndClose",
        pkg: "internal/poll",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "decref",
        name: "decref",
        pkg: "internal/poll",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "rwlock",
        name: "rwlock",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$Bool], false),
      },
      {
        prop: "rwunlock",
        name: "rwunlock",
        pkg: "internal/poll",
        typ: $funcType([$Bool], [$Bool], false),
      },
    ];
    errNetClosing.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Temporary",
        name: "Temporary",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$10.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Temporary",
        name: "Temporary",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    FD.init("internal/poll", [
      {
        prop: "fdmu",
        name: "fdmu",
        embedded: false,
        exported: false,
        typ: fdMutex,
        tag: "",
      },
      {
        prop: "Sysfd",
        name: "Sysfd",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "pd",
        name: "pd",
        embedded: false,
        exported: false,
        typ: pollDesc,
        tag: "",
      },
      {
        prop: "iovecs",
        name: "iovecs",
        embedded: false,
        exported: false,
        typ: ptrType$4,
        tag: "",
      },
      {
        prop: "csema",
        name: "csema",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "isBlocking",
        name: "isBlocking",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "IsStream",
        name: "IsStream",
        embedded: false,
        exported: true,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "ZeroReadIsEOF",
        name: "ZeroReadIsEOF",
        embedded: false,
        exported: true,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "isFile",
        name: "isFile",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    pollDesc.init("internal/poll", [
      {
        prop: "fd",
        name: "fd",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
      {
        prop: "closing",
        name: "closing",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    fdMutex.init("internal/poll", [
      {
        prop: "state",
        name: "state",
        embedded: false,
        exported: false,
        typ: $Uint64,
        tag: "",
      },
      {
        prop: "rsema",
        name: "rsema",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
      {
        prop: "wsema",
        name: "wsema",
        embedded: false,
        exported: false,
        typ: $Uint32,
        tag: "",
      },
    ]);
    errNetClosing.init("", []);
    DeadlineExceededError.init("", []);
    $pkg.$initLinknames = function () {
      runtime_Semacquire = $linknames["sync.runtime_Semacquire"];
      runtime_Semrelease = $linknames["sync.runtime_Semrelease"];
    };
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unix.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = atomic.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = syscall.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = time.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.CloseFunc = syscall.Close;
            $pkg.AcceptFunc = syscall.Accept;
            tryDupCloexec = 1;
            $pkg.ErrNetClosing = new errNetClosing.ptr();
            $pkg.ErrFileClosing = errors.New("use of closed file");
            $pkg.ErrNoDeadline = errors.New(
              "file type does not support deadline"
            );
            $pkg.ErrDeadlineExceeded = new DeadlineExceededError.ptr();
            $pkg.ErrNotPollable = errors.New("not pollable");
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/syscall/execenv"] = (function () {
    var $pkg = {},
      $init,
      syscall;
    syscall = $packages["syscall"];
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = syscall.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["internal/testlog"] = (function () {
    var $pkg = {},
      $init,
      sync,
      atomic,
      Interface,
      ptrType,
      logger,
      Logger,
      Stat;
    sync = $packages["sync"];
    atomic = $packages["sync/atomic"];
    Interface = $pkg.Interface = $newType(
      8,
      $kindInterface,
      "testlog.Interface",
      true,
      "internal/testlog",
      true,
      null
    );
    ptrType = $ptrType(Interface);
    Logger = function () {
      var impl;
      impl = logger.Load();
      if ($interfaceIsEqual(impl, $ifaceNil)) {
        return $ifaceNil;
      }
      return $assertType(impl, ptrType).$get();
    };
    $pkg.Logger = Logger;
    Stat = function (name) {
      var { log, name, $s, $r, $c } = $restore(this, { name });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            log = Logger();
            /* */ if (!$interfaceIsEqual(log, $ifaceNil)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!($interfaceIsEqual(log, $ifaceNil))) { */ case 1:
            $r = log.Stat(name);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: Stat, $c: true, $r, log, name, $s };
      return $f;
    };
    $pkg.Stat = Stat;
    Interface.init([
      {
        prop: "Chdir",
        name: "Chdir",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Getenv",
        name: "Getenv",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Open",
        name: "Open",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Stat",
        name: "Stat",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = sync.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = atomic.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            logger = new atomic.Value.ptr($ifaceNil);
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["path"] = (function () {
    var $pkg = {},
      $init,
      errors,
      bytealg,
      utf8;
    errors = $packages["errors"];
    bytealg = $packages["internal/bytealg"];
    utf8 = $packages["unicode/utf8"];
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bytealg.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ErrBadPattern = errors.New("syntax error in pattern");
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["io/fs"] = (function () {
    var $pkg = {},
      $init,
      errors,
      oserror,
      io,
      path,
      sort,
      time,
      utf8,
      DirEntry,
      FileInfo,
      FileMode,
      PathError,
      ptrType,
      sliceType$2,
      arrayType,
      interfaceType,
      errInvalid,
      errPermission,
      errExist,
      errNotExist,
      errClosed;
    errors = $packages["errors"];
    oserror = $packages["internal/oserror"];
    io = $packages["io"];
    path = $packages["path"];
    sort = $packages["sort"];
    time = $packages["time"];
    utf8 = $packages["unicode/utf8"];
    DirEntry = $pkg.DirEntry = $newType(
      8,
      $kindInterface,
      "fs.DirEntry",
      true,
      "io/fs",
      true,
      null
    );
    FileInfo = $pkg.FileInfo = $newType(
      8,
      $kindInterface,
      "fs.FileInfo",
      true,
      "io/fs",
      true,
      null
    );
    FileMode = $pkg.FileMode = $newType(
      4,
      $kindUint32,
      "fs.FileMode",
      true,
      "io/fs",
      true,
      null
    );
    PathError = $pkg.PathError = $newType(
      0,
      $kindStruct,
      "fs.PathError",
      true,
      "io/fs",
      true,
      function (Op_, Path_, Err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Op = "";
          this.Path = "";
          this.Err = $ifaceNil;
          return;
        }
        this.Op = Op_;
        this.Path = Path_;
        this.Err = Err_;
      }
    );
    ptrType = $ptrType(PathError);
    sliceType$2 = $sliceType($Uint8);
    arrayType = $arrayType($Uint8, 32);
    interfaceType = $interfaceType([
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ]);
    errInvalid = function () {
      return oserror.ErrInvalid;
    };
    errPermission = function () {
      return oserror.ErrPermission;
    };
    errExist = function () {
      return oserror.ErrExist;
    };
    errNotExist = function () {
      return oserror.ErrNotExist;
    };
    errClosed = function () {
      return oserror.ErrClosed;
    };
    FileMode.prototype.String = function () {
      var _i,
        _i$1,
        _ref,
        _ref$1,
        _rune,
        _rune$1,
        buf,
        c,
        c$1,
        i,
        i$1,
        m,
        w,
        y,
        y$1;
      m = this.$val;
      buf = arrayType.zero();
      w = 0;
      _ref = "dalTLDpSugct?";
      _i = 0;
      while (true) {
        if (!(_i < _ref.length)) {
          break;
        }
        _rune = $decodeRune(_ref, _i);
        i = _i;
        c = _rune[0];
        if (
          !(
            (m & (((y = ((31 - i) >> 0) >>> 0), y < 32 ? 1 << y : 0) >>> 0)) >>>
              0 ===
            0
          )
        ) {
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = (c << 24) >>> 24);
          w = (w + 1) >> 0;
        }
        _i += _rune[1];
      }
      if (w === 0) {
        w < 0 || w >= buf.length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf[w] = 45);
        w = (w + 1) >> 0;
      }
      _ref$1 = "rwxrwxrwx";
      _i$1 = 0;
      while (true) {
        if (!(_i$1 < _ref$1.length)) {
          break;
        }
        _rune$1 = $decodeRune(_ref$1, _i$1);
        i$1 = _i$1;
        c$1 = _rune$1[0];
        if (
          !(
            (m &
              (((y$1 = ((8 - i$1) >> 0) >>> 0), y$1 < 32 ? 1 << y$1 : 0) >>>
                0)) >>>
              0 ===
            0
          )
        ) {
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = (c$1 << 24) >>> 24);
        } else {
          w < 0 || w >= buf.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf[w] = 45);
        }
        w = (w + 1) >> 0;
        _i$1 += _rune$1[1];
      }
      return $bytesToString($subslice(new sliceType$2(buf), 0, w));
    };
    $ptrType(FileMode).prototype.String = function () {
      return new FileMode(this.$get()).String();
    };
    FileMode.prototype.IsDir = function () {
      var m;
      m = this.$val;
      return !((m & 2147483648) >>> 0 === 0);
    };
    $ptrType(FileMode).prototype.IsDir = function () {
      return new FileMode(this.$get()).IsDir();
    };
    FileMode.prototype.IsRegular = function () {
      var m;
      m = this.$val;
      return (m & 2401763328) >>> 0 === 0;
    };
    $ptrType(FileMode).prototype.IsRegular = function () {
      return new FileMode(this.$get()).IsRegular();
    };
    FileMode.prototype.Perm = function () {
      var m;
      m = this.$val;
      return (m & 511) >>> 0;
    };
    $ptrType(FileMode).prototype.Perm = function () {
      return new FileMode(this.$get()).Perm();
    };
    FileMode.prototype.Type = function () {
      var m;
      m = this.$val;
      return (m & 2401763328) >>> 0;
    };
    $ptrType(FileMode).prototype.Type = function () {
      return new FileMode(this.$get()).Type();
    };
    PathError.ptr.prototype.Error = function () {
      var { $24r, _r, e, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _r = e.Err.Error();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = e.Op + " " + e.Path + ": " + _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: PathError.ptr.prototype.Error,
        $c: true,
        $r,
        $24r,
        _r,
        e,
        $s,
      };
      return $f;
    };
    PathError.prototype.Error = function () {
      return this.$val.Error();
    };
    PathError.ptr.prototype.Unwrap = function () {
      var e;
      e = this;
      return e.Err;
    };
    PathError.prototype.Unwrap = function () {
      return this.$val.Unwrap();
    };
    PathError.ptr.prototype.Timeout = function () {
      var { $24r, _r, _tuple, _v, e, ok, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _tuple = $assertType(e.Err, interfaceType, true);
            t = _tuple[0];
            ok = _tuple[1];
            if (!ok) {
              _v = false;
              $s = 1;
              continue s;
            }
            _r = t.Timeout();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = _r;
          case 1:
            $24r = _v;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: PathError.ptr.prototype.Timeout,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        _v,
        e,
        ok,
        t,
        $s,
      };
      return $f;
    };
    PathError.prototype.Timeout = function () {
      return this.$val.Timeout();
    };
    FileMode.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "IsDir",
        name: "IsDir",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsRegular",
        name: "IsRegular",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Perm",
        name: "Perm",
        pkg: "",
        typ: $funcType([], [FileMode], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [FileMode], false),
      },
    ];
    ptrType.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Unwrap",
        name: "Unwrap",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    DirEntry.init([
      {
        prop: "Info",
        name: "Info",
        pkg: "",
        typ: $funcType([], [FileInfo, $error], false),
      },
      {
        prop: "IsDir",
        name: "IsDir",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [FileMode], false),
      },
    ]);
    FileInfo.init([
      {
        prop: "IsDir",
        name: "IsDir",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "ModTime",
        name: "ModTime",
        pkg: "",
        typ: $funcType([], [time.Time], false),
      },
      {
        prop: "Mode",
        name: "Mode",
        pkg: "",
        typ: $funcType([], [FileMode], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Sys",
        name: "Sys",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
    ]);
    PathError.init("", [
      {
        prop: "Op",
        name: "Op",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Path",
        name: "Path",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Err",
        name: "Err",
        embedded: false,
        exported: true,
        typ: $error,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = oserror.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = path.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = time.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.SkipDir = errors.New("skip this directory");
            $pkg.ErrInvalid = errInvalid();
            $pkg.ErrPermission = errPermission();
            $pkg.ErrExist = errExist();
            $pkg.ErrNotExist = errNotExist();
            $pkg.ErrClosed = errClosed();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["os"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js,
      itoa,
      oserror,
      poll,
      execenv,
      unix,
      testlog,
      unsafeheader,
      io,
      fs,
      runtime,
      sort,
      sync,
      atomic,
      syscall,
      time,
      fileStat,
      File,
      rawConn,
      file,
      unixDirent,
      LinkError,
      onlyWriter,
      timeout,
      SyscallError,
      dirInfo,
      readdirMode,
      sliceType,
      sliceType$1,
      sliceType$2,
      ptrType,
      ptrType$1,
      ptrType$2,
      ptrType$3,
      ptrType$5,
      ptrType$6,
      sliceType$4,
      ptrType$7,
      ptrType$8,
      ptrType$9,
      funcType,
      ptrType$17,
      ptrType$18,
      sliceType$7,
      sliceType$8,
      funcType$2,
      funcType$3,
      ptrType$19,
      ptrType$20,
      errPatternHasSeparator,
      errWriteAtInAppendMode,
      lstat,
      dirBufPool,
      testingForceReadDirLstat,
      _r,
      _r$1,
      _r$2,
      lstatNolog,
      fillFileStatFromSys,
      timespecToTime,
      Lstat,
      newRawConn,
      init,
      IsPathSeparator,
      basename,
      runtime_args,
      init$1,
      NewFile,
      newFile,
      epipecheck,
      newUnixDirent,
      sigpipe,
      syscallMode,
      ignoringEINTR,
      genericReadFrom,
      errNoDeadline,
      errDeadlineExceeded,
      IsNotExist,
      underlyingErrorIs,
      underlyingError,
      direntIno,
      direntReclen,
      direntNamlen,
      direntType,
      readInt,
      readIntBE,
      readIntLE;
    errors = $packages["errors"];
    js = $packages["github.com/gopherjs/gopherjs/js"];
    itoa = $packages["internal/itoa"];
    oserror = $packages["internal/oserror"];
    poll = $packages["internal/poll"];
    execenv = $packages["internal/syscall/execenv"];
    unix = $packages["internal/syscall/unix"];
    testlog = $packages["internal/testlog"];
    unsafeheader = $packages["internal/unsafeheader"];
    io = $packages["io"];
    fs = $packages["io/fs"];
    runtime = $packages["runtime"];
    sort = $packages["sort"];
    sync = $packages["sync"];
    atomic = $packages["sync/atomic"];
    syscall = $packages["syscall"];
    time = $packages["time"];
    fileStat = $pkg.fileStat = $newType(
      0,
      $kindStruct,
      "os.fileStat",
      true,
      "os",
      false,
      function (name_, size_, mode_, modTime_, sys_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.name = "";
          this.size = new $Int64(0, 0);
          this.mode = 0;
          this.modTime = new time.Time.ptr(
            new $Uint64(0, 0),
            new $Int64(0, 0),
            ptrType$3.nil
          );
          this.sys = new syscall.Stat_t.ptr(
            new $Int64(0, 0),
            new $Uint64(0, 0),
            0,
            0,
            0,
            0,
            new $Int64(0, 0),
            new $Int64(0, 0),
            0,
            0,
            new $Int64(0, 0),
            new $Int64(0, 0),
            new $Int64(0, 0),
            new $Int64(0, 0),
            new $Int64(0, 0),
            new $Int64(0, 0)
          );
          return;
        }
        this.name = name_;
        this.size = size_;
        this.mode = mode_;
        this.modTime = modTime_;
        this.sys = sys_;
      }
    );
    File = $pkg.File = $newType(
      0,
      $kindStruct,
      "os.File",
      true,
      "os",
      true,
      function (file_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.file = ptrType$9.nil;
          return;
        }
        this.file = file_;
      }
    );
    rawConn = $pkg.rawConn = $newType(
      0,
      $kindStruct,
      "os.rawConn",
      true,
      "os",
      false,
      function (file_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.file = ptrType$2.nil;
          return;
        }
        this.file = file_;
      }
    );
    file = $pkg.file = $newType(
      0,
      $kindStruct,
      "os.file",
      true,
      "os",
      false,
      function (pfd_, name_, dirinfo_, nonblock_, stdoutOrErr_, appendMode_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.pfd = new poll.FD.ptr(
            new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0),
            0,
            new poll.pollDesc.ptr(ptrType$6.nil, false),
            ptrType$7.nil,
            0,
            0,
            false,
            false,
            false
          );
          this.name = "";
          this.dirinfo = ptrType$8.nil;
          this.nonblock = false;
          this.stdoutOrErr = false;
          this.appendMode = false;
          return;
        }
        this.pfd = pfd_;
        this.name = name_;
        this.dirinfo = dirinfo_;
        this.nonblock = nonblock_;
        this.stdoutOrErr = stdoutOrErr_;
        this.appendMode = appendMode_;
      }
    );
    unixDirent = $pkg.unixDirent = $newType(
      0,
      $kindStruct,
      "os.unixDirent",
      true,
      "os",
      false,
      function (parent_, name_, typ_, info_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.parent = "";
          this.name = "";
          this.typ = 0;
          this.info = $ifaceNil;
          return;
        }
        this.parent = parent_;
        this.name = name_;
        this.typ = typ_;
        this.info = info_;
      }
    );
    LinkError = $pkg.LinkError = $newType(
      0,
      $kindStruct,
      "os.LinkError",
      true,
      "os",
      true,
      function (Op_, Old_, New_, Err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Op = "";
          this.Old = "";
          this.New = "";
          this.Err = $ifaceNil;
          return;
        }
        this.Op = Op_;
        this.Old = Old_;
        this.New = New_;
        this.Err = Err_;
      }
    );
    onlyWriter = $pkg.onlyWriter = $newType(
      0,
      $kindStruct,
      "os.onlyWriter",
      true,
      "os",
      false,
      function (Writer_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Writer = $ifaceNil;
          return;
        }
        this.Writer = Writer_;
      }
    );
    timeout = $pkg.timeout = $newType(
      8,
      $kindInterface,
      "os.timeout",
      true,
      "os",
      false,
      null
    );
    SyscallError = $pkg.SyscallError = $newType(
      0,
      $kindStruct,
      "os.SyscallError",
      true,
      "os",
      true,
      function (Syscall_, Err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Syscall = "";
          this.Err = $ifaceNil;
          return;
        }
        this.Syscall = Syscall_;
        this.Err = Err_;
      }
    );
    dirInfo = $pkg.dirInfo = $newType(
      0,
      $kindStruct,
      "os.dirInfo",
      true,
      "os",
      false,
      function (buf_, nbuf_, bufp_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.buf = ptrType.nil;
          this.nbuf = 0;
          this.bufp = 0;
          return;
        }
        this.buf = buf_;
        this.nbuf = nbuf_;
        this.bufp = bufp_;
      }
    );
    readdirMode = $pkg.readdirMode = $newType(
      4,
      $kindInt,
      "os.readdirMode",
      true,
      "os",
      false,
      null
    );
    sliceType = $sliceType($String);
    sliceType$1 = $sliceType($emptyInterface);
    sliceType$2 = $sliceType($Uint8);
    ptrType = $ptrType(sliceType$2);
    ptrType$1 = $ptrType(fileStat);
    ptrType$2 = $ptrType(File);
    ptrType$3 = $ptrType(time.Location);
    ptrType$5 = $ptrType(fs.PathError);
    ptrType$6 = $ptrType(poll.FD);
    sliceType$4 = $sliceType(syscall.Iovec);
    ptrType$7 = $ptrType(sliceType$4);
    ptrType$8 = $ptrType(dirInfo);
    ptrType$9 = $ptrType(file);
    funcType = $funcType([ptrType$9], [$error], false);
    ptrType$17 = $ptrType(LinkError);
    ptrType$18 = $ptrType(SyscallError);
    sliceType$7 = $sliceType(fs.DirEntry);
    sliceType$8 = $sliceType(fs.FileInfo);
    funcType$2 = $funcType([$Uintptr], [], false);
    funcType$3 = $funcType([$Uintptr], [$Bool], false);
    ptrType$19 = $ptrType(rawConn);
    ptrType$20 = $ptrType(unixDirent);
    fileStat.ptr.prototype.Size = function () {
      var fs$1;
      fs$1 = this;
      return fs$1.size;
    };
    fileStat.prototype.Size = function () {
      return this.$val.Size();
    };
    fileStat.ptr.prototype.Mode = function () {
      var fs$1;
      fs$1 = this;
      return fs$1.mode;
    };
    fileStat.prototype.Mode = function () {
      return this.$val.Mode();
    };
    fileStat.ptr.prototype.ModTime = function () {
      var fs$1;
      fs$1 = this;
      return fs$1.modTime;
    };
    fileStat.prototype.ModTime = function () {
      return this.$val.ModTime();
    };
    fileStat.ptr.prototype.Sys = function () {
      var fs$1;
      fs$1 = this;
      return fs$1.sys;
    };
    fileStat.prototype.Sys = function () {
      return this.$val.Sys();
    };
    fileStat.ptr.prototype.Name = function () {
      var fs$1;
      fs$1 = this;
      return fs$1.name;
    };
    fileStat.prototype.Name = function () {
      return this.$val.Name();
    };
    fileStat.ptr.prototype.IsDir = function () {
      var fs$1;
      fs$1 = this;
      return new fs.FileMode(fs$1.Mode()).IsDir();
    };
    fileStat.prototype.IsDir = function () {
      return this.$val.IsDir();
    };
    File.ptr.prototype.Stat = function () {
      var { _r$3, err, f, fs$1, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fs$1 = [fs$1];
            f = this;
            if (f === ptrType$2.nil) {
              $s = -1;
              return [$ifaceNil, $pkg.ErrInvalid];
            }
            fs$1[0] = new fileStat.ptr(
              "",
              new $Int64(0, 0),
              0,
              new time.Time.ptr(
                new $Uint64(0, 0),
                new $Int64(0, 0),
                ptrType$3.nil
              ),
              new syscall.Stat_t.ptr(
                new $Int64(0, 0),
                new $Uint64(0, 0),
                0,
                0,
                0,
                0,
                new $Int64(0, 0),
                new $Int64(0, 0),
                0,
                0,
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0)
              )
            );
            _r$3 = f.file.pfd.Fstat(fs$1[0].sys);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err = _r$3;
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [
                $ifaceNil,
                new fs.PathError.ptr("stat", f.file.name, err),
              ];
            }
            fillFileStatFromSys(fs$1[0], f.file.name);
            $s = -1;
            return [fs$1[0], $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Stat,
        $c: true,
        $r,
        _r$3,
        err,
        f,
        fs$1,
        $s,
      };
      return $f;
    };
    File.prototype.Stat = function () {
      return this.$val.Stat();
    };
    lstatNolog = function (name) {
      var { _r$3, err, fs$1, name, $s, $r, $c } = $restore(this, { name });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fs$1 = [fs$1];
            name = [name];
            fs$1[0] = new fileStat.ptr(
              "",
              new $Int64(0, 0),
              0,
              new time.Time.ptr(
                new $Uint64(0, 0),
                new $Int64(0, 0),
                ptrType$3.nil
              ),
              new syscall.Stat_t.ptr(
                new $Int64(0, 0),
                new $Uint64(0, 0),
                0,
                0,
                0,
                0,
                new $Int64(0, 0),
                new $Int64(0, 0),
                0,
                0,
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0),
                new $Int64(0, 0)
              )
            );
            _r$3 = ignoringEINTR(
              (function (fs$1, name) {
                return function $b() {
                  var { $24r, _r$3, $s, $r, $c } = $restore(this, {});
                  /* */ $s = $s || 0;
                  s: while (true) {
                    switch ($s) {
                      case 0:
                        _r$3 = syscall.Lstat(name[0], fs$1[0].sys);
                        /* */ $s = 1;
                      case 1:
                        if ($c) {
                          $c = false;
                          _r$3 = _r$3.$blk();
                        }
                        if (_r$3 && _r$3.$blk !== undefined) {
                          break s;
                        }
                        $24r = _r$3;
                        $s = 2;
                      case 2:
                        return $24r;
                      /* */
                    }
                    return;
                  }
                  var $f = { $blk: $b, $c: true, $r, $24r, _r$3, $s };
                  return $f;
                };
              })(fs$1, name)
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err = _r$3;
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [$ifaceNil, new fs.PathError.ptr("lstat", name[0], err)];
            }
            fillFileStatFromSys(fs$1[0], name[0]);
            $s = -1;
            return [fs$1[0], $ifaceNil];
          /* */
        }
        return;
      }
      var $f = { $blk: lstatNolog, $c: true, $r, _r$3, err, fs$1, name, $s };
      return $f;
    };
    fillFileStatFromSys = function (fs$1, name) {
      var _1, fs$1, name;
      fs$1.name = basename(name);
      fs$1.size = fs$1.sys.Size;
      time.Time.copy(
        fs$1.modTime,
        timespecToTime(fs$1.sys.Mtime, fs$1.sys.MtimeNsec)
      );
      fs$1.mode = ((fs$1.sys.Mode & 511) >>> 0) >>> 0;
      _1 = (fs$1.sys.Mode & 126976) >>> 0;
      if (_1 === 24576) {
        fs$1.mode = (fs$1.mode | 67108864) >>> 0;
      } else if (_1 === 8192) {
        fs$1.mode = (fs$1.mode | 69206016) >>> 0;
      } else if (_1 === 16384) {
        fs$1.mode = (fs$1.mode | 2147483648) >>> 0;
      } else if (_1 === 4096) {
        fs$1.mode = (fs$1.mode | 33554432) >>> 0;
      } else if (_1 === 40960) {
        fs$1.mode = (fs$1.mode | 134217728) >>> 0;
      } else if (_1 === 32768) {
      } else if (_1 === 49152) {
        fs$1.mode = (fs$1.mode | 16777216) >>> 0;
      }
      if (!((fs$1.sys.Mode & 1024) >>> 0 === 0)) {
        fs$1.mode = (fs$1.mode | 4194304) >>> 0;
      }
      if (!((fs$1.sys.Mode & 2048) >>> 0 === 0)) {
        fs$1.mode = (fs$1.mode | 8388608) >>> 0;
      }
      if (!((fs$1.sys.Mode & 512) >>> 0 === 0)) {
        fs$1.mode = (fs$1.mode | 1048576) >>> 0;
      }
    };
    timespecToTime = function (sec, nsec) {
      var nsec, sec;
      return time.Unix(sec, nsec);
    };
    Lstat = function (name) {
      var { $24r, _r$3, name, $s, $r, $c } = $restore(this, { name });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            $r = testlog.Stat(name);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r$3 = lstatNolog(name);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: Lstat, $c: true, $r, $24r, _r$3, name, $s };
      return $f;
    };
    $pkg.Lstat = Lstat;
    File.ptr.prototype.readFrom = function (r) {
      var _tmp, _tmp$1, _tmp$2, err, f, handled, n, r;
      n = new $Int64(0, 0);
      handled = false;
      err = $ifaceNil;
      f = this;
      _tmp = new $Int64(0, 0);
      _tmp$1 = false;
      _tmp$2 = $ifaceNil;
      n = _tmp;
      handled = _tmp$1;
      err = _tmp$2;
      return [n, handled, err];
    };
    File.prototype.readFrom = function (r) {
      return this.$val.readFrom(r);
    };
    rawConn.ptr.prototype.Control = function (f) {
      var { _r$3, c, err, err$1, f, $s, $r, $c } = $restore(this, { f });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            c = this;
            err = c.file.checkValid("SyscallConn.Control");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = c.file.file.pfd.RawControl(f);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err$1 = _r$3;
            runtime.KeepAlive(c.file);
            $s = -1;
            return err$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rawConn.ptr.prototype.Control,
        $c: true,
        $r,
        _r$3,
        c,
        err,
        err$1,
        f,
        $s,
      };
      return $f;
    };
    rawConn.prototype.Control = function (f) {
      return this.$val.Control(f);
    };
    rawConn.ptr.prototype.Read = function (f) {
      var { _r$3, c, err, err$1, f, $s, $r, $c } = $restore(this, { f });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            c = this;
            err = c.file.checkValid("SyscallConn.Read");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = c.file.file.pfd.RawRead(f);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err$1 = _r$3;
            runtime.KeepAlive(c.file);
            $s = -1;
            return err$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rawConn.ptr.prototype.Read,
        $c: true,
        $r,
        _r$3,
        c,
        err,
        err$1,
        f,
        $s,
      };
      return $f;
    };
    rawConn.prototype.Read = function (f) {
      return this.$val.Read(f);
    };
    rawConn.ptr.prototype.Write = function (f) {
      var { _r$3, c, err, err$1, f, $s, $r, $c } = $restore(this, { f });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            c = this;
            err = c.file.checkValid("SyscallConn.Write");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = c.file.file.pfd.RawWrite(f);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err$1 = _r$3;
            runtime.KeepAlive(c.file);
            $s = -1;
            return err$1;
          /* */
        }
        return;
      }
      var $f = {
        $blk: rawConn.ptr.prototype.Write,
        $c: true,
        $r,
        _r$3,
        c,
        err,
        err$1,
        f,
        $s,
      };
      return $f;
    };
    rawConn.prototype.Write = function (f) {
      return this.$val.Write(f);
    };
    newRawConn = function (file$1) {
      var file$1;
      return [new rawConn.ptr(file$1), $ifaceNil];
    };
    init = function () {
      if (false) {
        return;
      }
      $pkg.Args = runtime_args();
    };
    IsPathSeparator = function (c) {
      var c;
      return 47 === c;
    };
    $pkg.IsPathSeparator = IsPathSeparator;
    basename = function (name) {
      var i, name;
      i = (name.length - 1) >> 0;
      while (true) {
        if (!(i > 0 && name.charCodeAt(i) === 47)) {
          break;
        }
        name = $substring(name, 0, i);
        i = (i - 1) >> 0;
      }
      i = (i - 1) >> 0;
      while (true) {
        if (!(i >= 0)) {
          break;
        }
        if (name.charCodeAt(i) === 47) {
          name = $substring(name, (i + 1) >> 0);
          break;
        }
        i = (i - 1) >> 0;
      }
      return name;
    };
    runtime_args = function () {
      return $pkg.Args;
    };
    init$1 = function () {
      var argv, i, process;
      process = $global.process;
      if (!(process === undefined)) {
        argv = process.argv;
        if (!(argv === undefined) && $parseInt(argv.length) >= 1) {
          $pkg.Args = $makeSlice(sliceType, ($parseInt(argv.length) - 1) >> 0);
          i = 0;
          while (true) {
            if (!(i < ($parseInt(argv.length) - 1) >> 0)) {
              break;
            }
            i < 0 || i >= $pkg.Args.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : ($pkg.Args.$array[$pkg.Args.$offset + i] = $internalize(
                  argv[(i + 1) >> 0],
                  $String
                ));
            i = (i + 1) >> 0;
          }
        }
      }
      if ($pkg.Args.$length === 0) {
        $pkg.Args = new sliceType(["?"]);
      }
    };
    File.ptr.prototype.WriteString = function (s) {
      var { $24r, _r$3, _tuple, err, f, n, s, $s, $r, $c } = $restore(this, {
        s,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            _r$3 = f.Write(new sliceType$2($stringToBytes(s)));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            err = _tuple[1];
            $24r = [n, err];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.WriteString,
        $c: true,
        $r,
        $24r,
        _r$3,
        _tuple,
        err,
        f,
        n,
        s,
        $s,
      };
      return $f;
    };
    File.prototype.WriteString = function (s) {
      return this.$val.WriteString(s);
    };
    File.ptr.prototype.Fd = function () {
      var { _r$3, f, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            if (f === ptrType$2.nil) {
              $s = -1;
              return 4294967295;
            }
            /* */ if (f.file.nonblock) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (f.file.nonblock) { */ case 1:
            _r$3 = f.file.pfd.SetBlocking();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _r$3;
          /* } */ case 2:
            $s = -1;
            return f.file.pfd.Sysfd >>> 0;
          /* */
        }
        return;
      }
      var $f = { $blk: File.ptr.prototype.Fd, $c: true, $r, _r$3, f, $s };
      return $f;
    };
    File.prototype.Fd = function () {
      return this.$val.Fd();
    };
    NewFile = function (fd, name) {
      var { $24r, _r$3, _tuple, err, fd, kind, name, nb, $s, $r, $c } =
        $restore(this, { fd, name });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            kind = 0;
            _tuple = unix.IsNonblock(fd >> 0);
            nb = _tuple[0];
            err = _tuple[1];
            if ($interfaceIsEqual(err, $ifaceNil) && nb) {
              kind = 3;
            }
            _r$3 = newFile(fd, name, kind);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: NewFile,
        $c: true,
        $r,
        $24r,
        _r$3,
        _tuple,
        err,
        fd,
        kind,
        name,
        nb,
        $s,
      };
      return $f;
    };
    $pkg.NewFile = NewFile;
    newFile = function (fd, name, kind) {
      var {
        _1,
        _r$3,
        err,
        err$1,
        err$2,
        f,
        fd,
        fdi,
        kind,
        name,
        pollable,
        st,
        typ,
        $s,
        $r,
        $c,
      } = $restore(this, { fd, name, kind });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            fdi = [fdi];
            st = [st];
            fdi[0] = fd >> 0;
            if (fdi[0] < 0) {
              $s = -1;
              return ptrType$2.nil;
            }
            f = new File.ptr(
              new file.ptr(
                new poll.FD.ptr(
                  new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0),
                  fdi[0],
                  new poll.pollDesc.ptr(ptrType$6.nil, false),
                  ptrType$7.nil,
                  0,
                  0,
                  true,
                  true,
                  false
                ),
                name,
                ptrType$8.nil,
                false,
                fdi[0] === 1 || fdi[0] === 2,
                false
              )
            );
            pollable = kind === 1 || kind === 2 || kind === 3;
            /* */ if (kind === 1) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (kind === 1) { */ case 1:
            _1 = "js";
            /* */ if (
              _1 === "darwin" ||
              _1 === "ios" ||
              _1 === "dragonfly" ||
              _1 === "freebsd" ||
              _1 === "netbsd" ||
              _1 === "openbsd"
            ) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_1 === ("darwin") || _1 === ("ios") || _1 === ("dragonfly") || _1 === ("freebsd") || _1 === ("netbsd") || _1 === ("openbsd")) { */ case 4:
            st[0] = new syscall.Stat_t.ptr(
              new $Int64(0, 0),
              new $Uint64(0, 0),
              0,
              0,
              0,
              0,
              new $Int64(0, 0),
              new $Int64(0, 0),
              0,
              0,
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0),
              new $Int64(0, 0)
            );
            _r$3 = ignoringEINTR(
              (function (fdi, st) {
                return function $b() {
                  var { $24r, _r$3, $s, $r, $c } = $restore(this, {});
                  /* */ $s = $s || 0;
                  s: while (true) {
                    switch ($s) {
                      case 0:
                        _r$3 = syscall.Fstat(fdi[0], st[0]);
                        /* */ $s = 1;
                      case 1:
                        if ($c) {
                          $c = false;
                          _r$3 = _r$3.$blk();
                        }
                        if (_r$3 && _r$3.$blk !== undefined) {
                          break s;
                        }
                        $24r = _r$3;
                        $s = 2;
                      case 2:
                        return $24r;
                      /* */
                    }
                    return;
                  }
                  var $f = { $blk: $b, $c: true, $r, $24r, _r$3, $s };
                  return $f;
                };
              })(fdi, st)
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err = _r$3;
            typ = (st[0].Mode & 126976) >>> 0;
            if (
              $interfaceIsEqual(err, $ifaceNil) &&
              (typ === 32768 || typ === 16384)
            ) {
              pollable = false;
            }
            if (false && typ === 4096) {
              pollable = false;
            }
          /* } */ case 5:
          case 3:
          /* } */ case 2:
            err$1 = f.file.pfd.Init("file", pollable);
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
            } else if (pollable) {
              err$2 = syscall.SetNonblock(fdi[0], true);
              if ($interfaceIsEqual(err$2, $ifaceNil)) {
                f.file.nonblock = true;
              }
            }
            runtime.SetFinalizer(
              f.file,
              new funcType($methodExpr(ptrType$9, "close"))
            );
            $s = -1;
            return f;
          /* */
        }
        return;
      }
      var $f = {
        $blk: newFile,
        $c: true,
        $r,
        _1,
        _r$3,
        err,
        err$1,
        err$2,
        f,
        fd,
        fdi,
        kind,
        name,
        pollable,
        st,
        typ,
        $s,
      };
      return $f;
    };
    epipecheck = function (file$1, e) {
      var { e, file$1, $s, $r, $c } = $restore(this, { file$1, e });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            /* */ if (
              $interfaceIsEqual(e, new syscall.Errno(32)) &&
              file$1.file.stdoutOrErr
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ($interfaceIsEqual(e, new syscall.Errno(32)) && file$1.file.stdoutOrErr) { */ case 1:
            $r = sigpipe();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = { $blk: epipecheck, $c: true, $r, e, file$1, $s };
      return $f;
    };
    file.ptr.prototype.close = function () {
      var { _r$3, e, err, file$1, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            file$1 = this;
            if (file$1 === ptrType$9.nil) {
              $s = -1;
              return new syscall.Errno(22);
            }
            if (!(file$1.dirinfo === ptrType$8.nil)) {
              file$1.dirinfo.close();
              file$1.dirinfo = ptrType$8.nil;
            }
            err = $ifaceNil;
            _r$3 = file$1.pfd.Close();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              if ($interfaceIsEqual(e, poll.ErrFileClosing)) {
                e = $pkg.ErrClosed;
              }
              err = new fs.PathError.ptr("close", file$1.name, e);
            }
            runtime.SetFinalizer(file$1, $ifaceNil);
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = {
        $blk: file.ptr.prototype.close,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        file$1,
        $s,
      };
      return $f;
    };
    file.prototype.close = function () {
      return this.$val.close();
    };
    File.ptr.prototype.seek = function (offset, whence) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        err,
        f,
        offset,
        ret,
        whence,
        $s,
        $r,
        $c,
      } = $restore(this, { offset, whence });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            ret = new $Int64(0, 0);
            err = $ifaceNil;
            f = this;
            if (!(f.file.dirinfo === ptrType$8.nil)) {
              f.file.dirinfo.close();
              f.file.dirinfo = ptrType$8.nil;
            }
            _r$3 = f.file.pfd.Seek(offset, whence);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            ret = _tuple[0];
            err = _tuple[1];
            runtime.KeepAlive(f);
            _tmp = ret;
            _tmp$1 = err;
            ret = _tmp;
            err = _tmp$1;
            $s = -1;
            return [ret, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.seek,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        err,
        f,
        offset,
        ret,
        whence,
        $s,
      };
      return $f;
    };
    File.prototype.seek = function (offset, whence) {
      return this.$val.seek(offset, whence);
    };
    unixDirent.ptr.prototype.Name = function () {
      var d;
      d = this;
      return d.name;
    };
    unixDirent.prototype.Name = function () {
      return this.$val.Name();
    };
    unixDirent.ptr.prototype.IsDir = function () {
      var d;
      d = this;
      return new fs.FileMode(d.typ).IsDir();
    };
    unixDirent.prototype.IsDir = function () {
      return this.$val.IsDir();
    };
    unixDirent.ptr.prototype.Type = function () {
      var d;
      d = this;
      return d.typ;
    };
    unixDirent.prototype.Type = function () {
      return this.$val.Type();
    };
    unixDirent.ptr.prototype.Info = function () {
      var { $24r, _r$3, d, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            d = this;
            if (!$interfaceIsEqual(d.info, $ifaceNil)) {
              $s = -1;
              return [d.info, $ifaceNil];
            }
            _r$3 = lstat(d.parent + "/" + d.name);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: unixDirent.ptr.prototype.Info,
        $c: true,
        $r,
        $24r,
        _r$3,
        d,
        $s,
      };
      return $f;
    };
    unixDirent.prototype.Info = function () {
      return this.$val.Info();
    };
    newUnixDirent = function (parent, name, typ) {
      var {
        _r$3,
        _r$4,
        _r$5,
        _tuple,
        err,
        info,
        name,
        parent,
        typ,
        ude,
        $s,
        $r,
        $c,
      } = $restore(this, { parent, name, typ });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            ude = new unixDirent.ptr(parent, name, typ, $ifaceNil);
            if (!(typ === 4294967295) && !testingForceReadDirLstat) {
              $s = -1;
              return [ude, $ifaceNil];
            }
            _r$3 = lstat(parent + "/" + name);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            info = _tuple[0];
            err = _tuple[1];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [$ifaceNil, err];
            }
            _r$4 = info.Mode();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _r$5 = new fs.FileMode(_r$4).Type();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            ude.typ = _r$5;
            ude.info = info;
            $s = -1;
            return [ude, $ifaceNil];
          /* */
        }
        return;
      }
      var $f = {
        $blk: newUnixDirent,
        $c: true,
        $r,
        _r$3,
        _r$4,
        _r$5,
        _tuple,
        err,
        info,
        name,
        parent,
        typ,
        ude,
        $s,
      };
      return $f;
    };
    sigpipe = function () {
      $throwRuntimeError("native function not implemented: os.sigpipe");
    };
    File.ptr.prototype.Close = function () {
      var { $24r, _r$3, f, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            if (f === ptrType$2.nil) {
              $s = -1;
              return $pkg.ErrInvalid;
            }
            _r$3 = f.file.close();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Close,
        $c: true,
        $r,
        $24r,
        _r$3,
        f,
        $s,
      };
      return $f;
    };
    File.prototype.Close = function () {
      return this.$val.Close();
    };
    File.ptr.prototype.read = function (b) {
      var { _r$3, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r, $c } = $restore(
        this,
        { b }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            _r$3 = f.file.pfd.Read(b);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            err = _tuple[1];
            runtime.KeepAlive(f);
            _tmp = n;
            _tmp$1 = err;
            n = _tmp;
            err = _tmp$1;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.read,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        b,
        err,
        f,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.read = function (b) {
      return this.$val.read(b);
    };
    File.ptr.prototype.pread = function (b, off) {
      var { _r$3, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r, $c } =
        $restore(this, { b, off });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            _r$3 = f.file.pfd.Pread(b, off);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            err = _tuple[1];
            runtime.KeepAlive(f);
            _tmp = n;
            _tmp$1 = err;
            n = _tmp;
            err = _tmp$1;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.pread,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        b,
        err,
        f,
        n,
        off,
        $s,
      };
      return $f;
    };
    File.prototype.pread = function (b, off) {
      return this.$val.pread(b, off);
    };
    File.ptr.prototype.write = function (b) {
      var { _r$3, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r, $c } = $restore(
        this,
        { b }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            _r$3 = f.file.pfd.Write(b);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            err = _tuple[1];
            runtime.KeepAlive(f);
            _tmp = n;
            _tmp$1 = err;
            n = _tmp;
            err = _tmp$1;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.write,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        b,
        err,
        f,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.write = function (b) {
      return this.$val.write(b);
    };
    File.ptr.prototype.pwrite = function (b, off) {
      var { _r$3, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r, $c } =
        $restore(this, { b, off });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            _r$3 = f.file.pfd.Pwrite(b, off);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            err = _tuple[1];
            runtime.KeepAlive(f);
            _tmp = n;
            _tmp$1 = err;
            n = _tmp;
            err = _tmp$1;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.pwrite,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tuple,
        b,
        err,
        f,
        n,
        off,
        $s,
      };
      return $f;
    };
    File.prototype.pwrite = function (b, off) {
      return this.$val.pwrite(b, off);
    };
    syscallMode = function (i) {
      var i, o;
      o = 0;
      o = (o | (new fs.FileMode(i).Perm() >>> 0)) >>> 0;
      if (!((i & 8388608) >>> 0 === 0)) {
        o = (o | 2048) >>> 0;
      }
      if (!((i & 4194304) >>> 0 === 0)) {
        o = (o | 1024) >>> 0;
      }
      if (!((i & 1048576) >>> 0 === 0)) {
        o = (o | 512) >>> 0;
      }
      return o;
    };
    File.ptr.prototype.chmod = function (mode) {
      var { _r$3, e, err, f, mode, $s, $r, $c } = $restore(this, { mode });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("chmod");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.Fchmod(syscallMode(mode));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              $s = -1;
              return f.wrapErr("chmod", e);
            }
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.chmod,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        f,
        mode,
        $s,
      };
      return $f;
    };
    File.prototype.chmod = function (mode) {
      return this.$val.chmod(mode);
    };
    File.ptr.prototype.Chown = function (uid, gid) {
      var { _r$3, e, err, f, gid, uid, $s, $r, $c } = $restore(this, {
        uid,
        gid,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("chown");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.Fchown(uid, gid);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              $s = -1;
              return f.wrapErr("chown", e);
            }
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Chown,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        f,
        gid,
        uid,
        $s,
      };
      return $f;
    };
    File.prototype.Chown = function (uid, gid) {
      return this.$val.Chown(uid, gid);
    };
    File.ptr.prototype.Truncate = function (size) {
      var { _r$3, e, err, f, size, $s, $r, $c } = $restore(this, { size });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("truncate");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.Ftruncate(size);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              $s = -1;
              return f.wrapErr("truncate", e);
            }
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Truncate,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        f,
        size,
        $s,
      };
      return $f;
    };
    File.prototype.Truncate = function (size) {
      return this.$val.Truncate(size);
    };
    File.ptr.prototype.Sync = function () {
      var { _r$3, e, err, f, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("sync");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.Fsync();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              $s = -1;
              return f.wrapErr("sync", e);
            }
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Sync,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        f,
        $s,
      };
      return $f;
    };
    File.prototype.Sync = function () {
      return this.$val.Sync();
    };
    File.ptr.prototype.Chdir = function () {
      var { _r$3, e, err, f, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("chdir");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.Fchdir();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            e = _r$3;
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              $s = -1;
              return f.wrapErr("chdir", e);
            }
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Chdir,
        $c: true,
        $r,
        _r$3,
        e,
        err,
        f,
        $s,
      };
      return $f;
    };
    File.prototype.Chdir = function () {
      return this.$val.Chdir();
    };
    File.ptr.prototype.setDeadline = function (t) {
      var { $24r, _r$3, err, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("SetDeadline");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.SetDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.setDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        err,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.setDeadline = function (t) {
      return this.$val.setDeadline(t);
    };
    File.ptr.prototype.setReadDeadline = function (t) {
      var { $24r, _r$3, err, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("SetReadDeadline");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.SetReadDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.setReadDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        err,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.setReadDeadline = function (t) {
      return this.$val.setReadDeadline(t);
    };
    File.ptr.prototype.setWriteDeadline = function (t) {
      var { $24r, _r$3, err, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            err = f.checkValid("SetWriteDeadline");
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            _r$3 = f.file.pfd.SetWriteDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.setWriteDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        err,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.setWriteDeadline = function (t) {
      return this.$val.setWriteDeadline(t);
    };
    File.ptr.prototype.checkValid = function (op) {
      var f, op;
      f = this;
      if (f === ptrType$2.nil) {
        return $pkg.ErrInvalid;
      }
      return $ifaceNil;
    };
    File.prototype.checkValid = function (op) {
      return this.$val.checkValid(op);
    };
    ignoringEINTR = function (fn) {
      var { _r$3, err, fn, $s, $r, $c } = $restore(this, { fn });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
          /* while (true) { */ case 1:
            _r$3 = fn();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            err = _r$3;
            if (!$interfaceIsEqual(err, new syscall.Errno(4))) {
              $s = -1;
              return err;
            }
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = { $blk: ignoringEINTR, $c: true, $r, _r$3, err, fn, $s };
      return $f;
    };
    File.ptr.prototype.Name = function () {
      var f;
      f = this;
      return f.file.name;
    };
    File.prototype.Name = function () {
      return this.$val.Name();
    };
    LinkError.ptr.prototype.Error = function () {
      var { $24r, _r$3, e, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _r$3 = e.Err.Error();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = e.Op + " " + e.Old + " " + e.New + ": " + _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: LinkError.ptr.prototype.Error,
        $c: true,
        $r,
        $24r,
        _r$3,
        e,
        $s,
      };
      return $f;
    };
    LinkError.prototype.Error = function () {
      return this.$val.Error();
    };
    LinkError.ptr.prototype.Unwrap = function () {
      var e;
      e = this;
      return e.Err;
    };
    LinkError.prototype.Unwrap = function () {
      return this.$val.Unwrap();
    };
    File.ptr.prototype.Read = function (b) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        n,
        $s,
        $r,
        $c,
      } = $restore(this, { b });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("read");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = 0;
              _tmp$1 = err$1;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            _r$3 = f.read(b);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            e = _tuple[1];
            _tmp$2 = n;
            _tmp$3 = f.wrapErr("read", e);
            n = _tmp$2;
            err = _tmp$3;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Read,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.Read = function (b) {
      return this.$val.Read(b);
    };
    File.ptr.prototype.ReadAt = function (b, off) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        m,
        n,
        off,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { b, off });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("read");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = 0;
              _tmp$1 = err$1;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            if (off.$high < 0 || (off.$high === 0 && off.$low < 0)) {
              _tmp$2 = 0;
              _tmp$3 = new fs.PathError.ptr(
                "readat",
                f.file.name,
                errors.New("negative offset")
              );
              n = _tmp$2;
              err = _tmp$3;
              $s = -1;
              return [n, err];
            }
          /* while (true) { */ case 1:
            /* if (!(b.$length > 0)) { break; } */ if (!(b.$length > 0)) {
              $s = 2;
              continue;
            }
            _r$3 = f.pread(b, off);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            m = _tuple[0];
            e = _tuple[1];
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              err = f.wrapErr("read", e);
              /* break; */ $s = 2;
              continue;
            }
            n = (n + m) >> 0;
            b = $subslice(b, m);
            off =
              ((x = new $Int64(0, m)),
              new $Int64(off.$high + x.$high, off.$low + x.$low));
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.ReadAt,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        m,
        n,
        off,
        x,
        $s,
      };
      return $f;
    };
    File.prototype.ReadAt = function (b, off) {
      return this.$val.ReadAt(b, off);
    };
    File.ptr.prototype.ReadFrom = function (r) {
      var {
        $24r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        _tuple$1,
        e,
        err,
        err$1,
        f,
        handled,
        n,
        r,
        $s,
        $r,
        $c,
      } = $restore(this, { r });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = new $Int64(0, 0);
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("write");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = new $Int64(0, 0);
              _tmp$1 = err$1;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            _tuple = f.readFrom(r);
            n = _tuple[0];
            handled = _tuple[1];
            e = _tuple[2];
            /* */ if (!handled) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!handled) { */ case 1:
            _r$3 = genericReadFrom(f, r);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r$3;
            n = _tuple$1[0];
            err = _tuple$1[1];
            $24r = [n, err];
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            _tmp$2 = n;
            _tmp$3 = f.wrapErr("write", e);
            n = _tmp$2;
            err = _tmp$3;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.ReadFrom,
        $c: true,
        $r,
        $24r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        _tuple$1,
        e,
        err,
        err$1,
        f,
        handled,
        n,
        r,
        $s,
      };
      return $f;
    };
    File.prototype.ReadFrom = function (r) {
      return this.$val.ReadFrom(r);
    };
    genericReadFrom = function (f, r) {
      var { $24r, _r$3, f, r, x, $s, $r, $c } = $restore(this, { f, r });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r$3 = io.Copy(
              ((x = new onlyWriter.ptr(f)), new x.constructor.elem(x)),
              r
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: genericReadFrom, $c: true, $r, $24r, _r$3, f, r, x, $s };
      return $f;
    };
    File.ptr.prototype.Write = function (b) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        n,
        $s,
        $r,
        $c,
      } = $restore(this, { b });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("write");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = 0;
              _tmp$1 = err$1;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            _r$3 = f.write(b);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            n = _tuple[0];
            e = _tuple[1];
            if (n < 0) {
              n = 0;
            }
            if (!(n === b.$length)) {
              err = io.ErrShortWrite;
            }
            $r = epipecheck(f, e);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              err = f.wrapErr("write", e);
            }
            _tmp$2 = n;
            _tmp$3 = err;
            n = _tmp$2;
            err = _tmp$3;
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Write,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.Write = function (b) {
      return this.$val.Write(b);
    };
    File.ptr.prototype.WriteAt = function (b, off) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        m,
        n,
        off,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { b, off });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("write");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = 0;
              _tmp$1 = err$1;
              n = _tmp;
              err = _tmp$1;
              $s = -1;
              return [n, err];
            }
            if (f.file.appendMode) {
              _tmp$2 = 0;
              _tmp$3 = errWriteAtInAppendMode;
              n = _tmp$2;
              err = _tmp$3;
              $s = -1;
              return [n, err];
            }
            if (off.$high < 0 || (off.$high === 0 && off.$low < 0)) {
              _tmp$4 = 0;
              _tmp$5 = new fs.PathError.ptr(
                "writeat",
                f.file.name,
                errors.New("negative offset")
              );
              n = _tmp$4;
              err = _tmp$5;
              $s = -1;
              return [n, err];
            }
          /* while (true) { */ case 1:
            /* if (!(b.$length > 0)) { break; } */ if (!(b.$length > 0)) {
              $s = 2;
              continue;
            }
            _r$3 = f.pwrite(b, off);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            m = _tuple[0];
            e = _tuple[1];
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              err = f.wrapErr("write", e);
              /* break; */ $s = 2;
              continue;
            }
            n = (n + m) >> 0;
            b = $subslice(b, m);
            off =
              ((x = new $Int64(0, m)),
              new $Int64(off.$high + x.$high, off.$low + x.$low));
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.WriteAt,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        b,
        e,
        err,
        err$1,
        f,
        m,
        n,
        off,
        x,
        $s,
      };
      return $f;
    };
    File.prototype.WriteAt = function (b, off) {
      return this.$val.WriteAt(b, off);
    };
    File.ptr.prototype.Seek = function (offset, whence) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        e,
        err,
        err$1,
        f,
        offset,
        r,
        ret,
        whence,
        $s,
        $r,
        $c,
      } = $restore(this, { offset, whence });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            ret = new $Int64(0, 0);
            err = $ifaceNil;
            f = this;
            err$1 = f.checkValid("seek");
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp = new $Int64(0, 0);
              _tmp$1 = err$1;
              ret = _tmp;
              err = _tmp$1;
              $s = -1;
              return [ret, err];
            }
            _r$3 = f.seek(offset, whence);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            r = _tuple[0];
            e = _tuple[1];
            if (
              $interfaceIsEqual(e, $ifaceNil) &&
              !(f.file.dirinfo === ptrType$8.nil) &&
              !(r.$high === 0 && r.$low === 0)
            ) {
              e = new syscall.Errno(21);
            }
            if (!$interfaceIsEqual(e, $ifaceNil)) {
              _tmp$2 = new $Int64(0, 0);
              _tmp$3 = f.wrapErr("seek", e);
              ret = _tmp$2;
              err = _tmp$3;
              $s = -1;
              return [ret, err];
            }
            _tmp$4 = r;
            _tmp$5 = $ifaceNil;
            ret = _tmp$4;
            err = _tmp$5;
            $s = -1;
            return [ret, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Seek,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        e,
        err,
        err$1,
        f,
        offset,
        r,
        ret,
        whence,
        $s,
      };
      return $f;
    };
    File.prototype.Seek = function (offset, whence) {
      return this.$val.Seek(offset, whence);
    };
    File.ptr.prototype.wrapErr = function (op, err) {
      var err, f, op;
      f = this;
      if ($interfaceIsEqual(err, $ifaceNil) || $interfaceIsEqual(err, io.EOF)) {
        return err;
      }
      if ($interfaceIsEqual(err, poll.ErrFileClosing)) {
        err = $pkg.ErrClosed;
      }
      return new fs.PathError.ptr(op, f.file.name, err);
    };
    File.prototype.wrapErr = function (op, err) {
      return this.$val.wrapErr(op, err);
    };
    File.ptr.prototype.Chmod = function (mode) {
      var { $24r, _r$3, f, mode, $s, $r, $c } = $restore(this, { mode });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            _r$3 = f.chmod(mode);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Chmod,
        $c: true,
        $r,
        $24r,
        _r$3,
        f,
        mode,
        $s,
      };
      return $f;
    };
    File.prototype.Chmod = function (mode) {
      return this.$val.Chmod(mode);
    };
    File.ptr.prototype.SetDeadline = function (t) {
      var { $24r, _r$3, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            _r$3 = f.setDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.SetDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.SetDeadline = function (t) {
      return this.$val.SetDeadline(t);
    };
    File.ptr.prototype.SetReadDeadline = function (t) {
      var { $24r, _r$3, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            _r$3 = f.setReadDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.SetReadDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.SetReadDeadline = function (t) {
      return this.$val.SetReadDeadline(t);
    };
    File.ptr.prototype.SetWriteDeadline = function (t) {
      var { $24r, _r$3, f, t, $s, $r, $c } = $restore(this, { t });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            _r$3 = f.setWriteDeadline($clone(t, time.Time));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.SetWriteDeadline,
        $c: true,
        $r,
        $24r,
        _r$3,
        f,
        t,
        $s,
      };
      return $f;
    };
    File.prototype.SetWriteDeadline = function (t) {
      return this.$val.SetWriteDeadline(t);
    };
    File.ptr.prototype.SyscallConn = function () {
      var _returncast, err, f;
      f = this;
      err = f.checkValid("SyscallConn");
      if (!$interfaceIsEqual(err, $ifaceNil)) {
        return [$ifaceNil, err];
      }
      _returncast = newRawConn(f);
      return [_returncast[0], _returncast[1]];
    };
    File.prototype.SyscallConn = function () {
      return this.$val.SyscallConn();
    };
    errNoDeadline = function () {
      return poll.ErrNoDeadline;
    };
    errDeadlineExceeded = function () {
      return poll.ErrDeadlineExceeded;
    };
    SyscallError.ptr.prototype.Error = function () {
      var { $24r, _r$3, e, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _r$3 = e.Err.Error();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $24r = e.Syscall + ": " + _r$3;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: SyscallError.ptr.prototype.Error,
        $c: true,
        $r,
        $24r,
        _r$3,
        e,
        $s,
      };
      return $f;
    };
    SyscallError.prototype.Error = function () {
      return this.$val.Error();
    };
    SyscallError.ptr.prototype.Unwrap = function () {
      var e;
      e = this;
      return e.Err;
    };
    SyscallError.prototype.Unwrap = function () {
      return this.$val.Unwrap();
    };
    SyscallError.ptr.prototype.Timeout = function () {
      var { $24r, _r$3, _tuple, _v, e, ok, t, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            e = this;
            _tuple = $assertType(e.Err, timeout, true);
            t = _tuple[0];
            ok = _tuple[1];
            if (!ok) {
              _v = false;
              $s = 1;
              continue s;
            }
            _r$3 = t.Timeout();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _v = _r$3;
          case 1:
            $24r = _v;
            $s = 3;
          case 3:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: SyscallError.ptr.prototype.Timeout,
        $c: true,
        $r,
        $24r,
        _r$3,
        _tuple,
        _v,
        e,
        ok,
        t,
        $s,
      };
      return $f;
    };
    SyscallError.prototype.Timeout = function () {
      return this.$val.Timeout();
    };
    IsNotExist = function (err) {
      var err;
      return underlyingErrorIs(err, $pkg.ErrNotExist);
    };
    $pkg.IsNotExist = IsNotExist;
    underlyingErrorIs = function (err, target) {
      var _tuple, e, err, ok, target;
      err = underlyingError(err);
      if ($interfaceIsEqual(err, target)) {
        return true;
      }
      _tuple = $assertType(err, syscall.Errno, true);
      e = _tuple[0];
      ok = _tuple[1];
      return ok && new syscall.Errno(e).Is(target);
    };
    underlyingError = function (err) {
      var _ref, err, err$1, err$2, err$3;
      _ref = err;
      if ($assertType(_ref, ptrType$5, true)[1]) {
        err$1 = _ref.$val;
        return err$1.Err;
      } else if ($assertType(_ref, ptrType$17, true)[1]) {
        err$2 = _ref.$val;
        return err$2.Err;
      } else if ($assertType(_ref, ptrType$18, true)[1]) {
        err$3 = _ref.$val;
        return err$3.Err;
      }
      return err;
    };
    direntIno = function (buf) {
      var buf;
      return [new $Uint64(0, 1), true];
    };
    direntReclen = function (buf) {
      var buf;
      return readInt(buf, 0, 2);
    };
    direntNamlen = function (buf) {
      var _tuple, buf, ok, reclen;
      _tuple = direntReclen(buf);
      reclen = _tuple[0];
      ok = _tuple[1];
      if (!ok) {
        return [new $Uint64(0, 0), false];
      }
      return [new $Uint64(reclen.$high - 0, reclen.$low - 2), true];
    };
    direntType = function (buf) {
      var buf;
      return 4294967295;
    };
    dirInfo.ptr.prototype.close = function () {
      var d;
      d = this;
      if (!(d.buf === ptrType.nil)) {
        dirBufPool.Put(d.buf);
        d.buf = ptrType.nil;
      }
    };
    dirInfo.prototype.close = function () {
      return this.$val.close();
    };
    File.ptr.prototype.readdir = function (n, mode) {
      var {
        _i,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _ref,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        buf,
        c,
        d,
        de,
        dirents,
        err,
        err$1,
        err$2,
        errno,
        f,
        i,
        info,
        infos,
        ino,
        mode,
        n,
        name,
        names,
        namlen,
        ok,
        rec,
        reclen,
        x,
        x$1,
        x$2,
        $s,
        $r,
        $c,
      } = $restore(this, { n, mode });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            names = sliceType.nil;
            dirents = sliceType$7.nil;
            infos = sliceType$8.nil;
            err = $ifaceNil;
            f = this;
            /* */ if (f.file.dirinfo === ptrType$8.nil) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (f.file.dirinfo === ptrType$8.nil) { */ case 1:
            f.file.dirinfo = new dirInfo.ptr(ptrType.nil, 0, 0);
            _r$3 = dirBufPool.Get();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            f.file.dirinfo.buf = $assertType(_r$3, ptrType);
          /* } */ case 2:
            d = f.file.dirinfo;
            if (n === 0) {
              n = -1;
            }
          /* while (true) { */ case 4:
            /* if (!(!((n === 0)))) { break; } */ if (!!(n === 0)) {
              $s = 5;
              continue;
            }
            /* */ if (d.bufp >= d.nbuf) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (d.bufp >= d.nbuf) { */ case 6:
            d.bufp = 0;
            errno = $ifaceNil;
            _r$4 = f.file.pfd.ReadDirent(d.buf.$get());
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            _tuple = _r$4;
            d.nbuf = _tuple[0];
            errno = _tuple[1];
            runtime.KeepAlive(f);
            if (!$interfaceIsEqual(errno, $ifaceNil)) {
              _tmp = names;
              _tmp$1 = dirents;
              _tmp$2 = infos;
              _tmp$3 = new fs.PathError.ptr("readdirent", f.file.name, errno);
              names = _tmp;
              dirents = _tmp$1;
              infos = _tmp$2;
              err = _tmp$3;
              $s = -1;
              return [names, dirents, infos, err];
            }
            if (d.nbuf <= 0) {
              /* break; */ $s = 5;
              continue;
            }
          /* } */ case 7:
            buf = $subslice(d.buf.$get(), d.bufp, d.nbuf);
            _tuple$1 = direntReclen(buf);
            reclen = _tuple$1[0];
            ok = _tuple$1[1];
            if (
              !ok ||
              ((x = new $Uint64(0, buf.$length)),
              reclen.$high > x.$high ||
                (reclen.$high === x.$high && reclen.$low > x.$low))
            ) {
              /* break; */ $s = 5;
              continue;
            }
            rec = $subslice(buf, 0, $flatten64(reclen));
            d.bufp = (d.bufp + (reclen.$low >> 0)) >> 0;
            _tuple$2 = direntIno(rec);
            ino = _tuple$2[0];
            ok = _tuple$2[1];
            if (!ok) {
              /* break; */ $s = 5;
              continue;
            }
            if (ino.$high === 0 && ino.$low === 0) {
              /* continue; */ $s = 4;
              continue;
            }
            _tuple$3 = direntNamlen(rec);
            namlen = _tuple$3[0];
            ok = _tuple$3[1];
            if (
              !ok ||
              ((x$1 = new $Uint64(0 + namlen.$high, 2 + namlen.$low)),
              (x$2 = new $Uint64(0, rec.$length)),
              x$1.$high > x$2.$high ||
                (x$1.$high === x$2.$high && x$1.$low > x$2.$low))
            ) {
              /* break; */ $s = 5;
              continue;
            }
            name = $subslice(
              rec,
              2,
              $flatten64(new $Uint64(0 + namlen.$high, 2 + namlen.$low))
            );
            _ref = name;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              i = _i;
              c =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              if (c === 0) {
                name = $subslice(name, 0, i);
                break;
              }
              _i++;
            }
            if ($bytesToString(name) === "." || $bytesToString(name) === "..") {
              /* continue; */ $s = 4;
              continue;
            }
            if (n > 0) {
              n = (n - 1) >> 0;
            }
            /* */ if (mode === 0) {
              $s = 9;
              continue;
            }
            /* */ if (mode === 1) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (mode === 0) { */ case 9:
            names = $append(names, $bytesToString(name));
            $s = 12;
            continue;
          /* } else if (mode === 1) { */ case 10:
            _r$5 = newUnixDirent(
              f.file.name,
              $bytesToString(name),
              direntType(rec)
            );
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            _tuple$4 = _r$5;
            de = _tuple$4[0];
            err$1 = _tuple$4[1];
            if (IsNotExist(err$1)) {
              /* continue; */ $s = 4;
              continue;
            }
            if (!$interfaceIsEqual(err$1, $ifaceNil)) {
              _tmp$4 = sliceType.nil;
              _tmp$5 = dirents;
              _tmp$6 = sliceType$8.nil;
              _tmp$7 = err$1;
              names = _tmp$4;
              dirents = _tmp$5;
              infos = _tmp$6;
              err = _tmp$7;
              $s = -1;
              return [names, dirents, infos, err];
            }
            dirents = $append(dirents, de);
            $s = 12;
            continue;
          /* } else { */ case 11:
            _r$6 = lstat(f.file.name + "/" + $bytesToString(name));
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            _tuple$5 = _r$6;
            info = _tuple$5[0];
            err$2 = _tuple$5[1];
            if (IsNotExist(err$2)) {
              /* continue; */ $s = 4;
              continue;
            }
            if (!$interfaceIsEqual(err$2, $ifaceNil)) {
              _tmp$8 = sliceType.nil;
              _tmp$9 = sliceType$7.nil;
              _tmp$10 = infos;
              _tmp$11 = err$2;
              names = _tmp$8;
              dirents = _tmp$9;
              infos = _tmp$10;
              err = _tmp$11;
              $s = -1;
              return [names, dirents, infos, err];
            }
            infos = $append(infos, info);
          /* } */ case 12:
            $s = 4;
            continue;
          case 5:
            if (
              n > 0 &&
              (((names.$length + dirents.$length) >> 0) + infos.$length) >>
                0 ===
                0
            ) {
              _tmp$12 = sliceType.nil;
              _tmp$13 = sliceType$7.nil;
              _tmp$14 = sliceType$8.nil;
              _tmp$15 = io.EOF;
              names = _tmp$12;
              dirents = _tmp$13;
              infos = _tmp$14;
              err = _tmp$15;
              $s = -1;
              return [names, dirents, infos, err];
            }
            _tmp$16 = names;
            _tmp$17 = dirents;
            _tmp$18 = infos;
            _tmp$19 = $ifaceNil;
            names = _tmp$16;
            dirents = _tmp$17;
            infos = _tmp$18;
            err = _tmp$19;
            $s = -1;
            return [names, dirents, infos, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.readdir,
        $c: true,
        $r,
        _i,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _ref,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$14,
        _tmp$15,
        _tmp$16,
        _tmp$17,
        _tmp$18,
        _tmp$19,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        buf,
        c,
        d,
        de,
        dirents,
        err,
        err$1,
        err$2,
        errno,
        f,
        i,
        info,
        infos,
        ino,
        mode,
        n,
        name,
        names,
        namlen,
        ok,
        rec,
        reclen,
        x,
        x$1,
        x$2,
        $s,
      };
      return $f;
    };
    File.prototype.readdir = function (n, mode) {
      return this.$val.readdir(n, mode);
    };
    readInt = function (b, off, size) {
      var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, off, ok, size, u;
      u = new $Uint64(0, 0);
      ok = false;
      if (b.$length < ((off + size) >>> 0) >> 0) {
        _tmp = new $Uint64(0, 0);
        _tmp$1 = false;
        u = _tmp;
        ok = _tmp$1;
        return [u, ok];
      }
      if (false) {
        _tmp$2 = readIntBE($subslice(b, off), size);
        _tmp$3 = true;
        u = _tmp$2;
        ok = _tmp$3;
        return [u, ok];
      }
      _tmp$4 = readIntLE($subslice(b, off), size);
      _tmp$5 = true;
      u = _tmp$4;
      ok = _tmp$5;
      return [u, ok];
    };
    readIntBE = function (b, size) {
      var _1,
        b,
        size,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$15,
        x$16,
        x$17,
        x$18,
        x$19,
        x$2,
        x$20,
        x$21,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      _1 = size;
      if (_1 === 1) {
        return new $Uint64(
          0,
          0 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 0]
        );
      } else if (_1 === 2) {
        $unused(
          1 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 1]
        );
        return (
          (x = new $Uint64(
            0,
            1 >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + 1]
          )),
          (x$1 = $shiftLeft64(
            new $Uint64(
              0,
              0 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 0]
            ),
            8
          )),
          new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0)
        );
      } else if (_1 === 4) {
        $unused(
          3 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 3]
        );
        return (
          (x$2 =
            ((x$3 =
              ((x$4 = new $Uint64(
                0,
                3 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 3]
              )),
              (x$5 = $shiftLeft64(
                new $Uint64(
                  0,
                  2 >= b.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : b.$array[b.$offset + 2]
                ),
                8
              )),
              new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0))),
            (x$6 = $shiftLeft64(
              new $Uint64(
                0,
                1 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 1]
              ),
              16
            )),
            new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0))),
          (x$7 = $shiftLeft64(
            new $Uint64(
              0,
              0 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 0]
            ),
            24
          )),
          new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0)
        );
      } else if (_1 === 8) {
        $unused(
          7 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 7]
        );
        return (
          (x$8 =
            ((x$9 =
              ((x$10 =
                ((x$11 =
                  ((x$12 =
                    ((x$13 =
                      ((x$14 = new $Uint64(
                        0,
                        7 >= b.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : b.$array[b.$offset + 7]
                      )),
                      (x$15 = $shiftLeft64(
                        new $Uint64(
                          0,
                          6 >= b.$length
                            ? ($throwRuntimeError("index out of range"),
                              undefined)
                            : b.$array[b.$offset + 6]
                        ),
                        8
                      )),
                      new $Uint64(
                        x$14.$high | x$15.$high,
                        (x$14.$low | x$15.$low) >>> 0
                      ))),
                    (x$16 = $shiftLeft64(
                      new $Uint64(
                        0,
                        5 >= b.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : b.$array[b.$offset + 5]
                      ),
                      16
                    )),
                    new $Uint64(
                      x$13.$high | x$16.$high,
                      (x$13.$low | x$16.$low) >>> 0
                    ))),
                  (x$17 = $shiftLeft64(
                    new $Uint64(
                      0,
                      4 >= b.$length
                        ? ($throwRuntimeError("index out of range"), undefined)
                        : b.$array[b.$offset + 4]
                    ),
                    24
                  )),
                  new $Uint64(
                    x$12.$high | x$17.$high,
                    (x$12.$low | x$17.$low) >>> 0
                  ))),
                (x$18 = $shiftLeft64(
                  new $Uint64(
                    0,
                    3 >= b.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : b.$array[b.$offset + 3]
                  ),
                  32
                )),
                new $Uint64(
                  x$11.$high | x$18.$high,
                  (x$11.$low | x$18.$low) >>> 0
                ))),
              (x$19 = $shiftLeft64(
                new $Uint64(
                  0,
                  2 >= b.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : b.$array[b.$offset + 2]
                ),
                40
              )),
              new $Uint64(
                x$10.$high | x$19.$high,
                (x$10.$low | x$19.$low) >>> 0
              ))),
            (x$20 = $shiftLeft64(
              new $Uint64(
                0,
                1 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 1]
              ),
              48
            )),
            new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0))),
          (x$21 = $shiftLeft64(
            new $Uint64(
              0,
              0 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 0]
            ),
            56
          )),
          new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0)
        );
      } else {
        $panic(new $String("syscall: readInt with unsupported size"));
      }
    };
    readIntLE = function (b, size) {
      var _1,
        b,
        size,
        x,
        x$1,
        x$10,
        x$11,
        x$12,
        x$13,
        x$14,
        x$15,
        x$16,
        x$17,
        x$18,
        x$19,
        x$2,
        x$20,
        x$21,
        x$3,
        x$4,
        x$5,
        x$6,
        x$7,
        x$8,
        x$9;
      _1 = size;
      if (_1 === 1) {
        return new $Uint64(
          0,
          0 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 0]
        );
      } else if (_1 === 2) {
        $unused(
          1 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 1]
        );
        return (
          (x = new $Uint64(
            0,
            0 >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + 0]
          )),
          (x$1 = $shiftLeft64(
            new $Uint64(
              0,
              1 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 1]
            ),
            8
          )),
          new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0)
        );
      } else if (_1 === 4) {
        $unused(
          3 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 3]
        );
        return (
          (x$2 =
            ((x$3 =
              ((x$4 = new $Uint64(
                0,
                0 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 0]
              )),
              (x$5 = $shiftLeft64(
                new $Uint64(
                  0,
                  1 >= b.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : b.$array[b.$offset + 1]
                ),
                8
              )),
              new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0))),
            (x$6 = $shiftLeft64(
              new $Uint64(
                0,
                2 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 2]
              ),
              16
            )),
            new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0))),
          (x$7 = $shiftLeft64(
            new $Uint64(
              0,
              3 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 3]
            ),
            24
          )),
          new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0)
        );
      } else if (_1 === 8) {
        $unused(
          7 >= b.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : b.$array[b.$offset + 7]
        );
        return (
          (x$8 =
            ((x$9 =
              ((x$10 =
                ((x$11 =
                  ((x$12 =
                    ((x$13 =
                      ((x$14 = new $Uint64(
                        0,
                        0 >= b.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : b.$array[b.$offset + 0]
                      )),
                      (x$15 = $shiftLeft64(
                        new $Uint64(
                          0,
                          1 >= b.$length
                            ? ($throwRuntimeError("index out of range"),
                              undefined)
                            : b.$array[b.$offset + 1]
                        ),
                        8
                      )),
                      new $Uint64(
                        x$14.$high | x$15.$high,
                        (x$14.$low | x$15.$low) >>> 0
                      ))),
                    (x$16 = $shiftLeft64(
                      new $Uint64(
                        0,
                        2 >= b.$length
                          ? ($throwRuntimeError("index out of range"),
                            undefined)
                          : b.$array[b.$offset + 2]
                      ),
                      16
                    )),
                    new $Uint64(
                      x$13.$high | x$16.$high,
                      (x$13.$low | x$16.$low) >>> 0
                    ))),
                  (x$17 = $shiftLeft64(
                    new $Uint64(
                      0,
                      3 >= b.$length
                        ? ($throwRuntimeError("index out of range"), undefined)
                        : b.$array[b.$offset + 3]
                    ),
                    24
                  )),
                  new $Uint64(
                    x$12.$high | x$17.$high,
                    (x$12.$low | x$17.$low) >>> 0
                  ))),
                (x$18 = $shiftLeft64(
                  new $Uint64(
                    0,
                    4 >= b.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : b.$array[b.$offset + 4]
                  ),
                  32
                )),
                new $Uint64(
                  x$11.$high | x$18.$high,
                  (x$11.$low | x$18.$low) >>> 0
                ))),
              (x$19 = $shiftLeft64(
                new $Uint64(
                  0,
                  5 >= b.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : b.$array[b.$offset + 5]
                ),
                40
              )),
              new $Uint64(
                x$10.$high | x$19.$high,
                (x$10.$low | x$19.$low) >>> 0
              ))),
            (x$20 = $shiftLeft64(
              new $Uint64(
                0,
                6 >= b.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : b.$array[b.$offset + 6]
              ),
              48
            )),
            new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0))),
          (x$21 = $shiftLeft64(
            new $Uint64(
              0,
              7 >= b.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : b.$array[b.$offset + 7]
            ),
            56
          )),
          new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0)
        );
      } else {
        $panic(new $String("syscall: readInt with unsupported size"));
      }
    };
    File.ptr.prototype.Readdir = function (n) {
      var { _r$3, _tuple, err, f, infos, n, $s, $r, $c } = $restore(this, {
        n,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            if (f === ptrType$2.nil) {
              $s = -1;
              return [sliceType$8.nil, $pkg.ErrInvalid];
            }
            _r$3 = f.readdir(n, 2);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            infos = _tuple[2];
            err = _tuple[3];
            if (infos === sliceType$8.nil) {
              infos = new sliceType$8([]);
            }
            $s = -1;
            return [infos, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Readdir,
        $c: true,
        $r,
        _r$3,
        _tuple,
        err,
        f,
        infos,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.Readdir = function (n) {
      return this.$val.Readdir(n);
    };
    File.ptr.prototype.Readdirnames = function (n) {
      var {
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        err,
        f,
        n,
        names,
        $s,
        $r,
        $c,
      } = $restore(this, { n });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            names = sliceType.nil;
            err = $ifaceNil;
            f = this;
            if (f === ptrType$2.nil) {
              _tmp = sliceType.nil;
              _tmp$1 = $pkg.ErrInvalid;
              names = _tmp;
              err = _tmp$1;
              $s = -1;
              return [names, err];
            }
            _r$3 = f.readdir(n, 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            names = _tuple[0];
            err = _tuple[3];
            if (names === sliceType.nil) {
              names = new sliceType([]);
            }
            _tmp$2 = names;
            _tmp$3 = err;
            names = _tmp$2;
            err = _tmp$3;
            $s = -1;
            return [names, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Readdirnames,
        $c: true,
        $r,
        _r$3,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tuple,
        err,
        f,
        n,
        names,
        $s,
      };
      return $f;
    };
    File.prototype.Readdirnames = function (n) {
      return this.$val.Readdirnames(n);
    };
    File.ptr.prototype.ReadDir = function (n) {
      var { _r$3, _tuple, dirents, err, f, n, $s, $r, $c } = $restore(this, {
        n,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            if (f === ptrType$2.nil) {
              $s = -1;
              return [sliceType$7.nil, $pkg.ErrInvalid];
            }
            _r$3 = f.readdir(n, 1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _tuple = _r$3;
            dirents = _tuple[1];
            err = _tuple[3];
            if (dirents === sliceType$7.nil) {
              dirents = new sliceType$7([]);
            }
            $s = -1;
            return [dirents, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.ReadDir,
        $c: true,
        $r,
        _r$3,
        _tuple,
        dirents,
        err,
        f,
        n,
        $s,
      };
      return $f;
    };
    File.prototype.ReadDir = function (n) {
      return this.$val.ReadDir(n);
    };
    ptrType$1.methods = [
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Int64], false),
      },
      {
        prop: "Mode",
        name: "Mode",
        pkg: "",
        typ: $funcType([], [fs.FileMode], false),
      },
      {
        prop: "ModTime",
        name: "ModTime",
        pkg: "",
        typ: $funcType([], [time.Time], false),
      },
      {
        prop: "Sys",
        name: "Sys",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "IsDir",
        name: "IsDir",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$2.methods = [
      {
        prop: "Stat",
        name: "Stat",
        pkg: "",
        typ: $funcType([], [fs.FileInfo, $error], false),
      },
      {
        prop: "readFrom",
        name: "readFrom",
        pkg: "os",
        typ: $funcType([io.Reader], [$Int64, $Bool, $error], false),
      },
      {
        prop: "WriteString",
        name: "WriteString",
        pkg: "",
        typ: $funcType([$String], [$Int, $error], false),
      },
      {
        prop: "Fd",
        name: "Fd",
        pkg: "",
        typ: $funcType([], [$Uintptr], false),
      },
      {
        prop: "seek",
        name: "seek",
        pkg: "os",
        typ: $funcType([$Int64, $Int], [$Int64, $error], false),
      },
      {
        prop: "Close",
        name: "Close",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "read",
        name: "read",
        pkg: "os",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "pread",
        name: "pread",
        pkg: "os",
        typ: $funcType([sliceType$2, $Int64], [$Int, $error], false),
      },
      {
        prop: "write",
        name: "write",
        pkg: "os",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "pwrite",
        name: "pwrite",
        pkg: "os",
        typ: $funcType([sliceType$2, $Int64], [$Int, $error], false),
      },
      {
        prop: "chmod",
        name: "chmod",
        pkg: "os",
        typ: $funcType([fs.FileMode], [$error], false),
      },
      {
        prop: "Chown",
        name: "Chown",
        pkg: "",
        typ: $funcType([$Int, $Int], [$error], false),
      },
      {
        prop: "Truncate",
        name: "Truncate",
        pkg: "",
        typ: $funcType([$Int64], [$error], false),
      },
      {
        prop: "Sync",
        name: "Sync",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Chdir",
        name: "Chdir",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "setDeadline",
        name: "setDeadline",
        pkg: "os",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "setReadDeadline",
        name: "setReadDeadline",
        pkg: "os",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "setWriteDeadline",
        name: "setWriteDeadline",
        pkg: "os",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "checkValid",
        name: "checkValid",
        pkg: "os",
        typ: $funcType([$String], [$error], false),
      },
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "ReadAt",
        name: "ReadAt",
        pkg: "",
        typ: $funcType([sliceType$2, $Int64], [$Int, $error], false),
      },
      {
        prop: "ReadFrom",
        name: "ReadFrom",
        pkg: "",
        typ: $funcType([io.Reader], [$Int64, $error], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "WriteAt",
        name: "WriteAt",
        pkg: "",
        typ: $funcType([sliceType$2, $Int64], [$Int, $error], false),
      },
      {
        prop: "Seek",
        name: "Seek",
        pkg: "",
        typ: $funcType([$Int64, $Int], [$Int64, $error], false),
      },
      {
        prop: "wrapErr",
        name: "wrapErr",
        pkg: "os",
        typ: $funcType([$String, $error], [$error], false),
      },
      {
        prop: "Chmod",
        name: "Chmod",
        pkg: "",
        typ: $funcType([fs.FileMode], [$error], false),
      },
      {
        prop: "SetDeadline",
        name: "SetDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "SetReadDeadline",
        name: "SetReadDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "SetWriteDeadline",
        name: "SetWriteDeadline",
        pkg: "",
        typ: $funcType([time.Time], [$error], false),
      },
      {
        prop: "SyscallConn",
        name: "SyscallConn",
        pkg: "",
        typ: $funcType([], [syscall.RawConn, $error], false),
      },
      {
        prop: "readdir",
        name: "readdir",
        pkg: "os",
        typ: $funcType(
          [$Int, readdirMode],
          [sliceType, sliceType$7, sliceType$8, $error],
          false
        ),
      },
      {
        prop: "Readdir",
        name: "Readdir",
        pkg: "",
        typ: $funcType([$Int], [sliceType$8, $error], false),
      },
      {
        prop: "Readdirnames",
        name: "Readdirnames",
        pkg: "",
        typ: $funcType([$Int], [sliceType, $error], false),
      },
      {
        prop: "ReadDir",
        name: "ReadDir",
        pkg: "",
        typ: $funcType([$Int], [sliceType$7, $error], false),
      },
    ];
    ptrType$19.methods = [
      {
        prop: "Control",
        name: "Control",
        pkg: "",
        typ: $funcType([funcType$2], [$error], false),
      },
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([funcType$3], [$error], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([funcType$3], [$error], false),
      },
    ];
    ptrType$9.methods = [
      {
        prop: "close",
        name: "close",
        pkg: "os",
        typ: $funcType([], [$error], false),
      },
    ];
    ptrType$20.methods = [
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "IsDir",
        name: "IsDir",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "Type",
        name: "Type",
        pkg: "",
        typ: $funcType([], [fs.FileMode], false),
      },
      {
        prop: "Info",
        name: "Info",
        pkg: "",
        typ: $funcType([], [fs.FileInfo, $error], false),
      },
    ];
    ptrType$17.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Unwrap",
        name: "Unwrap",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
    ];
    ptrType$18.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Unwrap",
        name: "Unwrap",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType$8.methods = [
      {
        prop: "close",
        name: "close",
        pkg: "os",
        typ: $funcType([], [], false),
      },
    ];
    fileStat.init("os", [
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "size",
        name: "size",
        embedded: false,
        exported: false,
        typ: $Int64,
        tag: "",
      },
      {
        prop: "mode",
        name: "mode",
        embedded: false,
        exported: false,
        typ: fs.FileMode,
        tag: "",
      },
      {
        prop: "modTime",
        name: "modTime",
        embedded: false,
        exported: false,
        typ: time.Time,
        tag: "",
      },
      {
        prop: "sys",
        name: "sys",
        embedded: false,
        exported: false,
        typ: syscall.Stat_t,
        tag: "",
      },
    ]);
    File.init("os", [
      {
        prop: "file",
        name: "file",
        embedded: true,
        exported: false,
        typ: ptrType$9,
        tag: "",
      },
    ]);
    rawConn.init("os", [
      {
        prop: "file",
        name: "file",
        embedded: false,
        exported: false,
        typ: ptrType$2,
        tag: "",
      },
    ]);
    file.init("os", [
      {
        prop: "pfd",
        name: "pfd",
        embedded: false,
        exported: false,
        typ: poll.FD,
        tag: "",
      },
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "dirinfo",
        name: "dirinfo",
        embedded: false,
        exported: false,
        typ: ptrType$8,
        tag: "",
      },
      {
        prop: "nonblock",
        name: "nonblock",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "stdoutOrErr",
        name: "stdoutOrErr",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "appendMode",
        name: "appendMode",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    unixDirent.init("os", [
      {
        prop: "parent",
        name: "parent",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "typ",
        name: "typ",
        embedded: false,
        exported: false,
        typ: fs.FileMode,
        tag: "",
      },
      {
        prop: "info",
        name: "info",
        embedded: false,
        exported: false,
        typ: fs.FileInfo,
        tag: "",
      },
    ]);
    LinkError.init("", [
      {
        prop: "Op",
        name: "Op",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Old",
        name: "Old",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "New",
        name: "New",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Err",
        name: "Err",
        embedded: false,
        exported: true,
        typ: $error,
        tag: "",
      },
    ]);
    onlyWriter.init("", [
      {
        prop: "Writer",
        name: "Writer",
        embedded: true,
        exported: true,
        typ: io.Writer,
        tag: "",
      },
    ]);
    timeout.init([
      {
        prop: "Timeout",
        name: "Timeout",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ]);
    SyscallError.init("", [
      {
        prop: "Syscall",
        name: "Syscall",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Err",
        name: "Err",
        embedded: false,
        exported: true,
        typ: $error,
        tag: "",
      },
    ]);
    dirInfo.init("os", [
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: ptrType,
        tag: "",
      },
      {
        prop: "nbuf",
        name: "nbuf",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "bufp",
        name: "bufp",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = itoa.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = oserror.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = poll.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = execenv.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unix.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = testlog.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unsafeheader.$init();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = fs.$init();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = atomic.$init();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = syscall.$init();
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = time.$init();
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.Args = sliceType.nil;
            testingForceReadDirLstat = false;
            errPatternHasSeparator = errors.New(
              "pattern contains path separator"
            );
            errWriteAtInAppendMode = errors.New(
              "os: invalid use of WriteAt on file opened with O_APPEND"
            );
            lstat = Lstat;
            $pkg.ErrProcessDone = errors.New("os: process already finished");
            $pkg.ErrInvalid = fs.ErrInvalid;
            $pkg.ErrNotExist = fs.ErrNotExist;
            $pkg.ErrClosed = fs.ErrClosed;
            $pkg.ErrNoDeadline = errNoDeadline();
            $pkg.ErrDeadlineExceeded = errDeadlineExceeded();
            dirBufPool = new sync.Pool.ptr(sliceType$1.nil, function () {
              var buf, buf$24ptr;
              buf = $makeSlice(sliceType$2, 8192);
              return (
                buf$24ptr ||
                (buf$24ptr = new ptrType(
                  function () {
                    return buf;
                  },
                  function ($v) {
                    buf = $convertSliceType($v, sliceType$2);
                  }
                ))
              );
            });
            _r = NewFile(0, "/dev/stdin");
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $pkg.Stdin = _r;
            _r$1 = NewFile(1, "/dev/stdout");
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $pkg.Stdout = _r$1;
            _r$2 = NewFile(2, "/dev/stderr");
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $pkg.Stderr = _r$2;
            init();
            init$1();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["fmt"] = (function () {
    var $pkg = {},
      $init,
      errors,
      fmtsort,
      io,
      math,
      os,
      reflect,
      strconv,
      sync,
      utf8,
      scanError,
      ss,
      ssave,
      State,
      Formatter,
      Stringer,
      GoStringer,
      buffer,
      pp,
      fmtFlags,
      fmt,
      wrapError,
      arrayType,
      sliceType,
      sliceType$1,
      ptrType,
      ptrType$1,
      arrayType$1,
      sliceType$2,
      ptrType$4,
      ptrType$24,
      arrayType$3,
      funcType,
      ptrType$26,
      ptrType$27,
      space,
      ssFree,
      complexError,
      boolError,
      ppFree,
      isSpace,
      notSpace,
      indexRune,
      newPrinter,
      Fprintf,
      Printf,
      Sprintf,
      getField,
      tooLarge,
      parsenum,
      intFromArg,
      parseArgNumber,
      Errorf;
    errors = $packages["errors"];
    fmtsort = $packages["internal/fmtsort"];
    io = $packages["io"];
    math = $packages["math"];
    os = $packages["os"];
    reflect = $packages["reflect"];
    strconv = $packages["strconv"];
    sync = $packages["sync"];
    utf8 = $packages["unicode/utf8"];
    scanError = $pkg.scanError = $newType(
      0,
      $kindStruct,
      "fmt.scanError",
      true,
      "fmt",
      false,
      function (err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.err = $ifaceNil;
          return;
        }
        this.err = err_;
      }
    );
    ss = $pkg.ss = $newType(
      0,
      $kindStruct,
      "fmt.ss",
      true,
      "fmt",
      false,
      function (rs_, buf_, count_, atEOF_, ssave_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.rs = $ifaceNil;
          this.buf = buffer.nil;
          this.count = 0;
          this.atEOF = false;
          this.ssave = new ssave.ptr(false, false, false, 0, 0, 0);
          return;
        }
        this.rs = rs_;
        this.buf = buf_;
        this.count = count_;
        this.atEOF = atEOF_;
        this.ssave = ssave_;
      }
    );
    ssave = $pkg.ssave = $newType(
      0,
      $kindStruct,
      "fmt.ssave",
      true,
      "fmt",
      false,
      function (validSave_, nlIsEnd_, nlIsSpace_, argLimit_, limit_, maxWid_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.validSave = false;
          this.nlIsEnd = false;
          this.nlIsSpace = false;
          this.argLimit = 0;
          this.limit = 0;
          this.maxWid = 0;
          return;
        }
        this.validSave = validSave_;
        this.nlIsEnd = nlIsEnd_;
        this.nlIsSpace = nlIsSpace_;
        this.argLimit = argLimit_;
        this.limit = limit_;
        this.maxWid = maxWid_;
      }
    );
    State = $pkg.State = $newType(
      8,
      $kindInterface,
      "fmt.State",
      true,
      "fmt",
      true,
      null
    );
    Formatter = $pkg.Formatter = $newType(
      8,
      $kindInterface,
      "fmt.Formatter",
      true,
      "fmt",
      true,
      null
    );
    Stringer = $pkg.Stringer = $newType(
      8,
      $kindInterface,
      "fmt.Stringer",
      true,
      "fmt",
      true,
      null
    );
    GoStringer = $pkg.GoStringer = $newType(
      8,
      $kindInterface,
      "fmt.GoStringer",
      true,
      "fmt",
      true,
      null
    );
    buffer = $pkg.buffer = $newType(
      12,
      $kindSlice,
      "fmt.buffer",
      true,
      "fmt",
      false,
      null
    );
    pp = $pkg.pp = $newType(
      0,
      $kindStruct,
      "fmt.pp",
      true,
      "fmt",
      false,
      function (
        buf_,
        arg_,
        value_,
        fmt_,
        reordered_,
        goodArgNum_,
        panicking_,
        erroring_,
        wrapErrs_,
        wrappedErr_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.buf = buffer.nil;
          this.arg = $ifaceNil;
          this.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
          this.fmt = new fmt.ptr(
            ptrType$1.nil,
            new fmtFlags.ptr(
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false
            ),
            0,
            0,
            arrayType$1.zero()
          );
          this.reordered = false;
          this.goodArgNum = false;
          this.panicking = false;
          this.erroring = false;
          this.wrapErrs = false;
          this.wrappedErr = $ifaceNil;
          return;
        }
        this.buf = buf_;
        this.arg = arg_;
        this.value = value_;
        this.fmt = fmt_;
        this.reordered = reordered_;
        this.goodArgNum = goodArgNum_;
        this.panicking = panicking_;
        this.erroring = erroring_;
        this.wrapErrs = wrapErrs_;
        this.wrappedErr = wrappedErr_;
      }
    );
    fmtFlags = $pkg.fmtFlags = $newType(
      0,
      $kindStruct,
      "fmt.fmtFlags",
      true,
      "fmt",
      false,
      function (
        widPresent_,
        precPresent_,
        minus_,
        plus_,
        sharp_,
        space_,
        zero_,
        plusV_,
        sharpV_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.widPresent = false;
          this.precPresent = false;
          this.minus = false;
          this.plus = false;
          this.sharp = false;
          this.space = false;
          this.zero = false;
          this.plusV = false;
          this.sharpV = false;
          return;
        }
        this.widPresent = widPresent_;
        this.precPresent = precPresent_;
        this.minus = minus_;
        this.plus = plus_;
        this.sharp = sharp_;
        this.space = space_;
        this.zero = zero_;
        this.plusV = plusV_;
        this.sharpV = sharpV_;
      }
    );
    fmt = $pkg.fmt = $newType(
      0,
      $kindStruct,
      "fmt.fmt",
      true,
      "fmt",
      false,
      function (buf_, fmtFlags_, wid_, prec_, intbuf_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.buf = ptrType$1.nil;
          this.fmtFlags = new fmtFlags.ptr(
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
          );
          this.wid = 0;
          this.prec = 0;
          this.intbuf = arrayType$1.zero();
          return;
        }
        this.buf = buf_;
        this.fmtFlags = fmtFlags_;
        this.wid = wid_;
        this.prec = prec_;
        this.intbuf = intbuf_;
      }
    );
    wrapError = $pkg.wrapError = $newType(
      0,
      $kindStruct,
      "fmt.wrapError",
      true,
      "fmt",
      false,
      function (msg_, err_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.msg = "";
          this.err = $ifaceNil;
          return;
        }
        this.msg = msg_;
        this.err = err_;
      }
    );
    arrayType = $arrayType($Uint16, 2);
    sliceType = $sliceType(arrayType);
    sliceType$1 = $sliceType($emptyInterface);
    ptrType = $ptrType(reflect.rtype);
    ptrType$1 = $ptrType(buffer);
    arrayType$1 = $arrayType($Uint8, 68);
    sliceType$2 = $sliceType($Uint8);
    ptrType$4 = $ptrType(ss);
    ptrType$24 = $ptrType(pp);
    arrayType$3 = $arrayType($Uint8, 6);
    funcType = $funcType([$Int32], [$Bool], false);
    ptrType$26 = $ptrType(fmt);
    ptrType$27 = $ptrType(wrapError);
    ss.ptr.prototype.Read = function (buf) {
      var _tmp, _tmp$1, buf, err, n, s;
      n = 0;
      err = $ifaceNil;
      s = this;
      _tmp = 0;
      _tmp$1 = errors.New(
        "ScanState's Read should not be called. Use ReadRune"
      );
      n = _tmp;
      err = _tmp$1;
      return [n, err];
    };
    ss.prototype.Read = function (buf) {
      return this.$val.Read(buf);
    };
    ss.ptr.prototype.ReadRune = function () {
      var { _r, _tuple, err, r, s, size, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            r = 0;
            size = 0;
            err = $ifaceNil;
            s = this;
            if (s.atEOF || s.count >= s.ssave.argLimit) {
              err = io.EOF;
              $s = -1;
              return [r, size, err];
            }
            _r = s.rs.ReadRune();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            r = _tuple[0];
            size = _tuple[1];
            err = _tuple[2];
            if ($interfaceIsEqual(err, $ifaceNil)) {
              s.count = (s.count + 1) >> 0;
              if (s.ssave.nlIsEnd && r === 10) {
                s.atEOF = true;
              }
            } else if ($interfaceIsEqual(err, io.EOF)) {
              s.atEOF = true;
            }
            $s = -1;
            return [r, size, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: ss.ptr.prototype.ReadRune,
        $c: true,
        $r,
        _r,
        _tuple,
        err,
        r,
        s,
        size,
        $s,
      };
      return $f;
    };
    ss.prototype.ReadRune = function () {
      return this.$val.ReadRune();
    };
    ss.ptr.prototype.Width = function () {
      var _tmp, _tmp$1, _tmp$2, _tmp$3, ok, s, wid;
      wid = 0;
      ok = false;
      s = this;
      if (s.ssave.maxWid === 1073741824) {
        _tmp = 0;
        _tmp$1 = false;
        wid = _tmp;
        ok = _tmp$1;
        return [wid, ok];
      }
      _tmp$2 = s.ssave.maxWid;
      _tmp$3 = true;
      wid = _tmp$2;
      ok = _tmp$3;
      return [wid, ok];
    };
    ss.prototype.Width = function () {
      return this.$val.Width();
    };
    ss.ptr.prototype.getRune = function () {
      var { _r, _tuple, err, r, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            r = 0;
            s = this;
            _r = s.ReadRune();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            r = _tuple[0];
            err = _tuple[2];
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              if ($interfaceIsEqual(err, io.EOF)) {
                r = -1;
                $s = -1;
                return r;
              }
              s.error(err);
            }
            $s = -1;
            return r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: ss.ptr.prototype.getRune,
        $c: true,
        $r,
        _r,
        _tuple,
        err,
        r,
        s,
        $s,
      };
      return $f;
    };
    ss.prototype.getRune = function () {
      return this.$val.getRune();
    };
    ss.ptr.prototype.UnreadRune = function () {
      var { _r, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            _r = s.rs.UnreadRune();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r;
            s.atEOF = false;
            s.count = (s.count - 1) >> 0;
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = { $blk: ss.ptr.prototype.UnreadRune, $c: true, $r, _r, s, $s };
      return $f;
    };
    ss.prototype.UnreadRune = function () {
      return this.$val.UnreadRune();
    };
    ss.ptr.prototype.error = function (err) {
      var err, s, x;
      s = this;
      $panic(((x = new scanError.ptr(err)), new x.constructor.elem(x)));
    };
    ss.prototype.error = function (err) {
      return this.$val.error(err);
    };
    ss.ptr.prototype.errorString = function (err) {
      var err, s, x;
      s = this;
      $panic(
        ((x = new scanError.ptr(errors.New(err))), new x.constructor.elem(x))
      );
    };
    ss.prototype.errorString = function (err) {
      return this.$val.errorString(err);
    };
    ss.ptr.prototype.Token = function (skipSpace, f) {
      var { $24r, _r, err, f, s, skipSpace, tok, $s, $deferred, $r, $c } =
        $restore(this, { skipSpace, f });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              err = [err];
              tok = sliceType$2.nil;
              err[0] = $ifaceNil;
              s = this;
              $deferred.push([
                (function (err) {
                  return function () {
                    var _tuple, e, ok, se;
                    e = $recover();
                    if (!$interfaceIsEqual(e, $ifaceNil)) {
                      _tuple = $assertType(e, scanError, true);
                      se = $clone(_tuple[0], scanError);
                      ok = _tuple[1];
                      if (ok) {
                        err[0] = se.err;
                      } else {
                        $panic(e);
                      }
                    }
                  };
                })(err),
                [],
              ]);
              if (f === $throwNilPointerError) {
                f = notSpace;
              }
              s.buf = $subslice(s.buf, 0, 0);
              _r = s.token(skipSpace, f);
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              tok = _r;
              $24r = [tok, err[0]];
              $s = 2;
            case 2:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return [tok, err[0]];
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: ss.ptr.prototype.Token,
            $c: true,
            $r,
            $24r,
            _r,
            err,
            f,
            s,
            skipSpace,
            tok,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    ss.prototype.Token = function (skipSpace, f) {
      return this.$val.Token(skipSpace, f);
    };
    isSpace = function (r) {
      var _i, _ref, r, rng, rx;
      if (r >= 65536) {
        return false;
      }
      rx = (r << 16) >>> 16;
      _ref = space;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        rng = $clone(
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i],
          arrayType
        );
        if (rx < rng[0]) {
          return false;
        }
        if (rx <= rng[1]) {
          return true;
        }
        _i++;
      }
      return false;
    };
    notSpace = function (r) {
      var r;
      return !isSpace(r);
    };
    ss.ptr.prototype.free = function (old) {
      var old, s;
      s = this;
      if (old.validSave) {
        ssave.copy(s.ssave, old);
        return;
      }
      if (s.buf.$capacity > 1024) {
        return;
      }
      s.buf = $subslice(s.buf, 0, 0);
      s.rs = $ifaceNil;
      ssFree.Put(s);
    };
    ss.prototype.free = function (old) {
      return this.$val.free(old);
    };
    ss.ptr.prototype.SkipSpace = function () {
      var { _r, _r$1, _r$2, _v, r, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
          /* while (true) { */ case 1:
            _r = s.getRune();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            r = _r;
            if (r === -1) {
              $s = -1;
              return;
            }
            if (!(r === 13)) {
              _v = false;
              $s = 6;
              continue s;
            }
            _r$1 = s.peek("\n");
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _v = _r$1;
          case 6:
            /* */ if (_v) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_v) { */ case 4:
            /* continue; */ $s = 1;
            continue;
          /* } */ case 5:
            if (r === 10) {
              if (s.ssave.nlIsSpace) {
                /* continue; */ $s = 1;
                continue;
              }
              s.errorString("unexpected newline");
              $s = -1;
              return;
            }
            /* */ if (!isSpace(r)) {
              $s = 8;
              continue;
            }
            /* */ $s = 9;
            continue;
          /* if (!isSpace(r)) { */ case 8:
            _r$2 = s.UnreadRune();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$2;
            /* break; */ $s = 2;
            continue;
          /* } */ case 9:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: ss.ptr.prototype.SkipSpace,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        _v,
        r,
        s,
        $s,
      };
      return $f;
    };
    ss.prototype.SkipSpace = function () {
      return this.$val.SkipSpace();
    };
    ss.ptr.prototype.token = function (skipSpace, f) {
      var { _r, _r$1, _r$2, f, r, s, skipSpace, $s, $r, $c } = $restore(this, {
        skipSpace,
        f,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (skipSpace) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (skipSpace) { */ case 1:
            $r = s.SkipSpace();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
          /* while (true) { */ case 4:
            _r = s.getRune();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            r = _r;
            if (r === -1) {
              /* break; */ $s = 5;
              continue;
            }
            _r$1 = f(r);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$1) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!_r$1) { */ case 7:
            _r$2 = s.UnreadRune();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$2;
            /* break; */ $s = 5;
            continue;
          /* } */ case 8:
            (
              s.$ptr_buf ||
              (s.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                s
              ))
            ).writeRune(r);
            $s = 4;
            continue;
          case 5:
            $s = -1;
            return $convertSliceType(s.buf, sliceType$2);
          /* */
        }
        return;
      }
      var $f = {
        $blk: ss.ptr.prototype.token,
        $c: true,
        $r,
        _r,
        _r$1,
        _r$2,
        f,
        r,
        s,
        skipSpace,
        $s,
      };
      return $f;
    };
    ss.prototype.token = function (skipSpace, f) {
      return this.$val.token(skipSpace, f);
    };
    indexRune = function (s, r) {
      var _i, _ref, _rune, c, i, r, s;
      _ref = s;
      _i = 0;
      while (true) {
        if (!(_i < _ref.length)) {
          break;
        }
        _rune = $decodeRune(_ref, _i);
        i = _i;
        c = _rune[0];
        if (c === r) {
          return i;
        }
        _i += _rune[1];
      }
      return -1;
    };
    ss.ptr.prototype.peek = function (ok) {
      var { _r, _r$1, ok, r, s, $s, $r, $c } = $restore(this, { ok });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            _r = s.getRune();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            r = _r;
            /* */ if (!(r === -1)) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (!((r === -1))) { */ case 2:
            _r$1 = s.UnreadRune();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _r$1;
          /* } */ case 3:
            $s = -1;
            return indexRune(ok, r) >= 0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: ss.ptr.prototype.peek,
        $c: true,
        $r,
        _r,
        _r$1,
        ok,
        r,
        s,
        $s,
      };
      return $f;
    };
    ss.prototype.peek = function (ok) {
      return this.$val.peek(ok);
    };
    $ptrType(buffer).prototype.write = function (p) {
      var b, p;
      b = this;
      b.$set($appendSlice(b.$get(), p));
    };
    $ptrType(buffer).prototype.writeString = function (s) {
      var b, s;
      b = this;
      b.$set($appendSlice(b.$get(), s));
    };
    $ptrType(buffer).prototype.writeByte = function (c) {
      var b, c;
      b = this;
      b.$set($append(b.$get(), c));
    };
    $ptrType(buffer).prototype.writeRune = function (r) {
      var b, bp, n, r, w;
      bp = this;
      if (r < 128) {
        bp.$set($append(bp.$get(), (r << 24) >>> 24));
        return;
      }
      b = bp.$get();
      n = b.$length;
      while (true) {
        if (!((n + 4) >> 0 > b.$capacity)) {
          break;
        }
        b = $append(b, 0);
      }
      w = utf8.EncodeRune(
        $convertSliceType($subslice(b, n, (n + 4) >> 0), sliceType$2),
        r
      );
      bp.$set($subslice(b, 0, (n + w) >> 0));
    };
    newPrinter = function () {
      var { _r, p, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = ppFree.Get();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            p = $assertType(_r, ptrType$24);
            p.panicking = false;
            p.erroring = false;
            p.wrapErrs = false;
            p.fmt.init(
              p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
            );
            $s = -1;
            return p;
          /* */
        }
        return;
      }
      var $f = { $blk: newPrinter, $c: true, $r, _r, p, $s };
      return $f;
    };
    pp.ptr.prototype.free = function () {
      var p;
      p = this;
      if (p.buf.$capacity > 65536) {
        return;
      }
      p.buf = $subslice(p.buf, 0, 0);
      p.arg = $ifaceNil;
      p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
      p.wrappedErr = $ifaceNil;
      ppFree.Put(p);
    };
    pp.prototype.free = function () {
      return this.$val.free();
    };
    pp.ptr.prototype.Width = function () {
      var _tmp, _tmp$1, ok, p, wid;
      wid = 0;
      ok = false;
      p = this;
      _tmp = p.fmt.wid;
      _tmp$1 = p.fmt.fmtFlags.widPresent;
      wid = _tmp;
      ok = _tmp$1;
      return [wid, ok];
    };
    pp.prototype.Width = function () {
      return this.$val.Width();
    };
    pp.ptr.prototype.Precision = function () {
      var _tmp, _tmp$1, ok, p, prec;
      prec = 0;
      ok = false;
      p = this;
      _tmp = p.fmt.prec;
      _tmp$1 = p.fmt.fmtFlags.precPresent;
      prec = _tmp;
      ok = _tmp$1;
      return [prec, ok];
    };
    pp.prototype.Precision = function () {
      return this.$val.Precision();
    };
    pp.ptr.prototype.Flag = function (b) {
      var _1, b, p;
      p = this;
      _1 = b;
      if (_1 === 45) {
        return p.fmt.fmtFlags.minus;
      } else if (_1 === 43) {
        return p.fmt.fmtFlags.plus || p.fmt.fmtFlags.plusV;
      } else if (_1 === 35) {
        return p.fmt.fmtFlags.sharp || p.fmt.fmtFlags.sharpV;
      } else if (_1 === 32) {
        return p.fmt.fmtFlags.space;
      } else if (_1 === 48) {
        return p.fmt.fmtFlags.zero;
      }
      return false;
    };
    pp.prototype.Flag = function (b) {
      return this.$val.Flag(b);
    };
    pp.ptr.prototype.Write = function (b) {
      var _tmp, _tmp$1, b, err, p, ret;
      ret = 0;
      err = $ifaceNil;
      p = this;
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).write(b);
      _tmp = b.$length;
      _tmp$1 = $ifaceNil;
      ret = _tmp;
      err = _tmp$1;
      return [ret, err];
    };
    pp.prototype.Write = function (b) {
      return this.$val.Write(b);
    };
    pp.ptr.prototype.WriteString = function (s) {
      var _tmp, _tmp$1, err, p, ret, s;
      ret = 0;
      err = $ifaceNil;
      p = this;
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeString(s);
      _tmp = s.length;
      _tmp$1 = $ifaceNil;
      ret = _tmp;
      err = _tmp$1;
      return [ret, err];
    };
    pp.prototype.WriteString = function (s) {
      return this.$val.WriteString(s);
    };
    Fprintf = function (w, format, a) {
      var { _r, _r$1, _tuple, a, err, format, n, p, w, $s, $r, $c } = $restore(
        this,
        { w, format, a }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            _r = newPrinter();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            p = _r;
            $r = p.doPrintf(format, a);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r$1 = w.Write($convertSliceType(p.buf, sliceType$2));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple = _r$1;
            n = _tuple[0];
            err = _tuple[1];
            p.free();
            $s = -1;
            return [n, err];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Fprintf,
        $c: true,
        $r,
        _r,
        _r$1,
        _tuple,
        a,
        err,
        format,
        n,
        p,
        w,
        $s,
      };
      return $f;
    };
    $pkg.Fprintf = Fprintf;
    Printf = function (format, a) {
      var { $24r, _r, _tuple, a, err, format, n, $s, $r, $c } = $restore(this, {
        format,
        a,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            n = 0;
            err = $ifaceNil;
            _r = Fprintf(os.Stdout, format, a);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            n = _tuple[0];
            err = _tuple[1];
            $24r = [n, err];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Printf,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        a,
        err,
        format,
        n,
        $s,
      };
      return $f;
    };
    $pkg.Printf = Printf;
    Sprintf = function (format, a) {
      var { _r, a, format, p, s, $s, $r, $c } = $restore(this, { format, a });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = newPrinter();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            p = _r;
            $r = p.doPrintf(format, a);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            s = $bytesToString(p.buf);
            p.free();
            $s = -1;
            return s;
          /* */
        }
        return;
      }
      var $f = { $blk: Sprintf, $c: true, $r, _r, a, format, p, s, $s };
      return $f;
    };
    $pkg.Sprintf = Sprintf;
    getField = function (v, i) {
      var { _r, _r$1, i, v, val, $s, $r, $c } = $restore(this, { v, i });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = $clone(v, reflect.Value).Field(i);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            val = _r;
            /* */ if (
              $clone(val, reflect.Value).Kind() === 20 &&
              !$clone(val, reflect.Value).IsNil()
            ) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { */ case 2:
            _r$1 = $clone(val, reflect.Value).Elem();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            val = _r$1;
          /* } */ case 3:
            $s = -1;
            return val;
          /* */
        }
        return;
      }
      var $f = { $blk: getField, $c: true, $r, _r, _r$1, i, v, val, $s };
      return $f;
    };
    tooLarge = function (x) {
      var x;
      return x > 1000000 || x < -1000000;
    };
    parsenum = function (s, start, end) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        end,
        isnum,
        newi,
        num,
        s,
        start;
      num = 0;
      isnum = false;
      newi = 0;
      if (start >= end) {
        _tmp = 0;
        _tmp$1 = false;
        _tmp$2 = end;
        num = _tmp;
        isnum = _tmp$1;
        newi = _tmp$2;
        return [num, isnum, newi];
      }
      newi = start;
      while (true) {
        if (
          !(newi < end && 48 <= s.charCodeAt(newi) && s.charCodeAt(newi) <= 57)
        ) {
          break;
        }
        if (tooLarge(num)) {
          _tmp$3 = 0;
          _tmp$4 = false;
          _tmp$5 = end;
          num = _tmp$3;
          isnum = _tmp$4;
          newi = _tmp$5;
          return [num, isnum, newi];
        }
        num =
          ($imul(num, 10) +
            ((((s.charCodeAt(newi) - 48) << 24) >>> 24) >> 0)) >>
          0;
        isnum = true;
        newi = (newi + 1) >> 0;
      }
      return [num, isnum, newi];
    };
    pp.ptr.prototype.unknownType = function (v) {
      var { _r, p, v, $s, $r, $c } = $restore(this, { v });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            if (!$clone(v, reflect.Value).IsValid()) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("<nil>");
              $s = -1;
              return;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(63);
            _r = $clone(v, reflect.Value).Type().String();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(63);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.unknownType,
        $c: true,
        $r,
        _r,
        p,
        v,
        $s,
      };
      return $f;
    };
    pp.prototype.unknownType = function (v) {
      return this.$val.unknownType(v);
    };
    pp.ptr.prototype.badVerb = function (verb) {
      var { _r, _r$1, p, verb, $s, $r, $c } = $restore(this, { verb });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            p.erroring = true;
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("%!");
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeRune(verb);
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(40);
            /* */ if (!$interfaceIsEqual(p.arg, $ifaceNil)) {
              $s = 2;
              continue;
            }
            /* */ if ($clone(p.value, reflect.Value).IsValid()) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!($interfaceIsEqual(p.arg, $ifaceNil))) { */ case 2:
            _r = reflect.TypeOf(p.arg).String();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(61);
            $r = p.printArg(p.arg, 118);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 5;
            continue;
          /* } else if ($clone(p.value, reflect.Value).IsValid()) { */ case 3:
            _r$1 = $clone(p.value, reflect.Value).Type().String();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$1);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(61);
            $r = p.printValue($clone(p.value, reflect.Value), 118, 0);
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 5;
            continue;
          /* } else { */ case 4:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("<nil>");
          /* } */ case 5:
          case 1:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(41);
            p.erroring = false;
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.badVerb,
        $c: true,
        $r,
        _r,
        _r$1,
        p,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.badVerb = function (verb) {
      return this.$val.badVerb(verb);
    };
    pp.ptr.prototype.fmtBool = function (v, verb) {
      var { _1, p, v, verb, $s, $r, $c } = $restore(this, { v, verb });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (_1 === 116 || _1 === 118) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if ((_1 === (116)) || (_1 === (118))) { */ case 2:
            p.fmt.fmtBoolean(v);
            $s = 4;
            continue;
          /* } else { */ case 3:
            $r = p.badVerb(verb);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 4:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtBool,
        $c: true,
        $r,
        _1,
        p,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtBool = function (v, verb) {
      return this.$val.fmtBool(v, verb);
    };
    pp.ptr.prototype.fmt0x64 = function (v, leading0x) {
      var leading0x, p, sharp, v;
      p = this;
      sharp = p.fmt.fmtFlags.sharp;
      p.fmt.fmtFlags.sharp = leading0x;
      p.fmt.fmtInteger(v, 16, false, 118, "0123456789abcdefx");
      p.fmt.fmtFlags.sharp = sharp;
    };
    pp.prototype.fmt0x64 = function (v, leading0x) {
      return this.$val.fmt0x64(v, leading0x);
    };
    pp.ptr.prototype.fmtInteger = function (v, isSigned, verb) {
      var { _1, isSigned, p, v, verb, $s, $r, $c } = $restore(this, {
        v,
        isSigned,
        verb,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (_1 === 118) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 100) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 98) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 111 || _1 === 79) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 120) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 88) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 99) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 113) {
              $s = 9;
              continue;
            }
            /* */ if (_1 === 85) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_1 === (118)) { */ case 2:
            if (p.fmt.fmtFlags.sharpV && !isSigned) {
              p.fmt0x64(v, true);
            } else {
              p.fmt.fmtInteger(v, 10, isSigned, verb, "0123456789abcdefx");
            }
            $s = 12;
            continue;
          /* } else if (_1 === (100)) { */ case 3:
            p.fmt.fmtInteger(v, 10, isSigned, verb, "0123456789abcdefx");
            $s = 12;
            continue;
          /* } else if (_1 === (98)) { */ case 4:
            p.fmt.fmtInteger(v, 2, isSigned, verb, "0123456789abcdefx");
            $s = 12;
            continue;
          /* } else if ((_1 === (111)) || (_1 === (79))) { */ case 5:
            p.fmt.fmtInteger(v, 8, isSigned, verb, "0123456789abcdefx");
            $s = 12;
            continue;
          /* } else if (_1 === (120)) { */ case 6:
            p.fmt.fmtInteger(v, 16, isSigned, verb, "0123456789abcdefx");
            $s = 12;
            continue;
          /* } else if (_1 === (88)) { */ case 7:
            p.fmt.fmtInteger(v, 16, isSigned, verb, "0123456789ABCDEFX");
            $s = 12;
            continue;
          /* } else if (_1 === (99)) { */ case 8:
            p.fmt.fmtC(v);
            $s = 12;
            continue;
          /* } else if (_1 === (113)) { */ case 9:
            p.fmt.fmtQc(v);
            $s = 12;
            continue;
          /* } else if (_1 === (85)) { */ case 10:
            p.fmt.fmtUnicode(v);
            $s = 12;
            continue;
          /* } else { */ case 11:
            $r = p.badVerb(verb);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 12:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtInteger,
        $c: true,
        $r,
        _1,
        isSigned,
        p,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtInteger = function (v, isSigned, verb) {
      return this.$val.fmtInteger(v, isSigned, verb);
    };
    pp.ptr.prototype.fmtFloat = function (v, size, verb) {
      var { _1, p, size, v, verb, $s, $r, $c } = $restore(this, {
        v,
        size,
        verb,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (_1 === 118) {
              $s = 2;
              continue;
            }
            /* */ if (
              _1 === 98 ||
              _1 === 103 ||
              _1 === 71 ||
              _1 === 120 ||
              _1 === 88
            ) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 102 || _1 === 101 || _1 === 69) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 70) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (_1 === (118)) { */ case 2:
            p.fmt.fmtFloat(v, size, 103, -1);
            $s = 7;
            continue;
          /* } else if ((_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (120)) || (_1 === (88))) { */ case 3:
            p.fmt.fmtFloat(v, size, verb, -1);
            $s = 7;
            continue;
          /* } else if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { */ case 4:
            p.fmt.fmtFloat(v, size, verb, 6);
            $s = 7;
            continue;
          /* } else if (_1 === (70)) { */ case 5:
            p.fmt.fmtFloat(v, size, 102, 6);
            $s = 7;
            continue;
          /* } else { */ case 6:
            $r = p.badVerb(verb);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 7:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtFloat,
        $c: true,
        $r,
        _1,
        p,
        size,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtFloat = function (v, size, verb) {
      return this.$val.fmtFloat(v, size, verb);
    };
    pp.ptr.prototype.fmtComplex = function (v, size, verb) {
      var { _1, _q, _q$1, oldPlus, p, size, v, verb, $s, $r, $c } = $restore(
        this,
        { v, size, verb }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (
              _1 === 118 ||
              _1 === 98 ||
              _1 === 103 ||
              _1 === 71 ||
              _1 === 120 ||
              _1 === 88 ||
              _1 === 102 ||
              _1 === 70 ||
              _1 === 101 ||
              _1 === 69
            ) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (120)) || (_1 === (88)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { */ case 2:
            oldPlus = p.fmt.fmtFlags.plus;
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(40);
            $r = p.fmtFloat(
              v.$real,
              ((_q = size / 2),
              _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                ? _q >> 0
                : $throwRuntimeError("integer divide by zero")),
              verb
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            p.fmt.fmtFlags.plus = true;
            $r = p.fmtFloat(
              v.$imag,
              ((_q$1 = size / 2),
              _q$1 === _q$1 && _q$1 !== 1 / 0 && _q$1 !== -1 / 0
                ? _q$1 >> 0
                : $throwRuntimeError("integer divide by zero")),
              verb
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("i)");
            p.fmt.fmtFlags.plus = oldPlus;
            $s = 4;
            continue;
          /* } else { */ case 3:
            $r = p.badVerb(verb);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 4:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtComplex,
        $c: true,
        $r,
        _1,
        _q,
        _q$1,
        oldPlus,
        p,
        size,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtComplex = function (v, size, verb) {
      return this.$val.fmtComplex(v, size, verb);
    };
    pp.ptr.prototype.fmtString = function (v, verb) {
      var { _1, p, v, verb, $s, $r, $c } = $restore(this, { v, verb });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (_1 === 118) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 115) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 120) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 88) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 113) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (_1 === (118)) { */ case 2:
            if (p.fmt.fmtFlags.sharpV) {
              p.fmt.fmtQ(v);
            } else {
              p.fmt.fmtS(v);
            }
            $s = 8;
            continue;
          /* } else if (_1 === (115)) { */ case 3:
            p.fmt.fmtS(v);
            $s = 8;
            continue;
          /* } else if (_1 === (120)) { */ case 4:
            p.fmt.fmtSx(v, "0123456789abcdefx");
            $s = 8;
            continue;
          /* } else if (_1 === (88)) { */ case 5:
            p.fmt.fmtSx(v, "0123456789ABCDEFX");
            $s = 8;
            continue;
          /* } else if (_1 === (113)) { */ case 6:
            p.fmt.fmtQ(v);
            $s = 8;
            continue;
          /* } else { */ case 7:
            $r = p.badVerb(verb);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 8:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtString,
        $c: true,
        $r,
        _1,
        p,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtString = function (v, verb) {
      return this.$val.fmtString(v, verb);
    };
    pp.ptr.prototype.fmtBytes = function (v, verb, typeString) {
      var {
        _1,
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        c,
        c$1,
        i,
        i$1,
        p,
        typeString,
        v,
        verb,
        $s,
        $r,
        $c,
      } = $restore(this, { v, verb, typeString });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            _1 = verb;
            /* */ if (_1 === 118 || _1 === 100) {
              $s = 2;
              continue;
            }
            /* */ if (_1 === 115) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 120) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 88) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 113) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if ((_1 === (118)) || (_1 === (100))) { */ case 2:
            if (p.fmt.fmtFlags.sharpV) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString(typeString);
              if (v === sliceType$2.nil) {
                (
                  p.$ptr_buf ||
                  (p.$ptr_buf = new ptrType$1(
                    function () {
                      return this.$target.buf;
                    },
                    function ($v) {
                      this.$target.buf = $v;
                    },
                    p
                  ))
                ).writeString("(nil)");
                $s = -1;
                return;
              }
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(123);
              _ref = v;
              _i = 0;
              while (true) {
                if (!(_i < _ref.$length)) {
                  break;
                }
                i = _i;
                c =
                  _i < 0 || _i >= _ref.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : _ref.$array[_ref.$offset + _i];
                if (i > 0) {
                  (
                    p.$ptr_buf ||
                    (p.$ptr_buf = new ptrType$1(
                      function () {
                        return this.$target.buf;
                      },
                      function ($v) {
                        this.$target.buf = $v;
                      },
                      p
                    ))
                  ).writeString(", ");
                }
                p.fmt0x64(new $Uint64(0, c), true);
                _i++;
              }
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(125);
            } else {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(91);
              _ref$1 = v;
              _i$1 = 0;
              while (true) {
                if (!(_i$1 < _ref$1.$length)) {
                  break;
                }
                i$1 = _i$1;
                c$1 =
                  _i$1 < 0 || _i$1 >= _ref$1.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : _ref$1.$array[_ref$1.$offset + _i$1];
                if (i$1 > 0) {
                  (
                    p.$ptr_buf ||
                    (p.$ptr_buf = new ptrType$1(
                      function () {
                        return this.$target.buf;
                      },
                      function ($v) {
                        this.$target.buf = $v;
                      },
                      p
                    ))
                  ).writeByte(32);
                }
                p.fmt.fmtInteger(
                  new $Uint64(0, c$1),
                  10,
                  false,
                  verb,
                  "0123456789abcdefx"
                );
                _i$1++;
              }
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(93);
            }
            $s = 8;
            continue;
          /* } else if (_1 === (115)) { */ case 3:
            p.fmt.fmtBs(v);
            $s = 8;
            continue;
          /* } else if (_1 === (120)) { */ case 4:
            p.fmt.fmtBx(v, "0123456789abcdefx");
            $s = 8;
            continue;
          /* } else if (_1 === (88)) { */ case 5:
            p.fmt.fmtBx(v, "0123456789ABCDEFX");
            $s = 8;
            continue;
          /* } else if (_1 === (113)) { */ case 6:
            p.fmt.fmtQ($bytesToString(v));
            $s = 8;
            continue;
          /* } else { */ case 7:
            _r = reflect.ValueOf(v);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $r = p.printValue($clone(_r, reflect.Value), verb, 0);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 8:
          case 1:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtBytes,
        $c: true,
        $r,
        _1,
        _i,
        _i$1,
        _r,
        _ref,
        _ref$1,
        c,
        c$1,
        i,
        i$1,
        p,
        typeString,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtBytes = function (v, verb, typeString) {
      return this.$val.fmtBytes(v, verb, typeString);
    };
    pp.ptr.prototype.fmtPointer = function (value, verb) {
      var { _1, _2, _r, p, u, value, verb, $s, $r, $c } = $restore(this, {
        value,
        verb,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            u = 0;
            _1 = $clone(value, reflect.Value).Kind();
            /* */ if (
              _1 === 18 ||
              _1 === 19 ||
              _1 === 21 ||
              _1 === 22 ||
              _1 === 23 ||
              _1 === 26
            ) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { */ case 2:
            u = $clone(value, reflect.Value).Pointer();
            $s = 4;
            continue;
          /* } else { */ case 3:
            $r = p.badVerb(verb);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 4:
          case 1:
            _2 = verb;
            /* */ if (_2 === 118) {
              $s = 7;
              continue;
            }
            /* */ if (_2 === 112) {
              $s = 8;
              continue;
            }
            /* */ if (
              _2 === 98 ||
              _2 === 111 ||
              _2 === 100 ||
              _2 === 120 ||
              _2 === 88
            ) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (_2 === (118)) { */ case 7:
            /* */ if (p.fmt.fmtFlags.sharpV) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if (p.fmt.fmtFlags.sharpV) { */ case 12:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(40);
            _r = $clone(value, reflect.Value).Type().String();
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(")(");
            if (u === 0) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("nil");
            } else {
              p.fmt0x64(new $Uint64(0, u.constructor === Number ? u : 1), true);
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(41);
            $s = 14;
            continue;
          /* } else { */ case 13:
            if (u === 0) {
              p.fmt.padString("<nil>");
            } else {
              p.fmt0x64(
                new $Uint64(0, u.constructor === Number ? u : 1),
                !p.fmt.fmtFlags.sharp
              );
            }
          /* } */ case 14:
            $s = 11;
            continue;
          /* } else if (_2 === (112)) { */ case 8:
            p.fmt0x64(
              new $Uint64(0, u.constructor === Number ? u : 1),
              !p.fmt.fmtFlags.sharp
            );
            $s = 11;
            continue;
          /* } else if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { */ case 9:
            $r = p.fmtInteger(
              new $Uint64(0, u.constructor === Number ? u : 1),
              false,
              verb
            );
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 11;
            continue;
          /* } else { */ case 10:
            $r = p.badVerb(verb);
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 11:
          case 6:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.fmtPointer,
        $c: true,
        $r,
        _1,
        _2,
        _r,
        p,
        u,
        value,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.fmtPointer = function (value, verb) {
      return this.$val.fmtPointer(value, verb);
    };
    pp.ptr.prototype.catchPanic = function (arg, verb, method) {
      var { _r, arg, err, method, oldFlags, p, v, verb, $s, $r, $c } = $restore(
        this,
        { arg, verb, method }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            err = $recover();
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
            _r = reflect.ValueOf(arg);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
            if (
              $clone(v, reflect.Value).Kind() === 22 &&
              $clone(v, reflect.Value).IsNil()
            ) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("<nil>");
              $s = -1;
              return;
            }
            if (p.panicking) {
              $panic(err);
            }
            oldFlags = $clone(p.fmt.fmtFlags, fmtFlags);
            p.fmt.clearflags();
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("%!");
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeRune(verb);
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("(PANIC=");
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(method);
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(" method: ");
            p.panicking = true;
            $r = p.printArg(err, 118);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            p.panicking = false;
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(41);
            fmtFlags.copy(p.fmt.fmtFlags, oldFlags);
          /* } */ case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.catchPanic,
        $c: true,
        $r,
        _r,
        arg,
        err,
        method,
        oldFlags,
        p,
        v,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.catchPanic = function (arg, verb, method) {
      return this.$val.catchPanic(arg, verb, method);
    };
    pp.ptr.prototype.handleMethods = function (verb) {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        $24r$4,
        $24r$5,
        $24r$6,
        _1,
        _r,
        _r$1,
        _r$2,
        _ref,
        _tuple,
        _tuple$1,
        _tuple$2,
        err,
        formatter,
        handled,
        ok,
        ok$1,
        ok$2,
        p,
        stringer,
        v,
        v$1,
        verb,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { verb });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              handled = false;
              p = this;
              /* */ if (p.erroring) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (p.erroring) { */ case 1:
              $24r = handled;
              $s = 3;
            case 3:
              return $24r;
            /* } */ case 2:
              /* */ if (verb === 119) {
                $s = 4;
                continue;
              }
              /* */ $s = 5;
              continue;
            /* if (verb === 119) { */ case 4:
              _tuple = $assertType(p.arg, $error, true);
              err = _tuple[0];
              ok = _tuple[1];
              /* */ if (
                !ok ||
                !p.wrapErrs ||
                !$interfaceIsEqual(p.wrappedErr, $ifaceNil)
              ) {
                $s = 6;
                continue;
              }
              /* */ $s = 7;
              continue;
            /* if (!ok || !p.wrapErrs || !($interfaceIsEqual(p.wrappedErr, $ifaceNil))) { */ case 6:
              p.wrappedErr = $ifaceNil;
              p.wrapErrs = false;
              $r = p.badVerb(verb);
              /* */ $s = 8;
            case 8:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              handled = true;
              $24r$1 = handled;
              $s = 9;
            case 9:
              return $24r$1;
            /* } */ case 7:
              p.wrappedErr = err;
              verb = 118;
            /* } */ case 5:
              _tuple$1 = $assertType(p.arg, Formatter, true);
              formatter = _tuple$1[0];
              ok$1 = _tuple$1[1];
              /* */ if (ok$1) {
                $s = 10;
                continue;
              }
              /* */ $s = 11;
              continue;
            /* if (ok$1) { */ case 10:
              handled = true;
              $deferred.push([
                $methodVal(p, "catchPanic"),
                [p.arg, verb, "Format"],
              ]);
              $r = formatter.Format(p, verb);
              /* */ $s = 12;
            case 12:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $24r$2 = handled;
              $s = 13;
            case 13:
              return $24r$2;
            /* } */ case 11:
              /* */ if (p.fmt.fmtFlags.sharpV) {
                $s = 14;
                continue;
              }
              /* */ $s = 15;
              continue;
            /* if (p.fmt.fmtFlags.sharpV) { */ case 14:
              _tuple$2 = $assertType(p.arg, GoStringer, true);
              stringer = _tuple$2[0];
              ok$2 = _tuple$2[1];
              /* */ if (ok$2) {
                $s = 17;
                continue;
              }
              /* */ $s = 18;
              continue;
            /* if (ok$2) { */ case 17:
              handled = true;
              $deferred.push([
                $methodVal(p, "catchPanic"),
                [p.arg, verb, "GoString"],
              ]);
              _r = stringer.GoString();
              /* */ $s = 19;
            case 19:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $r = p.fmt.fmtS(_r);
              /* */ $s = 20;
            case 20:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $24r$3 = handled;
              $s = 21;
            case 21:
              return $24r$3;
            /* } */ case 18:
              $s = 16;
              continue;
            /* } else { */ case 15:
              _1 = verb;
              /* */ if (
                _1 === 118 ||
                _1 === 115 ||
                _1 === 120 ||
                _1 === 88 ||
                _1 === 113
              ) {
                $s = 23;
                continue;
              }
              /* */ $s = 24;
              continue;
            /* if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { */ case 23:
              _ref = p.arg;
              /* */ if ($assertType(_ref, $error, true)[1]) {
                $s = 25;
                continue;
              }
              /* */ if ($assertType(_ref, Stringer, true)[1]) {
                $s = 26;
                continue;
              }
              /* */ $s = 27;
              continue;
            /* if ($assertType(_ref, $error, true)[1]) { */ case 25:
              v = _ref;
              handled = true;
              $deferred.push([
                $methodVal(p, "catchPanic"),
                [p.arg, verb, "Error"],
              ]);
              _r$1 = v.Error();
              /* */ $s = 28;
            case 28:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              $r = p.fmtString(_r$1, verb);
              /* */ $s = 29;
            case 29:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $24r$4 = handled;
              $s = 30;
            case 30:
              return $24r$4;
            /* } else if ($assertType(_ref, Stringer, true)[1]) { */ case 26:
              v$1 = _ref;
              handled = true;
              $deferred.push([
                $methodVal(p, "catchPanic"),
                [p.arg, verb, "String"],
              ]);
              _r$2 = v$1.String();
              /* */ $s = 31;
            case 31:
              if ($c) {
                $c = false;
                _r$2 = _r$2.$blk();
              }
              if (_r$2 && _r$2.$blk !== undefined) {
                break s;
              }
              $r = p.fmtString(_r$2, verb);
              /* */ $s = 32;
            case 32:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $24r$5 = handled;
              $s = 33;
            case 33:
              return $24r$5;
            /* } */ case 27:
            /* } */ case 24:
            case 22:
            /* } */ case 16:
              handled = false;
              $24r$6 = handled;
              $s = 34;
            case 34:
              return $24r$6;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return handled;
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: pp.ptr.prototype.handleMethods,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            $24r$4,
            $24r$5,
            $24r$6,
            _1,
            _r,
            _r$1,
            _r$2,
            _ref,
            _tuple,
            _tuple$1,
            _tuple$2,
            err,
            formatter,
            handled,
            ok,
            ok$1,
            ok$2,
            p,
            stringer,
            v,
            v$1,
            verb,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    pp.prototype.handleMethods = function (verb) {
      return this.$val.handleMethods(verb);
    };
    pp.ptr.prototype.printArg = function (arg, verb) {
      var {
        _1,
        _2,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _ref,
        arg,
        f,
        f$1,
        f$10,
        f$11,
        f$12,
        f$13,
        f$14,
        f$15,
        f$16,
        f$17,
        f$18,
        f$19,
        f$2,
        f$3,
        f$4,
        f$5,
        f$6,
        f$7,
        f$8,
        f$9,
        p,
        verb,
        $s,
        $r,
        $c,
      } = $restore(this, { arg, verb });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            p.arg = arg;
            p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
            /* */ if ($interfaceIsEqual(arg, $ifaceNil)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 1:
            _1 = verb;
            /* */ if (_1 === 84 || _1 === 118) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if ((_1 === (84)) || (_1 === (118))) { */ case 4:
            p.fmt.padString("<nil>");
            $s = 6;
            continue;
          /* } else { */ case 5:
            $r = p.badVerb(verb);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 6:
          case 3:
            $s = -1;
            return;
          /* } */ case 2:
            _2 = verb;
            /* */ if (_2 === 84) {
              $s = 9;
              continue;
            }
            /* */ if (_2 === 112) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_2 === (84)) { */ case 9:
            _r = reflect.TypeOf(arg).String();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $r = p.fmt.fmtS(_r);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } else if (_2 === (112)) { */ case 10:
            _r$1 = reflect.ValueOf(arg);
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $r = p.fmtPointer($clone(_r$1, reflect.Value), 112);
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 11:
          case 8:
            _ref = arg;
            /* */ if ($assertType(_ref, $Bool, true)[1]) {
              $s = 16;
              continue;
            }
            /* */ if ($assertType(_ref, $Float32, true)[1]) {
              $s = 17;
              continue;
            }
            /* */ if ($assertType(_ref, $Float64, true)[1]) {
              $s = 18;
              continue;
            }
            /* */ if ($assertType(_ref, $Complex64, true)[1]) {
              $s = 19;
              continue;
            }
            /* */ if ($assertType(_ref, $Complex128, true)[1]) {
              $s = 20;
              continue;
            }
            /* */ if ($assertType(_ref, $Int, true)[1]) {
              $s = 21;
              continue;
            }
            /* */ if ($assertType(_ref, $Int8, true)[1]) {
              $s = 22;
              continue;
            }
            /* */ if ($assertType(_ref, $Int16, true)[1]) {
              $s = 23;
              continue;
            }
            /* */ if ($assertType(_ref, $Int32, true)[1]) {
              $s = 24;
              continue;
            }
            /* */ if ($assertType(_ref, $Int64, true)[1]) {
              $s = 25;
              continue;
            }
            /* */ if ($assertType(_ref, $Uint, true)[1]) {
              $s = 26;
              continue;
            }
            /* */ if ($assertType(_ref, $Uint8, true)[1]) {
              $s = 27;
              continue;
            }
            /* */ if ($assertType(_ref, $Uint16, true)[1]) {
              $s = 28;
              continue;
            }
            /* */ if ($assertType(_ref, $Uint32, true)[1]) {
              $s = 29;
              continue;
            }
            /* */ if ($assertType(_ref, $Uint64, true)[1]) {
              $s = 30;
              continue;
            }
            /* */ if ($assertType(_ref, $Uintptr, true)[1]) {
              $s = 31;
              continue;
            }
            /* */ if ($assertType(_ref, $String, true)[1]) {
              $s = 32;
              continue;
            }
            /* */ if ($assertType(_ref, sliceType$2, true)[1]) {
              $s = 33;
              continue;
            }
            /* */ if ($assertType(_ref, reflect.Value, true)[1]) {
              $s = 34;
              continue;
            }
            /* */ $s = 35;
            continue;
          /* if ($assertType(_ref, $Bool, true)[1]) { */ case 16:
            f = _ref.$val;
            $r = p.fmtBool(f, verb);
            /* */ $s = 37;
          case 37:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Float32, true)[1]) { */ case 17:
            f$1 = _ref.$val;
            $r = p.fmtFloat(f$1, 32, verb);
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Float64, true)[1]) { */ case 18:
            f$2 = _ref.$val;
            $r = p.fmtFloat(f$2, 64, verb);
            /* */ $s = 39;
          case 39:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Complex64, true)[1]) { */ case 19:
            f$3 = _ref.$val;
            $r = p.fmtComplex(new $Complex128(f$3.$real, f$3.$imag), 64, verb);
            /* */ $s = 40;
          case 40:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Complex128, true)[1]) { */ case 20:
            f$4 = _ref.$val;
            $r = p.fmtComplex(f$4, 128, verb);
            /* */ $s = 41;
          case 41:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Int, true)[1]) { */ case 21:
            f$5 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$5), true, verb);
            /* */ $s = 42;
          case 42:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Int8, true)[1]) { */ case 22:
            f$6 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$6), true, verb);
            /* */ $s = 43;
          case 43:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Int16, true)[1]) { */ case 23:
            f$7 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$7), true, verb);
            /* */ $s = 44;
          case 44:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Int32, true)[1]) { */ case 24:
            f$8 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$8), true, verb);
            /* */ $s = 45;
          case 45:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Int64, true)[1]) { */ case 25:
            f$9 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(f$9.$high, f$9.$low), true, verb);
            /* */ $s = 46;
          case 46:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uint, true)[1]) { */ case 26:
            f$10 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$10), false, verb);
            /* */ $s = 47;
          case 47:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uint8, true)[1]) { */ case 27:
            f$11 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$11), false, verb);
            /* */ $s = 48;
          case 48:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uint16, true)[1]) { */ case 28:
            f$12 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$12), false, verb);
            /* */ $s = 49;
          case 49:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uint32, true)[1]) { */ case 29:
            f$13 = _ref.$val;
            $r = p.fmtInteger(new $Uint64(0, f$13), false, verb);
            /* */ $s = 50;
          case 50:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uint64, true)[1]) { */ case 30:
            f$14 = _ref.$val;
            $r = p.fmtInteger(f$14, false, verb);
            /* */ $s = 51;
          case 51:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $Uintptr, true)[1]) { */ case 31:
            f$15 = _ref.$val;
            $r = p.fmtInteger(
              new $Uint64(0, f$15.constructor === Number ? f$15 : 1),
              false,
              verb
            );
            /* */ $s = 52;
          case 52:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, $String, true)[1]) { */ case 32:
            f$16 = _ref.$val;
            $r = p.fmtString(f$16, verb);
            /* */ $s = 53;
          case 53:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, sliceType$2, true)[1]) { */ case 33:
            f$17 = _ref.$val;
            $r = p.fmtBytes(f$17, verb, "[]byte");
            /* */ $s = 54;
          case 54:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else if ($assertType(_ref, reflect.Value, true)[1]) { */ case 34:
            f$18 = _ref.$val;
            /* */ if (
              $clone(f$18, reflect.Value).IsValid() &&
              $clone(f$18, reflect.Value).CanInterface()
            ) {
              $s = 55;
              continue;
            }
            /* */ $s = 56;
            continue;
          /* if ($clone(f$18, reflect.Value).IsValid() && $clone(f$18, reflect.Value).CanInterface()) { */ case 55:
            _r$2 = $clone(f$18, reflect.Value).Interface();
            /* */ $s = 57;
          case 57:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            p.arg = _r$2;
            _r$3 = p.handleMethods(verb);
            /* */ $s = 60;
          case 60:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$3) {
              $s = 58;
              continue;
            }
            /* */ $s = 59;
            continue;
          /* if (_r$3) { */ case 58:
            $s = -1;
            return;
          /* } */ case 59:
          /* } */ case 56:
            $r = p.printValue($clone(f$18, reflect.Value), verb, 0);
            /* */ $s = 61;
          case 61:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 36;
            continue;
          /* } else { */ case 35:
            f$19 = _ref;
            _r$4 = p.handleMethods(verb);
            /* */ $s = 64;
          case 64:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r$4) {
              $s = 62;
              continue;
            }
            /* */ $s = 63;
            continue;
          /* if (!_r$4) { */ case 62:
            _r$5 = reflect.ValueOf(f$19);
            /* */ $s = 65;
          case 65:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $r = p.printValue($clone(_r$5, reflect.Value), verb, 0);
            /* */ $s = 66;
          case 66:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 63:
          /* } */ case 36:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.printArg,
        $c: true,
        $r,
        _1,
        _2,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _ref,
        arg,
        f,
        f$1,
        f$10,
        f$11,
        f$12,
        f$13,
        f$14,
        f$15,
        f$16,
        f$17,
        f$18,
        f$19,
        f$2,
        f$3,
        f$4,
        f$5,
        f$6,
        f$7,
        f$8,
        f$9,
        p,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.printArg = function (arg, verb) {
      return this.$val.printArg(arg, verb);
    };
    pp.ptr.prototype.printValue = function (value, verb, depth) {
      var {
        _1,
        _2,
        _3,
        _4,
        _arg,
        _arg$1,
        _arg$2,
        _i,
        _i$1,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$19,
        _r$2,
        _r$20,
        _r$21,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _ref,
        _ref$1,
        a,
        bytes,
        depth,
        f,
        i,
        i$1,
        i$2,
        i$3,
        i$4,
        key,
        name,
        p,
        sorted,
        t,
        value,
        value$1,
        verb,
        x,
        x$1,
        $s,
        $r,
        $c,
      } = $restore(this, { value, verb, depth });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            /* */ if (
              depth > 0 &&
              $clone(value, reflect.Value).IsValid() &&
              $clone(value, reflect.Value).CanInterface()
            ) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { */ case 1:
            _r = $clone(value, reflect.Value).Interface();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            p.arg = _r;
            _r$1 = p.handleMethods(verb);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$1) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (_r$1) { */ case 4:
            $s = -1;
            return;
          /* } */ case 5:
          /* } */ case 2:
            p.arg = $ifaceNil;
            p.value = value;
            f = value;
            _1 = $clone(value, reflect.Value).Kind();
            /* */ if (_1 === 0) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 1) {
              $s = 9;
              continue;
            }
            /* */ if (
              _1 === 2 ||
              _1 === 3 ||
              _1 === 4 ||
              _1 === 5 ||
              _1 === 6
            ) {
              $s = 10;
              continue;
            }
            /* */ if (
              _1 === 7 ||
              _1 === 8 ||
              _1 === 9 ||
              _1 === 10 ||
              _1 === 11 ||
              _1 === 12
            ) {
              $s = 11;
              continue;
            }
            /* */ if (_1 === 13) {
              $s = 12;
              continue;
            }
            /* */ if (_1 === 14) {
              $s = 13;
              continue;
            }
            /* */ if (_1 === 15) {
              $s = 14;
              continue;
            }
            /* */ if (_1 === 16) {
              $s = 15;
              continue;
            }
            /* */ if (_1 === 24) {
              $s = 16;
              continue;
            }
            /* */ if (_1 === 21) {
              $s = 17;
              continue;
            }
            /* */ if (_1 === 25) {
              $s = 18;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 19;
              continue;
            }
            /* */ if (_1 === 17 || _1 === 23) {
              $s = 20;
              continue;
            }
            /* */ if (_1 === 22) {
              $s = 21;
              continue;
            }
            /* */ if (_1 === 18 || _1 === 19 || _1 === 26) {
              $s = 22;
              continue;
            }
            /* */ $s = 23;
            continue;
          /* if (_1 === (0)) { */ case 8:
            /* */ if (depth === 0) {
              $s = 25;
              continue;
            }
            /* */ $s = 26;
            continue;
          /* if (depth === 0) { */ case 25:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("<invalid reflect.Value>");
            $s = 27;
            continue;
          /* } else { */ case 26:
            _2 = verb;
            /* */ if (_2 === 118) {
              $s = 29;
              continue;
            }
            /* */ $s = 30;
            continue;
          /* if (_2 === (118)) { */ case 29:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("<nil>");
            $s = 31;
            continue;
          /* } else { */ case 30:
            $r = p.badVerb(verb);
            /* */ $s = 32;
          case 32:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 31:
          case 28:
          /* } */ case 27:
            $s = 24;
            continue;
          /* } else if (_1 === (1)) { */ case 9:
            $r = p.fmtBool($clone(f, reflect.Value).Bool(), verb);
            /* */ $s = 33;
          case 33:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 10:
            $r = p.fmtInteger(
              ((x = $clone(f, reflect.Value).Int()),
              new $Uint64(x.$high, x.$low)),
              true,
              verb
            );
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 11:
            $r = p.fmtInteger($clone(f, reflect.Value).Uint(), false, verb);
            /* */ $s = 35;
          case 35:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (13)) { */ case 12:
            $r = p.fmtFloat($clone(f, reflect.Value).Float(), 32, verb);
            /* */ $s = 36;
          case 36:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (14)) { */ case 13:
            $r = p.fmtFloat($clone(f, reflect.Value).Float(), 64, verb);
            /* */ $s = 37;
          case 37:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (15)) { */ case 14:
            $r = p.fmtComplex($clone(f, reflect.Value).Complex(), 64, verb);
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (16)) { */ case 15:
            $r = p.fmtComplex($clone(f, reflect.Value).Complex(), 128, verb);
            /* */ $s = 39;
          case 39:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (24)) { */ case 16:
            _r$2 = $clone(f, reflect.Value).String();
            /* */ $s = 40;
          case 40:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $r = p.fmtString(_r$2, verb);
            /* */ $s = 41;
          case 41:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if (_1 === (21)) { */ case 17:
            /* */ if (p.fmt.fmtFlags.sharpV) {
              $s = 42;
              continue;
            }
            /* */ $s = 43;
            continue;
          /* if (p.fmt.fmtFlags.sharpV) { */ case 42:
            _r$3 = $clone(f, reflect.Value).Type().String();
            /* */ $s = 45;
          case 45:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$3);
            /* */ $s = 46;
          case 46:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if ($clone(f, reflect.Value).IsNil()) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("(nil)");
              $s = -1;
              return;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(123);
            $s = 44;
            continue;
          /* } else { */ case 43:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("map[");
          /* } */ case 44:
            _r$4 = fmtsort.Sort($clone(f, reflect.Value));
            /* */ $s = 47;
          case 47:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            sorted = _r$4;
            _ref = sorted.Key;
            _i = 0;
          /* while (true) { */ case 48:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 49;
              continue;
            }
            i = _i;
            key =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            if (i > 0) {
              if (p.fmt.fmtFlags.sharpV) {
                (
                  p.$ptr_buf ||
                  (p.$ptr_buf = new ptrType$1(
                    function () {
                      return this.$target.buf;
                    },
                    function ($v) {
                      this.$target.buf = $v;
                    },
                    p
                  ))
                ).writeString(", ");
              } else {
                (
                  p.$ptr_buf ||
                  (p.$ptr_buf = new ptrType$1(
                    function () {
                      return this.$target.buf;
                    },
                    function ($v) {
                      this.$target.buf = $v;
                    },
                    p
                  ))
                ).writeByte(32);
              }
            }
            $r = p.printValue(
              $clone(key, reflect.Value),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 50;
          case 50:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(58);
            $r = p.printValue(
              $clone(
                ((x$1 = sorted.Value),
                i < 0 || i >= x$1.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x$1.$array[x$1.$offset + i]),
                reflect.Value
              ),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 51;
          case 51:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _i++;
            $s = 48;
            continue;
          case 49:
            if (p.fmt.fmtFlags.sharpV) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(125);
            } else {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(93);
            }
            $s = 24;
            continue;
          /* } else if (_1 === (25)) { */ case 18:
            /* */ if (p.fmt.fmtFlags.sharpV) {
              $s = 52;
              continue;
            }
            /* */ $s = 53;
            continue;
          /* if (p.fmt.fmtFlags.sharpV) { */ case 52:
            _r$5 = $clone(f, reflect.Value).Type().String();
            /* */ $s = 54;
          case 54:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$5);
            /* */ $s = 55;
          case 55:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 53:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(123);
            i$1 = 0;
          /* while (true) { */ case 56:
            /* if (!(i$1 < $clone(f, reflect.Value).NumField())) { break; } */ if (
              !(i$1 < $clone(f, reflect.Value).NumField())
            ) {
              $s = 57;
              continue;
            }
            if (i$1 > 0) {
              if (p.fmt.fmtFlags.sharpV) {
                (
                  p.$ptr_buf ||
                  (p.$ptr_buf = new ptrType$1(
                    function () {
                      return this.$target.buf;
                    },
                    function ($v) {
                      this.$target.buf = $v;
                    },
                    p
                  ))
                ).writeString(", ");
              } else {
                (
                  p.$ptr_buf ||
                  (p.$ptr_buf = new ptrType$1(
                    function () {
                      return this.$target.buf;
                    },
                    function ($v) {
                      this.$target.buf = $v;
                    },
                    p
                  ))
                ).writeByte(32);
              }
            }
            /* */ if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) {
              $s = 58;
              continue;
            }
            /* */ $s = 59;
            continue;
          /* if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { */ case 58:
            _r$6 = $clone(f, reflect.Value).Type().Field(i$1);
            /* */ $s = 60;
          case 60:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            name = _r$6.Name;
            if (!(name === "")) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString(name);
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(58);
            }
          /* } */ case 59:
            _r$7 = getField($clone(f, reflect.Value), i$1);
            /* */ $s = 61;
          case 61:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            $r = p.printValue(
              $clone(_r$7, reflect.Value),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 62;
          case 62:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i$1 = (i$1 + 1) >> 0;
            $s = 56;
            continue;
          case 57:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(125);
            $s = 24;
            continue;
          /* } else if (_1 === (20)) { */ case 19:
            _r$8 = $clone(f, reflect.Value).Elem();
            /* */ $s = 63;
          case 63:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            value$1 = _r$8;
            /* */ if (!$clone(value$1, reflect.Value).IsValid()) {
              $s = 64;
              continue;
            }
            /* */ $s = 65;
            continue;
          /* if (!$clone(value$1, reflect.Value).IsValid()) { */ case 64:
            /* */ if (p.fmt.fmtFlags.sharpV) {
              $s = 67;
              continue;
            }
            /* */ $s = 68;
            continue;
          /* if (p.fmt.fmtFlags.sharpV) { */ case 67:
            _r$9 = $clone(f, reflect.Value).Type().String();
            /* */ $s = 70;
          case 70:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$9);
            /* */ $s = 71;
          case 71:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("(nil)");
            $s = 69;
            continue;
          /* } else { */ case 68:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("<nil>");
          /* } */ case 69:
            $s = 66;
            continue;
          /* } else { */ case 65:
            $r = p.printValue(
              $clone(value$1, reflect.Value),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 72;
          case 72:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 66:
            $s = 24;
            continue;
          /* } else if ((_1 === (17)) || (_1 === (23))) { */ case 20:
            _3 = verb;
            /* */ if (_3 === 115 || _3 === 113 || _3 === 120 || _3 === 88) {
              $s = 74;
              continue;
            }
            /* */ $s = 75;
            continue;
          /* if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { */ case 74:
            t = $clone(f, reflect.Value).Type();
            _r$10 = t.Elem();
            /* */ $s = 78;
          case 78:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _r$11 = _r$10.Kind();
            /* */ $s = 79;
          case 79:
            if ($c) {
              $c = false;
              _r$11 = _r$11.$blk();
            }
            if (_r$11 && _r$11.$blk !== undefined) {
              break s;
            }
            /* */ if (_r$11 === 8) {
              $s = 76;
              continue;
            }
            /* */ $s = 77;
            continue;
          /* if (_r$11 === 8) { */ case 76:
            bytes = sliceType$2.nil;
            /* */ if ($clone(f, reflect.Value).Kind() === 23) {
              $s = 80;
              continue;
            }
            /* */ if ($clone(f, reflect.Value).CanAddr()) {
              $s = 81;
              continue;
            }
            /* */ $s = 82;
            continue;
          /* if ($clone(f, reflect.Value).Kind() === 23) { */ case 80:
            _r$12 = $clone(f, reflect.Value).Bytes();
            /* */ $s = 84;
          case 84:
            if ($c) {
              $c = false;
              _r$12 = _r$12.$blk();
            }
            if (_r$12 && _r$12.$blk !== undefined) {
              break s;
            }
            bytes = _r$12;
            $s = 83;
            continue;
          /* } else if ($clone(f, reflect.Value).CanAddr()) { */ case 81:
            _r$13 = $clone(f, reflect.Value).Slice(
              0,
              $clone(f, reflect.Value).Len()
            );
            /* */ $s = 85;
          case 85:
            if ($c) {
              $c = false;
              _r$13 = _r$13.$blk();
            }
            if (_r$13 && _r$13.$blk !== undefined) {
              break s;
            }
            _r$14 = $clone(_r$13, reflect.Value).Bytes();
            /* */ $s = 86;
          case 86:
            if ($c) {
              $c = false;
              _r$14 = _r$14.$blk();
            }
            if (_r$14 && _r$14.$blk !== undefined) {
              break s;
            }
            bytes = _r$14;
            $s = 83;
            continue;
          /* } else { */ case 82:
            bytes = $makeSlice(sliceType$2, $clone(f, reflect.Value).Len());
            _ref$1 = bytes;
            _i$1 = 0;
          /* while (true) { */ case 87:
            /* if (!(_i$1 < _ref$1.$length)) { break; } */ if (
              !(_i$1 < _ref$1.$length)
            ) {
              $s = 88;
              continue;
            }
            i$2 = _i$1;
            _r$15 = $clone(f, reflect.Value).Index(i$2);
            /* */ $s = 89;
          case 89:
            if ($c) {
              $c = false;
              _r$15 = _r$15.$blk();
            }
            if (_r$15 && _r$15.$blk !== undefined) {
              break s;
            }
            _r$16 = $clone(_r$15, reflect.Value).Uint();
            /* */ $s = 90;
          case 90:
            if ($c) {
              $c = false;
              _r$16 = _r$16.$blk();
            }
            if (_r$16 && _r$16.$blk !== undefined) {
              break s;
            }
            i$2 < 0 || i$2 >= bytes.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (bytes.$array[bytes.$offset + i$2] = (_r$16.$low << 24) >>> 24);
            _i$1++;
            $s = 87;
            continue;
          case 88:
          /* } */ case 83:
            _arg = bytes;
            _arg$1 = verb;
            _r$17 = t.String();
            /* */ $s = 91;
          case 91:
            if ($c) {
              $c = false;
              _r$17 = _r$17.$blk();
            }
            if (_r$17 && _r$17.$blk !== undefined) {
              break s;
            }
            _arg$2 = _r$17;
            $r = p.fmtBytes(_arg, _arg$1, _arg$2);
            /* */ $s = 92;
          case 92:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 77:
          /* } */ case 75:
          case 73:
            /* */ if (p.fmt.fmtFlags.sharpV) {
              $s = 93;
              continue;
            }
            /* */ $s = 94;
            continue;
          /* if (p.fmt.fmtFlags.sharpV) { */ case 93:
            _r$18 = $clone(f, reflect.Value).Type().String();
            /* */ $s = 96;
          case 96:
            if ($c) {
              $c = false;
              _r$18 = _r$18.$blk();
            }
            if (_r$18 && _r$18.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$18);
            /* */ $s = 97;
          case 97:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (
              $clone(f, reflect.Value).Kind() === 23 &&
              $clone(f, reflect.Value).IsNil()
            ) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("(nil)");
              $s = -1;
              return;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(123);
            i$3 = 0;
          /* while (true) { */ case 98:
            /* if (!(i$3 < $clone(f, reflect.Value).Len())) { break; } */ if (
              !(i$3 < $clone(f, reflect.Value).Len())
            ) {
              $s = 99;
              continue;
            }
            if (i$3 > 0) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString(", ");
            }
            _r$19 = $clone(f, reflect.Value).Index(i$3);
            /* */ $s = 100;
          case 100:
            if ($c) {
              $c = false;
              _r$19 = _r$19.$blk();
            }
            if (_r$19 && _r$19.$blk !== undefined) {
              break s;
            }
            $r = p.printValue(
              $clone(_r$19, reflect.Value),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 101;
          case 101:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i$3 = (i$3 + 1) >> 0;
            $s = 98;
            continue;
          case 99:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(125);
            $s = 95;
            continue;
          /* } else { */ case 94:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(91);
            i$4 = 0;
          /* while (true) { */ case 102:
            /* if (!(i$4 < $clone(f, reflect.Value).Len())) { break; } */ if (
              !(i$4 < $clone(f, reflect.Value).Len())
            ) {
              $s = 103;
              continue;
            }
            if (i$4 > 0) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeByte(32);
            }
            _r$20 = $clone(f, reflect.Value).Index(i$4);
            /* */ $s = 104;
          case 104:
            if ($c) {
              $c = false;
              _r$20 = _r$20.$blk();
            }
            if (_r$20 && _r$20.$blk !== undefined) {
              break s;
            }
            $r = p.printValue(
              $clone(_r$20, reflect.Value),
              verb,
              (depth + 1) >> 0
            );
            /* */ $s = 105;
          case 105:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            i$4 = (i$4 + 1) >> 0;
            $s = 102;
            continue;
          case 103:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(93);
          /* } */ case 95:
            $s = 24;
            continue;
          /* } else if (_1 === (22)) { */ case 21:
            /* */ if (
              depth === 0 &&
              !($clone(f, reflect.Value).Pointer() === 0)
            ) {
              $s = 106;
              continue;
            }
            /* */ $s = 107;
            continue;
          /* if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { */ case 106:
            _r$21 = $clone(f, reflect.Value).Elem();
            /* */ $s = 109;
          case 109:
            if ($c) {
              $c = false;
              _r$21 = _r$21.$blk();
            }
            if (_r$21 && _r$21.$blk !== undefined) {
              break s;
            }
            a = _r$21;
            _4 = $clone(a, reflect.Value).Kind();
            /* */ if (_4 === 17 || _4 === 23 || _4 === 25 || _4 === 21) {
              $s = 110;
              continue;
            }
            /* */ $s = 111;
            continue;
          /* if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { */ case 110:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(38);
            $r = p.printValue($clone(a, reflect.Value), verb, (depth + 1) >> 0);
            /* */ $s = 112;
          case 112:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 111:
          case 108:
          /* } */ case 107:
            $r = p.fmtPointer($clone(f, reflect.Value), verb);
            /* */ $s = 113;
          case 113:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { */ case 22:
            $r = p.fmtPointer($clone(f, reflect.Value), verb);
            /* */ $s = 114;
          case 114:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 24;
            continue;
          /* } else { */ case 23:
            $r = p.unknownType($clone(f, reflect.Value));
            /* */ $s = 115;
          case 115:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 24:
          case 7:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.printValue,
        $c: true,
        $r,
        _1,
        _2,
        _3,
        _4,
        _arg,
        _arg$1,
        _arg$2,
        _i,
        _i$1,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$19,
        _r$2,
        _r$20,
        _r$21,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _ref,
        _ref$1,
        a,
        bytes,
        depth,
        f,
        i,
        i$1,
        i$2,
        i$3,
        i$4,
        key,
        name,
        p,
        sorted,
        t,
        value,
        value$1,
        verb,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    pp.prototype.printValue = function (value, verb, depth) {
      return this.$val.printValue(value, verb, depth);
    };
    intFromArg = function (a, argNum) {
      var {
        _1,
        _r,
        _tuple,
        a,
        argNum,
        isInt,
        n,
        n$1,
        newArgNum,
        num,
        v,
        x,
        x$1,
        x$2,
        $s,
        $r,
        $c,
      } = $restore(this, { a, argNum });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            num = 0;
            isInt = false;
            newArgNum = 0;
            newArgNum = argNum;
            /* */ if (argNum < a.$length) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (argNum < a.$length) { */ case 1:
            _tuple = $assertType(
              argNum < 0 || argNum >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + argNum],
              $Int,
              true
            );
            num = _tuple[0];
            isInt = _tuple[1];
            /* */ if (!isInt) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!isInt) { */ case 3:
            _r = reflect.ValueOf(
              argNum < 0 || argNum >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + argNum]
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            v = _r;
            _1 = $clone(v, reflect.Value).Kind();
            if (_1 === 2 || _1 === 3 || _1 === 4 || _1 === 5 || _1 === 6) {
              n = $clone(v, reflect.Value).Int();
              if (
                ((x = new $Int64(
                  0,
                  (n.$low + (n.$high >> 31) * 4294967296) >> 0
                )),
                x.$high === n.$high && x.$low === n.$low)
              ) {
                num = (n.$low + (n.$high >> 31) * 4294967296) >> 0;
                isInt = true;
              }
            } else if (
              _1 === 7 ||
              _1 === 8 ||
              _1 === 9 ||
              _1 === 10 ||
              _1 === 11 ||
              _1 === 12
            ) {
              n$1 = $clone(v, reflect.Value).Uint();
              if (
                ((x$1 = new $Int64(n$1.$high, n$1.$low)),
                x$1.$high > 0 || (x$1.$high === 0 && x$1.$low >= 0)) &&
                ((x$2 = new $Uint64(0, n$1.$low >> 0)),
                x$2.$high === n$1.$high && x$2.$low === n$1.$low)
              ) {
                num = n$1.$low >> 0;
                isInt = true;
              }
            }
          case 5:
          /* } */ case 4:
            newArgNum = (argNum + 1) >> 0;
            if (tooLarge(num)) {
              num = 0;
              isInt = false;
            }
          /* } */ case 2:
            $s = -1;
            return [num, isInt, newArgNum];
          /* */
        }
        return;
      }
      var $f = {
        $blk: intFromArg,
        $c: true,
        $r,
        _1,
        _r,
        _tuple,
        a,
        argNum,
        isInt,
        n,
        n$1,
        newArgNum,
        num,
        v,
        x,
        x$1,
        x$2,
        $s,
      };
      return $f;
    };
    parseArgNumber = function (format) {
      var _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        _tuple,
        format,
        i,
        index,
        newi,
        ok,
        ok$1,
        wid,
        width;
      index = 0;
      wid = 0;
      ok = false;
      if (format.length < 3) {
        _tmp = 0;
        _tmp$1 = 1;
        _tmp$2 = false;
        index = _tmp;
        wid = _tmp$1;
        ok = _tmp$2;
        return [index, wid, ok];
      }
      i = 1;
      while (true) {
        if (!(i < format.length)) {
          break;
        }
        if (format.charCodeAt(i) === 93) {
          _tuple = parsenum(format, 1, i);
          width = _tuple[0];
          ok$1 = _tuple[1];
          newi = _tuple[2];
          if (!ok$1 || !(newi === i)) {
            _tmp$3 = 0;
            _tmp$4 = (i + 1) >> 0;
            _tmp$5 = false;
            index = _tmp$3;
            wid = _tmp$4;
            ok = _tmp$5;
            return [index, wid, ok];
          }
          _tmp$6 = (width - 1) >> 0;
          _tmp$7 = (i + 1) >> 0;
          _tmp$8 = true;
          index = _tmp$6;
          wid = _tmp$7;
          ok = _tmp$8;
          return [index, wid, ok];
        }
        i = (i + 1) >> 0;
      }
      _tmp$9 = 0;
      _tmp$10 = 1;
      _tmp$11 = false;
      index = _tmp$9;
      wid = _tmp$10;
      ok = _tmp$11;
      return [index, wid, ok];
    };
    pp.ptr.prototype.argNumber = function (argNum, format, i, numArgs) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tuple,
        argNum,
        format,
        found,
        i,
        index,
        newArgNum,
        newi,
        numArgs,
        ok,
        p,
        wid;
      newArgNum = 0;
      newi = 0;
      found = false;
      p = this;
      if (format.length <= i || !(format.charCodeAt(i) === 91)) {
        _tmp = argNum;
        _tmp$1 = i;
        _tmp$2 = false;
        newArgNum = _tmp;
        newi = _tmp$1;
        found = _tmp$2;
        return [newArgNum, newi, found];
      }
      p.reordered = true;
      _tuple = parseArgNumber($substring(format, i));
      index = _tuple[0];
      wid = _tuple[1];
      ok = _tuple[2];
      if (ok && 0 <= index && index < numArgs) {
        _tmp$3 = index;
        _tmp$4 = (i + wid) >> 0;
        _tmp$5 = true;
        newArgNum = _tmp$3;
        newi = _tmp$4;
        found = _tmp$5;
        return [newArgNum, newi, found];
      }
      p.goodArgNum = false;
      _tmp$6 = argNum;
      _tmp$7 = (i + wid) >> 0;
      _tmp$8 = ok;
      newArgNum = _tmp$6;
      newi = _tmp$7;
      found = _tmp$8;
      return [newArgNum, newi, found];
    };
    pp.prototype.argNumber = function (argNum, format, i, numArgs) {
      return this.$val.argNumber(argNum, format, i, numArgs);
    };
    pp.ptr.prototype.badArgNum = function (verb) {
      var p, verb;
      p = this;
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeString("%!");
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeRune(verb);
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeString("(BADINDEX)");
    };
    pp.prototype.badArgNum = function (verb) {
      return this.$val.badArgNum(verb);
    };
    pp.ptr.prototype.missingArg = function (verb) {
      var p, verb;
      p = this;
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeString("%!");
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeRune(verb);
      (
        p.$ptr_buf ||
        (p.$ptr_buf = new ptrType$1(
          function () {
            return this.$target.buf;
          },
          function ($v) {
            this.$target.buf = $v;
          },
          p
        ))
      ).writeString("(MISSING)");
    };
    pp.prototype.missingArg = function (verb) {
      return this.$val.missingArg(verb);
    };
    pp.ptr.prototype.doPrintf = function (format, a) {
      var {
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _ref,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        a,
        afterIndex,
        arg,
        argNum,
        c,
        end,
        format,
        i,
        i$1,
        lasti,
        p,
        size,
        verb,
        $s,
        $r,
        $c,
      } = $restore(this, { format, a });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            p = this;
            end = format.length;
            argNum = 0;
            afterIndex = false;
            p.reordered = false;
            i = 0;
          /* while (true) { */ case 1:
            /* if (!(i < end)) { break; } */ if (!(i < end)) {
              $s = 2;
              continue;
            }
            p.goodArgNum = true;
            lasti = i;
            while (true) {
              if (!(i < end && !(format.charCodeAt(i) === 37))) {
                break;
              }
              i = (i + 1) >> 0;
            }
            if (i > lasti) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString($substring(format, lasti, i));
            }
            if (i >= end) {
              /* break; */ $s = 2;
              continue;
            }
            i = (i + 1) >> 0;
            p.fmt.clearflags();
          /* while (true) { */ case 3:
            /* if (!(i < end)) { break; } */ if (!(i < end)) {
              $s = 4;
              continue;
            }
            c = format.charCodeAt(i);
            _1 = c;
            /* */ if (_1 === 35) {
              $s = 6;
              continue;
            }
            /* */ if (_1 === 48) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 43) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 45) {
              $s = 9;
              continue;
            }
            /* */ if (_1 === 32) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (_1 === (35)) { */ case 6:
            p.fmt.fmtFlags.sharp = true;
            $s = 12;
            continue;
          /* } else if (_1 === (48)) { */ case 7:
            p.fmt.fmtFlags.zero = !p.fmt.fmtFlags.minus;
            $s = 12;
            continue;
          /* } else if (_1 === (43)) { */ case 8:
            p.fmt.fmtFlags.plus = true;
            $s = 12;
            continue;
          /* } else if (_1 === (45)) { */ case 9:
            p.fmt.fmtFlags.minus = true;
            p.fmt.fmtFlags.zero = false;
            $s = 12;
            continue;
          /* } else if (_1 === (32)) { */ case 10:
            p.fmt.fmtFlags.space = true;
            $s = 12;
            continue;
          /* } else { */ case 11:
            /* */ if (97 <= c && c <= 122 && argNum < a.$length) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if (97 <= c && c <= 122 && argNum < a.$length) { */ case 13:
            if (c === 118) {
              p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
              p.fmt.fmtFlags.sharp = false;
              p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
              p.fmt.fmtFlags.plus = false;
            }
            $r = p.printArg(
              argNum < 0 || argNum >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + argNum],
              c >> 0
            );
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            argNum = (argNum + 1) >> 0;
            i = (i + 1) >> 0;
            /* continue formatLoop; */ $s = 1;
            continue s;
          /* } */ case 14:
            /* break simpleFormat; */ $s = 4;
            continue s;
          /* } */ case 12:
          case 5:
            i = (i + 1) >> 0;
            $s = 3;
            continue;
          case 4:
            _tuple = p.argNumber(argNum, format, i, a.$length);
            argNum = _tuple[0];
            i = _tuple[1];
            afterIndex = _tuple[2];
            /* */ if (i < end && format.charCodeAt(i) === 42) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (i < end && (format.charCodeAt(i) === 42)) { */ case 16:
            i = (i + 1) >> 0;
            _r = intFromArg(a, argNum);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r;
            p.fmt.wid = _tuple$1[0];
            p.fmt.fmtFlags.widPresent = _tuple$1[1];
            argNum = _tuple$1[2];
            if (!p.fmt.fmtFlags.widPresent) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("%!(BADWIDTH)");
            }
            if (p.fmt.wid < 0) {
              p.fmt.wid = -p.fmt.wid;
              p.fmt.fmtFlags.minus = true;
              p.fmt.fmtFlags.zero = false;
            }
            afterIndex = false;
            $s = 18;
            continue;
          /* } else { */ case 17:
            _tuple$2 = parsenum(format, i, end);
            p.fmt.wid = _tuple$2[0];
            p.fmt.fmtFlags.widPresent = _tuple$2[1];
            i = _tuple$2[2];
            if (afterIndex && p.fmt.fmtFlags.widPresent) {
              p.goodArgNum = false;
            }
          /* } */ case 18:
            /* */ if ((i + 1) >> 0 < end && format.charCodeAt(i) === 46) {
              $s = 20;
              continue;
            }
            /* */ $s = 21;
            continue;
          /* if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) { */ case 20:
            i = (i + 1) >> 0;
            if (afterIndex) {
              p.goodArgNum = false;
            }
            _tuple$3 = p.argNumber(argNum, format, i, a.$length);
            argNum = _tuple$3[0];
            i = _tuple$3[1];
            afterIndex = _tuple$3[2];
            /* */ if (i < end && format.charCodeAt(i) === 42) {
              $s = 22;
              continue;
            }
            /* */ $s = 23;
            continue;
          /* if (i < end && (format.charCodeAt(i) === 42)) { */ case 22:
            i = (i + 1) >> 0;
            _r$1 = intFromArg(a, argNum);
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple$4 = _r$1;
            p.fmt.prec = _tuple$4[0];
            p.fmt.fmtFlags.precPresent = _tuple$4[1];
            argNum = _tuple$4[2];
            if (p.fmt.prec < 0) {
              p.fmt.prec = 0;
              p.fmt.fmtFlags.precPresent = false;
            }
            if (!p.fmt.fmtFlags.precPresent) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("%!(BADPREC)");
            }
            afterIndex = false;
            $s = 24;
            continue;
          /* } else { */ case 23:
            _tuple$5 = parsenum(format, i, end);
            p.fmt.prec = _tuple$5[0];
            p.fmt.fmtFlags.precPresent = _tuple$5[1];
            i = _tuple$5[2];
            if (!p.fmt.fmtFlags.precPresent) {
              p.fmt.prec = 0;
              p.fmt.fmtFlags.precPresent = true;
            }
          /* } */ case 24:
          /* } */ case 21:
            if (!afterIndex) {
              _tuple$6 = p.argNumber(argNum, format, i, a.$length);
              argNum = _tuple$6[0];
              i = _tuple$6[1];
              afterIndex = _tuple$6[2];
            }
            if (i >= end) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString("%!(NOVERB)");
              /* break; */ $s = 2;
              continue;
            }
            _tmp = format.charCodeAt(i) >> 0;
            _tmp$1 = 1;
            verb = _tmp;
            size = _tmp$1;
            if (verb >= 128) {
              _tuple$7 = utf8.DecodeRuneInString($substring(format, i));
              verb = _tuple$7[0];
              size = _tuple$7[1];
            }
            i = (i + size) >> 0;
            /* */ if (verb === 37) {
              $s = 27;
              continue;
            }
            /* */ if (!p.goodArgNum) {
              $s = 28;
              continue;
            }
            /* */ if (argNum >= a.$length) {
              $s = 29;
              continue;
            }
            /* */ if (verb === 118) {
              $s = 30;
              continue;
            }
            /* */ $s = 31;
            continue;
          /* if ((verb === 37)) { */ case 27:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(37);
            $s = 32;
            continue;
          /* } else if (!p.goodArgNum) { */ case 28:
            p.badArgNum(verb);
            $s = 32;
            continue;
          /* } else if (argNum >= a.$length) { */ case 29:
            p.missingArg(verb);
            $s = 32;
            continue;
          /* } else if ((verb === 118)) { */ case 30:
            p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
            p.fmt.fmtFlags.sharp = false;
            p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
            p.fmt.fmtFlags.plus = false;
            $r = p.printArg(
              argNum < 0 || argNum >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + argNum],
              verb
            );
            /* */ $s = 33;
          case 33:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            argNum = (argNum + 1) >> 0;
            $s = 32;
            continue;
          /* } else { */ case 31:
            $r = p.printArg(
              argNum < 0 || argNum >= a.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : a.$array[a.$offset + argNum],
              verb
            );
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            argNum = (argNum + 1) >> 0;
          /* } */ case 32:
          case 26:
            $s = 1;
            continue;
          case 2:
            /* */ if (!p.reordered && argNum < a.$length) {
              $s = 35;
              continue;
            }
            /* */ $s = 36;
            continue;
          /* if (!p.reordered && argNum < a.$length) { */ case 35:
            p.fmt.clearflags();
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("%!(EXTRA ");
            _ref = $subslice(a, argNum);
            _i = 0;
          /* while (true) { */ case 37:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 38;
              continue;
            }
            i$1 = _i;
            arg =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            if (i$1 > 0) {
              (
                p.$ptr_buf ||
                (p.$ptr_buf = new ptrType$1(
                  function () {
                    return this.$target.buf;
                  },
                  function ($v) {
                    this.$target.buf = $v;
                  },
                  p
                ))
              ).writeString(", ");
            }
            /* */ if ($interfaceIsEqual(arg, $ifaceNil)) {
              $s = 39;
              continue;
            }
            /* */ $s = 40;
            continue;
          /* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 39:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString("<nil>");
            $s = 41;
            continue;
          /* } else { */ case 40:
            _r$2 = reflect.TypeOf(arg).String();
            /* */ $s = 42;
          case 42:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $r = (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeString(_r$2);
            /* */ $s = 43;
          case 43:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(61);
            $r = p.printArg(arg, 118);
            /* */ $s = 44;
          case 44:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 41:
            _i++;
            $s = 37;
            continue;
          case 38:
            (
              p.$ptr_buf ||
              (p.$ptr_buf = new ptrType$1(
                function () {
                  return this.$target.buf;
                },
                function ($v) {
                  this.$target.buf = $v;
                },
                p
              ))
            ).writeByte(41);
          /* } */ case 36:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: pp.ptr.prototype.doPrintf,
        $c: true,
        $r,
        _1,
        _i,
        _r,
        _r$1,
        _r$2,
        _ref,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        a,
        afterIndex,
        arg,
        argNum,
        c,
        end,
        format,
        i,
        i$1,
        lasti,
        p,
        size,
        verb,
        $s,
      };
      return $f;
    };
    pp.prototype.doPrintf = function (format, a) {
      return this.$val.doPrintf(format, a);
    };
    fmt.ptr.prototype.clearflags = function () {
      var f;
      f = this;
      fmtFlags.copy(
        f.fmtFlags,
        new fmtFlags.ptr(
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        )
      );
    };
    fmt.prototype.clearflags = function () {
      return this.$val.clearflags();
    };
    fmt.ptr.prototype.init = function (buf) {
      var buf, f;
      f = this;
      f.buf = buf;
      f.clearflags();
    };
    fmt.prototype.init = function (buf) {
      return this.$val.init(buf);
    };
    fmt.ptr.prototype.writePadding = function (n) {
      var _i, _ref, buf, f, i, n, newLen, oldLen, padByte, padding;
      f = this;
      if (n <= 0) {
        return;
      }
      buf = f.buf.$get();
      oldLen = buf.$length;
      newLen = (oldLen + n) >> 0;
      if (newLen > buf.$capacity) {
        buf = $makeSlice(buffer, ($imul(buf.$capacity, 2) + n) >> 0);
        $copySlice(buf, f.buf.$get());
      }
      padByte = 32;
      if (f.fmtFlags.zero) {
        padByte = 48;
      }
      padding = $subslice(buf, oldLen, newLen);
      _ref = padding;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        i < 0 || i >= padding.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (padding.$array[padding.$offset + i] = padByte);
        _i++;
      }
      f.buf.$set($subslice(buf, 0, newLen));
    };
    fmt.prototype.writePadding = function (n) {
      return this.$val.writePadding(n);
    };
    fmt.ptr.prototype.pad = function (b) {
      var b, f, width;
      f = this;
      if (!f.fmtFlags.widPresent || f.wid === 0) {
        f.buf.write(b);
        return;
      }
      width = (f.wid - utf8.RuneCount(b)) >> 0;
      if (!f.fmtFlags.minus) {
        f.writePadding(width);
        f.buf.write(b);
      } else {
        f.buf.write(b);
        f.writePadding(width);
      }
    };
    fmt.prototype.pad = function (b) {
      return this.$val.pad(b);
    };
    fmt.ptr.prototype.padString = function (s) {
      var f, s, width;
      f = this;
      if (!f.fmtFlags.widPresent || f.wid === 0) {
        f.buf.writeString(s);
        return;
      }
      width = (f.wid - utf8.RuneCountInString(s)) >> 0;
      if (!f.fmtFlags.minus) {
        f.writePadding(width);
        f.buf.writeString(s);
      } else {
        f.buf.writeString(s);
        f.writePadding(width);
      }
    };
    fmt.prototype.padString = function (s) {
      return this.$val.padString(s);
    };
    fmt.ptr.prototype.fmtBoolean = function (v) {
      var f, v;
      f = this;
      if (v) {
        f.padString("true");
      } else {
        f.padString("false");
      }
    };
    fmt.prototype.fmtBoolean = function (v) {
      return this.$val.fmtBoolean(v);
    };
    fmt.ptr.prototype.fmtUnicode = function (u) {
      var buf, f, i, oldZero, prec, u, width;
      f = this;
      buf = $subslice(new sliceType$2(f.intbuf), 0);
      prec = 4;
      if (f.fmtFlags.precPresent && f.prec > 4) {
        prec = f.prec;
        width = (((((((2 + prec) >> 0) + 2) >> 0) + 4) >> 0) + 1) >> 0;
        if (width > buf.$length) {
          buf = $makeSlice(sliceType$2, width);
        }
      }
      i = buf.$length;
      if (
        f.fmtFlags.sharp &&
        (u.$high < 0 || (u.$high === 0 && u.$low <= 1114111)) &&
        strconv.IsPrint(u.$low >> 0)
      ) {
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 39);
        i = (i - utf8.RuneLen(u.$low >> 0)) >> 0;
        utf8.EncodeRune($subslice(buf, i), u.$low >> 0);
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 39);
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 32);
      }
      while (true) {
        if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 16))) {
          break;
        }
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt(
              $flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))
            ));
        prec = (prec - 1) >> 0;
        u = $shiftRightUint64(u, 4);
      }
      i = (i - 1) >> 0;
      i < 0 || i >= buf.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt(
            $flatten64(u)
          ));
      prec = (prec - 1) >> 0;
      while (true) {
        if (!(prec > 0)) {
          break;
        }
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 48);
        prec = (prec - 1) >> 0;
      }
      i = (i - 1) >> 0;
      i < 0 || i >= buf.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf.$array[buf.$offset + i] = 43);
      i = (i - 1) >> 0;
      i < 0 || i >= buf.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf.$array[buf.$offset + i] = 85);
      oldZero = f.fmtFlags.zero;
      f.fmtFlags.zero = false;
      f.pad($subslice(buf, i));
      f.fmtFlags.zero = oldZero;
    };
    fmt.prototype.fmtUnicode = function (u) {
      return this.$val.fmtUnicode(u);
    };
    fmt.ptr.prototype.fmtInteger = function (u, base, isSigned, verb, digits) {
      var _1,
        _2,
        base,
        buf,
        digits,
        f,
        i,
        isSigned,
        negative,
        next,
        oldZero,
        oldZero$1,
        prec,
        u,
        verb,
        width,
        x,
        x$1,
        x$2,
        x$3,
        x$4;
      f = this;
      negative =
        isSigned &&
        ((x = new $Int64(u.$high, u.$low)),
        x.$high < 0 || (x.$high === 0 && x.$low < 0));
      if (negative) {
        u = new $Uint64(-u.$high, -u.$low);
      }
      buf = $subslice(new sliceType$2(f.intbuf), 0);
      if (f.fmtFlags.widPresent || f.fmtFlags.precPresent) {
        width = (((3 + f.wid) >> 0) + f.prec) >> 0;
        if (width > buf.$length) {
          buf = $makeSlice(sliceType$2, width);
        }
      }
      prec = 0;
      if (f.fmtFlags.precPresent) {
        prec = f.prec;
        if (prec === 0 && u.$high === 0 && u.$low === 0) {
          oldZero = f.fmtFlags.zero;
          f.fmtFlags.zero = false;
          f.writePadding(f.wid);
          f.fmtFlags.zero = oldZero;
          return;
        }
      } else if (f.fmtFlags.zero && f.fmtFlags.widPresent) {
        prec = f.wid;
        if (negative || f.fmtFlags.plus || f.fmtFlags.space) {
          prec = (prec - 1) >> 0;
        }
      }
      i = buf.$length;
      _1 = base;
      if (_1 === 10) {
        while (true) {
          if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 10))) {
            break;
          }
          i = (i - 1) >> 0;
          next = $div64(u, new $Uint64(0, 10), false);
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] =
                (((x$1 = new $Uint64(0 + u.$high, 48 + u.$low)),
                (x$2 = $mul64(next, new $Uint64(0, 10))),
                new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low)).$low <<
                  24) >>>
                24);
          u = next;
        }
      } else if (_1 === 16) {
        while (true) {
          if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 16))) {
            break;
          }
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] = digits.charCodeAt(
                $flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))
              ));
          u = $shiftRightUint64(u, 4);
        }
      } else if (_1 === 8) {
        while (true) {
          if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 8))) {
            break;
          }
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] =
                (((x$3 = new $Uint64(u.$high & 0, (u.$low & 7) >>> 0)),
                new $Uint64(0 + x$3.$high, 48 + x$3.$low)).$low <<
                  24) >>>
                24);
          u = $shiftRightUint64(u, 3);
        }
      } else if (_1 === 2) {
        while (true) {
          if (!(u.$high > 0 || (u.$high === 0 && u.$low >= 2))) {
            break;
          }
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] =
                (((x$4 = new $Uint64(u.$high & 0, (u.$low & 1) >>> 0)),
                new $Uint64(0 + x$4.$high, 48 + x$4.$low)).$low <<
                  24) >>>
                24);
          u = $shiftRightUint64(u, 1);
        }
      } else {
        $panic(new $String("fmt: unknown base; can't happen"));
      }
      i = (i - 1) >> 0;
      i < 0 || i >= buf.$length
        ? ($throwRuntimeError("index out of range"), undefined)
        : (buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(u)));
      while (true) {
        if (!(i > 0 && prec > (buf.$length - i) >> 0)) {
          break;
        }
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 48);
      }
      if (f.fmtFlags.sharp) {
        _2 = base;
        if (_2 === 2) {
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] = 98);
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] = 48);
        } else if (_2 === 8) {
          if (
            !(
              (i < 0 || i >= buf.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : buf.$array[buf.$offset + i]) === 48
            )
          ) {
            i = (i - 1) >> 0;
            i < 0 || i >= buf.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : (buf.$array[buf.$offset + i] = 48);
          }
        } else if (_2 === 16) {
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] = digits.charCodeAt(16));
          i = (i - 1) >> 0;
          i < 0 || i >= buf.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (buf.$array[buf.$offset + i] = 48);
        }
      }
      if (verb === 79) {
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 111);
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 48);
      }
      if (negative) {
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 45);
      } else if (f.fmtFlags.plus) {
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 43);
      } else if (f.fmtFlags.space) {
        i = (i - 1) >> 0;
        i < 0 || i >= buf.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (buf.$array[buf.$offset + i] = 32);
      }
      oldZero$1 = f.fmtFlags.zero;
      f.fmtFlags.zero = false;
      f.pad($subslice(buf, i));
      f.fmtFlags.zero = oldZero$1;
    };
    fmt.prototype.fmtInteger = function (u, base, isSigned, verb, digits) {
      return this.$val.fmtInteger(u, base, isSigned, verb, digits);
    };
    fmt.ptr.prototype.truncateString = function (s) {
      var _i, _ref, _rune, f, i, n, s;
      f = this;
      if (f.fmtFlags.precPresent) {
        n = f.prec;
        _ref = s;
        _i = 0;
        while (true) {
          if (!(_i < _ref.length)) {
            break;
          }
          _rune = $decodeRune(_ref, _i);
          i = _i;
          n = (n - 1) >> 0;
          if (n < 0) {
            return $substring(s, 0, i);
          }
          _i += _rune[1];
        }
      }
      return s;
    };
    fmt.prototype.truncateString = function (s) {
      return this.$val.truncateString(s);
    };
    fmt.ptr.prototype.truncate = function (b) {
      var _tuple, b, f, i, n, wid;
      f = this;
      if (f.fmtFlags.precPresent) {
        n = f.prec;
        i = 0;
        while (true) {
          if (!(i < b.$length)) {
            break;
          }
          n = (n - 1) >> 0;
          if (n < 0) {
            return $subslice(b, 0, i);
          }
          wid = 1;
          if (
            (i < 0 || i >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + i]) >= 128
          ) {
            _tuple = utf8.DecodeRune($subslice(b, i));
            wid = _tuple[1];
          }
          i = (i + wid) >> 0;
        }
      }
      return b;
    };
    fmt.prototype.truncate = function (b) {
      return this.$val.truncate(b);
    };
    fmt.ptr.prototype.fmtS = function (s) {
      var f, s;
      f = this;
      s = f.truncateString(s);
      f.padString(s);
    };
    fmt.prototype.fmtS = function (s) {
      return this.$val.fmtS(s);
    };
    fmt.ptr.prototype.fmtBs = function (b) {
      var b, f;
      f = this;
      b = f.truncate(b);
      f.pad(b);
    };
    fmt.prototype.fmtBs = function (b) {
      return this.$val.fmtBs(b);
    };
    fmt.ptr.prototype.fmtSbx = function (s, b, digits) {
      var b, buf, c, digits, f, i, length, s, width;
      f = this;
      length = b.$length;
      if (b === sliceType$2.nil) {
        length = s.length;
      }
      if (f.fmtFlags.precPresent && f.prec < length) {
        length = f.prec;
      }
      width = $imul(2, length);
      if (width > 0) {
        if (f.fmtFlags.space) {
          if (f.fmtFlags.sharp) {
            width = $imul(width, 2);
          }
          width = (width + ((length - 1) >> 0)) >> 0;
        } else if (f.fmtFlags.sharp) {
          width = (width + 2) >> 0;
        }
      } else {
        if (f.fmtFlags.widPresent) {
          f.writePadding(f.wid);
        }
        return;
      }
      if (f.fmtFlags.widPresent && f.wid > width && !f.fmtFlags.minus) {
        f.writePadding((f.wid - width) >> 0);
      }
      buf = f.buf.$get();
      if (f.fmtFlags.sharp) {
        buf = $append(buf, 48, digits.charCodeAt(16));
      }
      c = 0;
      i = 0;
      while (true) {
        if (!(i < length)) {
          break;
        }
        if (f.fmtFlags.space && i > 0) {
          buf = $append(buf, 32);
          if (f.fmtFlags.sharp) {
            buf = $append(buf, 48, digits.charCodeAt(16));
          }
        }
        if (!(b === sliceType$2.nil)) {
          c =
            i < 0 || i >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + i];
        } else {
          c = s.charCodeAt(i);
        }
        buf = $append(
          buf,
          digits.charCodeAt(((c >>> 4) << 24) >>> 24),
          digits.charCodeAt((c & 15) >>> 0)
        );
        i = (i + 1) >> 0;
      }
      f.buf.$set(buf);
      if (f.fmtFlags.widPresent && f.wid > width && f.fmtFlags.minus) {
        f.writePadding((f.wid - width) >> 0);
      }
    };
    fmt.prototype.fmtSbx = function (s, b, digits) {
      return this.$val.fmtSbx(s, b, digits);
    };
    fmt.ptr.prototype.fmtSx = function (s, digits) {
      var digits, f, s;
      f = this;
      f.fmtSbx(s, sliceType$2.nil, digits);
    };
    fmt.prototype.fmtSx = function (s, digits) {
      return this.$val.fmtSx(s, digits);
    };
    fmt.ptr.prototype.fmtBx = function (b, digits) {
      var b, digits, f;
      f = this;
      f.fmtSbx("", b, digits);
    };
    fmt.prototype.fmtBx = function (b, digits) {
      return this.$val.fmtBx(b, digits);
    };
    fmt.ptr.prototype.fmtQ = function (s) {
      var buf, f, s;
      f = this;
      s = f.truncateString(s);
      if (f.fmtFlags.sharp && strconv.CanBackquote(s)) {
        f.padString("`" + s + "`");
        return;
      }
      buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
      if (f.fmtFlags.plus) {
        f.pad(strconv.AppendQuoteToASCII(buf, s));
      } else {
        f.pad(strconv.AppendQuote(buf, s));
      }
    };
    fmt.prototype.fmtQ = function (s) {
      return this.$val.fmtQ(s);
    };
    fmt.ptr.prototype.fmtC = function (c) {
      var buf, c, f, r, w;
      f = this;
      r = c.$low >> 0;
      if (c.$high > 0 || (c.$high === 0 && c.$low > 1114111)) {
        r = 65533;
      }
      buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
      w = utf8.EncodeRune($subslice(buf, 0, 4), r);
      f.pad($subslice(buf, 0, w));
    };
    fmt.prototype.fmtC = function (c) {
      return this.$val.fmtC(c);
    };
    fmt.ptr.prototype.fmtQc = function (c) {
      var buf, c, f, r;
      f = this;
      r = c.$low >> 0;
      if (c.$high > 0 || (c.$high === 0 && c.$low > 1114111)) {
        r = 65533;
      }
      buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
      if (f.fmtFlags.plus) {
        f.pad(strconv.AppendQuoteRuneToASCII(buf, r));
      } else {
        f.pad(strconv.AppendQuoteRune(buf, r));
      }
    };
    fmt.prototype.fmtQc = function (c) {
      return this.$val.fmtQc(c);
    };
    fmt.ptr.prototype.fmtFloat = function (v, size, verb, prec) {
      var _1,
        _2,
        digits,
        f,
        hasDecimalPoint,
        i,
        num,
        oldZero,
        prec,
        sawNonzeroDigit,
        size,
        tail,
        tailBuf,
        v,
        verb;
      f = this;
      if (f.fmtFlags.precPresent) {
        prec = f.prec;
      }
      num = strconv.AppendFloat(
        $subslice(new sliceType$2(f.intbuf), 0, 1),
        v,
        (verb << 24) >>> 24,
        prec,
        size
      );
      if (
        (1 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : num.$array[num.$offset + 1]) === 45 ||
        (1 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : num.$array[num.$offset + 1]) === 43
      ) {
        num = $subslice(num, 1);
      } else {
        0 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (num.$array[num.$offset + 0] = 43);
      }
      if (
        f.fmtFlags.space &&
        (0 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : num.$array[num.$offset + 0]) === 43 &&
        !f.fmtFlags.plus
      ) {
        0 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (num.$array[num.$offset + 0] = 32);
      }
      if (
        (1 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : num.$array[num.$offset + 1]) === 73 ||
        (1 >= num.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : num.$array[num.$offset + 1]) === 78
      ) {
        oldZero = f.fmtFlags.zero;
        f.fmtFlags.zero = false;
        if (
          (1 >= num.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : num.$array[num.$offset + 1]) === 78 &&
          !f.fmtFlags.space &&
          !f.fmtFlags.plus
        ) {
          num = $subslice(num, 1);
        }
        f.pad(num);
        f.fmtFlags.zero = oldZero;
        return;
      }
      if (f.fmtFlags.sharp && !(verb === 98)) {
        digits = 0;
        _1 = verb;
        if (_1 === 118 || _1 === 103 || _1 === 71 || _1 === 120) {
          digits = prec;
          if (digits === -1) {
            digits = 6;
          }
        }
        tailBuf = arrayType$3.zero();
        tail = $subslice(new sliceType$2(tailBuf), 0, 0);
        hasDecimalPoint = false;
        sawNonzeroDigit = false;
        i = 1;
        while (true) {
          if (!(i < num.$length)) {
            break;
          }
          switch (0) {
            default:
              _2 =
                i < 0 || i >= num.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : num.$array[num.$offset + i];
              if (_2 === 46) {
                hasDecimalPoint = true;
              } else if (_2 === 112 || _2 === 80) {
                tail = $appendSlice(tail, $subslice(num, i));
                num = $subslice(num, 0, i);
              } else if (_2 === 101 || _2 === 69) {
                if (!(verb === 120) && !(verb === 88)) {
                  tail = $appendSlice(tail, $subslice(num, i));
                  num = $subslice(num, 0, i);
                  break;
                }
                if (
                  !(
                    (i < 0 || i >= num.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : num.$array[num.$offset + i]) === 48
                  )
                ) {
                  sawNonzeroDigit = true;
                }
                if (sawNonzeroDigit) {
                  digits = (digits - 1) >> 0;
                }
              } else {
                if (
                  !(
                    (i < 0 || i >= num.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : num.$array[num.$offset + i]) === 48
                  )
                ) {
                  sawNonzeroDigit = true;
                }
                if (sawNonzeroDigit) {
                  digits = (digits - 1) >> 0;
                }
              }
          }
          i = (i + 1) >> 0;
        }
        if (!hasDecimalPoint) {
          if (
            num.$length === 2 &&
            (1 >= num.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : num.$array[num.$offset + 1]) === 48
          ) {
            digits = (digits - 1) >> 0;
          }
          num = $append(num, 46);
        }
        while (true) {
          if (!(digits > 0)) {
            break;
          }
          num = $append(num, 48);
          digits = (digits - 1) >> 0;
        }
        num = $appendSlice(num, tail);
      }
      if (
        f.fmtFlags.plus ||
        !(
          (0 >= num.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : num.$array[num.$offset + 0]) === 43
        )
      ) {
        if (f.fmtFlags.zero && f.fmtFlags.widPresent && f.wid > num.$length) {
          f.buf.writeByte(
            0 >= num.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : num.$array[num.$offset + 0]
          );
          f.writePadding((f.wid - num.$length) >> 0);
          f.buf.write($subslice(num, 1));
          return;
        }
        f.pad(num);
        return;
      }
      f.pad($subslice(num, 1));
    };
    fmt.prototype.fmtFloat = function (v, size, verb, prec) {
      return this.$val.fmtFloat(v, size, verb, prec);
    };
    Errorf = function (format, a) {
      var { _r, a, err, format, p, s, $s, $r, $c } = $restore(this, {
        format,
        a,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = newPrinter();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            p = _r;
            p.wrapErrs = true;
            $r = p.doPrintf(format, a);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            s = $bytesToString(p.buf);
            err = $ifaceNil;
            if ($interfaceIsEqual(p.wrappedErr, $ifaceNil)) {
              err = errors.New(s);
            } else {
              err = new wrapError.ptr(s, p.wrappedErr);
            }
            p.free();
            $s = -1;
            return err;
          /* */
        }
        return;
      }
      var $f = { $blk: Errorf, $c: true, $r, _r, a, err, format, p, s, $s };
      return $f;
    };
    $pkg.Errorf = Errorf;
    wrapError.ptr.prototype.Error = function () {
      var e;
      e = this;
      return e.msg;
    };
    wrapError.prototype.Error = function () {
      return this.$val.Error();
    };
    wrapError.ptr.prototype.Unwrap = function () {
      var e;
      e = this;
      return e.err;
    };
    wrapError.prototype.Unwrap = function () {
      return this.$val.Unwrap();
    };
    ptrType$4.methods = [
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "ReadRune",
        name: "ReadRune",
        pkg: "",
        typ: $funcType([], [$Int32, $Int, $error], false),
      },
      {
        prop: "Width",
        name: "Width",
        pkg: "",
        typ: $funcType([], [$Int, $Bool], false),
      },
      {
        prop: "getRune",
        name: "getRune",
        pkg: "fmt",
        typ: $funcType([], [$Int32], false),
      },
      {
        prop: "mustReadRune",
        name: "mustReadRune",
        pkg: "fmt",
        typ: $funcType([], [$Int32], false),
      },
      {
        prop: "UnreadRune",
        name: "UnreadRune",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
      {
        prop: "error",
        name: "error",
        pkg: "fmt",
        typ: $funcType([$error], [], false),
      },
      {
        prop: "errorString",
        name: "errorString",
        pkg: "fmt",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Token",
        name: "Token",
        pkg: "",
        typ: $funcType([$Bool, funcType], [sliceType$2, $error], false),
      },
      {
        prop: "free",
        name: "free",
        pkg: "fmt",
        typ: $funcType([ssave], [], false),
      },
      {
        prop: "SkipSpace",
        name: "SkipSpace",
        pkg: "",
        typ: $funcType([], [], false),
      },
      {
        prop: "token",
        name: "token",
        pkg: "fmt",
        typ: $funcType([$Bool, funcType], [sliceType$2], false),
      },
      {
        prop: "consume",
        name: "consume",
        pkg: "fmt",
        typ: $funcType([$String, $Bool], [$Bool], false),
      },
      {
        prop: "peek",
        name: "peek",
        pkg: "fmt",
        typ: $funcType([$String], [$Bool], false),
      },
      {
        prop: "notEOF",
        name: "notEOF",
        pkg: "fmt",
        typ: $funcType([], [], false),
      },
      {
        prop: "accept",
        name: "accept",
        pkg: "fmt",
        typ: $funcType([$String], [$Bool], false),
      },
      {
        prop: "okVerb",
        name: "okVerb",
        pkg: "fmt",
        typ: $funcType([$Int32, $String, $String], [$Bool], false),
      },
      {
        prop: "scanBool",
        name: "scanBool",
        pkg: "fmt",
        typ: $funcType([$Int32], [$Bool], false),
      },
      {
        prop: "getBase",
        name: "getBase",
        pkg: "fmt",
        typ: $funcType([$Int32], [$Int, $String], false),
      },
      {
        prop: "scanNumber",
        name: "scanNumber",
        pkg: "fmt",
        typ: $funcType([$String, $Bool], [$String], false),
      },
      {
        prop: "scanRune",
        name: "scanRune",
        pkg: "fmt",
        typ: $funcType([$Int], [$Int64], false),
      },
      {
        prop: "scanBasePrefix",
        name: "scanBasePrefix",
        pkg: "fmt",
        typ: $funcType([], [$Int, $String, $Bool], false),
      },
      {
        prop: "scanInt",
        name: "scanInt",
        pkg: "fmt",
        typ: $funcType([$Int32, $Int], [$Int64], false),
      },
      {
        prop: "scanUint",
        name: "scanUint",
        pkg: "fmt",
        typ: $funcType([$Int32, $Int], [$Uint64], false),
      },
      {
        prop: "floatToken",
        name: "floatToken",
        pkg: "fmt",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "complexTokens",
        name: "complexTokens",
        pkg: "fmt",
        typ: $funcType([], [$String, $String], false),
      },
      {
        prop: "convertFloat",
        name: "convertFloat",
        pkg: "fmt",
        typ: $funcType([$String, $Int], [$Float64], false),
      },
      {
        prop: "scanComplex",
        name: "scanComplex",
        pkg: "fmt",
        typ: $funcType([$Int32, $Int], [$Complex128], false),
      },
      {
        prop: "convertString",
        name: "convertString",
        pkg: "fmt",
        typ: $funcType([$Int32], [$String], false),
      },
      {
        prop: "quotedString",
        name: "quotedString",
        pkg: "fmt",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "hexByte",
        name: "hexByte",
        pkg: "fmt",
        typ: $funcType([], [$Uint8, $Bool], false),
      },
      {
        prop: "hexString",
        name: "hexString",
        pkg: "fmt",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "scanPercent",
        name: "scanPercent",
        pkg: "fmt",
        typ: $funcType([], [], false),
      },
      {
        prop: "scanOne",
        name: "scanOne",
        pkg: "fmt",
        typ: $funcType([$Int32, $emptyInterface], [], false),
      },
      {
        prop: "doScan",
        name: "doScan",
        pkg: "fmt",
        typ: $funcType([sliceType$1], [$Int, $error], false),
      },
      {
        prop: "advance",
        name: "advance",
        pkg: "fmt",
        typ: $funcType([$String], [$Int], false),
      },
      {
        prop: "doScanf",
        name: "doScanf",
        pkg: "fmt",
        typ: $funcType([$String, sliceType$1], [$Int, $error], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "write",
        name: "write",
        pkg: "fmt",
        typ: $funcType([sliceType$2], [], false),
      },
      {
        prop: "writeString",
        name: "writeString",
        pkg: "fmt",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "writeByte",
        name: "writeByte",
        pkg: "fmt",
        typ: $funcType([$Uint8], [], false),
      },
      {
        prop: "writeRune",
        name: "writeRune",
        pkg: "fmt",
        typ: $funcType([$Int32], [], false),
      },
    ];
    ptrType$24.methods = [
      { prop: "free", name: "free", pkg: "fmt", typ: $funcType([], [], false) },
      {
        prop: "Width",
        name: "Width",
        pkg: "",
        typ: $funcType([], [$Int, $Bool], false),
      },
      {
        prop: "Precision",
        name: "Precision",
        pkg: "",
        typ: $funcType([], [$Int, $Bool], false),
      },
      {
        prop: "Flag",
        name: "Flag",
        pkg: "",
        typ: $funcType([$Int], [$Bool], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "WriteString",
        name: "WriteString",
        pkg: "",
        typ: $funcType([$String], [$Int, $error], false),
      },
      {
        prop: "unknownType",
        name: "unknownType",
        pkg: "fmt",
        typ: $funcType([reflect.Value], [], false),
      },
      {
        prop: "badVerb",
        name: "badVerb",
        pkg: "fmt",
        typ: $funcType([$Int32], [], false),
      },
      {
        prop: "fmtBool",
        name: "fmtBool",
        pkg: "fmt",
        typ: $funcType([$Bool, $Int32], [], false),
      },
      {
        prop: "fmt0x64",
        name: "fmt0x64",
        pkg: "fmt",
        typ: $funcType([$Uint64, $Bool], [], false),
      },
      {
        prop: "fmtInteger",
        name: "fmtInteger",
        pkg: "fmt",
        typ: $funcType([$Uint64, $Bool, $Int32], [], false),
      },
      {
        prop: "fmtFloat",
        name: "fmtFloat",
        pkg: "fmt",
        typ: $funcType([$Float64, $Int, $Int32], [], false),
      },
      {
        prop: "fmtComplex",
        name: "fmtComplex",
        pkg: "fmt",
        typ: $funcType([$Complex128, $Int, $Int32], [], false),
      },
      {
        prop: "fmtString",
        name: "fmtString",
        pkg: "fmt",
        typ: $funcType([$String, $Int32], [], false),
      },
      {
        prop: "fmtBytes",
        name: "fmtBytes",
        pkg: "fmt",
        typ: $funcType([sliceType$2, $Int32, $String], [], false),
      },
      {
        prop: "fmtPointer",
        name: "fmtPointer",
        pkg: "fmt",
        typ: $funcType([reflect.Value, $Int32], [], false),
      },
      {
        prop: "catchPanic",
        name: "catchPanic",
        pkg: "fmt",
        typ: $funcType([$emptyInterface, $Int32, $String], [], false),
      },
      {
        prop: "handleMethods",
        name: "handleMethods",
        pkg: "fmt",
        typ: $funcType([$Int32], [$Bool], false),
      },
      {
        prop: "printArg",
        name: "printArg",
        pkg: "fmt",
        typ: $funcType([$emptyInterface, $Int32], [], false),
      },
      {
        prop: "printValue",
        name: "printValue",
        pkg: "fmt",
        typ: $funcType([reflect.Value, $Int32, $Int], [], false),
      },
      {
        prop: "argNumber",
        name: "argNumber",
        pkg: "fmt",
        typ: $funcType([$Int, $String, $Int, $Int], [$Int, $Int, $Bool], false),
      },
      {
        prop: "badArgNum",
        name: "badArgNum",
        pkg: "fmt",
        typ: $funcType([$Int32], [], false),
      },
      {
        prop: "missingArg",
        name: "missingArg",
        pkg: "fmt",
        typ: $funcType([$Int32], [], false),
      },
      {
        prop: "doPrintf",
        name: "doPrintf",
        pkg: "fmt",
        typ: $funcType([$String, sliceType$1], [], false),
      },
      {
        prop: "doPrint",
        name: "doPrint",
        pkg: "fmt",
        typ: $funcType([sliceType$1], [], false),
      },
      {
        prop: "doPrintln",
        name: "doPrintln",
        pkg: "fmt",
        typ: $funcType([sliceType$1], [], false),
      },
    ];
    ptrType$26.methods = [
      {
        prop: "clearflags",
        name: "clearflags",
        pkg: "fmt",
        typ: $funcType([], [], false),
      },
      {
        prop: "init",
        name: "init",
        pkg: "fmt",
        typ: $funcType([ptrType$1], [], false),
      },
      {
        prop: "writePadding",
        name: "writePadding",
        pkg: "fmt",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "pad",
        name: "pad",
        pkg: "fmt",
        typ: $funcType([sliceType$2], [], false),
      },
      {
        prop: "padString",
        name: "padString",
        pkg: "fmt",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "fmtBoolean",
        name: "fmtBoolean",
        pkg: "fmt",
        typ: $funcType([$Bool], [], false),
      },
      {
        prop: "fmtUnicode",
        name: "fmtUnicode",
        pkg: "fmt",
        typ: $funcType([$Uint64], [], false),
      },
      {
        prop: "fmtInteger",
        name: "fmtInteger",
        pkg: "fmt",
        typ: $funcType([$Uint64, $Int, $Bool, $Int32, $String], [], false),
      },
      {
        prop: "truncateString",
        name: "truncateString",
        pkg: "fmt",
        typ: $funcType([$String], [$String], false),
      },
      {
        prop: "truncate",
        name: "truncate",
        pkg: "fmt",
        typ: $funcType([sliceType$2], [sliceType$2], false),
      },
      {
        prop: "fmtS",
        name: "fmtS",
        pkg: "fmt",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "fmtBs",
        name: "fmtBs",
        pkg: "fmt",
        typ: $funcType([sliceType$2], [], false),
      },
      {
        prop: "fmtSbx",
        name: "fmtSbx",
        pkg: "fmt",
        typ: $funcType([$String, sliceType$2, $String], [], false),
      },
      {
        prop: "fmtSx",
        name: "fmtSx",
        pkg: "fmt",
        typ: $funcType([$String, $String], [], false),
      },
      {
        prop: "fmtBx",
        name: "fmtBx",
        pkg: "fmt",
        typ: $funcType([sliceType$2, $String], [], false),
      },
      {
        prop: "fmtQ",
        name: "fmtQ",
        pkg: "fmt",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "fmtC",
        name: "fmtC",
        pkg: "fmt",
        typ: $funcType([$Uint64], [], false),
      },
      {
        prop: "fmtQc",
        name: "fmtQc",
        pkg: "fmt",
        typ: $funcType([$Uint64], [], false),
      },
      {
        prop: "fmtFloat",
        name: "fmtFloat",
        pkg: "fmt",
        typ: $funcType([$Float64, $Int, $Int32, $Int], [], false),
      },
    ];
    ptrType$27.methods = [
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Unwrap",
        name: "Unwrap",
        pkg: "",
        typ: $funcType([], [$error], false),
      },
    ];
    scanError.init("fmt", [
      {
        prop: "err",
        name: "err",
        embedded: false,
        exported: false,
        typ: $error,
        tag: "",
      },
    ]);
    ss.init("fmt", [
      {
        prop: "rs",
        name: "rs",
        embedded: false,
        exported: false,
        typ: io.RuneScanner,
        tag: "",
      },
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: buffer,
        tag: "",
      },
      {
        prop: "count",
        name: "count",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "atEOF",
        name: "atEOF",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "ssave",
        name: "ssave",
        embedded: true,
        exported: false,
        typ: ssave,
        tag: "",
      },
    ]);
    ssave.init("fmt", [
      {
        prop: "validSave",
        name: "validSave",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "nlIsEnd",
        name: "nlIsEnd",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "nlIsSpace",
        name: "nlIsSpace",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "argLimit",
        name: "argLimit",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "limit",
        name: "limit",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "maxWid",
        name: "maxWid",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    State.init([
      {
        prop: "Flag",
        name: "Flag",
        pkg: "",
        typ: $funcType([$Int], [$Bool], false),
      },
      {
        prop: "Precision",
        name: "Precision",
        pkg: "",
        typ: $funcType([], [$Int, $Bool], false),
      },
      {
        prop: "Width",
        name: "Width",
        pkg: "",
        typ: $funcType([], [$Int, $Bool], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
    ]);
    Formatter.init([
      {
        prop: "Format",
        name: "Format",
        pkg: "",
        typ: $funcType([State, $Int32], [], false),
      },
    ]);
    Stringer.init([
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ]);
    GoStringer.init([
      {
        prop: "GoString",
        name: "GoString",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ]);
    buffer.init($Uint8);
    pp.init("fmt", [
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: buffer,
        tag: "",
      },
      {
        prop: "arg",
        name: "arg",
        embedded: false,
        exported: false,
        typ: $emptyInterface,
        tag: "",
      },
      {
        prop: "value",
        name: "value",
        embedded: false,
        exported: false,
        typ: reflect.Value,
        tag: "",
      },
      {
        prop: "fmt",
        name: "fmt",
        embedded: false,
        exported: false,
        typ: fmt,
        tag: "",
      },
      {
        prop: "reordered",
        name: "reordered",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "goodArgNum",
        name: "goodArgNum",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "panicking",
        name: "panicking",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "erroring",
        name: "erroring",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "wrapErrs",
        name: "wrapErrs",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "wrappedErr",
        name: "wrappedErr",
        embedded: false,
        exported: false,
        typ: $error,
        tag: "",
      },
    ]);
    fmtFlags.init("fmt", [
      {
        prop: "widPresent",
        name: "widPresent",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "precPresent",
        name: "precPresent",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "minus",
        name: "minus",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "plus",
        name: "plus",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "sharp",
        name: "sharp",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "space",
        name: "space",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "zero",
        name: "zero",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "plusV",
        name: "plusV",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "sharpV",
        name: "sharpV",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
    ]);
    fmt.init("fmt", [
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "fmtFlags",
        name: "fmtFlags",
        embedded: true,
        exported: false,
        typ: fmtFlags,
        tag: "",
      },
      {
        prop: "wid",
        name: "wid",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "prec",
        name: "prec",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "intbuf",
        name: "intbuf",
        embedded: false,
        exported: false,
        typ: arrayType$1,
        tag: "",
      },
    ]);
    wrapError.init("fmt", [
      {
        prop: "msg",
        name: "msg",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "err",
        name: "err",
        embedded: false,
        exported: false,
        typ: $error,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = fmtsort.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = math.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = os.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = reflect.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strconv.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            space = new sliceType([
              $toNativeArray($kindUint16, [9, 13]),
              $toNativeArray($kindUint16, [32, 32]),
              $toNativeArray($kindUint16, [133, 133]),
              $toNativeArray($kindUint16, [160, 160]),
              $toNativeArray($kindUint16, [5760, 5760]),
              $toNativeArray($kindUint16, [8192, 8202]),
              $toNativeArray($kindUint16, [8232, 8233]),
              $toNativeArray($kindUint16, [8239, 8239]),
              $toNativeArray($kindUint16, [8287, 8287]),
              $toNativeArray($kindUint16, [12288, 12288]),
            ]);
            ssFree = new sync.Pool.ptr(sliceType$1.nil, function () {
              return new ss.ptr(
                $ifaceNil,
                buffer.nil,
                0,
                false,
                new ssave.ptr(false, false, false, 0, 0, 0)
              );
            });
            complexError = errors.New("syntax error scanning complex number");
            boolError = errors.New("syntax error scanning boolean");
            ppFree = new sync.Pool.ptr(sliceType$1.nil, function () {
              return new pp.ptr(
                buffer.nil,
                $ifaceNil,
                new reflect.Value.ptr(ptrType.nil, 0, 0),
                new fmt.ptr(
                  ptrType$1.nil,
                  new fmtFlags.ptr(
                    false,
                    false,
                    false,
                    false,
                    false,
                    false,
                    false,
                    false,
                    false
                  ),
                  0,
                  0,
                  arrayType$1.zero()
                ),
                false,
                false,
                false,
                false,
                false,
                $ifaceNil
              );
            });
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["bytes"] = (function () {
    var $pkg = {},
      $init,
      errors,
      bytealg,
      io,
      unicode,
      utf8,
      errNegativeRead,
      errUnreadByte,
      Equal,
      LastIndexByte,
      HasPrefix;
    errors = $packages["errors"];
    bytealg = $packages["internal/bytealg"];
    io = $packages["io"];
    unicode = $packages["unicode"];
    utf8 = $packages["unicode/utf8"];
    Equal = function (a, b) {
      var _i, _ref, a, b, c, i;
      if (!(a.$length === b.$length)) {
        return false;
      }
      _ref = a;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        c =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (
          !(
            c ===
            (i < 0 || i >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + i])
          )
        ) {
          return false;
        }
        _i++;
      }
      return true;
    };
    $pkg.Equal = Equal;
    LastIndexByte = function (s, c) {
      var c, i, s;
      i = (s.$length - 1) >> 0;
      while (true) {
        if (!(i >= 0)) {
          break;
        }
        if (
          (i < 0 || i >= s.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : s.$array[s.$offset + i]) === c
        ) {
          return i;
        }
        i = (i - 1) >> 0;
      }
      return -1;
    };
    $pkg.LastIndexByte = LastIndexByte;
    HasPrefix = function (s, prefix) {
      var prefix, s;
      return (
        s.$length >= prefix.$length &&
        Equal($subslice(s, 0, prefix.$length), prefix)
      );
    };
    $pkg.HasPrefix = HasPrefix;
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bytealg.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unicode.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
            errNegativeRead = errors.New(
              "bytes.Buffer: reader returned negative count from Read"
            );
            errUnreadByte = errors.New(
              "bytes.Buffer: UnreadByte: previous operation was not a successful read"
            );
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["go/token"] = (function () {
    var $pkg = {},
      $init,
      fmt,
      nosync,
      sort,
      strconv,
      unicode,
      utf8,
      Token,
      serializedFile,
      serializedFileSet,
      Position,
      Pos,
      File,
      lineInfo,
      FileSet,
      sliceType,
      ptrType,
      sliceType$1,
      ptrType$1,
      sliceType$2,
      sliceType$3,
      sliceType$4,
      ptrType$2,
      sliceType$5,
      funcType,
      funcType$1,
      tokens,
      keywords,
      init,
      Lookup,
      searchLineInfos,
      NewFileSet,
      searchFiles,
      searchInts;
    fmt = $packages["fmt"];
    nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
    sort = $packages["sort"];
    strconv = $packages["strconv"];
    unicode = $packages["unicode"];
    utf8 = $packages["unicode/utf8"];
    Token = $pkg.Token = $newType(
      4,
      $kindInt,
      "token.Token",
      true,
      "go/token",
      true,
      null
    );
    serializedFile = $pkg.serializedFile = $newType(
      0,
      $kindStruct,
      "token.serializedFile",
      true,
      "go/token",
      false,
      function (Name_, Base_, Size_, Lines_, Infos_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Name = "";
          this.Base = 0;
          this.Size = 0;
          this.Lines = sliceType$2.nil;
          this.Infos = sliceType$3.nil;
          return;
        }
        this.Name = Name_;
        this.Base = Base_;
        this.Size = Size_;
        this.Lines = Lines_;
        this.Infos = Infos_;
      }
    );
    serializedFileSet = $pkg.serializedFileSet = $newType(
      0,
      $kindStruct,
      "token.serializedFileSet",
      true,
      "go/token",
      false,
      function (Base_, Files_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Base = 0;
          this.Files = sliceType.nil;
          return;
        }
        this.Base = Base_;
        this.Files = Files_;
      }
    );
    Position = $pkg.Position = $newType(
      0,
      $kindStruct,
      "token.Position",
      true,
      "go/token",
      true,
      function (Filename_, Offset_, Line_, Column_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Filename = "";
          this.Offset = 0;
          this.Line = 0;
          this.Column = 0;
          return;
        }
        this.Filename = Filename_;
        this.Offset = Offset_;
        this.Line = Line_;
        this.Column = Column_;
      }
    );
    Pos = $pkg.Pos = $newType(
      4,
      $kindInt,
      "token.Pos",
      true,
      "go/token",
      true,
      null
    );
    File = $pkg.File = $newType(
      0,
      $kindStruct,
      "token.File",
      true,
      "go/token",
      true,
      function (set_, name_, base_, size_, mutex_, lines_, infos_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.set = ptrType$1.nil;
          this.name = "";
          this.base = 0;
          this.size = 0;
          this.mutex = new nosync.Mutex.ptr(false);
          this.lines = sliceType$2.nil;
          this.infos = sliceType$3.nil;
          return;
        }
        this.set = set_;
        this.name = name_;
        this.base = base_;
        this.size = size_;
        this.mutex = mutex_;
        this.lines = lines_;
        this.infos = infos_;
      }
    );
    lineInfo = $pkg.lineInfo = $newType(
      0,
      $kindStruct,
      "token.lineInfo",
      true,
      "go/token",
      false,
      function (Offset_, Filename_, Line_, Column_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.Offset = 0;
          this.Filename = "";
          this.Line = 0;
          this.Column = 0;
          return;
        }
        this.Offset = Offset_;
        this.Filename = Filename_;
        this.Line = Line_;
        this.Column = Column_;
      }
    );
    FileSet = $pkg.FileSet = $newType(
      0,
      $kindStruct,
      "token.FileSet",
      true,
      "go/token",
      true,
      function (mutex_, base_, files_, last_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.mutex = new nosync.RWMutex.ptr(false, 0);
          this.base = 0;
          this.files = sliceType$1.nil;
          this.last = ptrType.nil;
          return;
        }
        this.mutex = mutex_;
        this.base = base_;
        this.files = files_;
        this.last = last_;
      }
    );
    sliceType = $sliceType(serializedFile);
    ptrType = $ptrType(File);
    sliceType$1 = $sliceType(ptrType);
    ptrType$1 = $ptrType(FileSet);
    sliceType$2 = $sliceType($Int);
    sliceType$3 = $sliceType(lineInfo);
    sliceType$4 = $sliceType($emptyInterface);
    ptrType$2 = $ptrType(Position);
    sliceType$5 = $sliceType($Uint8);
    funcType = $funcType([$emptyInterface], [$error], false);
    funcType$1 = $funcType([ptrType], [$Bool], false);
    Token.prototype.String = function () {
      var s, tok;
      tok = this.$val;
      s = "";
      if (0 <= tok && tok < 89) {
        s =
          tok < 0 || tok >= tokens.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : tokens[tok];
      }
      if (s === "") {
        s = "token(" + strconv.Itoa(tok >> 0) + ")";
      }
      return s;
    };
    $ptrType(Token).prototype.String = function () {
      return new Token(this.$get()).String();
    };
    Token.prototype.Precedence = function () {
      var _1, op;
      op = this.$val;
      _1 = op;
      if (_1 === 35) {
        return 1;
      } else if (_1 === 34) {
        return 2;
      } else if (
        _1 === 39 ||
        _1 === 44 ||
        _1 === 40 ||
        _1 === 45 ||
        _1 === 41 ||
        _1 === 46
      ) {
        return 3;
      } else if (_1 === 12 || _1 === 13 || _1 === 18 || _1 === 19) {
        return 4;
      } else if (
        _1 === 14 ||
        _1 === 15 ||
        _1 === 16 ||
        _1 === 20 ||
        _1 === 21 ||
        _1 === 17 ||
        _1 === 22
      ) {
        return 5;
      }
      return 0;
    };
    $ptrType(Token).prototype.Precedence = function () {
      return new Token(this.$get()).Precedence();
    };
    init = function () {
      var _key, i;
      keywords = new $global.Map();
      i = 61;
      while (true) {
        if (!(i < 86)) {
          break;
        }
        _key =
          i < 0 || i >= tokens.length
            ? ($throwRuntimeError("index out of range"), undefined)
            : tokens[i];
        (keywords || $throwRuntimeError("assignment to entry in nil map")).set(
          $String.keyFor(_key),
          { k: _key, v: i }
        );
        i = (i + 1) >> 0;
      }
    };
    Lookup = function (ident) {
      var _entry, _tuple, ident, is_keyword, tok;
      _tuple =
        ((_entry = $mapIndex(keywords, $String.keyFor(ident))),
        _entry !== undefined ? [_entry.v, true] : [0, false]);
      tok = _tuple[0];
      is_keyword = _tuple[1];
      if (is_keyword) {
        return tok;
      }
      return 4;
    };
    $pkg.Lookup = Lookup;
    Token.prototype.IsLiteral = function () {
      var tok;
      tok = this.$val;
      return 3 < tok && tok < 10;
    };
    $ptrType(Token).prototype.IsLiteral = function () {
      return new Token(this.$get()).IsLiteral();
    };
    Token.prototype.IsOperator = function () {
      var tok;
      tok = this.$val;
      return (11 < tok && tok < 59) || tok === 88;
    };
    $ptrType(Token).prototype.IsOperator = function () {
      return new Token(this.$get()).IsOperator();
    };
    Token.prototype.IsKeyword = function () {
      var tok;
      tok = this.$val;
      return 60 < tok && tok < 86;
    };
    $ptrType(Token).prototype.IsKeyword = function () {
      return new Token(this.$get()).IsKeyword();
    };
    FileSet.ptr.prototype.Read = function (decode) {
      var { _r, decode, err, f, files, i, s, ss, x, $s, $r, $c } = $restore(
        this,
        { decode }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            ss = [ss];
            s = this;
            ss[0] = new serializedFileSet.ptr(0, sliceType.nil);
            _r = decode(ss[0]);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            err = _r;
            if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return err;
            }
            s.mutex.Lock();
            s.base = ss[0].Base;
            files = $makeSlice(sliceType$1, ss[0].Files.$length);
            i = 0;
            while (true) {
              if (!(i < ss[0].Files.$length)) {
                break;
              }
              f =
                ((x = ss[0].Files),
                i < 0 || i >= x.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x.$array[x.$offset + i]);
              i < 0 || i >= files.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : (files.$array[files.$offset + i] = new File.ptr(
                    s,
                    f.Name,
                    f.Base,
                    f.Size,
                    new nosync.Mutex.ptr(false),
                    f.Lines,
                    f.Infos
                  ));
              i = (i + 1) >> 0;
            }
            s.files = files;
            s.last = ptrType.nil;
            s.mutex.Unlock();
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.Read,
        $c: true,
        $r,
        _r,
        decode,
        err,
        f,
        files,
        i,
        s,
        ss,
        x,
        $s,
      };
      return $f;
    };
    FileSet.prototype.Read = function (decode) {
      return this.$val.Read(decode);
    };
    FileSet.ptr.prototype.Write = function (encode) {
      var { $24r, _i, _r, _ref, encode, f, files, i, s, ss, $s, $r, $c } =
        $restore(this, { encode });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            ss = new serializedFileSet.ptr(0, sliceType.nil);
            s.mutex.Lock();
            ss.Base = s.base;
            files = $makeSlice(sliceType, s.files.$length);
            _ref = s.files;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              i = _i;
              f =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              f.mutex.Lock();
              serializedFile.copy(
                i < 0 || i >= files.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : files.$array[files.$offset + i],
                new serializedFile.ptr(
                  f.name,
                  f.base,
                  f.size,
                  $appendSlice(sliceType$2.nil, f.lines),
                  $appendSlice(sliceType$3.nil, f.infos)
                )
              );
              f.mutex.Unlock();
              _i++;
            }
            ss.Files = files;
            s.mutex.Unlock();
            _r = encode(new ss.constructor.elem(ss));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.Write,
        $c: true,
        $r,
        $24r,
        _i,
        _r,
        _ref,
        encode,
        f,
        files,
        i,
        s,
        ss,
        $s,
      };
      return $f;
    };
    FileSet.prototype.Write = function (encode) {
      return this.$val.Write(encode);
    };
    Position.ptr.prototype.IsValid = function () {
      var pos;
      pos = this;
      return pos.Line > 0;
    };
    Position.prototype.IsValid = function () {
      return this.$val.IsValid();
    };
    Position.ptr.prototype.String = function () {
      var { _r, _r$1, pos, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = this;
            s = pos.Filename;
            /* */ if (pos.IsValid()) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (pos.IsValid()) { */ case 1:
            if (!(s === "")) {
              s = s + ":";
            }
            _r = fmt.Sprintf("%d", new sliceType$4([new $Int(pos.Line)]));
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            s = s + _r;
            /* */ if (!(pos.Column === 0)) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (!((pos.Column === 0))) { */ case 4:
            _r$1 = fmt.Sprintf(":%d", new sliceType$4([new $Int(pos.Column)]));
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            s = s + _r$1;
          /* } */ case 5:
          /* } */ case 2:
            if (s === "") {
              s = "-";
            }
            $s = -1;
            return s;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Position.ptr.prototype.String,
        $c: true,
        $r,
        _r,
        _r$1,
        pos,
        s,
        $s,
      };
      return $f;
    };
    Position.prototype.String = function () {
      return this.$val.String();
    };
    Pos.prototype.IsValid = function () {
      var p;
      p = this.$val;
      return !(p === 0);
    };
    $ptrType(Pos).prototype.IsValid = function () {
      return new Pos(this.$get()).IsValid();
    };
    File.ptr.prototype.Name = function () {
      var f;
      f = this;
      return f.name;
    };
    File.prototype.Name = function () {
      return this.$val.Name();
    };
    File.ptr.prototype.Base = function () {
      var f;
      f = this;
      return f.base;
    };
    File.prototype.Base = function () {
      return this.$val.Base();
    };
    File.ptr.prototype.Size = function () {
      var f;
      f = this;
      return f.size;
    };
    File.prototype.Size = function () {
      return this.$val.Size();
    };
    File.ptr.prototype.LineCount = function () {
      var f, n;
      f = this;
      f.mutex.Lock();
      n = f.lines.$length;
      f.mutex.Unlock();
      return n;
    };
    File.prototype.LineCount = function () {
      return this.$val.LineCount();
    };
    File.ptr.prototype.AddLine = function (offset) {
      var f, i, offset, x, x$1;
      f = this;
      f.mutex.Lock();
      i = f.lines.$length;
      if (
        (i === 0 ||
          ((x = f.lines),
          (x$1 = (i - 1) >> 0),
          x$1 < 0 || x$1 >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + x$1]) < offset) &&
        offset < f.size
      ) {
        f.lines = $append(f.lines, offset);
      }
      f.mutex.Unlock();
    };
    File.prototype.AddLine = function (offset) {
      return this.$val.AddLine(offset);
    };
    File.ptr.prototype.MergeLine = function (line) {
      var { _r, _r$1, f, line, $s, $deferred, $r, $c } = $restore(this, {
        line,
      });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              f = this;
              /* */ if (line < 1) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (line < 1) { */ case 1:
              _r = fmt.Sprintf(
                "invalid line number %d (should be >= 1)",
                new sliceType$4([new $Int(line)])
              );
              /* */ $s = 3;
            case 3:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r));
            /* } */ case 2:
              f.mutex.Lock();
              $deferred.push([$methodVal(f.mutex, "Unlock"), []]);
              /* */ if (line >= f.lines.$length) {
                $s = 4;
                continue;
              }
              /* */ $s = 5;
              continue;
            /* if (line >= f.lines.$length) { */ case 4:
              _r$1 = fmt.Sprintf(
                "invalid line number %d (should be < %d)",
                new sliceType$4([new $Int(line), new $Int(f.lines.$length)])
              );
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r$1));
            /* } */ case 5:
              $copySlice(
                $subslice(f.lines, line),
                $subslice(f.lines, (line + 1) >> 0)
              );
              f.lines = $subslice(f.lines, 0, (f.lines.$length - 1) >> 0);
              $s = -1;
              return;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: File.ptr.prototype.MergeLine,
            $c: true,
            $r,
            _r,
            _r$1,
            f,
            line,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    File.prototype.MergeLine = function (line) {
      return this.$val.MergeLine(line);
    };
    File.ptr.prototype.SetLines = function (lines) {
      var _i, _ref, f, i, lines, offset, size, x;
      f = this;
      size = f.size;
      _ref = lines;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        offset =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (
          (i > 0 &&
            offset <=
              ((x = (i - 1) >> 0),
              x < 0 || x >= lines.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : lines.$array[lines.$offset + x])) ||
          size <= offset
        ) {
          return false;
        }
        _i++;
      }
      f.mutex.Lock();
      f.lines = lines;
      f.mutex.Unlock();
      return true;
    };
    File.prototype.SetLines = function (lines) {
      return this.$val.SetLines(lines);
    };
    File.ptr.prototype.SetLinesForContent = function (content) {
      var _i, _ref, b, content, f, line, lines, offset;
      f = this;
      lines = sliceType$2.nil;
      line = 0;
      _ref = content;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        offset = _i;
        b =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (line >= 0) {
          lines = $append(lines, line);
        }
        line = -1;
        if (b === 10) {
          line = (offset + 1) >> 0;
        }
        _i++;
      }
      f.mutex.Lock();
      f.lines = lines;
      f.mutex.Unlock();
    };
    File.prototype.SetLinesForContent = function (content) {
      return this.$val.SetLinesForContent(content);
    };
    File.ptr.prototype.LineStart = function (line) {
      var { $24r, _r, _r$1, f, line, x, x$1, $s, $deferred, $r, $c } = $restore(
        this,
        { line }
      );
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              f = this;
              /* */ if (line < 1) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (line < 1) { */ case 1:
              _r = fmt.Sprintf(
                "invalid line number %d (should be >= 1)",
                new sliceType$4([new $Int(line)])
              );
              /* */ $s = 3;
            case 3:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r));
            /* } */ case 2:
              f.mutex.Lock();
              $deferred.push([$methodVal(f.mutex, "Unlock"), []]);
              /* */ if (line > f.lines.$length) {
                $s = 4;
                continue;
              }
              /* */ $s = 5;
              continue;
            /* if (line > f.lines.$length) { */ case 4:
              _r$1 = fmt.Sprintf(
                "invalid line number %d (should be < %d)",
                new sliceType$4([new $Int(line), new $Int(f.lines.$length)])
              );
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r$1));
            /* } */ case 5:
              $24r =
                ((f.base +
                  ((x = f.lines),
                  (x$1 = (line - 1) >> 0),
                  x$1 < 0 || x$1 >= x.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : x.$array[x.$offset + x$1])) >>
                  0) >>
                0;
              $s = 7;
            case 7:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return 0;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: File.ptr.prototype.LineStart,
            $c: true,
            $r,
            $24r,
            _r,
            _r$1,
            f,
            line,
            x,
            x$1,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    File.prototype.LineStart = function (line) {
      return this.$val.LineStart(line);
    };
    File.ptr.prototype.AddLineInfo = function (offset, filename, line) {
      var f, filename, line, offset;
      f = this;
      f.AddLineColumnInfo(offset, filename, line, 1);
    };
    File.prototype.AddLineInfo = function (offset, filename, line) {
      return this.$val.AddLineInfo(offset, filename, line);
    };
    File.ptr.prototype.AddLineColumnInfo = function (
      offset,
      filename,
      line,
      column
    ) {
      var column, f, filename, i, line, offset, x, x$1;
      f = this;
      f.mutex.Lock();
      i = f.infos.$length;
      if (
        i === 0 ||
        (((x = f.infos),
        (x$1 = (i - 1) >> 0),
        x$1 < 0 || x$1 >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : x.$array[x.$offset + x$1]).Offset < offset &&
          offset < f.size)
      ) {
        f.infos = $append(
          f.infos,
          new lineInfo.ptr(offset, filename, line, column)
        );
      }
      f.mutex.Unlock();
    };
    File.prototype.AddLineColumnInfo = function (
      offset,
      filename,
      line,
      column
    ) {
      return this.$val.AddLineColumnInfo(offset, filename, line, column);
    };
    File.ptr.prototype.Pos = function (offset) {
      var { _r, f, offset, $s, $r, $c } = $restore(this, { offset });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            /* */ if (offset > f.size) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (offset > f.size) { */ case 1:
            _r = fmt.Sprintf(
              "invalid file offset %d (should be <= %d)",
              new sliceType$4([new $Int(offset), new $Int(f.size)])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(new $String(_r));
          /* } */ case 2:
            $s = -1;
            return ((f.base + offset) >> 0) >> 0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Pos,
        $c: true,
        $r,
        _r,
        f,
        offset,
        $s,
      };
      return $f;
    };
    File.prototype.Pos = function (offset) {
      return this.$val.Pos(offset);
    };
    File.ptr.prototype.Offset = function (p) {
      var { _r, f, p, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            /* */ if (p >> 0 < f.base || p >> 0 > (f.base + f.size) >> 0) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (((p >> 0)) < f.base || ((p >> 0)) > (f.base + f.size >> 0)) { */ case 1:
            _r = fmt.Sprintf(
              "invalid Pos value %d (should be in [%d, %d])",
              new sliceType$4([
                new Pos(p),
                new $Int(f.base),
                new $Int((f.base + f.size) >> 0),
              ])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(new $String(_r));
          /* } */ case 2:
            $s = -1;
            return ((p >> 0) - f.base) >> 0;
          /* */
        }
        return;
      }
      var $f = { $blk: File.ptr.prototype.Offset, $c: true, $r, _r, f, p, $s };
      return $f;
    };
    File.prototype.Offset = function (p) {
      return this.$val.Offset(p);
    };
    File.ptr.prototype.Line = function (p) {
      var { $24r, _r, f, p, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = this;
            _r = f.Position(p);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r.Line;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Line,
        $c: true,
        $r,
        $24r,
        _r,
        f,
        p,
        $s,
      };
      return $f;
    };
    File.prototype.Line = function (p) {
      return this.$val.Line(p);
    };
    searchLineInfos = function (a, x) {
      var { $24r, _r, a, x, $s, $r, $c } = $restore(this, { a, x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            a = [a];
            x = [x];
            _r = sort.Search(
              a[0].$length,
              (function (a, x) {
                return function (i) {
                  var i;
                  return (
                    (i < 0 || i >= a[0].$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : a[0].$array[a[0].$offset + i]
                    ).Offset > x[0]
                  );
                };
              })(a, x)
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = (_r - 1) >> 0;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: searchLineInfos, $c: true, $r, $24r, _r, a, x, $s };
      return $f;
    };
    File.ptr.prototype.unpack = function (offset, adjusted) {
      var {
        $24r,
        _r,
        _tmp,
        _tmp$1,
        adjusted,
        alt,
        column,
        d,
        f,
        filename,
        i,
        i$1,
        i$2,
        line,
        offset,
        x,
        x$1,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { offset, adjusted });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              filename = "";
              line = 0;
              column = 0;
              f = this;
              f.mutex.Lock();
              $deferred.push([$methodVal(f.mutex, "Unlock"), []]);
              filename = f.name;
              i = searchInts(f.lines, offset);
              if (i >= 0) {
                _tmp = (i + 1) >> 0;
                _tmp$1 =
                  (((offset -
                    ((x = f.lines),
                    i < 0 || i >= x.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : x.$array[x.$offset + i])) >>
                    0) +
                    1) >>
                  0;
                line = _tmp;
                column = _tmp$1;
              }
              /* */ if (adjusted && f.infos.$length > 0) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (adjusted && f.infos.$length > 0) { */ case 1:
              _r = searchLineInfos(f.infos, offset);
              /* */ $s = 3;
            case 3:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              i$1 = _r;
              if (i$1 >= 0) {
                alt =
                  ((x$1 = f.infos),
                  i$1 < 0 || i$1 >= x$1.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : x$1.$array[x$1.$offset + i$1]);
                filename = alt.Filename;
                i$2 = searchInts(f.lines, alt.Offset);
                if (i$2 >= 0) {
                  d = (line - ((i$2 + 1) >> 0)) >> 0;
                  line = (alt.Line + d) >> 0;
                  if (alt.Column === 0) {
                    column = 0;
                  } else if (d === 0) {
                    column = (alt.Column + ((offset - alt.Offset) >> 0)) >> 0;
                  }
                }
              }
            /* } */ case 2:
              $24r = [filename, line, column];
              $s = 4;
            case 4:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return [filename, line, column];
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: File.ptr.prototype.unpack,
            $c: true,
            $r,
            $24r,
            _r,
            _tmp,
            _tmp$1,
            adjusted,
            alt,
            column,
            d,
            f,
            filename,
            i,
            i$1,
            i$2,
            line,
            offset,
            x,
            x$1,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    File.prototype.unpack = function (offset, adjusted) {
      return this.$val.unpack(offset, adjusted);
    };
    File.ptr.prototype.position = function (p, adjusted) {
      var { _r, _tuple, adjusted, f, offset, p, pos, $s, $r, $c } = $restore(
        this,
        { p, adjusted }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = new Position.ptr("", 0, 0, 0);
            f = this;
            offset = ((p >> 0) - f.base) >> 0;
            pos.Offset = offset;
            _r = f.unpack(offset, adjusted);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            pos.Filename = _tuple[0];
            pos.Line = _tuple[1];
            pos.Column = _tuple[2];
            $s = -1;
            return pos;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.position,
        $c: true,
        $r,
        _r,
        _tuple,
        adjusted,
        f,
        offset,
        p,
        pos,
        $s,
      };
      return $f;
    };
    File.prototype.position = function (p, adjusted) {
      return this.$val.position(p, adjusted);
    };
    File.ptr.prototype.PositionFor = function (p, adjusted) {
      var { _r, _r$1, adjusted, f, p, pos, $s, $r, $c } = $restore(this, {
        p,
        adjusted,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = new Position.ptr("", 0, 0, 0);
            f = this;
            /* */ if (!(p === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((p === 0))) { */ case 1:
            /* */ if (p >> 0 < f.base || p >> 0 > (f.base + f.size) >> 0) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (((p >> 0)) < f.base || ((p >> 0)) > (f.base + f.size >> 0)) { */ case 3:
            _r = fmt.Sprintf(
              "invalid Pos value %d (should be in [%d, %d])",
              new sliceType$4([
                new Pos(p),
                new $Int(f.base),
                new $Int((f.base + f.size) >> 0),
              ])
            );
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(new $String(_r));
          /* } */ case 4:
            _r$1 = f.position(p, adjusted);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            Position.copy(pos, _r$1);
          /* } */ case 2:
            $s = -1;
            return pos;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.PositionFor,
        $c: true,
        $r,
        _r,
        _r$1,
        adjusted,
        f,
        p,
        pos,
        $s,
      };
      return $f;
    };
    File.prototype.PositionFor = function (p, adjusted) {
      return this.$val.PositionFor(p, adjusted);
    };
    File.ptr.prototype.Position = function (p) {
      var { $24r, _r, f, p, pos, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = new Position.ptr("", 0, 0, 0);
            f = this;
            _r = f.PositionFor(p, true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Position.copy(pos, _r);
            $24r = pos;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: File.ptr.prototype.Position,
        $c: true,
        $r,
        $24r,
        _r,
        f,
        p,
        pos,
        $s,
      };
      return $f;
    };
    File.prototype.Position = function (p) {
      return this.$val.Position(p);
    };
    NewFileSet = function () {
      return new FileSet.ptr(
        new nosync.RWMutex.ptr(false, 0),
        1,
        sliceType$1.nil,
        ptrType.nil
      );
    };
    $pkg.NewFileSet = NewFileSet;
    FileSet.ptr.prototype.Base = function () {
      var b, s;
      s = this;
      s.mutex.RLock();
      b = s.base;
      s.mutex.RUnlock();
      return b;
    };
    FileSet.prototype.Base = function () {
      return this.$val.Base();
    };
    FileSet.ptr.prototype.AddFile = function (filename, base, size) {
      var {
        $24r,
        _r,
        _r$1,
        base,
        f,
        filename,
        s,
        size,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { filename, base, size });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              s = this;
              s.mutex.Lock();
              $deferred.push([$methodVal(s.mutex, "Unlock"), []]);
              if (base < 0) {
                base = s.base;
              }
              /* */ if (base < s.base) {
                $s = 1;
                continue;
              }
              /* */ $s = 2;
              continue;
            /* if (base < s.base) { */ case 1:
              _r = fmt.Sprintf(
                "invalid base %d (should be >= %d)",
                new sliceType$4([new $Int(base), new $Int(s.base)])
              );
              /* */ $s = 3;
            case 3:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r));
            /* } */ case 2:
              /* */ if (size < 0) {
                $s = 4;
                continue;
              }
              /* */ $s = 5;
              continue;
            /* if (size < 0) { */ case 4:
              _r$1 = fmt.Sprintf(
                "invalid size %d (should be >= 0)",
                new sliceType$4([new $Int(size)])
              );
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              $panic(new $String(_r$1));
            /* } */ case 5:
              f = new File.ptr(
                s,
                filename,
                base,
                size,
                new nosync.Mutex.ptr(false),
                new sliceType$2([0]),
                sliceType$3.nil
              );
              base = (base + ((size + 1) >> 0)) >> 0;
              if (base < 0) {
                $panic(
                  new $String(
                    "token.Pos offset overflow (> 2G of source code in file set)"
                  )
                );
              }
              s.base = base;
              s.files = $append(s.files, f);
              s.last = f;
              $24r = f;
              $s = 7;
            case 7:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return ptrType.nil;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: FileSet.ptr.prototype.AddFile,
            $c: true,
            $r,
            $24r,
            _r,
            _r$1,
            base,
            f,
            filename,
            s,
            size,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    FileSet.prototype.AddFile = function (filename, base, size) {
      return this.$val.AddFile(filename, base, size);
    };
    FileSet.ptr.prototype.Iterate = function (f) {
      var { _r, _v, f, file, i, s, x, $s, $r, $c } = $restore(this, { f });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            i = 0;
          /* while (true) { */ case 1:
            file = ptrType.nil;
            s.mutex.RLock();
            if (i < s.files.$length) {
              file =
                ((x = s.files),
                i < 0 || i >= x.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x.$array[x.$offset + i]);
            }
            s.mutex.RUnlock();
            if (file === ptrType.nil) {
              _v = true;
              $s = 5;
              continue s;
            }
            _r = f(file);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _v = !_r;
          case 5:
            /* */ if (_v) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (_v) { */ case 3:
            /* break; */ $s = 2;
            continue;
          /* } */ case 4:
            i = (i + 1) >> 0;
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.Iterate,
        $c: true,
        $r,
        _r,
        _v,
        f,
        file,
        i,
        s,
        x,
        $s,
      };
      return $f;
    };
    FileSet.prototype.Iterate = function (f) {
      return this.$val.Iterate(f);
    };
    searchFiles = function (a, x) {
      var { $24r, _r, a, x, $s, $r, $c } = $restore(this, { a, x });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            a = [a];
            x = [x];
            _r = sort.Search(
              a[0].$length,
              (function (a, x) {
                return function (i) {
                  var i;
                  return (
                    (i < 0 || i >= a[0].$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : a[0].$array[a[0].$offset + i]
                    ).base > x[0]
                  );
                };
              })(a, x)
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = (_r - 1) >> 0;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: searchFiles, $c: true, $r, $24r, _r, a, x, $s };
      return $f;
    };
    FileSet.ptr.prototype.file = function (p) {
      var { _r, f, f$1, i, p, s, x, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            s.mutex.RLock();
            f = s.last;
            if (
              !(f === ptrType.nil) &&
              f.base <= p >> 0 &&
              p >> 0 <= (f.base + f.size) >> 0
            ) {
              s.mutex.RUnlock();
              $s = -1;
              return f;
            }
            _r = searchFiles(s.files, p >> 0);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            i = _r;
            if (i >= 0) {
              f$1 =
                ((x = s.files),
                i < 0 || i >= x.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : x.$array[x.$offset + i]);
              if (p >> 0 <= (f$1.base + f$1.size) >> 0) {
                s.mutex.RUnlock();
                s.mutex.Lock();
                s.last = f$1;
                s.mutex.Unlock();
                $s = -1;
                return f$1;
              }
            }
            s.mutex.RUnlock();
            $s = -1;
            return ptrType.nil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.file,
        $c: true,
        $r,
        _r,
        f,
        f$1,
        i,
        p,
        s,
        x,
        $s,
      };
      return $f;
    };
    FileSet.prototype.file = function (p) {
      return this.$val.file(p);
    };
    FileSet.ptr.prototype.File = function (p) {
      var { _r, f, p, s, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            f = ptrType.nil;
            s = this;
            /* */ if (!(p === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((p === 0))) { */ case 1:
            _r = s.file(p);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            f = _r;
          /* } */ case 2:
            $s = -1;
            return f;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.File,
        $c: true,
        $r,
        _r,
        f,
        p,
        s,
        $s,
      };
      return $f;
    };
    FileSet.prototype.File = function (p) {
      return this.$val.File(p);
    };
    FileSet.ptr.prototype.PositionFor = function (p, adjusted) {
      var { $24r, _r, _r$1, adjusted, f, p, pos, s, $s, $r, $c } = $restore(
        this,
        { p, adjusted }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = new Position.ptr("", 0, 0, 0);
            s = this;
            /* */ if (!(p === 0)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((p === 0))) { */ case 1:
            _r = s.file(p);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            f = _r;
            /* */ if (!(f === ptrType.nil)) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (!(f === ptrType.nil)) { */ case 4:
            _r$1 = f.position(p, adjusted);
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            Position.copy(pos, _r$1);
            $24r = pos;
            $s = 7;
          case 7:
            return $24r;
          /* } */ case 5:
          /* } */ case 2:
            $s = -1;
            return pos;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.PositionFor,
        $c: true,
        $r,
        $24r,
        _r,
        _r$1,
        adjusted,
        f,
        p,
        pos,
        s,
        $s,
      };
      return $f;
    };
    FileSet.prototype.PositionFor = function (p, adjusted) {
      return this.$val.PositionFor(p, adjusted);
    };
    FileSet.ptr.prototype.Position = function (p) {
      var { $24r, _r, p, pos, s, $s, $r, $c } = $restore(this, { p });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = new Position.ptr("", 0, 0, 0);
            s = this;
            _r = s.PositionFor(p, true);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            Position.copy(pos, _r);
            $24r = pos;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: FileSet.ptr.prototype.Position,
        $c: true,
        $r,
        $24r,
        _r,
        p,
        pos,
        s,
        $s,
      };
      return $f;
    };
    FileSet.prototype.Position = function (p) {
      return this.$val.Position(p);
    };
    searchInts = function (a, x) {
      var _tmp, _tmp$1, a, h, i, j, x;
      _tmp = 0;
      _tmp$1 = a.$length;
      i = _tmp;
      j = _tmp$1;
      while (true) {
        if (!(i < j)) {
          break;
        }
        h = (((((i + j) >> 0) >>> 0) >>> 1) >>> 0) >> 0;
        if (
          (h < 0 || h >= a.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : a.$array[a.$offset + h]) <= x
        ) {
          i = (h + 1) >> 0;
        } else {
          j = h;
        }
      }
      return (i - 1) >> 0;
    };
    Token.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Precedence",
        name: "Precedence",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "IsLiteral",
        name: "IsLiteral",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsOperator",
        name: "IsOperator",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "IsKeyword",
        name: "IsKeyword",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    Position.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
    ];
    ptrType$2.methods = [
      {
        prop: "IsValid",
        name: "IsValid",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    Pos.methods = [
      {
        prop: "IsValid",
        name: "IsValid",
        pkg: "",
        typ: $funcType([], [$Bool], false),
      },
    ];
    ptrType.methods = [
      {
        prop: "Name",
        name: "Name",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "Base",
        name: "Base",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Size",
        name: "Size",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "LineCount",
        name: "LineCount",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "AddLine",
        name: "AddLine",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "MergeLine",
        name: "MergeLine",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "SetLines",
        name: "SetLines",
        pkg: "",
        typ: $funcType([sliceType$2], [$Bool], false),
      },
      {
        prop: "SetLinesForContent",
        name: "SetLinesForContent",
        pkg: "",
        typ: $funcType([sliceType$5], [], false),
      },
      {
        prop: "LineStart",
        name: "LineStart",
        pkg: "",
        typ: $funcType([$Int], [Pos], false),
      },
      {
        prop: "AddLineInfo",
        name: "AddLineInfo",
        pkg: "",
        typ: $funcType([$Int, $String, $Int], [], false),
      },
      {
        prop: "AddLineColumnInfo",
        name: "AddLineColumnInfo",
        pkg: "",
        typ: $funcType([$Int, $String, $Int, $Int], [], false),
      },
      {
        prop: "Pos",
        name: "Pos",
        pkg: "",
        typ: $funcType([$Int], [Pos], false),
      },
      {
        prop: "Offset",
        name: "Offset",
        pkg: "",
        typ: $funcType([Pos], [$Int], false),
      },
      {
        prop: "Line",
        name: "Line",
        pkg: "",
        typ: $funcType([Pos], [$Int], false),
      },
      {
        prop: "unpack",
        name: "unpack",
        pkg: "go/token",
        typ: $funcType([$Int, $Bool], [$String, $Int, $Int], false),
      },
      {
        prop: "position",
        name: "position",
        pkg: "go/token",
        typ: $funcType([Pos, $Bool], [Position], false),
      },
      {
        prop: "PositionFor",
        name: "PositionFor",
        pkg: "",
        typ: $funcType([Pos, $Bool], [Position], false),
      },
      {
        prop: "Position",
        name: "Position",
        pkg: "",
        typ: $funcType([Pos], [Position], false),
      },
    ];
    ptrType$1.methods = [
      {
        prop: "Read",
        name: "Read",
        pkg: "",
        typ: $funcType([funcType], [$error], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([funcType], [$error], false),
      },
      {
        prop: "Base",
        name: "Base",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "AddFile",
        name: "AddFile",
        pkg: "",
        typ: $funcType([$String, $Int, $Int], [ptrType], false),
      },
      {
        prop: "Iterate",
        name: "Iterate",
        pkg: "",
        typ: $funcType([funcType$1], [], false),
      },
      {
        prop: "file",
        name: "file",
        pkg: "go/token",
        typ: $funcType([Pos], [ptrType], false),
      },
      {
        prop: "File",
        name: "File",
        pkg: "",
        typ: $funcType([Pos], [ptrType], false),
      },
      {
        prop: "PositionFor",
        name: "PositionFor",
        pkg: "",
        typ: $funcType([Pos, $Bool], [Position], false),
      },
      {
        prop: "Position",
        name: "Position",
        pkg: "",
        typ: $funcType([Pos], [Position], false),
      },
    ];
    serializedFile.init("", [
      {
        prop: "Name",
        name: "Name",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Base",
        name: "Base",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Size",
        name: "Size",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Lines",
        name: "Lines",
        embedded: false,
        exported: true,
        typ: sliceType$2,
        tag: "",
      },
      {
        prop: "Infos",
        name: "Infos",
        embedded: false,
        exported: true,
        typ: sliceType$3,
        tag: "",
      },
    ]);
    serializedFileSet.init("", [
      {
        prop: "Base",
        name: "Base",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Files",
        name: "Files",
        embedded: false,
        exported: true,
        typ: sliceType,
        tag: "",
      },
    ]);
    Position.init("", [
      {
        prop: "Filename",
        name: "Filename",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Offset",
        name: "Offset",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Line",
        name: "Line",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Column",
        name: "Column",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    File.init("go/token", [
      {
        prop: "set",
        name: "set",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "name",
        name: "name",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "base",
        name: "base",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "size",
        name: "size",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "mutex",
        name: "mutex",
        embedded: false,
        exported: false,
        typ: nosync.Mutex,
        tag: "",
      },
      {
        prop: "lines",
        name: "lines",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
      {
        prop: "infos",
        name: "infos",
        embedded: false,
        exported: false,
        typ: sliceType$3,
        tag: "",
      },
    ]);
    lineInfo.init("", [
      {
        prop: "Offset",
        name: "Offset",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Filename",
        name: "Filename",
        embedded: false,
        exported: true,
        typ: $String,
        tag: "",
      },
      {
        prop: "Line",
        name: "Line",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
      {
        prop: "Column",
        name: "Column",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    FileSet.init("go/token", [
      {
        prop: "mutex",
        name: "mutex",
        embedded: false,
        exported: false,
        typ: nosync.RWMutex,
        tag: "",
      },
      {
        prop: "base",
        name: "base",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "files",
        name: "files",
        embedded: false,
        exported: false,
        typ: sliceType$1,
        tag: "",
      },
      {
        prop: "last",
        name: "last",
        embedded: false,
        exported: false,
        typ: ptrType,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = fmt.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = nosync.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strconv.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unicode.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            keywords = false;
            tokens = $toNativeArray($kindString, [
              "ILLEGAL",
              "EOF",
              "COMMENT",
              "",
              "IDENT",
              "INT",
              "FLOAT",
              "IMAG",
              "CHAR",
              "STRING",
              "",
              "",
              "+",
              "-",
              "*",
              "/",
              "%",
              "&",
              "|",
              "^",
              "<<",
              ">>",
              "&^",
              "+=",
              "-=",
              "*=",
              "/=",
              "%=",
              "&=",
              "|=",
              "^=",
              "<<=",
              ">>=",
              "&^=",
              "&&",
              "||",
              "<-",
              "++",
              "--",
              "==",
              "<",
              ">",
              "=",
              "!",
              "!=",
              "<=",
              ">=",
              ":=",
              "...",
              "(",
              "[",
              "{",
              ",",
              ".",
              ")",
              "]",
              "}",
              ";",
              ":",
              "",
              "",
              "break",
              "case",
              "chan",
              "const",
              "continue",
              "default",
              "defer",
              "else",
              "fallthrough",
              "for",
              "func",
              "go",
              "goto",
              "if",
              "import",
              "interface",
              "map",
              "package",
              "range",
              "return",
              "select",
              "struct",
              "switch",
              "type",
              "var",
              "",
              "",
              "~",
            ]);
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["strings"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js,
      bytealg,
      io,
      sync,
      unicode,
      utf8,
      Builder,
      ptrType$1,
      sliceType$2,
      Join,
      HasPrefix,
      TrimPrefix,
      Replace,
      ReplaceAll,
      Index,
      Count;
    errors = $packages["errors"];
    js = $packages["github.com/gopherjs/gopherjs/js"];
    bytealg = $packages["internal/bytealg"];
    io = $packages["io"];
    sync = $packages["sync"];
    unicode = $packages["unicode"];
    utf8 = $packages["unicode/utf8"];
    Builder = $pkg.Builder = $newType(
      0,
      $kindStruct,
      "strings.Builder",
      true,
      "strings",
      true,
      function (addr_, buf_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.addr = ptrType$1.nil;
          this.buf = sliceType$2.nil;
          return;
        }
        this.addr = addr_;
        this.buf = buf_;
      }
    );
    ptrType$1 = $ptrType(Builder);
    sliceType$2 = $sliceType($Uint8);
    Join = function (elems, sep) {
      var _1, _i, _ref, b, elems, i, n, s, sep;
      _1 = elems.$length;
      if (_1 === 0) {
        return "";
      } else if (_1 === 1) {
        return 0 >= elems.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : elems.$array[elems.$offset + 0];
      }
      n = $imul(sep.length, (elems.$length - 1) >> 0);
      i = 0;
      while (true) {
        if (!(i < elems.$length)) {
          break;
        }
        n =
          (n +
            (i < 0 || i >= elems.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : elems.$array[elems.$offset + i]
            ).length) >>
          0;
        i = (i + 1) >> 0;
      }
      b = new Builder.ptr(ptrType$1.nil, sliceType$2.nil);
      b.Grow(n);
      b.WriteString(
        0 >= elems.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : elems.$array[elems.$offset + 0]
      );
      _ref = $subslice(elems, 1);
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        s =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        b.WriteString(sep);
        b.WriteString(s);
        _i++;
      }
      return b.String();
    };
    $pkg.Join = Join;
    HasPrefix = function (s, prefix) {
      var prefix, s;
      return (
        s.length >= prefix.length && $substring(s, 0, prefix.length) === prefix
      );
    };
    $pkg.HasPrefix = HasPrefix;
    TrimPrefix = function (s, prefix) {
      var prefix, s;
      if (HasPrefix(s, prefix)) {
        return $substring(s, prefix.length);
      }
      return s;
    };
    $pkg.TrimPrefix = TrimPrefix;
    Replace = function (s, old, new$1, n) {
      var _tuple, b, i, j, m, n, new$1, old, s, start, wid;
      if (old === new$1 || n === 0) {
        return s;
      }
      m = Count(s, old);
      if (m === 0) {
        return s;
      } else if (n < 0 || m < n) {
        n = m;
      }
      b = new Builder.ptr(ptrType$1.nil, sliceType$2.nil);
      b.Grow((s.length + $imul(n, (new$1.length - old.length) >> 0)) >> 0);
      start = 0;
      i = 0;
      while (true) {
        if (!(i < n)) {
          break;
        }
        j = start;
        if (old.length === 0) {
          if (i > 0) {
            _tuple = utf8.DecodeRuneInString($substring(s, start));
            wid = _tuple[1];
            j = (j + wid) >> 0;
          }
        } else {
          j = (j + Index($substring(s, start), old)) >> 0;
        }
        b.WriteString($substring(s, start, j));
        b.WriteString(new$1);
        start = (j + old.length) >> 0;
        i = (i + 1) >> 0;
      }
      b.WriteString($substring(s, start));
      return b.String();
    };
    $pkg.Replace = Replace;
    ReplaceAll = function (s, old, new$1) {
      var new$1, old, s;
      return Replace(s, old, new$1, -1);
    };
    $pkg.ReplaceAll = ReplaceAll;
    Index = function (s, sep) {
      var s, sep;
      return $parseInt(s.indexOf(sep)) >> 0;
    };
    $pkg.Index = Index;
    Count = function (s, sep) {
      var n, pos, s, sep;
      n = 0;
      if (sep.length === 0) {
        return (utf8.RuneCountInString(s) + 1) >> 0;
      } else if (sep.length > s.length) {
        return 0;
      } else if (sep.length === s.length) {
        if (sep === s) {
          return 1;
        }
        return 0;
      }
      while (true) {
        pos = Index(s, sep);
        if (pos === -1) {
          break;
        }
        n = (n + 1) >> 0;
        s = $substring(s, (pos + sep.length) >> 0);
      }
      return n;
    };
    $pkg.Count = Count;
    Builder.ptr.prototype.String = function () {
      var b;
      b = this;
      return $bytesToString(b.buf);
    };
    Builder.prototype.String = function () {
      return this.$val.String();
    };
    Builder.ptr.prototype.copyCheck = function () {
      var b;
      b = this;
      if (b.addr === ptrType$1.nil) {
        b.addr = b;
      } else if (!(b.addr === b)) {
        $panic(
          new $String(
            "strings: illegal use of non-zero Builder copied by value"
          )
        );
      }
    };
    Builder.prototype.copyCheck = function () {
      return this.$val.copyCheck();
    };
    Builder.ptr.prototype.Len = function () {
      var b;
      b = this;
      return b.buf.$length;
    };
    Builder.prototype.Len = function () {
      return this.$val.Len();
    };
    Builder.ptr.prototype.Cap = function () {
      var b;
      b = this;
      return b.buf.$capacity;
    };
    Builder.prototype.Cap = function () {
      return this.$val.Cap();
    };
    Builder.ptr.prototype.Reset = function () {
      var b;
      b = this;
      b.addr = ptrType$1.nil;
      b.buf = sliceType$2.nil;
    };
    Builder.prototype.Reset = function () {
      return this.$val.Reset();
    };
    Builder.ptr.prototype.grow = function (n) {
      var b, buf, n;
      b = this;
      buf = $makeSlice(
        sliceType$2,
        b.buf.$length,
        ($imul(2, b.buf.$capacity) + n) >> 0
      );
      $copySlice(buf, b.buf);
      b.buf = buf;
    };
    Builder.prototype.grow = function (n) {
      return this.$val.grow(n);
    };
    Builder.ptr.prototype.Grow = function (n) {
      var b, n;
      b = this;
      b.copyCheck();
      if (n < 0) {
        $panic(new $String("strings.Builder.Grow: negative count"));
      }
      if ((b.buf.$capacity - b.buf.$length) >> 0 < n) {
        b.grow(n);
      }
    };
    Builder.prototype.Grow = function (n) {
      return this.$val.Grow(n);
    };
    Builder.ptr.prototype.Write = function (p) {
      var b, p;
      b = this;
      b.copyCheck();
      b.buf = $appendSlice(b.buf, p);
      return [p.$length, $ifaceNil];
    };
    Builder.prototype.Write = function (p) {
      return this.$val.Write(p);
    };
    Builder.ptr.prototype.WriteByte = function (c) {
      var b, c;
      b = this;
      b.copyCheck();
      b.buf = $append(b.buf, c);
      return $ifaceNil;
    };
    Builder.prototype.WriteByte = function (c) {
      return this.$val.WriteByte(c);
    };
    Builder.ptr.prototype.WriteRune = function (r) {
      var b, l, n, r;
      b = this;
      b.copyCheck();
      if (r >>> 0 < 128) {
        b.buf = $append(b.buf, (r << 24) >>> 24);
        return [1, $ifaceNil];
      }
      l = b.buf.$length;
      if ((b.buf.$capacity - l) >> 0 < 4) {
        b.grow(4);
      }
      n = utf8.EncodeRune($subslice(b.buf, l, (l + 4) >> 0), r);
      b.buf = $subslice(b.buf, 0, (l + n) >> 0);
      return [n, $ifaceNil];
    };
    Builder.prototype.WriteRune = function (r) {
      return this.$val.WriteRune(r);
    };
    Builder.ptr.prototype.WriteString = function (s) {
      var b, s;
      b = this;
      b.copyCheck();
      b.buf = $appendSlice(b.buf, s);
      return [s.length, $ifaceNil];
    };
    Builder.prototype.WriteString = function (s) {
      return this.$val.WriteString(s);
    };
    ptrType$1.methods = [
      {
        prop: "String",
        name: "String",
        pkg: "",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "copyCheck",
        name: "copyCheck",
        pkg: "strings",
        typ: $funcType([], [], false),
      },
      { prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false) },
      { prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false) },
      { prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false) },
      {
        prop: "grow",
        name: "grow",
        pkg: "strings",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "Grow",
        name: "Grow",
        pkg: "",
        typ: $funcType([$Int], [], false),
      },
      {
        prop: "Write",
        name: "Write",
        pkg: "",
        typ: $funcType([sliceType$2], [$Int, $error], false),
      },
      {
        prop: "WriteByte",
        name: "WriteByte",
        pkg: "",
        typ: $funcType([$Uint8], [$error], false),
      },
      {
        prop: "WriteRune",
        name: "WriteRune",
        pkg: "",
        typ: $funcType([$Int32], [$Int, $error], false),
      },
      {
        prop: "WriteString",
        name: "WriteString",
        pkg: "",
        typ: $funcType([$String], [$Int, $error], false),
      },
    ];
    Builder.init("strings", [
      {
        prop: "addr",
        name: "addr",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: sliceType$2,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = bytealg.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sync.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unicode.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["path/filepath"] = (function () {
    var $pkg = {},
      $init,
      errors,
      fs,
      os,
      runtime,
      sort,
      strings,
      syscall,
      utf8,
      lazybuf,
      sliceType$1,
      ptrType,
      IsAbs,
      volumeNameLen,
      join,
      Clean,
      FromSlash,
      Split,
      Join,
      VolumeName;
    errors = $packages["errors"];
    fs = $packages["io/fs"];
    os = $packages["os"];
    runtime = $packages["runtime"];
    sort = $packages["sort"];
    strings = $packages["strings"];
    syscall = $packages["syscall"];
    utf8 = $packages["unicode/utf8"];
    lazybuf = $pkg.lazybuf = $newType(
      0,
      $kindStruct,
      "filepath.lazybuf",
      true,
      "path/filepath",
      false,
      function (path_, buf_, w_, volAndPath_, volLen_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.path = "";
          this.buf = sliceType$1.nil;
          this.w = 0;
          this.volAndPath = "";
          this.volLen = 0;
          return;
        }
        this.path = path_;
        this.buf = buf_;
        this.w = w_;
        this.volAndPath = volAndPath_;
        this.volLen = volLen_;
      }
    );
    sliceType$1 = $sliceType($Uint8);
    ptrType = $ptrType(lazybuf);
    IsAbs = function (path) {
      var path;
      return strings.HasPrefix(path, "/");
    };
    $pkg.IsAbs = IsAbs;
    volumeNameLen = function (path) {
      var path;
      return 0;
    };
    join = function (elem) {
      var _i, _ref, e, elem, i;
      _ref = elem;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        i = _i;
        e =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (!(e === "")) {
          return Clean(strings.Join($subslice(elem, i), "/"));
        }
        _i++;
      }
      return "";
    };
    lazybuf.ptr.prototype.index = function (i) {
      var b, i, x;
      b = this;
      if (!(b.buf === sliceType$1.nil)) {
        return (
          (x = b.buf),
          i < 0 || i >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + i]
        );
      }
      return b.path.charCodeAt(i);
    };
    lazybuf.prototype.index = function (i) {
      return this.$val.index(i);
    };
    lazybuf.ptr.prototype.append = function (c) {
      var b, c, x, x$1;
      b = this;
      if (b.buf === sliceType$1.nil) {
        if (b.w < b.path.length && b.path.charCodeAt(b.w) === c) {
          b.w = (b.w + 1) >> 0;
          return;
        }
        b.buf = $makeSlice(sliceType$1, b.path.length);
        $copyString(b.buf, $substring(b.path, 0, b.w));
      }
      (x = b.buf),
        (x$1 = b.w),
        x$1 < 0 || x$1 >= x.$length
          ? ($throwRuntimeError("index out of range"), undefined)
          : (x.$array[x.$offset + x$1] = c);
      b.w = (b.w + 1) >> 0;
    };
    lazybuf.prototype.append = function (c) {
      return this.$val.append(c);
    };
    lazybuf.ptr.prototype.string = function () {
      var b;
      b = this;
      if (b.buf === sliceType$1.nil) {
        return $substring(b.volAndPath, 0, (b.volLen + b.w) >> 0);
      }
      return (
        $substring(b.volAndPath, 0, b.volLen) +
        $bytesToString($subslice(b.buf, 0, b.w))
      );
    };
    lazybuf.prototype.string = function () {
      return this.$val.string();
    };
    Clean = function (path) {
      var _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        dotdot,
        n,
        originalPath,
        out,
        path,
        r,
        rooted,
        volLen;
      originalPath = path;
      volLen = volumeNameLen(path);
      path = $substring(path, volLen);
      if (path === "") {
        if (volLen > 1 && !(originalPath.charCodeAt(1) === 58)) {
          return FromSlash(originalPath);
        }
        return originalPath + ".";
      }
      rooted = os.IsPathSeparator(path.charCodeAt(0));
      n = path.length;
      out = new lazybuf.ptr(path, sliceType$1.nil, 0, originalPath, volLen);
      _tmp = 0;
      _tmp$1 = 0;
      r = _tmp;
      dotdot = _tmp$1;
      if (rooted) {
        out.append(47);
        _tmp$2 = 1;
        _tmp$3 = 1;
        r = _tmp$2;
        dotdot = _tmp$3;
      }
      while (true) {
        if (!(r < n)) {
          break;
        }
        if (os.IsPathSeparator(path.charCodeAt(r))) {
          r = (r + 1) >> 0;
        } else if (
          path.charCodeAt(r) === 46 &&
          ((r + 1) >> 0 === n ||
            os.IsPathSeparator(path.charCodeAt((r + 1) >> 0)))
        ) {
          r = (r + 1) >> 0;
        } else if (
          path.charCodeAt(r) === 46 &&
          path.charCodeAt((r + 1) >> 0) === 46 &&
          ((r + 2) >> 0 === n ||
            os.IsPathSeparator(path.charCodeAt((r + 2) >> 0)))
        ) {
          r = (r + 2) >> 0;
          if (out.w > dotdot) {
            out.w = (out.w - 1) >> 0;
            while (true) {
              if (!(out.w > dotdot && !os.IsPathSeparator(out.index(out.w)))) {
                break;
              }
              out.w = (out.w - 1) >> 0;
            }
          } else if (!rooted) {
            if (out.w > 0) {
              out.append(47);
            }
            out.append(46);
            out.append(46);
            dotdot = out.w;
          }
        } else {
          if ((rooted && !(out.w === 1)) || (!rooted && !(out.w === 0))) {
            out.append(47);
          }
          while (true) {
            if (!(r < n && !os.IsPathSeparator(path.charCodeAt(r)))) {
              break;
            }
            out.append(path.charCodeAt(r));
            r = (r + 1) >> 0;
          }
        }
      }
      if (out.w === 0) {
        out.append(46);
      }
      return FromSlash(out.string());
    };
    $pkg.Clean = Clean;
    FromSlash = function (path) {
      var path;
      if (true) {
        return path;
      }
      return strings.ReplaceAll(path, "/", "/");
    };
    $pkg.FromSlash = FromSlash;
    Split = function (path) {
      var _tmp, _tmp$1, dir, file, i, path, vol;
      dir = "";
      file = "";
      vol = VolumeName(path);
      i = (path.length - 1) >> 0;
      while (true) {
        if (!(i >= vol.length && !os.IsPathSeparator(path.charCodeAt(i)))) {
          break;
        }
        i = (i - 1) >> 0;
      }
      _tmp = $substring(path, 0, (i + 1) >> 0);
      _tmp$1 = $substring(path, (i + 1) >> 0);
      dir = _tmp;
      file = _tmp$1;
      return [dir, file];
    };
    $pkg.Split = Split;
    Join = function (elem) {
      var elem;
      return join(elem);
    };
    $pkg.Join = Join;
    VolumeName = function (path) {
      var path;
      return $substring(path, 0, volumeNameLen(path));
    };
    $pkg.VolumeName = VolumeName;
    ptrType.methods = [
      {
        prop: "index",
        name: "index",
        pkg: "path/filepath",
        typ: $funcType([$Int], [$Uint8], false),
      },
      {
        prop: "append",
        name: "append",
        pkg: "path/filepath",
        typ: $funcType([$Uint8], [], false),
      },
      {
        prop: "string",
        name: "string",
        pkg: "path/filepath",
        typ: $funcType([], [$String], false),
      },
    ];
    lazybuf.init("path/filepath", [
      {
        prop: "path",
        name: "path",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "buf",
        name: "buf",
        embedded: false,
        exported: false,
        typ: sliceType$1,
        tag: "",
      },
      {
        prop: "w",
        name: "w",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "volAndPath",
        name: "volAndPath",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "volLen",
        name: "volLen",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = fs.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = os.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strings.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = syscall.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $pkg.ErrBadPattern = errors.New("syntax error in pattern");
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["go/scanner"] = (function () {
    var $pkg = {},
      $init,
      bytes,
      fmt,
      token,
      io,
      filepath,
      sort,
      strconv,
      unicode,
      utf8,
      ErrorHandler,
      Scanner,
      Mode,
      sliceType,
      sliceType$1,
      sliceType$2,
      ptrType,
      ptrType$1,
      ptrType$2,
      prefix,
      trailingDigits,
      isLetter,
      isDigit,
      digitVal,
      lower,
      isDecimal,
      isHex,
      litname,
      invalidSep,
      stripCR;
    bytes = $packages["bytes"];
    fmt = $packages["fmt"];
    token = $packages["go/token"];
    io = $packages["io"];
    filepath = $packages["path/filepath"];
    sort = $packages["sort"];
    strconv = $packages["strconv"];
    unicode = $packages["unicode"];
    utf8 = $packages["unicode/utf8"];
    ErrorHandler = $pkg.ErrorHandler = $newType(
      4,
      $kindFunc,
      "scanner.ErrorHandler",
      true,
      "go/scanner",
      true,
      null
    );
    Scanner = $pkg.Scanner = $newType(
      0,
      $kindStruct,
      "scanner.Scanner",
      true,
      "go/scanner",
      true,
      function (
        file_,
        dir_,
        src_,
        err_,
        mode_,
        ch_,
        offset_,
        rdOffset_,
        lineOffset_,
        insertSemi_,
        ErrorCount_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.file = ptrType$1.nil;
          this.dir = "";
          this.src = sliceType.nil;
          this.err = $throwNilPointerError;
          this.mode = 0;
          this.ch = 0;
          this.offset = 0;
          this.rdOffset = 0;
          this.lineOffset = 0;
          this.insertSemi = false;
          this.ErrorCount = 0;
          return;
        }
        this.file = file_;
        this.dir = dir_;
        this.src = src_;
        this.err = err_;
        this.mode = mode_;
        this.ch = ch_;
        this.offset = offset_;
        this.rdOffset = rdOffset_;
        this.lineOffset = lineOffset_;
        this.insertSemi = insertSemi_;
        this.ErrorCount = ErrorCount_;
      }
    );
    Mode = $pkg.Mode = $newType(
      4,
      $kindUint,
      "scanner.Mode",
      true,
      "go/scanner",
      true,
      null
    );
    sliceType = $sliceType($Uint8);
    sliceType$1 = $sliceType($emptyInterface);
    sliceType$2 = $sliceType($String);
    ptrType = $ptrType($Int);
    ptrType$1 = $ptrType(token.File);
    ptrType$2 = $ptrType(Scanner);
    Scanner.ptr.prototype.next = function () {
      var { _tmp, _tmp$1, _tuple, r, s, w, x, x$1, $s, $r, $c } = $restore(
        this,
        {}
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (s.rdOffset < s.src.$length) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (s.rdOffset < s.src.$length) { */ case 1:
            s.offset = s.rdOffset;
            if (s.ch === 10) {
              s.lineOffset = s.offset;
              s.file.AddLine(s.offset);
            }
            _tmp =
              ((x = s.src),
              (x$1 = s.rdOffset),
              x$1 < 0 || x$1 >= x.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : x.$array[x.$offset + x$1]) >> 0;
            _tmp$1 = 1;
            r = _tmp;
            w = _tmp$1;
            /* */ if (r === 0) {
              $s = 5;
              continue;
            }
            /* */ if (r >= 128) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if ((r === 0)) { */ case 5:
            $r = s.error(s.offset, "illegal character NUL");
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 7;
            continue;
          /* } else if (r >= 128) { */ case 6:
            _tuple = utf8.DecodeRune($subslice(s.src, s.rdOffset));
            r = _tuple[0];
            w = _tuple[1];
            /* */ if (r === 65533 && w === 1) {
              $s = 9;
              continue;
            }
            /* */ if (r === 65279 && s.offset > 0) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if ((r === 65533) && (w === 1)) { */ case 9:
            $r = s.error(s.offset, "illegal UTF-8 encoding");
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 11;
            continue;
          /* } else if ((r === 65279) && s.offset > 0) { */ case 10:
            $r = s.error(s.offset, "illegal byte order mark");
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 11:
          /* } */ case 7:
          case 4:
            s.rdOffset = (s.rdOffset + w) >> 0;
            s.ch = r;
            $s = 3;
            continue;
          /* } else { */ case 2:
            s.offset = s.src.$length;
            if (s.ch === 10) {
              s.lineOffset = s.offset;
              s.file.AddLine(s.offset);
            }
            s.ch = -1;
          /* } */ case 3:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.next,
        $c: true,
        $r,
        _tmp,
        _tmp$1,
        _tuple,
        r,
        s,
        w,
        x,
        x$1,
        $s,
      };
      return $f;
    };
    Scanner.prototype.next = function () {
      return this.$val.next();
    };
    Scanner.ptr.prototype.peek = function () {
      var s, x, x$1;
      s = this;
      if (s.rdOffset < s.src.$length) {
        return (
          (x = s.src),
          (x$1 = s.rdOffset),
          x$1 < 0 || x$1 >= x.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : x.$array[x.$offset + x$1]
        );
      }
      return 0;
    };
    Scanner.prototype.peek = function () {
      return this.$val.peek();
    };
    Scanner.ptr.prototype.Init = function (file, src, err, mode) {
      var { _r, _tuple, err, file, mode, s, src, $s, $r, $c } = $restore(this, {
        file,
        src,
        err,
        mode,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (!(file.Size() === src.$length)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((file.Size() === src.$length))) { */ case 1:
            _r = fmt.Sprintf(
              "file size (%d) does not match src len (%d)",
              new sliceType$1([new $Int(file.Size()), new $Int(src.$length)])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(new $String(_r));
          /* } */ case 2:
            s.file = file;
            _tuple = filepath.Split(file.Name());
            s.dir = _tuple[0];
            s.src = src;
            s.err = err;
            s.mode = mode;
            s.ch = 32;
            s.offset = 0;
            s.rdOffset = 0;
            s.lineOffset = 0;
            s.insertSemi = false;
            s.ErrorCount = 0;
            $r = s.next();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            /* */ if (s.ch === 65279) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (s.ch === 65279) { */ case 5:
            $r = s.next();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 6:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.Init,
        $c: true,
        $r,
        _r,
        _tuple,
        err,
        file,
        mode,
        s,
        src,
        $s,
      };
      return $f;
    };
    Scanner.prototype.Init = function (file, src, err, mode) {
      return this.$val.Init(file, src, err, mode);
    };
    Scanner.ptr.prototype.error = function (offs, msg) {
      var { _r, _r$1, msg, offs, s, $s, $r, $c } = $restore(this, {
        offs,
        msg,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (!(s.err === $throwNilPointerError)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!(s.err === $throwNilPointerError)) { */ case 1:
            _r = s.file.Pos(offs);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = s.file.Position(_r);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $r = s.err($clone(_r$1, token.Position), msg);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 2:
            s.ErrorCount = (s.ErrorCount + 1) >> 0;
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.error,
        $c: true,
        $r,
        _r,
        _r$1,
        msg,
        offs,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.error = function (offs, msg) {
      return this.$val.error(offs, msg);
    };
    Scanner.ptr.prototype.errorf = function (offs, format, args) {
      var { _arg, _arg$1, _r, args, format, offs, s, $s, $r, $c } = $restore(
        this,
        { offs, format, args }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            _arg = offs;
            _r = fmt.Sprintf(format, args);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg$1 = _r;
            $r = s.error(_arg, _arg$1);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.errorf,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _r,
        args,
        format,
        offs,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.errorf = function (offs, format, args) {
      return this.$val.errorf(offs, format, args);
    };
    Scanner.ptr.prototype.scanComment = function () {
      var { ch, lit, next, numCR, offs, s, x, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = (s.offset - 1) >> 0;
            next = -1;
            numCR = 0;
            /* */ if (s.ch === 47) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (s.ch === 47) { */ case 1:
            $r = s.next();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* while (true) { */ case 4:
            /* if (!(!((s.ch === 10)) && s.ch >= 0)) { break; } */ if (
              !(!(s.ch === 10) && s.ch >= 0)
            ) {
              $s = 5;
              continue;
            }
            if (s.ch === 13) {
              numCR = (numCR + 1) >> 0;
            }
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 4;
            continue;
          case 5:
            next = s.offset;
            if (s.ch === 10) {
              next = (next + 1) >> 0;
            }
            /* goto exit */ $s = 7;
            continue;
          /* } */ case 2:
            $r = s.next();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* while (true) { */ case 9:
            /* if (!(s.ch >= 0)) { break; } */ if (!(s.ch >= 0)) {
              $s = 10;
              continue;
            }
            ch = s.ch;
            if (ch === 13) {
              numCR = (numCR + 1) >> 0;
            }
            $r = s.next();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            /* */ if (ch === 42 && s.ch === 47) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if ((ch === 42) && (s.ch === 47)) { */ case 12:
            $r = s.next();
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            next = s.offset;
            /* goto exit */ $s = 7;
            continue;
          /* } */ case 13:
            $s = 9;
            continue;
          case 10:
            $r = s.error(offs, "comment not terminated");
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* exit: */ case 7:
            lit = $subslice(s.src, offs, s.offset);
            if (
              numCR > 0 &&
              lit.$length >= 2 &&
              (1 >= lit.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : lit.$array[lit.$offset + 1]) === 47 &&
              ((x = (lit.$length - 1) >> 0),
              x < 0 || x >= lit.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : lit.$array[lit.$offset + x]) === 13
            ) {
              lit = $subslice(lit, 0, (lit.$length - 1) >> 0);
              numCR = (numCR - 1) >> 0;
            }
            /* */ if (
              next >= 0 &&
              ((1 >= lit.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : lit.$array[lit.$offset + 1]) === 42 ||
                offs === s.lineOffset) &&
              bytes.HasPrefix($subslice(lit, 2), prefix)
            ) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (next >= 0 && (((1 >= lit.$length ? ($throwRuntimeError("index out of range"), undefined) : lit.$array[lit.$offset + 1]) === 42) || (offs === s.lineOffset)) && bytes.HasPrefix($subslice(lit, 2), prefix)) { */ case 16:
            $r = s.updateLineInfo(next, offs, lit);
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 17:
            if (numCR > 0) {
              lit = stripCR(
                lit,
                (1 >= lit.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : lit.$array[lit.$offset + 1]) === 42
              );
            }
            $s = -1;
            return $bytesToString(lit);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanComment,
        $c: true,
        $r,
        ch,
        lit,
        next,
        numCR,
        offs,
        s,
        x,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanComment = function () {
      return this.$val.scanComment();
    };
    Scanner.ptr.prototype.updateLineInfo = function (next, offs, text) {
      var {
        _r,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        _tuple$1,
        col,
        filename,
        i,
        i2,
        line,
        n,
        n2,
        next,
        offs,
        ok,
        ok2,
        s,
        text,
        $s,
        $r,
        $c,
      } = $restore(this, { next, offs, text });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            if (
              (1 >= text.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : text.$array[text.$offset + 1]) === 42
            ) {
              text = $subslice(text, 0, (text.$length - 2) >> 0);
            }
            text = $subslice(text, 7);
            offs = (offs + 7) >> 0;
            _tuple = trailingDigits(text);
            i = _tuple[0];
            n = _tuple[1];
            ok = _tuple[2];
            if (i === 0) {
              $s = -1;
              return;
            }
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            $r = s.error(
              (offs + i) >> 0,
              "invalid line number: " + $bytesToString($subslice(text, i))
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 2:
            _tmp = 0;
            _tmp$1 = 0;
            line = _tmp;
            col = _tmp$1;
            _tuple$1 = trailingDigits($subslice(text, 0, (i - 1) >> 0));
            i2 = _tuple$1[0];
            n2 = _tuple$1[1];
            ok2 = _tuple$1[2];
            /* */ if (ok2) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (ok2) { */ case 4:
            _tmp$2 = i2;
            _tmp$3 = i;
            i = _tmp$2;
            i2 = _tmp$3;
            _tmp$4 = n2;
            _tmp$5 = n;
            line = _tmp$4;
            col = _tmp$5;
            /* */ if (col === 0) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (col === 0) { */ case 7:
            $r = s.error(
              (offs + i2) >> 0,
              "invalid column number: " + $bytesToString($subslice(text, i2))
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 8:
            text = $subslice(text, 0, (i2 - 1) >> 0);
            $s = 6;
            continue;
          /* } else { */ case 5:
            line = n;
          /* } */ case 6:
            /* */ if (line === 0) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (line === 0) { */ case 10:
            $r = s.error(
              (offs + i) >> 0,
              "invalid line number: " + $bytesToString($subslice(text, i))
            );
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return;
          /* } */ case 11:
            filename = $bytesToString($subslice(text, 0, (i - 1) >> 0));
            /* */ if (filename === "" && ok2) {
              $s = 13;
              continue;
            }
            /* */ if (!(filename === "")) {
              $s = 14;
              continue;
            }
            /* */ $s = 15;
            continue;
          /* if (filename === "" && ok2) { */ case 13:
            _r = s.file.Pos(offs);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r$1 = s.file.Position(_r);
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            filename = _r$1.Filename;
            $s = 15;
            continue;
          /* } else if (!(filename === "")) { */ case 14:
            filename = filepath.Clean(filename);
            if (!filepath.IsAbs(filename)) {
              filename = filepath.Join(new sliceType$2([s.dir, filename]));
            }
          /* } */ case 15:
            s.file.AddLineColumnInfo(next, filename, line, col);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.updateLineInfo,
        $c: true,
        $r,
        _r,
        _r$1,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tuple,
        _tuple$1,
        col,
        filename,
        i,
        i2,
        line,
        n,
        n2,
        next,
        offs,
        ok,
        ok2,
        s,
        text,
        $s,
      };
      return $f;
    };
    Scanner.prototype.updateLineInfo = function (next, offs, text) {
      return this.$val.updateLineInfo(next, offs, text);
    };
    trailingDigits = function (text) {
      var _tuple, err, i, n, text;
      i = bytes.LastIndexByte(text, 58);
      if (i < 0) {
        return [0, 0, false];
      }
      _tuple = strconv.ParseUint(
        $bytesToString($subslice(text, (i + 1) >> 0)),
        10,
        0
      );
      n = _tuple[0];
      err = _tuple[1];
      return [(i + 1) >> 0, n.$low >> 0, $interfaceIsEqual(err, $ifaceNil)];
    };
    Scanner.ptr.prototype.findLineEnd = function () {
      var {
        $24r,
        $24r$1,
        $24r$2,
        $24r$3,
        $24r$4,
        ch,
        s,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              s = [s];
              s[0] = this;
              $deferred.push([
                (function (s) {
                  return function $b(offs) {
                    var { offs, $s, $r, $c } = $restore(this, { offs });
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          s[0].ch = 47;
                          s[0].offset = offs;
                          s[0].rdOffset = (offs + 1) >> 0;
                          $r = s[0].next();
                          /* */ $s = 1;
                        case 1:
                          if ($c) {
                            $c = false;
                            $r = $r.$blk();
                          }
                          if ($r && $r.$blk !== undefined) {
                            break s;
                          }
                          $s = -1;
                          return;
                        /* */
                      }
                      return;
                    }
                    var $f = { $blk: $b, $c: true, $r, offs, $s };
                    return $f;
                  };
                })(s),
                [(s[0].offset - 1) >> 0],
              ]);
            /* while (true) { */ case 1:
              /* if (!((s[0].ch === 47) || (s[0].ch === 42))) { break; } */ if (
                !(s[0].ch === 47 || s[0].ch === 42)
              ) {
                $s = 2;
                continue;
              }
              /* */ if (s[0].ch === 47) {
                $s = 3;
                continue;
              }
              /* */ $s = 4;
              continue;
            /* if (s[0].ch === 47) { */ case 3:
              $24r = true;
              $s = 5;
            case 5:
              return $24r;
            /* } */ case 4:
              $r = s[0].next();
              /* */ $s = 6;
            case 6:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
            /* while (true) { */ case 7:
              /* if (!(s[0].ch >= 0)) { break; } */ if (!(s[0].ch >= 0)) {
                $s = 8;
                continue;
              }
              ch = s[0].ch;
              /* */ if (ch === 10) {
                $s = 9;
                continue;
              }
              /* */ $s = 10;
              continue;
            /* if (ch === 10) { */ case 9:
              $24r$1 = true;
              $s = 11;
            case 11:
              return $24r$1;
            /* } */ case 10:
              $r = s[0].next();
              /* */ $s = 12;
            case 12:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              /* */ if (ch === 42 && s[0].ch === 47) {
                $s = 13;
                continue;
              }
              /* */ $s = 14;
              continue;
            /* if ((ch === 42) && (s[0].ch === 47)) { */ case 13:
              $r = s[0].next();
              /* */ $s = 15;
            case 15:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              /* break; */ $s = 8;
              continue;
            /* } */ case 14:
              $s = 7;
              continue;
            case 8:
              $r = s[0].skipWhitespace();
              /* */ $s = 16;
            case 16:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              /* */ if (s[0].ch < 0 || s[0].ch === 10) {
                $s = 17;
                continue;
              }
              /* */ $s = 18;
              continue;
            /* if (s[0].ch < 0 || (s[0].ch === 10)) { */ case 17:
              $24r$2 = true;
              $s = 19;
            case 19:
              return $24r$2;
            /* } */ case 18:
              /* */ if (!(s[0].ch === 47)) {
                $s = 20;
                continue;
              }
              /* */ $s = 21;
              continue;
            /* if (!((s[0].ch === 47))) { */ case 20:
              $24r$3 = false;
              $s = 22;
            case 22:
              return $24r$3;
            /* } */ case 21:
              $r = s[0].next();
              /* */ $s = 23;
            case 23:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              $s = 1;
              continue;
            case 2:
              $24r$4 = false;
              $s = 24;
            case 24:
              return $24r$4;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return false;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Scanner.ptr.prototype.findLineEnd,
            $c: true,
            $r,
            $24r,
            $24r$1,
            $24r$2,
            $24r$3,
            $24r$4,
            ch,
            s,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    Scanner.prototype.findLineEnd = function () {
      return this.$val.findLineEnd();
    };
    isLetter = function (ch) {
      var ch;
      return (
        (97 <= lower(ch) && lower(ch) <= 122) ||
        ch === 95 ||
        (ch >= 128 && unicode.IsLetter(ch))
      );
    };
    isDigit = function (ch) {
      var ch;
      return isDecimal(ch) || (ch >= 128 && unicode.IsDigit(ch));
    };
    Scanner.ptr.prototype.scanIdentifier = function () {
      var { _i, _ref, b, offs, rdOffset, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = s.offset;
            _ref = $subslice(s.src, s.rdOffset);
            _i = 0;
          /* while (true) { */ case 1:
            /* if (!(_i < _ref.$length)) { break; } */ if (
              !(_i < _ref.$length)
            ) {
              $s = 2;
              continue;
            }
            rdOffset = _i;
            b =
              _i < 0 || _i >= _ref.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref.$array[_ref.$offset + _i];
            if (
              (97 <= b && b <= 122) ||
              (65 <= b && b <= 90) ||
              b === 95 ||
              (48 <= b && b <= 57)
            ) {
              _i++;
              /* continue; */ $s = 1;
              continue;
            }
            s.rdOffset = (s.rdOffset + rdOffset) >> 0;
            /* */ if (0 < b && b < 128) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (0 < b && b < 128) { */ case 3:
            s.ch = b >> 0;
            s.offset = s.rdOffset;
            s.rdOffset = (s.rdOffset + 1) >> 0;
            /* goto exit */ $s = 5;
            continue;
          /* } */ case 4:
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* while (true) { */ case 7:
            /* if (!(isLetter(s.ch) || isDigit(s.ch))) { break; } */ if (
              !(isLetter(s.ch) || isDigit(s.ch))
            ) {
              $s = 8;
              continue;
            }
            $r = s.next();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 7;
            continue;
          case 8:
            /* goto exit */ $s = 5;
            continue;
          case 2:
            s.offset = s.src.$length;
            s.rdOffset = s.src.$length;
            s.ch = -1;
          /* exit: */ case 5:
            $s = -1;
            return $bytesToString($subslice(s.src, offs, s.offset));
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanIdentifier,
        $c: true,
        $r,
        _i,
        _ref,
        b,
        offs,
        rdOffset,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanIdentifier = function () {
      return this.$val.scanIdentifier();
    };
    digitVal = function (ch) {
      var ch;
      if (48 <= ch && ch <= 57) {
        return ((ch - 48) >> 0) >> 0;
      } else if (97 <= lower(ch) && lower(ch) <= 102) {
        return ((((lower(ch) - 97) >> 0) + 10) >> 0) >> 0;
      }
      return 16;
    };
    lower = function (ch) {
      var ch;
      return 32 | ch;
    };
    isDecimal = function (ch) {
      var ch;
      return 48 <= ch && ch <= 57;
    };
    isHex = function (ch) {
      var ch;
      return (48 <= ch && ch <= 57) || (97 <= lower(ch) && lower(ch) <= 102);
    };
    Scanner.ptr.prototype.digits = function (base, invalid) {
      var { base, digsep, ds, ds$1, invalid, max, s, $s, $r, $c } = $restore(
        this,
        { base, invalid }
      );
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            digsep = 0;
            s = this;
            /* */ if (base <= 10) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (base <= 10) { */ case 1:
            max = ((48 + base) >> 0) >> 0;
          /* while (true) { */ case 4:
            /* if (!(isDecimal(s.ch) || (s.ch === 95))) { break; } */ if (
              !(isDecimal(s.ch) || s.ch === 95)
            ) {
              $s = 5;
              continue;
            }
            ds = 1;
            if (s.ch === 95) {
              ds = 2;
            } else if (s.ch >= max && invalid.$get() < 0) {
              invalid.$set(s.offset);
            }
            digsep = digsep | ds;
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 4;
            continue;
          case 5:
            $s = 3;
            continue;
          /* } else { */ case 2:
          /* while (true) { */ case 7:
            /* if (!(isHex(s.ch) || (s.ch === 95))) { break; } */ if (
              !(isHex(s.ch) || s.ch === 95)
            ) {
              $s = 8;
              continue;
            }
            ds$1 = 1;
            if (s.ch === 95) {
              ds$1 = 2;
            }
            digsep = digsep | ds$1;
            $r = s.next();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 7;
            continue;
          case 8:
          /* } */ case 3:
            $s = -1;
            return digsep;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.digits,
        $c: true,
        $r,
        base,
        digsep,
        ds,
        ds$1,
        invalid,
        max,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.digits = function (base, invalid) {
      return this.$val.digits(base, invalid);
    };
    Scanner.ptr.prototype.scanNumber = function () {
      var {
        _1,
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        base,
        digsep,
        ds,
        e,
        i,
        invalid,
        lit,
        offs,
        prefix$1,
        s,
        tok,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            invalid = [invalid];
            s = this;
            offs = s.offset;
            tok = 0;
            base = 10;
            prefix$1 = 0;
            digsep = 0;
            invalid[0] = -1;
            /* */ if (!(s.ch === 46)) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!((s.ch === 46))) { */ case 1:
            tok = 5;
            /* */ if (s.ch === 48) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (s.ch === 48) { */ case 3:
            $r = s.next();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _1 = lower(s.ch);
            /* */ if (_1 === 120) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 111) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 98) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (_1 === (120)) { */ case 7:
            $r = s.next();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp = 16;
            _tmp$1 = 120;
            base = _tmp;
            prefix$1 = _tmp$1;
            $s = 11;
            continue;
          /* } else if (_1 === (111)) { */ case 8:
            $r = s.next();
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp$2 = 8;
            _tmp$3 = 111;
            base = _tmp$2;
            prefix$1 = _tmp$3;
            $s = 11;
            continue;
          /* } else if (_1 === (98)) { */ case 9:
            $r = s.next();
            /* */ $s = 14;
          case 14:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp$4 = 2;
            _tmp$5 = 98;
            base = _tmp$4;
            prefix$1 = _tmp$5;
            $s = 11;
            continue;
          /* } else { */ case 10:
            _tmp$6 = 8;
            _tmp$7 = 48;
            base = _tmp$6;
            prefix$1 = _tmp$7;
            digsep = 1;
          /* } */ case 11:
          case 6:
          /* } */ case 4:
            _r = s.digits(
              base,
              invalid.$ptr ||
                (invalid.$ptr = new ptrType(
                  function () {
                    return this.$target[0];
                  },
                  function ($v) {
                    this.$target[0] = $v;
                  },
                  invalid
                ))
            );
            /* */ $s = 15;
          case 15:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            digsep = digsep | _r;
          /* } */ case 2:
            /* */ if (s.ch === 46) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (s.ch === 46) { */ case 16:
            tok = 6;
            /* */ if (prefix$1 === 111 || prefix$1 === 98) {
              $s = 18;
              continue;
            }
            /* */ $s = 19;
            continue;
          /* if ((prefix$1 === 111) || (prefix$1 === 98)) { */ case 18:
            $r = s.error(
              s.offset,
              "invalid radix point in " + litname(prefix$1)
            );
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 19:
            $r = s.next();
            /* */ $s = 21;
          case 21:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r$1 = s.digits(
              base,
              invalid.$ptr ||
                (invalid.$ptr = new ptrType(
                  function () {
                    return this.$target[0];
                  },
                  function ($v) {
                    this.$target[0] = $v;
                  },
                  invalid
                ))
            );
            /* */ $s = 22;
          case 22:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            digsep = digsep | _r$1;
          /* } */ case 17:
            /* */ if ((digsep & 1) === 0) {
              $s = 23;
              continue;
            }
            /* */ $s = 24;
            continue;
          /* if ((digsep & 1) === 0) { */ case 23:
            $r = s.error(s.offset, litname(prefix$1) + " has no digits");
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 24:
            e = lower(s.ch);
            /* */ if (e === 101 || e === 112) {
              $s = 26;
              continue;
            }
            /* */ if (prefix$1 === 120 && tok === 6) {
              $s = 27;
              continue;
            }
            /* */ $s = 28;
            continue;
          /* if ((e === 101) || (e === 112)) { */ case 26:
            /* */ if (e === 101 && !(prefix$1 === 0) && !(prefix$1 === 48)) {
              $s = 30;
              continue;
            }
            /* */ if (e === 112 && !(prefix$1 === 120)) {
              $s = 31;
              continue;
            }
            /* */ $s = 32;
            continue;
          /* if ((e === 101) && !((prefix$1 === 0)) && !((prefix$1 === 48))) { */ case 30:
            $r = s.errorf(
              s.offset,
              "%q exponent requires decimal mantissa",
              new sliceType$1([new $Int32(s.ch)])
            );
            /* */ $s = 33;
          case 33:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 32;
            continue;
          /* } else if ((e === 112) && !((prefix$1 === 120))) { */ case 31:
            $r = s.errorf(
              s.offset,
              "%q exponent requires hexadecimal mantissa",
              new sliceType$1([new $Int32(s.ch)])
            );
            /* */ $s = 34;
          case 34:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 32:
          case 29:
            $r = s.next();
            /* */ $s = 35;
          case 35:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            tok = 6;
            /* */ if (s.ch === 43 || s.ch === 45) {
              $s = 36;
              continue;
            }
            /* */ $s = 37;
            continue;
          /* if ((s.ch === 43) || (s.ch === 45)) { */ case 36:
            $r = s.next();
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 37:
            _r$2 = s.digits(10, ptrType.nil);
            /* */ $s = 39;
          case 39:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            ds = _r$2;
            digsep = digsep | ds;
            /* */ if ((ds & 1) === 0) {
              $s = 40;
              continue;
            }
            /* */ $s = 41;
            continue;
          /* if ((ds & 1) === 0) { */ case 40:
            $r = s.error(s.offset, "exponent has no digits");
            /* */ $s = 42;
          case 42:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 41:
            $s = 28;
            continue;
          /* } else if ((prefix$1 === 120) && (tok === 6)) { */ case 27:
            $r = s.error(
              s.offset,
              "hexadecimal mantissa requires a 'p' exponent"
            );
            /* */ $s = 43;
          case 43:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 28:
            /* */ if (s.ch === 105) {
              $s = 44;
              continue;
            }
            /* */ $s = 45;
            continue;
          /* if (s.ch === 105) { */ case 44:
            tok = 7;
            $r = s.next();
            /* */ $s = 46;
          case 46:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 45:
            lit = $bytesToString($subslice(s.src, offs, s.offset));
            /* */ if (tok === 5 && invalid[0] >= 0) {
              $s = 47;
              continue;
            }
            /* */ $s = 48;
            continue;
          /* if ((tok === 5) && invalid[0] >= 0) { */ case 47:
            $r = s.errorf(
              invalid[0],
              "invalid digit %q in %s",
              new sliceType$1([
                new $Uint8(lit.charCodeAt((invalid[0] - offs) >> 0)),
                new $String(litname(prefix$1)),
              ])
            );
            /* */ $s = 49;
          case 49:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 48:
            /* */ if (!((digsep & 2) === 0)) {
              $s = 50;
              continue;
            }
            /* */ $s = 51;
            continue;
          /* if (!(((digsep & 2) === 0))) { */ case 50:
            i = invalidSep(lit);
            /* */ if (i >= 0) {
              $s = 52;
              continue;
            }
            /* */ $s = 53;
            continue;
          /* if (i >= 0) { */ case 52:
            $r = s.error(
              (offs + i) >> 0,
              "'_' must separate successive digits"
            );
            /* */ $s = 54;
          case 54:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 53:
          /* } */ case 51:
            $s = -1;
            return [tok, lit];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanNumber,
        $c: true,
        $r,
        _1,
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        base,
        digsep,
        ds,
        e,
        i,
        invalid,
        lit,
        offs,
        prefix$1,
        s,
        tok,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanNumber = function () {
      return this.$val.scanNumber();
    };
    litname = function (prefix$1) {
      var _1, prefix$1;
      _1 = prefix$1;
      if (_1 === 120) {
        return "hexadecimal literal";
      } else if (_1 === 111 || _1 === 48) {
        return "octal literal";
      } else if (_1 === 98) {
        return "binary literal";
      }
      return "decimal literal";
    };
    invalidSep = function (x) {
      var d, i, p, x, x1;
      x1 = 32;
      d = 46;
      i = 0;
      if (x.length >= 2 && x.charCodeAt(0) === 48) {
        x1 = lower(x.charCodeAt(1) >> 0);
        if (x1 === 120 || x1 === 111 || x1 === 98) {
          d = 48;
          i = 2;
        }
      }
      while (true) {
        if (!(i < x.length)) {
          break;
        }
        p = d;
        d = x.charCodeAt(i) >> 0;
        if (d === 95) {
          if (!(p === 48)) {
            return i;
          }
        } else if (isDecimal(d) || (x1 === 120 && isHex(d))) {
          d = 48;
        } else {
          if (p === 95) {
            return (i - 1) >> 0;
          }
          d = 46;
        }
        i = (i + 1) >> 0;
      }
      if (d === 95) {
        return (x.length - 1) >> 0;
      }
      return -1;
    };
    Scanner.ptr.prototype.scanEscape = function (quote) {
      var {
        _1,
        _r,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        base,
        d,
        max,
        msg,
        msg$1,
        n,
        offs,
        quote,
        s,
        x,
        $s,
        $r,
        $c,
      } = $restore(this, { quote });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = s.offset;
            n = 0;
            _tmp = 0;
            _tmp$1 = 0;
            base = _tmp;
            max = _tmp$1;
            _1 = s.ch;
            /* */ if (
              _1 === 97 ||
              _1 === 98 ||
              _1 === 102 ||
              _1 === 110 ||
              _1 === 114 ||
              _1 === 116 ||
              _1 === 118 ||
              _1 === 92 ||
              _1 === quote
            ) {
              $s = 2;
              continue;
            }
            /* */ if (
              _1 === 48 ||
              _1 === 49 ||
              _1 === 50 ||
              _1 === 51 ||
              _1 === 52 ||
              _1 === 53 ||
              _1 === 54 ||
              _1 === 55
            ) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 120) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 117) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 85) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if ((_1 === (97)) || (_1 === (98)) || (_1 === (102)) || (_1 === (110)) || (_1 === (114)) || (_1 === (116)) || (_1 === (118)) || (_1 === (92)) || (_1 === (quote))) { */ case 2:
            $r = s.next();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return true;
          /* } else if ((_1 === (48)) || (_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) { */ case 3:
            _tmp$2 = 3;
            _tmp$3 = 8;
            _tmp$4 = 255;
            n = _tmp$2;
            base = _tmp$3;
            max = _tmp$4;
            $s = 8;
            continue;
          /* } else if (_1 === (120)) { */ case 4:
            $r = s.next();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp$5 = 2;
            _tmp$6 = 16;
            _tmp$7 = 255;
            n = _tmp$5;
            base = _tmp$6;
            max = _tmp$7;
            $s = 8;
            continue;
          /* } else if (_1 === (117)) { */ case 5:
            $r = s.next();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp$8 = 4;
            _tmp$9 = 16;
            _tmp$10 = 1114111;
            n = _tmp$8;
            base = _tmp$9;
            max = _tmp$10;
            $s = 8;
            continue;
          /* } else if (_1 === (85)) { */ case 6:
            $r = s.next();
            /* */ $s = 12;
          case 12:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _tmp$11 = 8;
            _tmp$12 = 16;
            _tmp$13 = 1114111;
            n = _tmp$11;
            base = _tmp$12;
            max = _tmp$13;
            $s = 8;
            continue;
          /* } else { */ case 7:
            msg = "unknown escape sequence";
            if (s.ch < 0) {
              msg = "escape sequence not terminated";
            }
            $r = s.error(offs, msg);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return false;
          /* } */ case 8:
          case 1:
            x = 0;
          /* while (true) { */ case 14:
            /* if (!(n > 0)) { break; } */ if (!(n > 0)) {
              $s = 15;
              continue;
            }
            d = digitVal(s.ch) >>> 0;
            /* */ if (d >= base) {
              $s = 16;
              continue;
            }
            /* */ $s = 17;
            continue;
          /* if (d >= base) { */ case 16:
            _r = fmt.Sprintf(
              "illegal character %#U in escape sequence",
              new sliceType$1([new $Int32(s.ch)])
            );
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            msg$1 = _r;
            if (s.ch < 0) {
              msg$1 = "escape sequence not terminated";
            }
            $r = s.error(s.offset, msg$1);
            /* */ $s = 19;
          case 19:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return false;
          /* } */ case 17:
            x = (($imul(x, base) >>> 0) + d) >>> 0;
            $r = s.next();
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            n = (n - 1) >> 0;
            $s = 14;
            continue;
          case 15:
            /* */ if (x > max || (55296 <= x && x < 57344)) {
              $s = 21;
              continue;
            }
            /* */ $s = 22;
            continue;
          /* if (x > max || 55296 <= x && x < 57344) { */ case 21:
            $r = s.error(offs, "escape sequence is invalid Unicode code point");
            /* */ $s = 23;
          case 23:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return false;
          /* } */ case 22:
            $s = -1;
            return true;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanEscape,
        $c: true,
        $r,
        _1,
        _r,
        _tmp,
        _tmp$1,
        _tmp$10,
        _tmp$11,
        _tmp$12,
        _tmp$13,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tmp$9,
        base,
        d,
        max,
        msg,
        msg$1,
        n,
        offs,
        quote,
        s,
        x,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanEscape = function (quote) {
      return this.$val.scanEscape(quote);
    };
    Scanner.ptr.prototype.scanRune = function () {
      var { _r, ch, n, offs, s, valid, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = (s.offset - 1) >> 0;
            valid = true;
            n = 0;
          /* while (true) { */ case 1:
            ch = s.ch;
            /* */ if (ch === 10 || ch < 0) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if ((ch === 10) || ch < 0) { */ case 3:
            /* */ if (valid) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (valid) { */ case 5:
            $r = s.error(offs, "rune literal not terminated");
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            valid = false;
          /* } */ case 6:
            /* break; */ $s = 2;
            continue;
          /* } */ case 4:
            $r = s.next();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (ch === 39) {
              /* break; */ $s = 2;
              continue;
            }
            n = (n + 1) >> 0;
            /* */ if (ch === 92) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (ch === 92) { */ case 9:
            _r = s.scanEscape(39);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            /* */ if (!_r) {
              $s = 11;
              continue;
            }
            /* */ $s = 12;
            continue;
          /* if (!_r) { */ case 11:
            valid = false;
          /* } */ case 12:
          /* } */ case 10:
            $s = 1;
            continue;
          case 2:
            /* */ if (valid && !(n === 1)) {
              $s = 14;
              continue;
            }
            /* */ $s = 15;
            continue;
          /* if (valid && !((n === 1))) { */ case 14:
            $r = s.error(offs, "illegal rune literal");
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 15:
            $s = -1;
            return $bytesToString($subslice(s.src, offs, s.offset));
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanRune,
        $c: true,
        $r,
        _r,
        ch,
        n,
        offs,
        s,
        valid,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanRune = function () {
      return this.$val.scanRune();
    };
    Scanner.ptr.prototype.scanString = function () {
      var { _r, ch, offs, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = (s.offset - 1) >> 0;
          /* while (true) { */ case 1:
            ch = s.ch;
            /* */ if (ch === 10 || ch < 0) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if ((ch === 10) || ch < 0) { */ case 3:
            $r = s.error(offs, "string literal not terminated");
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            /* break; */ $s = 2;
            continue;
          /* } */ case 4:
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (ch === 34) {
              /* break; */ $s = 2;
              continue;
            }
            /* */ if (ch === 92) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (ch === 92) { */ case 7:
            _r = s.scanEscape(34);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _r;
          /* } */ case 8:
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return $bytesToString($subslice(s.src, offs, s.offset));
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanString,
        $c: true,
        $r,
        _r,
        ch,
        offs,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanString = function () {
      return this.$val.scanString();
    };
    stripCR = function (b, comment) {
      var _i, _ref, b, c, ch, comment, i, j, x, x$1;
      c = $makeSlice(sliceType, b.$length);
      i = 0;
      _ref = b;
      _i = 0;
      while (true) {
        if (!(_i < _ref.$length)) {
          break;
        }
        j = _i;
        ch =
          _i < 0 || _i >= _ref.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : _ref.$array[_ref.$offset + _i];
        if (
          !(ch === 13) ||
          (comment &&
            i > 2 &&
            ((x = (i - 1) >> 0),
            x < 0 || x >= c.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : c.$array[c.$offset + x]) === 42 &&
            (j + 1) >> 0 < b.$length &&
            ((x$1 = (j + 1) >> 0),
            x$1 < 0 || x$1 >= b.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : b.$array[b.$offset + x$1]) === 47)
        ) {
          i < 0 || i >= c.$length
            ? ($throwRuntimeError("index out of range"), undefined)
            : (c.$array[c.$offset + i] = ch);
          i = (i + 1) >> 0;
        }
        _i++;
      }
      return $subslice(c, 0, i);
    };
    Scanner.ptr.prototype.scanRawString = function () {
      var { ch, hasCR, lit, offs, s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            offs = (s.offset - 1) >> 0;
            hasCR = false;
          /* while (true) { */ case 1:
            ch = s.ch;
            /* */ if (ch < 0) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (ch < 0) { */ case 3:
            $r = s.error(offs, "raw string literal not terminated");
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            /* break; */ $s = 2;
            continue;
          /* } */ case 4:
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            if (ch === 96) {
              /* break; */ $s = 2;
              continue;
            }
            if (ch === 13) {
              hasCR = true;
            }
            $s = 1;
            continue;
          case 2:
            lit = $subslice(s.src, offs, s.offset);
            if (hasCR) {
              lit = stripCR(lit, false);
            }
            $s = -1;
            return $bytesToString(lit);
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.scanRawString,
        $c: true,
        $r,
        ch,
        hasCR,
        lit,
        offs,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.scanRawString = function () {
      return this.$val.scanRawString();
    };
    Scanner.ptr.prototype.skipWhitespace = function () {
      var { s, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
          /* while (true) { */ case 1:
            /* if (!((s.ch === 32) || (s.ch === 9) || (s.ch === 10) && !s.insertSemi || (s.ch === 13))) { break; } */ if (
              !(
                s.ch === 32 ||
                s.ch === 9 ||
                (s.ch === 10 && !s.insertSemi) ||
                s.ch === 13
              )
            ) {
              $s = 2;
              continue;
            }
            $r = s.next();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 1;
            continue;
          case 2:
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.skipWhitespace,
        $c: true,
        $r,
        s,
        $s,
      };
      return $f;
    };
    Scanner.prototype.skipWhitespace = function () {
      return this.$val.skipWhitespace();
    };
    Scanner.ptr.prototype.switch2 = function (tok0, tok1) {
      var { s, tok0, tok1, $s, $r, $c } = $restore(this, { tok0, tok1 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (s.ch === 61) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (s.ch === 61) { */ case 1:
            $r = s.next();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return tok1;
          /* } */ case 2:
            $s = -1;
            return tok0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.switch2,
        $c: true,
        $r,
        s,
        tok0,
        tok1,
        $s,
      };
      return $f;
    };
    Scanner.prototype.switch2 = function (tok0, tok1) {
      return this.$val.switch2(tok0, tok1);
    };
    Scanner.ptr.prototype.switch3 = function (tok0, tok1, ch2, tok2) {
      var { ch2, s, tok0, tok1, tok2, $s, $r, $c } = $restore(this, {
        tok0,
        tok1,
        ch2,
        tok2,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (s.ch === 61) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (s.ch === 61) { */ case 1:
            $r = s.next();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return tok1;
          /* } */ case 2:
            /* */ if (s.ch === ch2) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (s.ch === ch2) { */ case 4:
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return tok2;
          /* } */ case 5:
            $s = -1;
            return tok0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.switch3,
        $c: true,
        $r,
        ch2,
        s,
        tok0,
        tok1,
        tok2,
        $s,
      };
      return $f;
    };
    Scanner.prototype.switch3 = function (tok0, tok1, ch2, tok2) {
      return this.$val.switch3(tok0, tok1, ch2, tok2);
    };
    Scanner.ptr.prototype.switch4 = function (tok0, tok1, ch2, tok2, tok3) {
      var { ch2, s, tok0, tok1, tok2, tok3, $s, $r, $c } = $restore(this, {
        tok0,
        tok1,
        ch2,
        tok2,
        tok3,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            s = this;
            /* */ if (s.ch === 61) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (s.ch === 61) { */ case 1:
            $r = s.next();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return tok1;
          /* } */ case 2:
            /* */ if (s.ch === ch2) {
              $s = 4;
              continue;
            }
            /* */ $s = 5;
            continue;
          /* if (s.ch === ch2) { */ case 4:
            $r = s.next();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            /* */ if (s.ch === 61) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (s.ch === 61) { */ case 7:
            $r = s.next();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return tok3;
          /* } */ case 8:
            $s = -1;
            return tok2;
          /* } */ case 5:
            $s = -1;
            return tok0;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.switch4,
        $c: true,
        $r,
        ch2,
        s,
        tok0,
        tok1,
        tok2,
        tok3,
        $s,
      };
      return $f;
    };
    Scanner.prototype.switch4 = function (tok0, tok1, ch2, tok2, tok3) {
      return this.$val.switch4(tok0, tok1, ch2, tok2, tok3);
    };
    Scanner.ptr.prototype.Scan = function () {
      var {
        _1,
        _2,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$19,
        _r$2,
        _r$20,
        _r$21,
        _r$22,
        _r$23,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tuple,
        _v,
        ch,
        comment,
        insertSemi,
        lit,
        pos,
        s,
        tok,
        $s,
        $r,
        $c,
      } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            pos = 0;
            tok = 0;
            lit = "";
            s = this;
          /* scanAgain: */ case 1:
            $r = s.skipWhitespace();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r = s.file.Pos(s.offset);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            pos = _r;
            insertSemi = false;
            ch = s.ch;
            /* */ if (isLetter(ch)) {
              $s = 5;
              continue;
            }
            /* */ if (
              isDecimal(ch) ||
              (ch === 46 && isDecimal(s.peek() >> 0))
            ) {
              $s = 6;
              continue;
            }
            /* */ $s = 7;
            continue;
          /* if (isLetter(ch)) { */ case 5:
            _r$1 = s.scanIdentifier();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            lit = _r$1;
            if (lit.length > 1) {
              tok = token.Lookup(lit);
              _1 = tok;
              if (
                _1 === 4 ||
                _1 === 61 ||
                _1 === 65 ||
                _1 === 69 ||
                _1 === 80
              ) {
                insertSemi = true;
              }
            } else {
              insertSemi = true;
              tok = 4;
            }
            $s = 8;
            continue;
          /* } else if (isDecimal(ch) || (ch === 46) && isDecimal(((s.peek() >> 0)))) { */ case 6:
            insertSemi = true;
            _r$2 = s.scanNumber();
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _tuple = _r$2;
            tok = _tuple[0];
            lit = _tuple[1];
            $s = 8;
            continue;
          /* } else { */ case 7:
            $r = s.next();
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _2 = ch;
            /* */ if (_2 === -1) {
              $s = 13;
              continue;
            }
            /* */ if (_2 === 10) {
              $s = 14;
              continue;
            }
            /* */ if (_2 === 34) {
              $s = 15;
              continue;
            }
            /* */ if (_2 === 39) {
              $s = 16;
              continue;
            }
            /* */ if (_2 === 96) {
              $s = 17;
              continue;
            }
            /* */ if (_2 === 58) {
              $s = 18;
              continue;
            }
            /* */ if (_2 === 46) {
              $s = 19;
              continue;
            }
            /* */ if (_2 === 44) {
              $s = 20;
              continue;
            }
            /* */ if (_2 === 59) {
              $s = 21;
              continue;
            }
            /* */ if (_2 === 40) {
              $s = 22;
              continue;
            }
            /* */ if (_2 === 41) {
              $s = 23;
              continue;
            }
            /* */ if (_2 === 91) {
              $s = 24;
              continue;
            }
            /* */ if (_2 === 93) {
              $s = 25;
              continue;
            }
            /* */ if (_2 === 123) {
              $s = 26;
              continue;
            }
            /* */ if (_2 === 125) {
              $s = 27;
              continue;
            }
            /* */ if (_2 === 43) {
              $s = 28;
              continue;
            }
            /* */ if (_2 === 45) {
              $s = 29;
              continue;
            }
            /* */ if (_2 === 42) {
              $s = 30;
              continue;
            }
            /* */ if (_2 === 47) {
              $s = 31;
              continue;
            }
            /* */ if (_2 === 37) {
              $s = 32;
              continue;
            }
            /* */ if (_2 === 94) {
              $s = 33;
              continue;
            }
            /* */ if (_2 === 60) {
              $s = 34;
              continue;
            }
            /* */ if (_2 === 62) {
              $s = 35;
              continue;
            }
            /* */ if (_2 === 61) {
              $s = 36;
              continue;
            }
            /* */ if (_2 === 33) {
              $s = 37;
              continue;
            }
            /* */ if (_2 === 38) {
              $s = 38;
              continue;
            }
            /* */ if (_2 === 124) {
              $s = 39;
              continue;
            }
            /* */ if (_2 === 126) {
              $s = 40;
              continue;
            }
            /* */ $s = 41;
            continue;
          /* if (_2 === (-1)) { */ case 13:
            if (s.insertSemi) {
              s.insertSemi = false;
              _tmp = pos;
              _tmp$1 = 57;
              _tmp$2 = "\n";
              pos = _tmp;
              tok = _tmp$1;
              lit = _tmp$2;
              $s = -1;
              return [pos, tok, lit];
            }
            tok = 1;
            $s = 42;
            continue;
          /* } else if (_2 === (10)) { */ case 14:
            s.insertSemi = false;
            _tmp$3 = pos;
            _tmp$4 = 57;
            _tmp$5 = "\n";
            pos = _tmp$3;
            tok = _tmp$4;
            lit = _tmp$5;
            $s = -1;
            return [pos, tok, lit];
          /* } else if (_2 === (34)) { */ case 15:
            insertSemi = true;
            tok = 9;
            _r$3 = s.scanString();
            /* */ $s = 43;
          case 43:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            lit = _r$3;
            $s = 42;
            continue;
          /* } else if (_2 === (39)) { */ case 16:
            insertSemi = true;
            tok = 8;
            _r$4 = s.scanRune();
            /* */ $s = 44;
          case 44:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            lit = _r$4;
            $s = 42;
            continue;
          /* } else if (_2 === (96)) { */ case 17:
            insertSemi = true;
            tok = 9;
            _r$5 = s.scanRawString();
            /* */ $s = 45;
          case 45:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            lit = _r$5;
            $s = 42;
            continue;
          /* } else if (_2 === (58)) { */ case 18:
            _r$6 = s.switch2(58, 47);
            /* */ $s = 46;
          case 46:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            tok = _r$6;
            $s = 42;
            continue;
          /* } else if (_2 === (46)) { */ case 19:
            tok = 53;
            /* */ if (s.ch === 46 && s.peek() === 46) {
              $s = 47;
              continue;
            }
            /* */ $s = 48;
            continue;
          /* if ((s.ch === 46) && (s.peek() === 46)) { */ case 47:
            $r = s.next();
            /* */ $s = 49;
          case 49:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = s.next();
            /* */ $s = 50;
          case 50:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            tok = 48;
          /* } */ case 48:
            $s = 42;
            continue;
          /* } else if (_2 === (44)) { */ case 20:
            tok = 52;
            $s = 42;
            continue;
          /* } else if (_2 === (59)) { */ case 21:
            tok = 57;
            lit = ";";
            $s = 42;
            continue;
          /* } else if (_2 === (40)) { */ case 22:
            tok = 49;
            $s = 42;
            continue;
          /* } else if (_2 === (41)) { */ case 23:
            insertSemi = true;
            tok = 54;
            $s = 42;
            continue;
          /* } else if (_2 === (91)) { */ case 24:
            tok = 50;
            $s = 42;
            continue;
          /* } else if (_2 === (93)) { */ case 25:
            insertSemi = true;
            tok = 55;
            $s = 42;
            continue;
          /* } else if (_2 === (123)) { */ case 26:
            tok = 51;
            $s = 42;
            continue;
          /* } else if (_2 === (125)) { */ case 27:
            insertSemi = true;
            tok = 56;
            $s = 42;
            continue;
          /* } else if (_2 === (43)) { */ case 28:
            _r$7 = s.switch3(12, 23, 43, 37);
            /* */ $s = 51;
          case 51:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            tok = _r$7;
            if (tok === 37) {
              insertSemi = true;
            }
            $s = 42;
            continue;
          /* } else if (_2 === (45)) { */ case 29:
            _r$8 = s.switch3(13, 24, 45, 38);
            /* */ $s = 52;
          case 52:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            tok = _r$8;
            if (tok === 38) {
              insertSemi = true;
            }
            $s = 42;
            continue;
          /* } else if (_2 === (42)) { */ case 30:
            _r$9 = s.switch2(14, 25);
            /* */ $s = 53;
          case 53:
            if ($c) {
              $c = false;
              _r$9 = _r$9.$blk();
            }
            if (_r$9 && _r$9.$blk !== undefined) {
              break s;
            }
            tok = _r$9;
            $s = 42;
            continue;
          /* } else if (_2 === (47)) { */ case 31:
            /* */ if (s.ch === 47 || s.ch === 42) {
              $s = 54;
              continue;
            }
            /* */ $s = 55;
            continue;
          /* if ((s.ch === 47) || (s.ch === 42)) { */ case 54:
            if (!s.insertSemi) {
              _v = false;
              $s = 59;
              continue s;
            }
            _r$10 = s.findLineEnd();
            /* */ $s = 60;
          case 60:
            if ($c) {
              $c = false;
              _r$10 = _r$10.$blk();
            }
            if (_r$10 && _r$10.$blk !== undefined) {
              break s;
            }
            _v = _r$10;
          case 59:
            /* */ if (_v) {
              $s = 57;
              continue;
            }
            /* */ $s = 58;
            continue;
          /* if (_v) { */ case 57:
            s.ch = 47;
            _r$11 = s.file.Offset(pos);
            /* */ $s = 61;
          case 61:
            if ($c) {
              $c = false;
              _r$11 = _r$11.$blk();
            }
            if (_r$11 && _r$11.$blk !== undefined) {
              break s;
            }
            s.offset = _r$11;
            s.rdOffset = (s.offset + 1) >> 0;
            s.insertSemi = false;
            _tmp$6 = pos;
            _tmp$7 = 57;
            _tmp$8 = "\n";
            pos = _tmp$6;
            tok = _tmp$7;
            lit = _tmp$8;
            $s = -1;
            return [pos, tok, lit];
          /* } */ case 58:
            _r$12 = s.scanComment();
            /* */ $s = 62;
          case 62:
            if ($c) {
              $c = false;
              _r$12 = _r$12.$blk();
            }
            if (_r$12 && _r$12.$blk !== undefined) {
              break s;
            }
            comment = _r$12;
            /* */ if ((s.mode & 1) >>> 0 === 0) {
              $s = 63;
              continue;
            }
            /* */ $s = 64;
            continue;
          /* if (((s.mode & 1) >>> 0) === 0) { */ case 63:
            s.insertSemi = false;
            /* goto scanAgain */ $s = 1;
            continue;
          /* } */ case 64:
            tok = 2;
            lit = comment;
            $s = 56;
            continue;
          /* } else { */ case 55:
            _r$13 = s.switch2(15, 26);
            /* */ $s = 65;
          case 65:
            if ($c) {
              $c = false;
              _r$13 = _r$13.$blk();
            }
            if (_r$13 && _r$13.$blk !== undefined) {
              break s;
            }
            tok = _r$13;
          /* } */ case 56:
            $s = 42;
            continue;
          /* } else if (_2 === (37)) { */ case 32:
            _r$14 = s.switch2(16, 27);
            /* */ $s = 66;
          case 66:
            if ($c) {
              $c = false;
              _r$14 = _r$14.$blk();
            }
            if (_r$14 && _r$14.$blk !== undefined) {
              break s;
            }
            tok = _r$14;
            $s = 42;
            continue;
          /* } else if (_2 === (94)) { */ case 33:
            _r$15 = s.switch2(19, 30);
            /* */ $s = 67;
          case 67:
            if ($c) {
              $c = false;
              _r$15 = _r$15.$blk();
            }
            if (_r$15 && _r$15.$blk !== undefined) {
              break s;
            }
            tok = _r$15;
            $s = 42;
            continue;
          /* } else if (_2 === (60)) { */ case 34:
            /* */ if (s.ch === 45) {
              $s = 68;
              continue;
            }
            /* */ $s = 69;
            continue;
          /* if (s.ch === 45) { */ case 68:
            $r = s.next();
            /* */ $s = 71;
          case 71:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            tok = 36;
            $s = 70;
            continue;
          /* } else { */ case 69:
            _r$16 = s.switch4(40, 45, 60, 20, 31);
            /* */ $s = 72;
          case 72:
            if ($c) {
              $c = false;
              _r$16 = _r$16.$blk();
            }
            if (_r$16 && _r$16.$blk !== undefined) {
              break s;
            }
            tok = _r$16;
          /* } */ case 70:
            $s = 42;
            continue;
          /* } else if (_2 === (62)) { */ case 35:
            _r$17 = s.switch4(41, 46, 62, 21, 32);
            /* */ $s = 73;
          case 73:
            if ($c) {
              $c = false;
              _r$17 = _r$17.$blk();
            }
            if (_r$17 && _r$17.$blk !== undefined) {
              break s;
            }
            tok = _r$17;
            $s = 42;
            continue;
          /* } else if (_2 === (61)) { */ case 36:
            _r$18 = s.switch2(42, 39);
            /* */ $s = 74;
          case 74:
            if ($c) {
              $c = false;
              _r$18 = _r$18.$blk();
            }
            if (_r$18 && _r$18.$blk !== undefined) {
              break s;
            }
            tok = _r$18;
            $s = 42;
            continue;
          /* } else if (_2 === (33)) { */ case 37:
            _r$19 = s.switch2(43, 44);
            /* */ $s = 75;
          case 75:
            if ($c) {
              $c = false;
              _r$19 = _r$19.$blk();
            }
            if (_r$19 && _r$19.$blk !== undefined) {
              break s;
            }
            tok = _r$19;
            $s = 42;
            continue;
          /* } else if (_2 === (38)) { */ case 38:
            /* */ if (s.ch === 94) {
              $s = 76;
              continue;
            }
            /* */ $s = 77;
            continue;
          /* if (s.ch === 94) { */ case 76:
            $r = s.next();
            /* */ $s = 79;
          case 79:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            _r$20 = s.switch2(22, 33);
            /* */ $s = 80;
          case 80:
            if ($c) {
              $c = false;
              _r$20 = _r$20.$blk();
            }
            if (_r$20 && _r$20.$blk !== undefined) {
              break s;
            }
            tok = _r$20;
            $s = 78;
            continue;
          /* } else { */ case 77:
            _r$21 = s.switch3(17, 28, 38, 34);
            /* */ $s = 81;
          case 81:
            if ($c) {
              $c = false;
              _r$21 = _r$21.$blk();
            }
            if (_r$21 && _r$21.$blk !== undefined) {
              break s;
            }
            tok = _r$21;
          /* } */ case 78:
            $s = 42;
            continue;
          /* } else if (_2 === (124)) { */ case 39:
            _r$22 = s.switch3(18, 29, 124, 35);
            /* */ $s = 82;
          case 82:
            if ($c) {
              $c = false;
              _r$22 = _r$22.$blk();
            }
            if (_r$22 && _r$22.$blk !== undefined) {
              break s;
            }
            tok = _r$22;
            $s = 42;
            continue;
          /* } else if (_2 === (126)) { */ case 40:
            tok = 88;
            $s = 42;
            continue;
          /* } else { */ case 41:
            /* */ if (!(ch === 65279)) {
              $s = 83;
              continue;
            }
            /* */ $s = 84;
            continue;
          /* if (!((ch === 65279))) { */ case 83:
            _r$23 = s.file.Offset(pos);
            /* */ $s = 85;
          case 85:
            if ($c) {
              $c = false;
              _r$23 = _r$23.$blk();
            }
            if (_r$23 && _r$23.$blk !== undefined) {
              break s;
            }
            $r = s.errorf(
              _r$23,
              "illegal character %#U",
              new sliceType$1([new $Int32(ch)])
            );
            /* */ $s = 86;
          case 86:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 84:
            insertSemi = s.insertSemi;
            tok = 0;
            lit = $encodeRune(ch);
          /* } */ case 42:
          case 12:
          /* } */ case 8:
          case 4:
            if ((s.mode & 2) >>> 0 === 0) {
              s.insertSemi = insertSemi;
            }
            $s = -1;
            return [pos, tok, lit];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Scanner.ptr.prototype.Scan,
        $c: true,
        $r,
        _1,
        _2,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$19,
        _r$2,
        _r$20,
        _r$21,
        _r$22,
        _r$23,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _tmp,
        _tmp$1,
        _tmp$2,
        _tmp$3,
        _tmp$4,
        _tmp$5,
        _tmp$6,
        _tmp$7,
        _tmp$8,
        _tuple,
        _v,
        ch,
        comment,
        insertSemi,
        lit,
        pos,
        s,
        tok,
        $s,
      };
      return $f;
    };
    Scanner.prototype.Scan = function () {
      return this.$val.Scan();
    };
    ptrType$2.methods = [
      {
        prop: "next",
        name: "next",
        pkg: "go/scanner",
        typ: $funcType([], [], false),
      },
      {
        prop: "peek",
        name: "peek",
        pkg: "go/scanner",
        typ: $funcType([], [$Uint8], false),
      },
      {
        prop: "Init",
        name: "Init",
        pkg: "",
        typ: $funcType([ptrType$1, sliceType, ErrorHandler, Mode], [], false),
      },
      {
        prop: "error",
        name: "error",
        pkg: "go/scanner",
        typ: $funcType([$Int, $String], [], false),
      },
      {
        prop: "errorf",
        name: "errorf",
        pkg: "go/scanner",
        typ: $funcType([$Int, $String, sliceType$1], [], true),
      },
      {
        prop: "scanComment",
        name: "scanComment",
        pkg: "go/scanner",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "updateLineInfo",
        name: "updateLineInfo",
        pkg: "go/scanner",
        typ: $funcType([$Int, $Int, sliceType], [], false),
      },
      {
        prop: "findLineEnd",
        name: "findLineEnd",
        pkg: "go/scanner",
        typ: $funcType([], [$Bool], false),
      },
      {
        prop: "scanIdentifier",
        name: "scanIdentifier",
        pkg: "go/scanner",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "digits",
        name: "digits",
        pkg: "go/scanner",
        typ: $funcType([$Int, ptrType], [$Int], false),
      },
      {
        prop: "scanNumber",
        name: "scanNumber",
        pkg: "go/scanner",
        typ: $funcType([], [token.Token, $String], false),
      },
      {
        prop: "scanEscape",
        name: "scanEscape",
        pkg: "go/scanner",
        typ: $funcType([$Int32], [$Bool], false),
      },
      {
        prop: "scanRune",
        name: "scanRune",
        pkg: "go/scanner",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "scanString",
        name: "scanString",
        pkg: "go/scanner",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "scanRawString",
        name: "scanRawString",
        pkg: "go/scanner",
        typ: $funcType([], [$String], false),
      },
      {
        prop: "skipWhitespace",
        name: "skipWhitespace",
        pkg: "go/scanner",
        typ: $funcType([], [], false),
      },
      {
        prop: "switch2",
        name: "switch2",
        pkg: "go/scanner",
        typ: $funcType([token.Token, token.Token], [token.Token], false),
      },
      {
        prop: "switch3",
        name: "switch3",
        pkg: "go/scanner",
        typ: $funcType(
          [token.Token, token.Token, $Int32, token.Token],
          [token.Token],
          false
        ),
      },
      {
        prop: "switch4",
        name: "switch4",
        pkg: "go/scanner",
        typ: $funcType(
          [token.Token, token.Token, $Int32, token.Token, token.Token],
          [token.Token],
          false
        ),
      },
      {
        prop: "Scan",
        name: "Scan",
        pkg: "",
        typ: $funcType([], [token.Pos, token.Token, $String], false),
      },
    ];
    ErrorHandler.init([token.Position, $String], [], false);
    Scanner.init("go/scanner", [
      {
        prop: "file",
        name: "file",
        embedded: false,
        exported: false,
        typ: ptrType$1,
        tag: "",
      },
      {
        prop: "dir",
        name: "dir",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "src",
        name: "src",
        embedded: false,
        exported: false,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "err",
        name: "err",
        embedded: false,
        exported: false,
        typ: ErrorHandler,
        tag: "",
      },
      {
        prop: "mode",
        name: "mode",
        embedded: false,
        exported: false,
        typ: Mode,
        tag: "",
      },
      {
        prop: "ch",
        name: "ch",
        embedded: false,
        exported: false,
        typ: $Int32,
        tag: "",
      },
      {
        prop: "offset",
        name: "offset",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "rdOffset",
        name: "rdOffset",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "lineOffset",
        name: "lineOffset",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "insertSemi",
        name: "insertSemi",
        embedded: false,
        exported: false,
        typ: $Bool,
        tag: "",
      },
      {
        prop: "ErrorCount",
        name: "ErrorCount",
        embedded: false,
        exported: true,
        typ: $Int,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = bytes.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = fmt.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = token.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = io.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = filepath.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = sort.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strconv.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = unicode.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = utf8.$init();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            prefix = new sliceType($stringToBytes("line "));
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["github.com/maja42/goval/internal"] = (function () {
    var $pkg = {},
      $init,
      errors,
      fmt,
      scanner,
      token,
      math,
      reflect,
      runtime,
      strconv,
      strings,
      yySymType,
      yyLexer,
      yyParserImpl,
      Token,
      Lexer,
      arrayType,
      structType,
      arrayType$1,
      sliceType,
      mapType,
      arrayType$2,
      sliceType$1,
      sliceType$2,
      ptrType,
      ptrType$1,
      sliceType$3,
      ptrType$2,
      ptrType$3,
      funcType,
      mapType$1,
      yyToknames,
      yyStatenames,
      yyExca,
      yyAct,
      yyPact,
      yyPgo,
      yyR1,
      yyR2,
      yyChk,
      yyDef,
      yyTok1,
      yyTok2,
      yyTok3,
      yyErrorMessages,
      yyDebug,
      yyErrorVerbose,
      init,
      typeOf,
      asBool,
      asInteger,
      add,
      sub,
      mul,
      div,
      mod,
      unaryMinus,
      deepEqual,
      compare,
      compareInt,
      compareFloat,
      asObjectKey,
      addObjectMember,
      accessVar,
      accessField,
      slice,
      arrayContains,
      callFunction,
      callAndRecover,
      yyNewParser,
      yyTokname,
      yyStatname,
      yyErrorMessage,
      yylex1,
      NewLexer,
      Evaluate;
    errors = $packages["errors"];
    fmt = $packages["fmt"];
    scanner = $packages["go/scanner"];
    token = $packages["go/token"];
    math = $packages["math"];
    reflect = $packages["reflect"];
    runtime = $packages["runtime"];
    strconv = $packages["strconv"];
    strings = $packages["strings"];
    yySymType = $pkg.yySymType = $newType(
      0,
      $kindStruct,
      "internal.yySymType",
      true,
      "github.com/maja42/goval/internal",
      false,
      function (yys_, token_, expr_, exprList_, exprMap_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.yys = 0;
          this.token = new Token.ptr("", $ifaceNil);
          this.expr = $ifaceNil;
          this.exprList = sliceType.nil;
          this.exprMap = false;
          return;
        }
        this.yys = yys_;
        this.token = token_;
        this.expr = expr_;
        this.exprList = exprList_;
        this.exprMap = exprMap_;
      }
    );
    yyLexer = $pkg.yyLexer = $newType(
      8,
      $kindInterface,
      "internal.yyLexer",
      true,
      "github.com/maja42/goval/internal",
      false,
      null
    );
    yyParserImpl = $pkg.yyParserImpl = $newType(
      0,
      $kindStruct,
      "internal.yyParserImpl",
      true,
      "github.com/maja42/goval/internal",
      false,
      function (lval_, stack_, char$2_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.lval = new yySymType.ptr(
            0,
            new Token.ptr("", $ifaceNil),
            $ifaceNil,
            sliceType.nil,
            false
          );
          this.stack = arrayType$2.zero();
          this.char$2 = 0;
          return;
        }
        this.lval = lval_;
        this.stack = stack_;
        this.char$2 = char$2_;
      }
    );
    Token = $pkg.Token = $newType(
      0,
      $kindStruct,
      "internal.Token",
      true,
      "github.com/maja42/goval/internal",
      true,
      function (literal_, value_) {
        this.$val = this;
        if (arguments.length === 0) {
          this.literal = "";
          this.value = $ifaceNil;
          return;
        }
        this.literal = literal_;
        this.value = value_;
      }
    );
    Lexer = $pkg.Lexer = $newType(
      0,
      $kindStruct,
      "internal.Lexer",
      true,
      "github.com/maja42/goval/internal",
      true,
      function (
        scanner_,
        result_,
        nextTokenType_,
        nextTokenInfo_,
        variables_,
        functions_
      ) {
        this.$val = this;
        if (arguments.length === 0) {
          this.scanner = new scanner.Scanner.ptr(
            ptrType$1.nil,
            "",
            sliceType$3.nil,
            $throwNilPointerError,
            0,
            0,
            0,
            0,
            0,
            false,
            0
          );
          this.result = $ifaceNil;
          this.nextTokenType = 0;
          this.nextTokenInfo = new Token.ptr("", $ifaceNil);
          this.variables = false;
          this.functions = false;
          return;
        }
        this.scanner = scanner_;
        this.result = result_;
        this.nextTokenType = nextTokenType_;
        this.nextTokenInfo = nextTokenInfo_;
        this.variables = variables_;
        this.functions = functions_;
      }
    );
    arrayType = $arrayType($String, 0);
    structType = $structType("github.com/maja42/goval/internal", [
      {
        prop: "state",
        name: "state",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "token",
        name: "token",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "msg",
        name: "msg",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
    ]);
    arrayType$1 = $arrayType(structType, 0);
    sliceType = $sliceType($emptyInterface);
    mapType = $mapType($String, $emptyInterface);
    arrayType$2 = $arrayType(yySymType, 16);
    sliceType$1 = $sliceType($Int);
    sliceType$2 = $sliceType(yySymType);
    ptrType = $ptrType(Lexer);
    ptrType$1 = $ptrType(token.File);
    sliceType$3 = $sliceType($Uint8);
    ptrType$2 = $ptrType(yySymType);
    ptrType$3 = $ptrType(yyParserImpl);
    funcType = $funcType([sliceType], [$emptyInterface, $error], true);
    mapType$1 = $mapType($String, funcType);
    init = function () {
      yyDebug = 0;
      yyErrorVerbose = true;
    };
    typeOf = function (val) {
      var { _1, _r, _tuple, _tuple$1, kind, ok, ok$1, val, $s, $r, $c } =
        $restore(this, { val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if ($interfaceIsEqual(val, $ifaceNil)) {
              $s = -1;
              return "nil";
            }
            _r = reflect.TypeOf(val).Kind();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            kind = _r;
            _1 = kind;
            if (_1 === 1) {
              $s = -1;
              return "bool";
            } else if (_1 === 2 || _1 === 14) {
              $s = -1;
              return "number";
            } else if (_1 === 24) {
              $s = -1;
              return "string";
            }
            _tuple = $assertType(val, sliceType, true);
            ok = _tuple[1];
            if (ok) {
              $s = -1;
              return "array";
            }
            _tuple$1 = $assertType(val, mapType, true);
            ok$1 = _tuple$1[1];
            if (ok$1) {
              $s = -1;
              return "object";
            }
            $s = -1;
            return "<unknown type>";
          /* */
        }
        return;
      }
      var $f = {
        $blk: typeOf,
        $c: true,
        $r,
        _1,
        _r,
        _tuple,
        _tuple$1,
        kind,
        ok,
        ok$1,
        val,
        $s,
      };
      return $f;
    };
    asBool = function (val) {
      var { _arg, _r, _r$1, _tuple, b, ok, val, $s, $r, $c } = $restore(this, {
        val,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val, $Bool, true);
            b = _tuple[0];
            ok = _tuple[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = typeOf(val);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "type error: required bool, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 2:
            $s = -1;
            return b;
          /* */
        }
        return;
      }
      var $f = {
        $blk: asBool,
        $c: true,
        $r,
        _arg,
        _r,
        _r$1,
        _tuple,
        b,
        ok,
        val,
        $s,
      };
      return $f;
    };
    asInteger = function (val) {
      var {
        _arg,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        f,
        i,
        ok,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val, $Int, true);
            i = _tuple[0];
            ok = _tuple[1];
            if (ok) {
              $s = -1;
              return i;
            }
            _tuple$1 = $assertType(val, $Float64, true);
            f = _tuple$1[0];
            ok = _tuple$1[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = typeOf(val);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "type error: required number of type integer, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 2:
            i = f >> 0;
            /* */ if (!(i === f)) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (!(((i) === f))) { */ case 5:
            _r$2 = fmt.Errorf(
              "type error: cannot cast floating point number to integer without losing precision",
              sliceType.nil
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
          /* } */ case 6:
            $s = -1;
            return i;
          /* */
        }
        return;
      }
      var $f = {
        $blk: asInteger,
        $c: true,
        $r,
        _arg,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        f,
        i,
        ok,
        val,
        $s,
      };
      return $f;
    };
    add = function (val1, val2) {
      var {
        _arg,
        _arg$1,
        _entry,
        _entry$1,
        _i,
        _i$1,
        _key,
        _key$1,
        _key$2,
        _key$3,
        _keys,
        _keys$1,
        _r,
        _r$1,
        _r$2,
        _ref,
        _ref$1,
        _size,
        _size$1,
        _tuple,
        _tuple$1,
        _tuple$10,
        _tuple$11,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        _tuple$8,
        _tuple$9,
        arr1,
        arr1OK,
        arr2,
        arr2OK,
        bool1,
        bool1OK,
        bool2,
        bool2OK,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        k,
        k$1,
        obj1,
        obj1OK,
        obj2,
        obj2OK,
        str1,
        str1OK,
        str2,
        str2OK,
        sum,
        v,
        v$1,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $String, true);
            str1 = _tuple[0];
            str1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $String, true);
            str2 = _tuple$1[0];
            str2OK = _tuple$1[1];
            if (str1OK && str2OK) {
              $s = -1;
              return new $String(str1 + str2);
            }
            _tuple$2 = $assertType(val1, $Int, true);
            int1 = _tuple$2[0];
            int1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Int, true);
            int2 = _tuple$3[0];
            int2OK = _tuple$3[1];
            if (int1OK && int2OK) {
              $s = -1;
              return new $Int((int1 + int2) >> 0);
            }
            _tuple$4 = $assertType(val1, $Float64, true);
            float1 = _tuple$4[0];
            float1OK = _tuple$4[1];
            _tuple$5 = $assertType(val2, $Float64, true);
            float2 = _tuple$5[0];
            float2OK = _tuple$5[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            if (float1OK && float2OK) {
              $s = -1;
              return new $Float64(float1 + float2);
            }
            if (str1OK && float2OK) {
              $s = -1;
              return new $String(
                str1 + strconv.FormatFloat(float2, 102, -1, 64)
              );
            }
            if (float1OK && str2OK) {
              $s = -1;
              return new $String(
                strconv.FormatFloat(float1, 102, -1, 64) + str2
              );
            }
            if (str1OK && $interfaceIsEqual(val2, $ifaceNil)) {
              $s = -1;
              return new $String(str1 + "nil");
            }
            if ($interfaceIsEqual(val1, $ifaceNil) && str2OK) {
              $s = -1;
              return new $String("nil" + str2);
            }
            _tuple$6 = $assertType(val1, $Bool, true);
            bool1 = _tuple$6[0];
            bool1OK = _tuple$6[1];
            _tuple$7 = $assertType(val2, $Bool, true);
            bool2 = _tuple$7[0];
            bool2OK = _tuple$7[1];
            if (str1OK && bool2OK) {
              $s = -1;
              return new $String(str1 + strconv.FormatBool(bool2));
            }
            if (bool1OK && str2OK) {
              $s = -1;
              return new $String(strconv.FormatBool(bool1) + str2);
            }
            _tuple$8 = $assertType(val1, sliceType, true);
            arr1 = _tuple$8[0];
            arr1OK = _tuple$8[1];
            _tuple$9 = $assertType(val2, sliceType, true);
            arr2 = _tuple$9[0];
            arr2OK = _tuple$9[1];
            if (arr1OK && arr2OK) {
              $s = -1;
              return $appendSlice(arr1, arr2);
            }
            _tuple$10 = $assertType(val1, mapType, true);
            obj1 = _tuple$10[0];
            obj1OK = _tuple$10[1];
            _tuple$11 = $assertType(val2, mapType, true);
            obj2 = _tuple$11[0];
            obj2OK = _tuple$11[1];
            if (obj1OK && obj2OK) {
              sum = new $global.Map();
              _ref = obj1;
              _i = 0;
              _keys = _ref ? _ref.keys() : undefined;
              _size = _ref ? _ref.size : 0;
              while (true) {
                if (!(_i < _size)) {
                  break;
                }
                _key = _keys.next().value;
                _entry = _ref.get(_key);
                if (_entry === undefined) {
                  _i++;
                  continue;
                }
                k = _entry.k;
                v = _entry.v;
                _key$1 = k;
                (
                  sum || $throwRuntimeError("assignment to entry in nil map")
                ).set($String.keyFor(_key$1), { k: _key$1, v: v });
                _i++;
              }
              _ref$1 = obj2;
              _i$1 = 0;
              _keys$1 = _ref$1 ? _ref$1.keys() : undefined;
              _size$1 = _ref$1 ? _ref$1.size : 0;
              while (true) {
                if (!(_i$1 < _size$1)) {
                  break;
                }
                _key$2 = _keys$1.next().value;
                _entry$1 = _ref$1.get(_key$2);
                if (_entry$1 === undefined) {
                  _i$1++;
                  continue;
                }
                k$1 = _entry$1.k;
                v$1 = _entry$1.v;
                _key$3 = k$1;
                (
                  sum || $throwRuntimeError("assignment to entry in nil map")
                ).set($String.keyFor(_key$3), { k: _key$3, v: v$1 });
                _i$1++;
              }
              $s = -1;
              return new mapType(sum);
            }
            _r = typeOf(val1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = typeOf(val2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$1);
            _r$2 = fmt.Errorf(
              "type error: cannot add or concatenate type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: add,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _entry,
        _entry$1,
        _i,
        _i$1,
        _key,
        _key$1,
        _key$2,
        _key$3,
        _keys,
        _keys$1,
        _r,
        _r$1,
        _r$2,
        _ref,
        _ref$1,
        _size,
        _size$1,
        _tuple,
        _tuple$1,
        _tuple$10,
        _tuple$11,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        _tuple$6,
        _tuple$7,
        _tuple$8,
        _tuple$9,
        arr1,
        arr1OK,
        arr2,
        arr2OK,
        bool1,
        bool1OK,
        bool2,
        bool2OK,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        k,
        k$1,
        obj1,
        obj1OK,
        obj2,
        obj2OK,
        str1,
        str1OK,
        str2,
        str2OK,
        sum,
        v,
        v$1,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    sub = function (val1, val2) {
      var {
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $Int, true);
            int1 = _tuple[0];
            int1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $Int, true);
            int2 = _tuple$1[0];
            int2OK = _tuple$1[1];
            if (int1OK && int2OK) {
              $s = -1;
              return new $Int((int1 - int2) >> 0);
            }
            _tuple$2 = $assertType(val1, $Float64, true);
            float1 = _tuple$2[0];
            float1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Float64, true);
            float2 = _tuple$3[0];
            float2OK = _tuple$3[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            if (float1OK && float2OK) {
              $s = -1;
              return new $Float64(float1 - float2);
            }
            _r = typeOf(val1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = typeOf(val2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$1);
            _r$2 = fmt.Errorf(
              "type error: cannot subtract type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: sub,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    mul = function (val1, val2) {
      var {
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $Int, true);
            int1 = _tuple[0];
            int1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $Int, true);
            int2 = _tuple$1[0];
            int2OK = _tuple$1[1];
            if (int1OK && int2OK) {
              $s = -1;
              return new $Int($imul(int1, int2));
            }
            _tuple$2 = $assertType(val1, $Float64, true);
            float1 = _tuple$2[0];
            float1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Float64, true);
            float2 = _tuple$3[0];
            float2OK = _tuple$3[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            if (float1OK && float2OK) {
              $s = -1;
              return new $Float64(float1 * float2);
            }
            _r = typeOf(val1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = typeOf(val2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$1);
            _r$2 = fmt.Errorf(
              "type error: cannot multiply type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mul,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    div = function (val1, val2) {
      var {
        _arg,
        _arg$1,
        _q,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $Int, true);
            int1 = _tuple[0];
            int1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $Int, true);
            int2 = _tuple$1[0];
            int2OK = _tuple$1[1];
            if (int1OK && int2OK) {
              $s = -1;
              return new $Int(
                ((_q = int1 / int2),
                _q === _q && _q !== 1 / 0 && _q !== -1 / 0
                  ? _q >> 0
                  : $throwRuntimeError("integer divide by zero"))
              );
            }
            _tuple$2 = $assertType(val1, $Float64, true);
            float1 = _tuple$2[0];
            float1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Float64, true);
            float2 = _tuple$3[0];
            float2OK = _tuple$3[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            if (float1OK && float2OK) {
              $s = -1;
              return new $Float64(float1 / float2);
            }
            _r = typeOf(val1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = typeOf(val2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$1);
            _r$2 = fmt.Errorf(
              "type error: cannot divide type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: div,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _q,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    mod = function (val1, val2) {
      var {
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2 });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $Int, true);
            int1 = _tuple[0];
            int1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $Int, true);
            int2 = _tuple$1[0];
            int2OK = _tuple$1[1];
            if (int1OK && int2OK) {
              $s = -1;
              return new $Int(
                ((_r = int1 % int2),
                _r === _r ? _r : $throwRuntimeError("integer divide by zero"))
              );
            }
            _tuple$2 = $assertType(val1, $Float64, true);
            float1 = _tuple$2[0];
            float1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Float64, true);
            float2 = _tuple$3[0];
            float2OK = _tuple$3[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            if (float1OK && float2OK) {
              $s = -1;
              return new $Float64(math.Mod(float1, float2));
            }
            _r$1 = typeOf(val1);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r$1);
            _r$2 = typeOf(val2);
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$2);
            _r$3 = fmt.Errorf(
              "type error: cannot perform modulo on type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            $panic(_r$3);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: mod,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    unaryMinus = function (val) {
      var {
        _arg,
        _r,
        _r$1,
        _tuple,
        _tuple$1,
        floatVal,
        intVal,
        ok,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val, $Int, true);
            intVal = _tuple[0];
            ok = _tuple[1];
            if (ok) {
              $s = -1;
              return new $Int(-intVal);
            }
            _tuple$1 = $assertType(val, $Float64, true);
            floatVal = _tuple$1[0];
            ok = _tuple$1[1];
            if (ok) {
              $s = -1;
              return new $Float64(-floatVal);
            }
            _r = typeOf(val);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "type error: unary minus requires number, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: unaryMinus,
        $c: true,
        $r,
        _arg,
        _r,
        _r$1,
        _tuple,
        _tuple$1,
        floatVal,
        intVal,
        ok,
        val,
        $s,
      };
      return $f;
    };
    deepEqual = function (val1, val2) {
      var _entry,
        _entry$1,
        _entry$2,
        _i,
        _i$1,
        _key,
        _keys,
        _ref,
        _ref$1,
        _ref$2,
        _size,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        float2,
        float2$1,
        idx,
        idx$1,
        int2,
        int2$1,
        ok,
        ok$1,
        ok$2,
        ok$3,
        typ1,
        typ1$1,
        typ1$2,
        typ1$3,
        typ2,
        typ2$1,
        val1,
        val2;
      _ref = val1;
      if ($assertType(_ref, sliceType, true)[1]) {
        typ1 = _ref.$val;
        _tuple = $assertType(val2, sliceType, true);
        typ2 = _tuple[0];
        ok = _tuple[1];
        if (!ok || !(typ1.$length === typ2.$length)) {
          return false;
        }
        _ref$1 = typ1;
        _i = 0;
        while (true) {
          if (!(_i < _ref$1.$length)) {
            break;
          }
          idx = _i;
          if (
            !deepEqual(
              idx < 0 || idx >= typ1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : typ1.$array[typ1.$offset + idx],
              idx < 0 || idx >= typ2.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : typ2.$array[typ2.$offset + idx]
            )
          ) {
            return false;
          }
          _i++;
        }
        return true;
      } else if ($assertType(_ref, mapType, true)[1]) {
        typ1$1 = _ref.$val;
        _tuple$1 = $assertType(val2, mapType, true);
        typ2$1 = _tuple$1[0];
        ok$1 = _tuple$1[1];
        if (
          !ok$1 ||
          !((typ1$1 ? typ1$1.size : 0) === (typ2$1 ? typ2$1.size : 0))
        ) {
          return false;
        }
        _ref$2 = typ1$1;
        _i$1 = 0;
        _keys = _ref$2 ? _ref$2.keys() : undefined;
        _size = _ref$2 ? _ref$2.size : 0;
        while (true) {
          if (!(_i$1 < _size)) {
            break;
          }
          _key = _keys.next().value;
          _entry = _ref$2.get(_key);
          if (_entry === undefined) {
            _i$1++;
            continue;
          }
          idx$1 = _entry.k;
          if (
            !deepEqual(
              ((_entry$1 = $mapIndex(typ1$1, $String.keyFor(idx$1))),
              _entry$1 !== undefined ? _entry$1.v : $ifaceNil),
              ((_entry$2 = $mapIndex(typ2$1, $String.keyFor(idx$1))),
              _entry$2 !== undefined ? _entry$2.v : $ifaceNil)
            )
          ) {
            return false;
          }
          _i$1++;
        }
        return true;
      } else if ($assertType(_ref, $Int, true)[1]) {
        typ1$2 = _ref.$val;
        _tuple$2 = $assertType(val2, $Int, true);
        int2 = _tuple$2[0];
        ok$2 = _tuple$2[1];
        if (ok$2) {
          return typ1$2 === int2;
        }
        _tuple$3 = $assertType(val2, $Float64, true);
        float2 = _tuple$3[0];
        ok$2 = _tuple$3[1];
        if (ok$2) {
          return typ1$2 === float2;
        }
        return false;
      } else if ($assertType(_ref, $Float64, true)[1]) {
        typ1$3 = _ref.$val;
        _tuple$4 = $assertType(val2, $Float64, true);
        float2$1 = _tuple$4[0];
        ok$3 = _tuple$4[1];
        if (ok$3) {
          return typ1$3 === float2$1;
        }
        _tuple$5 = $assertType(val2, $Int, true);
        int2$1 = _tuple$5[0];
        ok$3 = _tuple$5[1];
        if (ok$3) {
          return typ1$3 === int2$1;
        }
        return false;
      }
      return $interfaceIsEqual(val1, val2);
    };
    compare = function (val1, val2, operation) {
      var {
        $24r,
        $24r$1,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        operation,
        val1,
        val2,
        $s,
        $r,
        $c,
      } = $restore(this, { val1, val2, operation });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(val1, $Int, true);
            int1 = _tuple[0];
            int1OK = _tuple[1];
            _tuple$1 = $assertType(val2, $Int, true);
            int2 = _tuple$1[0];
            int2OK = _tuple$1[1];
            /* */ if (int1OK && int2OK) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (int1OK && int2OK) { */ case 1:
            _r = compareInt(int1, int2, operation);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 4;
          case 4:
            return $24r;
          /* } */ case 2:
            _tuple$2 = $assertType(val1, $Float64, true);
            float1 = _tuple$2[0];
            float1OK = _tuple$2[1];
            _tuple$3 = $assertType(val2, $Float64, true);
            float2 = _tuple$3[0];
            float2OK = _tuple$3[1];
            if (int1OK) {
              float1 = int1;
              float1OK = true;
            }
            if (int2OK) {
              float2 = int2;
              float2OK = true;
            }
            /* */ if (float1OK && float2OK) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (float1OK && float2OK) { */ case 5:
            _r$1 = compareFloat(float1, float2, operation);
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r$1 = _r$1;
            $s = 8;
          case 8:
            return $24r$1;
          /* } */ case 6:
            _r$2 = typeOf(val1);
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r$2);
            _r$3 = typeOf(val2);
            /* */ $s = 10;
          case 10:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$3);
            _r$4 = fmt.Errorf(
              "type error: cannot compare type %s and %s",
              new sliceType([_arg, _arg$1])
            );
            /* */ $s = 11;
          case 11:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $panic(_r$4);
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: compare,
        $c: true,
        $r,
        $24r,
        $24r$1,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        float1,
        float1OK,
        float2,
        float2OK,
        int1,
        int1OK,
        int2,
        int2OK,
        operation,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    compareInt = function (val1, val2, operation) {
      var { _1, _r, operation, val1, val2, $s, $r, $c } = $restore(this, {
        val1,
        val2,
        operation,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _1 = operation;
            if (_1 === "<") {
              $s = -1;
              return val1 < val2;
            } else if (_1 === "<=") {
              $s = -1;
              return val1 <= val2;
            } else if (_1 === ">") {
              $s = -1;
              return val1 > val2;
            } else if (_1 === ">=") {
              $s = -1;
              return val1 >= val2;
            }
            _r = fmt.Errorf(
              "syntax error: unsupported operation %q",
              new sliceType([new $String(operation)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(_r);
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: compareInt,
        $c: true,
        $r,
        _1,
        _r,
        operation,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    compareFloat = function (val1, val2, operation) {
      var { _1, _r, operation, val1, val2, $s, $r, $c } = $restore(this, {
        val1,
        val2,
        operation,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _1 = operation;
            if (_1 === "<") {
              $s = -1;
              return val1 < val2;
            } else if (_1 === "<=") {
              $s = -1;
              return val1 <= val2;
            } else if (_1 === ">") {
              $s = -1;
              return val1 > val2;
            } else if (_1 === ">=") {
              $s = -1;
              return val1 >= val2;
            }
            _r = fmt.Errorf(
              "syntax error: unsupported operation %q",
              new sliceType([new $String(operation)])
            );
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(_r);
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: compareFloat,
        $c: true,
        $r,
        _1,
        _r,
        operation,
        val1,
        val2,
        $s,
      };
      return $f;
    };
    asObjectKey = function (key) {
      var { _arg, _r, _r$1, _tuple, key, ok, s, $s, $r, $c } = $restore(this, {
        key,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(key, $String, true);
            s = _tuple[0];
            ok = _tuple[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = typeOf(key);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "type error: object key must be string, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 2:
            $s = -1;
            return s;
          /* */
        }
        return;
      }
      var $f = {
        $blk: asObjectKey,
        $c: true,
        $r,
        _arg,
        _r,
        _r$1,
        _tuple,
        key,
        ok,
        s,
        $s,
      };
      return $f;
    };
    addObjectMember = function (obj, key, val) {
      var { _entry, _key, _r, _r$1, _tuple, key, obj, ok, s, val, $s, $r, $c } =
        $restore(this, { obj, key, val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _r = asObjectKey(key);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            s = _r;
            _tuple =
              ((_entry = $mapIndex(obj, $String.keyFor(s))),
              _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
            ok = _tuple[1];
            /* */ if (ok) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (ok) { */ case 2:
            _r$1 = fmt.Errorf(
              "syntax error: duplicate object key %q",
              new sliceType([new $String(s)])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 3:
            _key = s;
            (obj || $throwRuntimeError("assignment to entry in nil map")).set(
              $String.keyFor(_key),
              { k: _key, v: val }
            );
            $s = -1;
            return obj;
          /* */
        }
        return;
      }
      var $f = {
        $blk: addObjectMember,
        $c: true,
        $r,
        _entry,
        _key,
        _r,
        _r$1,
        _tuple,
        key,
        obj,
        ok,
        s,
        val,
        $s,
      };
      return $f;
    };
    accessVar = function (variables, varName) {
      var { _entry, _r, _tuple, ok, val, varName, variables, $s, $r, $c } =
        $restore(this, { variables, varName });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple =
              ((_entry = $mapIndex(variables, $String.keyFor(varName))),
              _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
            val = _tuple[0];
            ok = _tuple[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = fmt.Errorf(
              "var error: variable %q does not exist",
              new sliceType([new $String(varName)])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(_r);
          /* } */ case 2:
            $s = -1;
            return val;
          /* */
        }
        return;
      }
      var $f = {
        $blk: accessVar,
        $c: true,
        $r,
        _entry,
        _r,
        _tuple,
        ok,
        val,
        varName,
        variables,
        $s,
      };
      return $f;
    };
    accessField = function (s, field) {
      var {
        _arg,
        _arg$1,
        _arg$2,
        _entry,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        arrVar,
        field,
        floatIdx,
        intIdx,
        key,
        obj,
        ok,
        ok$1,
        ok$2,
        ok$3,
        s,
        val,
        $s,
        $r,
        $c,
      } = $restore(this, { s, field });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(s, mapType, true);
            obj = _tuple[0];
            ok = _tuple[1];
            /* */ if (ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (ok) { */ case 1:
            _tuple$1 = $assertType(field, $String, true);
            key = _tuple$1[0];
            ok$1 = _tuple$1[1];
            /* */ if (!ok$1) {
              $s = 3;
              continue;
            }
            /* */ $s = 4;
            continue;
          /* if (!ok$1) { */ case 3:
            _r = typeOf(field);
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "syntax error: object key must be string, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 4:
            _tuple$2 =
              ((_entry = $mapIndex(obj, $String.keyFor(key))),
              _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
            val = _tuple$2[0];
            ok$1 = _tuple$2[1];
            /* */ if (!ok$1) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (!ok$1) { */ case 7:
            _r$2 = fmt.Errorf(
              "var error: object has no member %q",
              new sliceType([field])
            );
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
          /* } */ case 8:
            $s = -1;
            return val;
          /* } */ case 2:
            _tuple$3 = $assertType(s, sliceType, true);
            arrVar = _tuple$3[0];
            ok = _tuple$3[1];
            /* */ if (ok) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if (ok) { */ case 10:
            _tuple$4 = $assertType(field, $Int, true);
            intIdx = _tuple$4[0];
            ok$2 = _tuple$4[1];
            /* */ if (!ok$2) {
              $s = 12;
              continue;
            }
            /* */ $s = 13;
            continue;
          /* if (!ok$2) { */ case 12:
            _tuple$5 = $assertType(field, $Float64, true);
            floatIdx = _tuple$5[0];
            ok$3 = _tuple$5[1];
            /* */ if (!ok$3) {
              $s = 14;
              continue;
            }
            /* */ $s = 15;
            continue;
          /* if (!ok$3) { */ case 14:
            _r$3 = typeOf(field);
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            _arg$1 = new $String(_r$3);
            _r$4 = fmt.Errorf(
              "syntax error: array index must be number, but was %s",
              new sliceType([_arg$1])
            );
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $panic(_r$4);
          /* } */ case 15:
            intIdx = floatIdx >> 0;
            /* */ if (!(intIdx === floatIdx)) {
              $s = 18;
              continue;
            }
            /* */ $s = 19;
            continue;
          /* if (!(((intIdx) === floatIdx))) { */ case 18:
            _r$5 = fmt.Errorf(
              "eval error: array index must be whole number, but was %f",
              new sliceType([new $Float64(floatIdx)])
            );
            /* */ $s = 20;
          case 20:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $panic(_r$5);
          /* } */ case 19:
          /* } */ case 13:
            /* */ if (intIdx < 0 || intIdx >= arrVar.$length) {
              $s = 21;
              continue;
            }
            /* */ $s = 22;
            continue;
          /* if (intIdx < 0 || intIdx >= arrVar.$length) { */ case 21:
            _r$6 = fmt.Errorf(
              "var error: array index %d is out of range [%d, %d]",
              new sliceType([
                new $Int(intIdx),
                new $Int(0),
                new $Int(arrVar.$length),
              ])
            );
            /* */ $s = 23;
          case 23:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            $panic(_r$6);
          /* } */ case 22:
            $s = -1;
            return intIdx < 0 || intIdx >= arrVar.$length
              ? ($throwRuntimeError("index out of range"), undefined)
              : arrVar.$array[arrVar.$offset + intIdx];
          /* } */ case 11:
            _r$7 = typeOf(s);
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            _arg$2 = new $String(_r$7);
            _r$8 = fmt.Errorf(
              "syntax error: cannot access fields on type %s",
              new sliceType([_arg$2])
            );
            /* */ $s = 25;
          case 25:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            $panic(_r$8);
            $s = -1;
            return $ifaceNil;
          /* */
        }
        return;
      }
      var $f = {
        $blk: accessField,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _arg$2,
        _entry,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        _tuple$5,
        arrVar,
        field,
        floatIdx,
        intIdx,
        key,
        obj,
        ok,
        ok$1,
        ok$2,
        ok$3,
        s,
        val,
        $s,
      };
      return $f;
    };
    slice = function (v, from, to) {
      var {
        _arg,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        arr,
        from,
        fromInt,
        isArr,
        isStr,
        str,
        to,
        toInt,
        v,
        $s,
        $r,
        $c,
      } = $restore(this, { v, from, to });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(v, $String, true);
            str = _tuple[0];
            isStr = _tuple[1];
            _tuple$1 = $assertType(v, sliceType, true);
            arr = _tuple$1[0];
            isArr = _tuple$1[1];
            /* */ if (!isStr && !isArr) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!isStr && !isArr) { */ case 1:
            _r = typeOf(v);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "syntax error: slicing requires an array or string, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 2:
            _tmp = 0;
            _tmp$1 = 0;
            fromInt = _tmp;
            toInt = _tmp$1;
            /* */ if ($interfaceIsEqual(from, $ifaceNil)) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if ($interfaceIsEqual(from, $ifaceNil)) { */ case 5:
            fromInt = 0;
            $s = 7;
            continue;
          /* } else { */ case 6:
            _r$2 = asInteger(from);
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            fromInt = _r$2;
          /* } */ case 7:
            /* */ if ($interfaceIsEqual(to, $ifaceNil) && isStr) {
              $s = 9;
              continue;
            }
            /* */ if ($interfaceIsEqual(to, $ifaceNil) && isArr) {
              $s = 10;
              continue;
            }
            /* */ $s = 11;
            continue;
          /* if ($interfaceIsEqual(to, $ifaceNil) && isStr) { */ case 9:
            toInt = str.length;
            $s = 12;
            continue;
          /* } else if ($interfaceIsEqual(to, $ifaceNil) && isArr) { */ case 10:
            toInt = arr.$length;
            $s = 12;
            continue;
          /* } else { */ case 11:
            _r$3 = asInteger(to);
            /* */ $s = 13;
          case 13:
            if ($c) {
              $c = false;
              _r$3 = _r$3.$blk();
            }
            if (_r$3 && _r$3.$blk !== undefined) {
              break s;
            }
            toInt = _r$3;
          /* } */ case 12:
            /* */ if (fromInt < 0) {
              $s = 14;
              continue;
            }
            /* */ $s = 15;
            continue;
          /* if (fromInt < 0) { */ case 14:
            _r$4 = fmt.Errorf(
              "range error: start-index %d is negative",
              new sliceType([new $Int(fromInt)])
            );
            /* */ $s = 16;
          case 16:
            if ($c) {
              $c = false;
              _r$4 = _r$4.$blk();
            }
            if (_r$4 && _r$4.$blk !== undefined) {
              break s;
            }
            $panic(_r$4);
          /* } */ case 15:
            /* */ if (isStr) {
              $s = 17;
              continue;
            }
            /* */ $s = 18;
            continue;
          /* if (isStr) { */ case 17:
            /* */ if (toInt < 0 || toInt > str.length) {
              $s = 19;
              continue;
            }
            /* */ $s = 20;
            continue;
          /* if (toInt < 0 || toInt > str.length) { */ case 19:
            _r$5 = fmt.Errorf(
              "range error: end-index %d is out of range [0, %d]",
              new sliceType([new $Int(toInt), new $Int(str.length)])
            );
            /* */ $s = 21;
          case 21:
            if ($c) {
              $c = false;
              _r$5 = _r$5.$blk();
            }
            if (_r$5 && _r$5.$blk !== undefined) {
              break s;
            }
            $panic(_r$5);
          /* } */ case 20:
            /* */ if (fromInt > toInt) {
              $s = 22;
              continue;
            }
            /* */ $s = 23;
            continue;
          /* if (fromInt > toInt) { */ case 22:
            _r$6 = fmt.Errorf(
              "range error: start-index %d is greater than end-index %d",
              new sliceType([new $Int(fromInt), new $Int(toInt)])
            );
            /* */ $s = 24;
          case 24:
            if ($c) {
              $c = false;
              _r$6 = _r$6.$blk();
            }
            if (_r$6 && _r$6.$blk !== undefined) {
              break s;
            }
            $panic(_r$6);
          /* } */ case 23:
            $s = -1;
            return new $String($substring(str, fromInt, toInt));
          /* } */ case 18:
            /* */ if (toInt < 0 || toInt > arr.$length) {
              $s = 25;
              continue;
            }
            /* */ $s = 26;
            continue;
          /* if (toInt < 0 || toInt > arr.$length) { */ case 25:
            _r$7 = fmt.Errorf(
              "range error: end-index %d is out of range [0, %d]",
              new sliceType([new $Int(toInt), new $Int(arr.$length)])
            );
            /* */ $s = 27;
          case 27:
            if ($c) {
              $c = false;
              _r$7 = _r$7.$blk();
            }
            if (_r$7 && _r$7.$blk !== undefined) {
              break s;
            }
            $panic(_r$7);
          /* } */ case 26:
            /* */ if (fromInt > toInt) {
              $s = 28;
              continue;
            }
            /* */ $s = 29;
            continue;
          /* if (fromInt > toInt) { */ case 28:
            _r$8 = fmt.Errorf(
              "range error: start-index %d is greater than end-index %d",
              new sliceType([new $Int(fromInt), new $Int(toInt)])
            );
            /* */ $s = 30;
          case 30:
            if ($c) {
              $c = false;
              _r$8 = _r$8.$blk();
            }
            if (_r$8 && _r$8.$blk !== undefined) {
              break s;
            }
            $panic(_r$8);
          /* } */ case 29:
            $s = -1;
            return $subslice(arr, fromInt, toInt);
          /* */
        }
        return;
      }
      var $f = {
        $blk: slice,
        $c: true,
        $r,
        _arg,
        _r,
        _r$1,
        _r$2,
        _r$3,
        _r$4,
        _r$5,
        _r$6,
        _r$7,
        _r$8,
        _tmp,
        _tmp$1,
        _tuple,
        _tuple$1,
        arr,
        from,
        fromInt,
        isArr,
        isStr,
        str,
        to,
        toInt,
        v,
        $s,
      };
      return $f;
    };
    arrayContains = function (arr, val) {
      var { _arg, _i, _r, _r$1, _ref, _tuple, a, arr, ok, v, val, $s, $r, $c } =
        $restore(this, { arr, val });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple = $assertType(arr, sliceType, true);
            a = _tuple[0];
            ok = _tuple[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = typeOf(arr);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r);
            _r$1 = fmt.Errorf(
              "syntax error: in-operator requires array, but was %s",
              new sliceType([_arg])
            );
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $panic(_r$1);
          /* } */ case 2:
            _ref = a;
            _i = 0;
            while (true) {
              if (!(_i < _ref.$length)) {
                break;
              }
              v =
                _i < 0 || _i >= _ref.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref.$array[_ref.$offset + _i];
              if (deepEqual(v, val)) {
                $s = -1;
                return true;
              }
              _i++;
            }
            $s = -1;
            return false;
          /* */
        }
        return;
      }
      var $f = {
        $blk: arrayContains,
        $c: true,
        $r,
        _arg,
        _i,
        _r,
        _r$1,
        _ref,
        _tuple,
        a,
        arr,
        ok,
        v,
        val,
        $s,
      };
      return $f;
    };
    callFunction = function (functions, name, args) {
      var {
        _entry,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        args,
        err,
        f,
        functions,
        name,
        ok,
        res,
        $s,
        $r,
        $c,
      } = $restore(this, { functions, name, args });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            _tuple =
              ((_entry = $mapIndex(functions, $String.keyFor(name))),
              _entry !== undefined
                ? [_entry.v, true]
                : [$throwNilPointerError, false]);
            f = _tuple[0];
            ok = _tuple[1];
            /* */ if (!ok) {
              $s = 1;
              continue;
            }
            /* */ $s = 2;
            continue;
          /* if (!ok) { */ case 1:
            _r = fmt.Errorf(
              "syntax error: no such function %q",
              new sliceType([new $String(name)])
            );
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(_r);
          /* } */ case 2:
            _r$1 = callAndRecover(f, args);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _tuple$1 = _r$1;
            res = _tuple$1[0];
            err = _tuple$1[1];
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 5:
            _r$2 = fmt.Errorf(
              "function error: %q - %w",
              new sliceType([new $String(name), err])
            );
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            $panic(_r$2);
          /* } */ case 6:
            $s = -1;
            return res;
          /* */
        }
        return;
      }
      var $f = {
        $blk: callFunction,
        $c: true,
        $r,
        _entry,
        _r,
        _r$1,
        _r$2,
        _tuple,
        _tuple$1,
        args,
        err,
        f,
        functions,
        name,
        ok,
        res,
        $s,
      };
      return $f;
    };
    callAndRecover = function (f, args) {
      var { $24r, _, _r, _tuple, args, f, retErr, $s, $deferred, $r, $c } =
        $restore(this, { f, args });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              retErr = [retErr];
              _ = $ifaceNil;
              retErr[0] = $ifaceNil;
              $deferred.push([
                (function (retErr) {
                  return function $b() {
                    var { _r, _tuple, _tuple$1, err, ok, ok$1, r, $s, $r, $c } =
                      $restore(this, {});
                    /* */ $s = $s || 0;
                    s: while (true) {
                      switch ($s) {
                        case 0:
                          r = $recover();
                          if ($interfaceIsEqual(r, $ifaceNil)) {
                            $s = -1;
                            return;
                          }
                          _tuple = $assertType(r, runtime.Error, true);
                          ok = _tuple[1];
                          if (ok) {
                            $panic(r);
                          }
                          _tuple$1 = $assertType(r, $error, true);
                          err = _tuple$1[0];
                          ok$1 = _tuple$1[1];
                          /* */ if (ok$1) {
                            $s = 1;
                            continue;
                          }
                          /* */ $s = 2;
                          continue;
                        /* if (ok$1) { */ case 1:
                          retErr[0] = err;
                          $s = 3;
                          continue;
                        /* } else { */ case 2:
                          _r = fmt.Errorf("panic: %v", new sliceType([r]));
                          /* */ $s = 4;
                        case 4:
                          if ($c) {
                            $c = false;
                            _r = _r.$blk();
                          }
                          if (_r && _r.$blk !== undefined) {
                            break s;
                          }
                          retErr[0] = _r;
                        /* } */ case 3:
                          $s = -1;
                          return;
                        /* */
                      }
                      return;
                    }
                    var $f = {
                      $blk: $b,
                      $c: true,
                      $r,
                      _r,
                      _tuple,
                      _tuple$1,
                      err,
                      ok,
                      ok$1,
                      r,
                      $s,
                    };
                    return $f;
                  };
                })(retErr),
                [],
              ]);
              _r = f(args);
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              _tuple = _r;
              _ = _tuple[0];
              retErr[0] = _tuple[1];
              $24r = [_, retErr[0]];
              $s = 2;
            case 2:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return [_, retErr[0]];
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: callAndRecover,
            $c: true,
            $r,
            $24r,
            _,
            _r,
            _tuple,
            args,
            f,
            retErr,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    yyParserImpl.ptr.prototype.Lookahead = function () {
      var p;
      p = this;
      return p.char$2;
    };
    yyParserImpl.prototype.Lookahead = function () {
      return this.$val.Lookahead();
    };
    yyNewParser = function () {
      return new yyParserImpl.ptr(
        new yySymType.ptr(
          0,
          new Token.ptr("", $ifaceNil),
          $ifaceNil,
          sliceType.nil,
          false
        ),
        arrayType$2.zero(),
        0
      );
    };
    yyTokname = function (c) {
      var { $24r, _r, c, x, x$1, $s, $r, $c } = $restore(this, { c });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (c >= 1 && (c - 1) >> 0 < 39) {
              if (
                !(
                  ((x = (c - 1) >> 0),
                  x < 0 || x >= yyToknames.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyToknames[x]) === ""
                )
              ) {
                $s = -1;
                return (
                  (x$1 = (c - 1) >> 0),
                  x$1 < 0 || x$1 >= yyToknames.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyToknames[x$1]
                );
              }
            }
            _r = fmt.Sprintf("tok-%v", new sliceType([new $Int(c)]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: yyTokname, $c: true, $r, $24r, _r, c, x, x$1, $s };
      return $f;
    };
    yyStatname = function (s) {
      var { $24r, _r, s, $s, $r, $c } = $restore(this, { s });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (s >= 0 && s < 0) {
              if (
                !(
                  (s < 0 || s >= yyStatenames.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyStatenames[s]) === ""
                )
              ) {
                $s = -1;
                return s < 0 || s >= yyStatenames.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyStatenames[s];
              }
            }
            _r = fmt.Sprintf("state-%v", new sliceType([new $Int(s)]));
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $24r = _r;
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = { $blk: yyStatname, $c: true, $r, $24r, _r, s, $s };
      return $f;
    };
    yyErrorMessage = function (state, lookAhead) {
      var {
        _i,
        _i$1,
        _r,
        _r$1,
        _ref,
        _ref$1,
        base,
        e,
        expected,
        i,
        i$1,
        lookAhead,
        n,
        res,
        state,
        tok,
        tok$1,
        tok$2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
        $r,
        $c,
      } = $restore(this, { state, lookAhead });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (!yyErrorVerbose) {
              $s = -1;
              return "syntax error";
            }
            _ref = yyErrorMessages;
            _i = 0;
            while (true) {
              if (!(_i < 0)) {
                break;
              }
              e = $clone(
                _i < 0 || _i >= _ref.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : _ref[_i],
                structType
              );
              if (e.state === state && e.token === lookAhead) {
                $s = -1;
                return "syntax error: " + e.msg;
              }
              _i++;
            }
            _r = yyTokname(lookAhead);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            res = "syntax error: unexpected " + _r;
            expected = $makeSlice(sliceType$1, 0, 4);
            base =
              state < 0 || state >= yyPact.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyPact[state];
            tok = 4;
            while (true) {
              if (!((tok - 1) >> 0 < 39)) {
                break;
              }
              n = (base + tok) >> 0;
              if (
                n >= 0 &&
                n < 561 &&
                ((x =
                  n < 0 || n >= yyAct.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyAct[n]),
                x < 0 || x >= yyChk.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyChk[x]) === tok
              ) {
                if (expected.$length === expected.$capacity) {
                  $s = -1;
                  return res;
                }
                expected = $append(expected, tok);
              }
              tok = (tok + 1) >> 0;
            }
            if (
              (state < 0 || state >= yyDef.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyDef[state]) === -2
            ) {
              i = 0;
              while (true) {
                if (
                  !(
                    !(
                      (i < 0 || i >= yyExca.length
                        ? ($throwRuntimeError("index out of range"), undefined)
                        : yyExca[i]) === -1
                    ) ||
                    !(
                      ((x$1 = (i + 1) >> 0),
                      x$1 < 0 || x$1 >= yyExca.length
                        ? ($throwRuntimeError("index out of range"), undefined)
                        : yyExca[x$1]) === state
                    )
                  )
                ) {
                  break;
                }
                i = (i + 2) >> 0;
              }
              i = (i + 2) >> 0;
              while (true) {
                if (
                  !(
                    (i < 0 || i >= yyExca.length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : yyExca[i]) >= 0
                  )
                ) {
                  break;
                }
                tok$1 =
                  i < 0 || i >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[i];
                if (
                  tok$1 < 4 ||
                  ((x$2 = (i + 1) >> 0),
                  x$2 < 0 || x$2 >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[x$2]) === 0
                ) {
                  i = (i + 2) >> 0;
                  continue;
                }
                if (expected.$length === expected.$capacity) {
                  $s = -1;
                  return res;
                }
                expected = $append(expected, tok$1);
                i = (i + 2) >> 0;
              }
              if (
                !(
                  ((x$3 = (i + 1) >> 0),
                  x$3 < 0 || x$3 >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[x$3]) === 0
                )
              ) {
                $s = -1;
                return res;
              }
            }
            _ref$1 = expected;
            _i$1 = 0;
          /* while (true) { */ case 2:
            /* if (!(_i$1 < _ref$1.$length)) { break; } */ if (
              !(_i$1 < _ref$1.$length)
            ) {
              $s = 3;
              continue;
            }
            i$1 = _i$1;
            tok$2 =
              _i$1 < 0 || _i$1 >= _ref$1.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : _ref$1.$array[_ref$1.$offset + _i$1];
            if (i$1 === 0) {
              res = res + ", expecting ";
            } else {
              res = res + " or ";
            }
            _r$1 = yyTokname(tok$2);
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            res = res + _r$1;
            _i$1++;
            $s = 2;
            continue;
          case 3:
            $s = -1;
            return res;
          /* */
        }
        return;
      }
      var $f = {
        $blk: yyErrorMessage,
        $c: true,
        $r,
        _i,
        _i$1,
        _r,
        _r$1,
        _ref,
        _ref$1,
        base,
        e,
        expected,
        i,
        i$1,
        lookAhead,
        n,
        res,
        state,
        tok,
        tok$1,
        tok$2,
        x,
        x$1,
        x$2,
        x$3,
        $s,
      };
      return $f;
    };
    yylex1 = function (lex, lval) {
      var {
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        char$1,
        i,
        lex,
        lval,
        token$1,
        x,
        x$1,
        x$2,
        $s,
        $r,
        $c,
      } = $restore(this, { lex, lval });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            char$1 = 0;
            token$1 = 0;
            token$1 = 0;
            _r = lex.Lex(lval);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            char$1 = _r;
            /* */ if (char$1 <= 0) {
              $s = 2;
              continue;
            }
            /* */ $s = 3;
            continue;
          /* if (char$1 <= 0) { */ case 2:
            token$1 = yyTok1[0];
            /* goto out */ $s = 4;
            continue;
          /* } */ case 3:
            /* */ if (char$1 < 126) {
              $s = 5;
              continue;
            }
            /* */ $s = 6;
            continue;
          /* if (char$1 < 126) { */ case 5:
            token$1 =
              char$1 < 0 || char$1 >= yyTok1.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyTok1[char$1];
            /* goto out */ $s = 4;
            continue;
          /* } */ case 6:
            /* */ if (char$1 >= 57344) {
              $s = 7;
              continue;
            }
            /* */ $s = 8;
            continue;
          /* if (char$1 >= 57344) { */ case 7:
            /* */ if (char$1 < 57363) {
              $s = 9;
              continue;
            }
            /* */ $s = 10;
            continue;
          /* if (char$1 < 57363) { */ case 9:
            token$1 =
              ((x = (char$1 - 57344) >> 0),
              x < 0 || x >= yyTok2.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyTok2[x]);
            /* goto out */ $s = 4;
            continue;
          /* } */ case 10:
          /* } */ case 8:
            i = 0;
          /* while (true) { */ case 11:
            /* if (!(i < 1)) { break; } */ if (!(i < 1)) {
              $s = 12;
              continue;
            }
            token$1 =
              ((x$1 = (i + 0) >> 0),
              x$1 < 0 || x$1 >= yyTok3.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyTok3[x$1]);
            /* */ if (token$1 === char$1) {
              $s = 13;
              continue;
            }
            /* */ $s = 14;
            continue;
          /* if (token$1 === char$1) { */ case 13:
            token$1 =
              ((x$2 = (i + 1) >> 0),
              x$2 < 0 || x$2 >= yyTok3.length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyTok3[x$2]);
            /* goto out */ $s = 4;
            continue;
          /* } */ case 14:
            i = (i + 2) >> 0;
            $s = 11;
            continue;
          case 12:
          /* out: */ case 4:
            if (token$1 === 0) {
              token$1 = yyTok2[1];
            }
            /* */ if (yyDebug >= 3) {
              $s = 15;
              continue;
            }
            /* */ $s = 16;
            continue;
          /* if (yyDebug >= 3) { */ case 15:
            _r$1 = yyTokname(token$1);
            /* */ $s = 17;
          case 17:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            _arg = new $String(_r$1);
            _arg$1 = new $Uint(char$1 >>> 0);
            _r$2 = fmt.Printf("lex %s(%d)\n", new sliceType([_arg, _arg$1]));
            /* */ $s = 18;
          case 18:
            if ($c) {
              $c = false;
              _r$2 = _r$2.$blk();
            }
            if (_r$2 && _r$2.$blk !== undefined) {
              break s;
            }
            _r$2;
          /* } */ case 16:
            _tmp = char$1;
            _tmp$1 = token$1;
            char$1 = _tmp;
            token$1 = _tmp$1;
            $s = -1;
            return [char$1, token$1];
          /* */
        }
        return;
      }
      var $f = {
        $blk: yylex1,
        $c: true,
        $r,
        _arg,
        _arg$1,
        _r,
        _r$1,
        _r$2,
        _tmp,
        _tmp$1,
        char$1,
        i,
        lex,
        lval,
        token$1,
        x,
        x$1,
        x$2,
        $s,
      };
      return $f;
    };
    yyParserImpl.ptr.prototype.Parse = function (yylex) {
      var {
        $24r,
        $24r$1,
        Errflag,
        Nerrs,
        _1,
        _2,
        _arg,
        _arg$1,
        _arg$2,
        _arg$3,
        _arg$4,
        _arg$5,
        _arg$6,
        _key,
        _r,
        _r$1,
        _r$10,
        _r$11,
        _r$12,
        _r$13,
        _r$14,
        _r$15,
        _r$16,
        _r$17,
        _r$18,
        _r$19,
        _r$2,
        _r$20,
        _r$21,
        _r$22,
        _r$23,
        _r$24,
        _r$25,
        _r$26,
        _r$27,
        _r$28,
        _r$29,
        _r$3,
        _r$30,
        _r$31,
        _r$32,
        _r$33,
        _r$34,
        _r$35,
        _r$36,
        _r$37,
        _r$38,
        _r$39,
        _r$4,
        _r$40,
        _r$41,
        _r$42,
        _r$43,
        _r$44,
        _r$45,
        _r$46,
        _r$47,
        _r$48,
        _r$49,
        _r$5,
        _r$50,
        _r$51,
        _r$52,
        _r$53,
        _r$54,
        _r$6,
        _r$7,
        _r$8,
        _r$9,
        _tuple,
        _tuple$1,
        l,
        l$1,
        left,
        left$1,
        nyys,
        nyys$1,
        r,
        r$1,
        right,
        right$1,
        x,
        x$1,
        x$2,
        x$3,
        x$4,
        x$5,
        x$6,
        xi,
        y,
        y$1,
        yyDollar,
        yyS,
        yyVAL,
        yyg,
        yyj,
        yylex,
        yyn,
        yynt,
        yyp,
        yypt,
        yyrcvr,
        yystate,
        yytoken,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { yylex });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              yyrcvr = [yyrcvr];
              yystate = [yystate];
              yytoken = [yytoken];
              yyrcvr[0] = this;
              yyn = 0;
              yyVAL = new yySymType.ptr(
                0,
                new Token.ptr("", $ifaceNil),
                $ifaceNil,
                sliceType.nil,
                false
              );
              yyDollar = sliceType$2.nil;
              $unused(yyDollar);
              yyS = new sliceType$2(yyrcvr[0].stack);
              Nerrs = 0;
              Errflag = 0;
              yystate[0] = 0;
              yyrcvr[0].char$2 = -1;
              yytoken[0] = -1;
              $deferred.push([
                (function (yyrcvr, yystate, yytoken) {
                  return function () {
                    yystate[0] = -1;
                    yyrcvr[0].char$2 = -1;
                    yytoken[0] = -1;
                  };
                })(yyrcvr, yystate, yytoken),
                [],
              ]);
              yyp = -1;
              /* goto yystack */ $s = 1;
              continue;
            /* ret0: */ case 2:
              $24r = 0;
              $s = 3;
            case 3:
              return $24r;
            /* ret1: */ case 4:
              $24r$1 = 1;
              $s = 5;
            case 5:
              return $24r$1;
            /* yystack: */ case 1:
              /* */ if (yyDebug >= 4) {
                $s = 6;
                continue;
              }
              /* */ $s = 7;
              continue;
            /* if (yyDebug >= 4) { */ case 6:
              _r = yyTokname(yytoken[0]);
              /* */ $s = 8;
            case 8:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              _arg = new $String(_r);
              _r$1 = yyStatname(yystate[0]);
              /* */ $s = 9;
            case 9:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _arg$1 = new $String(_r$1);
              _r$2 = fmt.Printf(
                "char %v in %v\n",
                new sliceType([_arg, _arg$1])
              );
              /* */ $s = 10;
            case 10:
              if ($c) {
                $c = false;
                _r$2 = _r$2.$blk();
              }
              if (_r$2 && _r$2.$blk !== undefined) {
                break s;
              }
              _r$2;
            /* } */ case 7:
              yyp = (yyp + 1) >> 0;
              if (yyp >= yyS.$length) {
                nyys = $makeSlice(sliceType$2, $imul(yyS.$length, 2));
                $copySlice(nyys, yyS);
                yyS = nyys;
              }
              yySymType.copy(
                yyp < 0 || yyp >= yyS.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyS.$array[yyS.$offset + yyp],
                yyVAL
              );
              (yyp < 0 || yyp >= yyS.$length
                ? ($throwRuntimeError("index out of range"), undefined)
                : yyS.$array[yyS.$offset + yyp]
              ).yys = yystate[0];
            /* yynewstate: */ case 11:
              yyn =
                yystate[0] < 0 || yystate[0] >= yyPact.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyPact[yystate[0]];
              /* */ if (yyn <= -1000) {
                $s = 12;
                continue;
              }
              /* */ $s = 13;
              continue;
            /* if (yyn <= -1000) { */ case 12:
              /* goto yydefault */ $s = 14;
              continue;
            /* } */ case 13:
              /* */ if (yyrcvr[0].char$2 < 0) {
                $s = 15;
                continue;
              }
              /* */ $s = 16;
              continue;
            /* if (yyrcvr[0].char$2 < 0) { */ case 15:
              _r$3 = yylex1(yylex, yyrcvr[0].lval);
              /* */ $s = 17;
            case 17:
              if ($c) {
                $c = false;
                _r$3 = _r$3.$blk();
              }
              if (_r$3 && _r$3.$blk !== undefined) {
                break s;
              }
              _tuple = _r$3;
              yyrcvr[0].char$2 = _tuple[0];
              yytoken[0] = _tuple[1];
            /* } */ case 16:
              yyn = (yyn + yytoken[0]) >> 0;
              /* */ if (yyn < 0 || yyn >= 561) {
                $s = 18;
                continue;
              }
              /* */ $s = 19;
              continue;
            /* if (yyn < 0 || yyn >= 561) { */ case 18:
              /* goto yydefault */ $s = 14;
              continue;
            /* } */ case 19:
              yyn =
                yyn < 0 || yyn >= yyAct.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyAct[yyn];
              /* */ if (
                (yyn < 0 || yyn >= yyChk.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyChk[yyn]) === yytoken[0]
              ) {
                $s = 20;
                continue;
              }
              /* */ $s = 21;
              continue;
            /* if (((yyn < 0 || yyn >= yyChk.length) ? ($throwRuntimeError("index out of range"), undefined) : yyChk[yyn]) === yytoken[0]) { */ case 20:
              yyrcvr[0].char$2 = -1;
              yytoken[0] = -1;
              yySymType.copy(yyVAL, yyrcvr[0].lval);
              yystate[0] = yyn;
              if (Errflag > 0) {
                Errflag = (Errflag - 1) >> 0;
              }
              /* goto yystack */ $s = 1;
              continue;
            /* } */ case 21:
            /* yydefault: */ case 14:
              yyn =
                yystate[0] < 0 || yystate[0] >= yyDef.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDef[yystate[0]];
              /* */ if (yyn === -2) {
                $s = 22;
                continue;
              }
              /* */ $s = 23;
              continue;
            /* if (yyn === -2) { */ case 22:
              /* */ if (yyrcvr[0].char$2 < 0) {
                $s = 24;
                continue;
              }
              /* */ $s = 25;
              continue;
            /* if (yyrcvr[0].char$2 < 0) { */ case 24:
              _r$4 = yylex1(yylex, yyrcvr[0].lval);
              /* */ $s = 26;
            case 26:
              if ($c) {
                $c = false;
                _r$4 = _r$4.$blk();
              }
              if (_r$4 && _r$4.$blk !== undefined) {
                break s;
              }
              _tuple$1 = _r$4;
              yyrcvr[0].char$2 = _tuple$1[0];
              yytoken[0] = _tuple$1[1];
            /* } */ case 25:
              xi = 0;
              while (true) {
                if (
                  ((x = (xi + 0) >> 0),
                  x < 0 || x >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[x]) === -1 &&
                  ((x$1 = (xi + 1) >> 0),
                  x$1 < 0 || x$1 >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[x$1]) === yystate[0]
                ) {
                  break;
                }
                xi = (xi + 2) >> 0;
              }
              xi = (xi + 2) >> 0;
              while (true) {
                yyn =
                  ((x$2 = (xi + 0) >> 0),
                  x$2 < 0 || x$2 >= yyExca.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyExca[x$2]);
                if (yyn < 0 || yyn === yytoken[0]) {
                  break;
                }
                xi = (xi + 2) >> 0;
              }
              yyn =
                ((x$3 = (xi + 1) >> 0),
                x$3 < 0 || x$3 >= yyExca.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyExca[x$3]);
              /* */ if (yyn < 0) {
                $s = 27;
                continue;
              }
              /* */ $s = 28;
              continue;
            /* if (yyn < 0) { */ case 27:
              /* goto ret0 */ $s = 2;
              continue;
            /* } */ case 28:
            /* } */ case 23:
              /* */ if (yyn === 0) {
                $s = 29;
                continue;
              }
              /* */ $s = 30;
              continue;
            /* if (yyn === 0) { */ case 29:
              _1 = Errflag;
              /* */ if (_1 === 0) {
                $s = 32;
                continue;
              }
              /* */ if (_1 === 1 || _1 === 2) {
                $s = 33;
                continue;
              }
              /* */ if (_1 === 3) {
                $s = 34;
                continue;
              }
              /* */ $s = 35;
              continue;
            /* if (_1 === (0)) { */ case 32:
              _r$5 = yyErrorMessage(yystate[0], yytoken[0]);
              /* */ $s = 36;
            case 36:
              if ($c) {
                $c = false;
                _r$5 = _r$5.$blk();
              }
              if (_r$5 && _r$5.$blk !== undefined) {
                break s;
              }
              $r = yylex.Error(_r$5);
              /* */ $s = 37;
            case 37:
              if ($c) {
                $c = false;
                $r = $r.$blk();
              }
              if ($r && $r.$blk !== undefined) {
                break s;
              }
              Nerrs = (Nerrs + 1) >> 0;
              /* */ if (yyDebug >= 1) {
                $s = 38;
                continue;
              }
              /* */ $s = 39;
              continue;
            /* if (yyDebug >= 1) { */ case 38:
              _r$6 = yyStatname(yystate[0]);
              /* */ $s = 40;
            case 40:
              if ($c) {
                $c = false;
                _r$6 = _r$6.$blk();
              }
              if (_r$6 && _r$6.$blk !== undefined) {
                break s;
              }
              _arg$2 = new $String(_r$6);
              _r$7 = fmt.Printf("%s", new sliceType([_arg$2]));
              /* */ $s = 41;
            case 41:
              if ($c) {
                $c = false;
                _r$7 = _r$7.$blk();
              }
              if (_r$7 && _r$7.$blk !== undefined) {
                break s;
              }
              _r$7;
              _r$8 = yyTokname(yytoken[0]);
              /* */ $s = 42;
            case 42:
              if ($c) {
                $c = false;
                _r$8 = _r$8.$blk();
              }
              if (_r$8 && _r$8.$blk !== undefined) {
                break s;
              }
              _arg$3 = new $String(_r$8);
              _r$9 = fmt.Printf(" saw %s\n", new sliceType([_arg$3]));
              /* */ $s = 43;
            case 43:
              if ($c) {
                $c = false;
                _r$9 = _r$9.$blk();
              }
              if (_r$9 && _r$9.$blk !== undefined) {
                break s;
              }
              _r$9;
            /* } */ case 39:
              Errflag = 3;
            /* while (true) { */ case 44:
              /* if (!(yyp >= 0)) { break; } */ if (!(yyp >= 0)) {
                $s = 45;
                continue;
              }
              yyn =
                (((x$4 = (
                  yyp < 0 || yyp >= yyS.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyS.$array[yyS.$offset + yyp]
                ).yys),
                x$4 < 0 || x$4 >= yyPact.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyPact[x$4]) +
                  2) >>
                0;
              /* */ if (yyn >= 0 && yyn < 561) {
                $s = 46;
                continue;
              }
              /* */ $s = 47;
              continue;
            /* if (yyn >= 0 && yyn < 561) { */ case 46:
              yystate[0] =
                yyn < 0 || yyn >= yyAct.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyAct[yyn];
              /* */ if (
                (yystate[0] < 0 || yystate[0] >= yyChk.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyChk[yystate[0]]) === 2
              ) {
                $s = 48;
                continue;
              }
              /* */ $s = 49;
              continue;
            /* if (((yystate[0] < 0 || yystate[0] >= yyChk.length) ? ($throwRuntimeError("index out of range"), undefined) : yyChk[yystate[0]]) === 2) { */ case 48:
              /* goto yystack */ $s = 1;
              continue;
            /* } */ case 49:
            /* } */ case 47:
              /* */ if (yyDebug >= 2) {
                $s = 50;
                continue;
              }
              /* */ $s = 51;
              continue;
            /* if (yyDebug >= 2) { */ case 50:
              _r$10 = fmt.Printf(
                "error recovery pops state %d\n",
                new sliceType([
                  new $Int(
                    (yyp < 0 || yyp >= yyS.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : yyS.$array[yyS.$offset + yyp]
                    ).yys
                  ),
                ])
              );
              /* */ $s = 52;
            case 52:
              if ($c) {
                $c = false;
                _r$10 = _r$10.$blk();
              }
              if (_r$10 && _r$10.$blk !== undefined) {
                break s;
              }
              _r$10;
            /* } */ case 51:
              yyp = (yyp - 1) >> 0;
              $s = 44;
              continue;
            case 45:
              /* goto ret1 */ $s = 4;
              continue;
              $s = 35;
              continue;
            /* } else if ((_1 === (1)) || (_1 === (2))) { */ case 33:
              Errflag = 3;
            /* while (true) { */ case 53:
              /* if (!(yyp >= 0)) { break; } */ if (!(yyp >= 0)) {
                $s = 54;
                continue;
              }
              yyn =
                (((x$5 = (
                  yyp < 0 || yyp >= yyS.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyS.$array[yyS.$offset + yyp]
                ).yys),
                x$5 < 0 || x$5 >= yyPact.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyPact[x$5]) +
                  2) >>
                0;
              /* */ if (yyn >= 0 && yyn < 561) {
                $s = 55;
                continue;
              }
              /* */ $s = 56;
              continue;
            /* if (yyn >= 0 && yyn < 561) { */ case 55:
              yystate[0] =
                yyn < 0 || yyn >= yyAct.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyAct[yyn];
              /* */ if (
                (yystate[0] < 0 || yystate[0] >= yyChk.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyChk[yystate[0]]) === 2
              ) {
                $s = 57;
                continue;
              }
              /* */ $s = 58;
              continue;
            /* if (((yystate[0] < 0 || yystate[0] >= yyChk.length) ? ($throwRuntimeError("index out of range"), undefined) : yyChk[yystate[0]]) === 2) { */ case 57:
              /* goto yystack */ $s = 1;
              continue;
            /* } */ case 58:
            /* } */ case 56:
              /* */ if (yyDebug >= 2) {
                $s = 59;
                continue;
              }
              /* */ $s = 60;
              continue;
            /* if (yyDebug >= 2) { */ case 59:
              _r$11 = fmt.Printf(
                "error recovery pops state %d\n",
                new sliceType([
                  new $Int(
                    (yyp < 0 || yyp >= yyS.$length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : yyS.$array[yyS.$offset + yyp]
                    ).yys
                  ),
                ])
              );
              /* */ $s = 61;
            case 61:
              if ($c) {
                $c = false;
                _r$11 = _r$11.$blk();
              }
              if (_r$11 && _r$11.$blk !== undefined) {
                break s;
              }
              _r$11;
            /* } */ case 60:
              yyp = (yyp - 1) >> 0;
              $s = 53;
              continue;
            case 54:
              /* goto ret1 */ $s = 4;
              continue;
              $s = 35;
              continue;
            /* } else if (_1 === (3)) { */ case 34:
              /* */ if (yyDebug >= 2) {
                $s = 62;
                continue;
              }
              /* */ $s = 63;
              continue;
            /* if (yyDebug >= 2) { */ case 62:
              _r$12 = yyTokname(yytoken[0]);
              /* */ $s = 64;
            case 64:
              if ($c) {
                $c = false;
                _r$12 = _r$12.$blk();
              }
              if (_r$12 && _r$12.$blk !== undefined) {
                break s;
              }
              _arg$4 = new $String(_r$12);
              _r$13 = fmt.Printf(
                "error recovery discards %s\n",
                new sliceType([_arg$4])
              );
              /* */ $s = 65;
            case 65:
              if ($c) {
                $c = false;
                _r$13 = _r$13.$blk();
              }
              if (_r$13 && _r$13.$blk !== undefined) {
                break s;
              }
              _r$13;
            /* } */ case 63:
              /* */ if (yytoken[0] === 1) {
                $s = 66;
                continue;
              }
              /* */ $s = 67;
              continue;
            /* if (yytoken[0] === 1) { */ case 66:
              /* goto ret1 */ $s = 4;
              continue;
            /* } */ case 67:
              yyrcvr[0].char$2 = -1;
              yytoken[0] = -1;
              /* goto yynewstate */ $s = 11;
              continue;
            /* } */ case 35:
            case 31:
            /* } */ case 30:
              /* */ if (yyDebug >= 2) {
                $s = 68;
                continue;
              }
              /* */ $s = 69;
              continue;
            /* if (yyDebug >= 2) { */ case 68:
              _arg$5 = new $Int(yyn);
              _r$14 = yyStatname(yystate[0]);
              /* */ $s = 70;
            case 70:
              if ($c) {
                $c = false;
                _r$14 = _r$14.$blk();
              }
              if (_r$14 && _r$14.$blk !== undefined) {
                break s;
              }
              _arg$6 = new $String(_r$14);
              _r$15 = fmt.Printf(
                "reduce %v in:\n\t%v\n",
                new sliceType([_arg$5, _arg$6])
              );
              /* */ $s = 71;
            case 71:
              if ($c) {
                $c = false;
                _r$15 = _r$15.$blk();
              }
              if (_r$15 && _r$15.$blk !== undefined) {
                break s;
              }
              _r$15;
            /* } */ case 69:
              yynt = yyn;
              yypt = yyp;
              $unused(yypt);
              yyp =
                (yyp -
                  (yyn < 0 || yyn >= yyR2.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyR2[yyn])) >>
                0;
              if ((yyp + 1) >> 0 >= yyS.$length) {
                nyys$1 = $makeSlice(sliceType$2, $imul(yyS.$length, 2));
                $copySlice(nyys$1, yyS);
                yyS = nyys$1;
              }
              yySymType.copy(
                yyVAL,
                ((x$6 = (yyp + 1) >> 0),
                x$6 < 0 || x$6 >= yyS.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyS.$array[yyS.$offset + x$6])
              );
              yyn =
                yyn < 0 || yyn >= yyR1.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyR1[yyn];
              yyg =
                yyn < 0 || yyn >= yyPgo.length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyPgo[yyn];
              yyj =
                (((yyg +
                  (yyp < 0 || yyp >= yyS.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyS.$array[yyS.$offset + yyp]
                  ).yys) >>
                  0) +
                  1) >>
                0;
              if (yyj >= 561) {
                yystate[0] =
                  yyg < 0 || yyg >= yyAct.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyAct[yyg];
              } else {
                yystate[0] =
                  yyj < 0 || yyj >= yyAct.length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyAct[yyj];
                if (
                  !(
                    (yystate[0] < 0 || yystate[0] >= yyChk.length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : yyChk[yystate[0]]) === -yyn
                  )
                ) {
                  yystate[0] =
                    yyg < 0 || yyg >= yyAct.length
                      ? ($throwRuntimeError("index out of range"), undefined)
                      : yyAct[yyg];
                }
              }
              _2 = yynt;
              /* */ if (_2 === 1) {
                $s = 73;
                continue;
              }
              /* */ if (_2 === 7) {
                $s = 74;
                continue;
              }
              /* */ if (_2 === 8) {
                $s = 75;
                continue;
              }
              /* */ if (_2 === 9) {
                $s = 76;
                continue;
              }
              /* */ if (_2 === 10) {
                $s = 77;
                continue;
              }
              /* */ if (_2 === 11) {
                $s = 78;
                continue;
              }
              /* */ if (_2 === 12) {
                $s = 79;
                continue;
              }
              /* */ if (_2 === 13) {
                $s = 80;
                continue;
              }
              /* */ if (_2 === 14) {
                $s = 81;
                continue;
              }
              /* */ if (_2 === 15) {
                $s = 82;
                continue;
              }
              /* */ if (_2 === 16) {
                $s = 83;
                continue;
              }
              /* */ if (_2 === 17) {
                $s = 84;
                continue;
              }
              /* */ if (_2 === 18) {
                $s = 85;
                continue;
              }
              /* */ if (_2 === 19) {
                $s = 86;
                continue;
              }
              /* */ if (_2 === 20) {
                $s = 87;
                continue;
              }
              /* */ if (_2 === 21) {
                $s = 88;
                continue;
              }
              /* */ if (_2 === 22) {
                $s = 89;
                continue;
              }
              /* */ if (_2 === 23) {
                $s = 90;
                continue;
              }
              /* */ if (_2 === 24) {
                $s = 91;
                continue;
              }
              /* */ if (_2 === 25) {
                $s = 92;
                continue;
              }
              /* */ if (_2 === 26) {
                $s = 93;
                continue;
              }
              /* */ if (_2 === 27) {
                $s = 94;
                continue;
              }
              /* */ if (_2 === 28) {
                $s = 95;
                continue;
              }
              /* */ if (_2 === 29) {
                $s = 96;
                continue;
              }
              /* */ if (_2 === 30) {
                $s = 97;
                continue;
              }
              /* */ if (_2 === 31) {
                $s = 98;
                continue;
              }
              /* */ if (_2 === 32) {
                $s = 99;
                continue;
              }
              /* */ if (_2 === 33) {
                $s = 100;
                continue;
              }
              /* */ if (_2 === 34) {
                $s = 101;
                continue;
              }
              /* */ if (_2 === 35) {
                $s = 102;
                continue;
              }
              /* */ if (_2 === 36) {
                $s = 103;
                continue;
              }
              /* */ if (_2 === 37) {
                $s = 104;
                continue;
              }
              /* */ if (_2 === 38) {
                $s = 105;
                continue;
              }
              /* */ if (_2 === 39) {
                $s = 106;
                continue;
              }
              /* */ if (_2 === 40) {
                $s = 107;
                continue;
              }
              /* */ if (_2 === 41) {
                $s = 108;
                continue;
              }
              /* */ if (_2 === 42) {
                $s = 109;
                continue;
              }
              /* */ if (_2 === 43) {
                $s = 110;
                continue;
              }
              /* */ if (_2 === 44) {
                $s = 111;
                continue;
              }
              /* */ if (_2 === 45) {
                $s = 112;
                continue;
              }
              /* */ if (_2 === 46) {
                $s = 113;
                continue;
              }
              /* */ if (_2 === 47) {
                $s = 114;
                continue;
              }
              /* */ if (_2 === 48) {
                $s = 115;
                continue;
              }
              /* */ if (_2 === 49) {
                $s = 116;
                continue;
              }
              /* */ if (_2 === 50) {
                $s = 117;
                continue;
              }
              /* */ if (_2 === 51) {
                $s = 118;
                continue;
              }
              /* */ $s = 119;
              continue;
            /* if (_2 === (1)) { */ case 73:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
              ).expr;
              $assertType(yylex, ptrType).result = yyVAL.expr;
              $s = 119;
              continue;
            /* } else if (_2 === (7)) { */ case 74:
              yyDollar = $subslice(yyS, (yypt - 5) >> 0, (yypt + 1) >> 0);
              _r$16 = asBool(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 123;
            case 123:
              if ($c) {
                $c = false;
                _r$16 = _r$16.$blk();
              }
              if (_r$16 && _r$16.$blk !== undefined) {
                break s;
              }
              /* */ if (_r$16) {
                $s = 120;
                continue;
              }
              /* */ $s = 121;
              continue;
            /* if (_r$16) { */ case 120:
              yyVAL.expr = (
                3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
              ).expr;
              $s = 122;
              continue;
            /* } else { */ case 121:
              yyVAL.expr = (
                5 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 5]
              ).expr;
            /* } */ case 122:
              $s = 119;
              continue;
            /* } else if (_2 === (8)) { */ case 75:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
              ).expr;
              $s = 119;
              continue;
            /* } else if (_2 === (9)) { */ case 76:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$17 = callFunction(
                $assertType(yylex, ptrType).functions,
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).token.literal,
                new sliceType([])
              );
              /* */ $s = 124;
            case 124:
              if ($c) {
                $c = false;
                _r$17 = _r$17.$blk();
              }
              if (_r$17 && _r$17.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$17;
              $s = 119;
              continue;
            /* } else if (_2 === (10)) { */ case 77:
              yyDollar = $subslice(yyS, (yypt - 4) >> 0, (yypt + 1) >> 0);
              _r$18 = callFunction(
                $assertType(yylex, ptrType).functions,
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).token.literal,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).exprList
              );
              /* */ $s = 125;
            case 125:
              if ($c) {
                $c = false;
                _r$18 = _r$18.$blk();
              }
              if (_r$18 && _r$18.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$18;
              $s = 119;
              continue;
            /* } else if (_2 === (11)) { */ case 78:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = $ifaceNil;
              $s = 119;
              continue;
            /* } else if (_2 === (12)) { */ case 79:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
              ).token.value;
              $s = 119;
              continue;
            /* } else if (_2 === (13)) { */ case 80:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
              ).token.value;
              $s = 119;
              continue;
            /* } else if (_2 === (14)) { */ case 81:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
              ).token.value;
              $s = 119;
              continue;
            /* } else if (_2 === (15)) { */ case 82:
              yyDollar = $subslice(yyS, (yypt - 2) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = new sliceType([]);
              $s = 119;
              continue;
            /* } else if (_2 === (16)) { */ case 83:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = (
                2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
              ).exprList;
              $s = 119;
              continue;
            /* } else if (_2 === (17)) { */ case 84:
              yyDollar = $subslice(yyS, (yypt - 2) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = new mapType($makeMap($String.keyFor, []));
              $s = 119;
              continue;
            /* } else if (_2 === (18)) { */ case 85:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = new mapType(
                (2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
                ).exprMap
              );
              $s = 119;
              continue;
            /* } else if (_2 === (19)) { */ case 86:
              yyDollar = $subslice(yyS, (yypt - 2) >> 0, (yypt + 1) >> 0);
              _r$19 = unaryMinus(
                (2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
                ).expr
              );
              /* */ $s = 126;
            case 126:
              if ($c) {
                $c = false;
                _r$19 = _r$19.$blk();
              }
              if (_r$19 && _r$19.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$19;
              $s = 119;
              continue;
            /* } else if (_2 === (20)) { */ case 87:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$20 = add(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 127;
            case 127:
              if ($c) {
                $c = false;
                _r$20 = _r$20.$blk();
              }
              if (_r$20 && _r$20.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$20;
              $s = 119;
              continue;
            /* } else if (_2 === (21)) { */ case 88:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$21 = sub(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 128;
            case 128:
              if ($c) {
                $c = false;
                _r$21 = _r$21.$blk();
              }
              if (_r$21 && _r$21.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$21;
              $s = 119;
              continue;
            /* } else if (_2 === (22)) { */ case 89:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$22 = mul(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 129;
            case 129:
              if ($c) {
                $c = false;
                _r$22 = _r$22.$blk();
              }
              if (_r$22 && _r$22.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$22;
              $s = 119;
              continue;
            /* } else if (_2 === (23)) { */ case 90:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$23 = div(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 130;
            case 130:
              if ($c) {
                $c = false;
                _r$23 = _r$23.$blk();
              }
              if (_r$23 && _r$23.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$23;
              $s = 119;
              continue;
            /* } else if (_2 === (24)) { */ case 91:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$24 = mod(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 131;
            case 131:
              if ($c) {
                $c = false;
                _r$24 = _r$24.$blk();
              }
              if (_r$24 && _r$24.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$24;
              $s = 119;
              continue;
            /* } else if (_2 === (25)) { */ case 92:
              yyDollar = $subslice(yyS, (yypt - 2) >> 0, (yypt + 1) >> 0);
              _r$25 = asBool(
                (2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
                ).expr
              );
              /* */ $s = 132;
            case 132:
              if ($c) {
                $c = false;
                _r$25 = _r$25.$blk();
              }
              if (_r$25 && _r$25.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(!_r$25);
              $s = 119;
              continue;
            /* } else if (_2 === (26)) { */ case 93:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = new $Bool(
                deepEqual(
                  (1 >= yyDollar.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyDollar.$array[yyDollar.$offset + 1]
                  ).expr,
                  (3 >= yyDollar.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyDollar.$array[yyDollar.$offset + 3]
                  ).expr
                )
              );
              $s = 119;
              continue;
            /* } else if (_2 === (27)) { */ case 94:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.expr = new $Bool(
                !deepEqual(
                  (1 >= yyDollar.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyDollar.$array[yyDollar.$offset + 1]
                  ).expr,
                  (3 >= yyDollar.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyDollar.$array[yyDollar.$offset + 3]
                  ).expr
                )
              );
              $s = 119;
              continue;
            /* } else if (_2 === (28)) { */ case 95:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$26 = compare(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                "<"
              );
              /* */ $s = 133;
            case 133:
              if ($c) {
                $c = false;
                _r$26 = _r$26.$blk();
              }
              if (_r$26 && _r$26.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(_r$26);
              $s = 119;
              continue;
            /* } else if (_2 === (29)) { */ case 96:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$27 = compare(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                ">"
              );
              /* */ $s = 134;
            case 134:
              if ($c) {
                $c = false;
                _r$27 = _r$27.$blk();
              }
              if (_r$27 && _r$27.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(_r$27);
              $s = 119;
              continue;
            /* } else if (_2 === (30)) { */ case 97:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$28 = compare(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                "<="
              );
              /* */ $s = 135;
            case 135:
              if ($c) {
                $c = false;
                _r$28 = _r$28.$blk();
              }
              if (_r$28 && _r$28.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(_r$28);
              $s = 119;
              continue;
            /* } else if (_2 === (31)) { */ case 98:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$29 = compare(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                ">="
              );
              /* */ $s = 136;
            case 136:
              if ($c) {
                $c = false;
                _r$29 = _r$29.$blk();
              }
              if (_r$29 && _r$29.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(_r$29);
              $s = 119;
              continue;
            /* } else if (_2 === (32)) { */ case 99:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$30 = asBool(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 137;
            case 137:
              if ($c) {
                $c = false;
                _r$30 = _r$30.$blk();
              }
              if (_r$30 && _r$30.$blk !== undefined) {
                break s;
              }
              left = _r$30;
              _r$31 = asBool(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 138;
            case 138:
              if ($c) {
                $c = false;
                _r$31 = _r$31.$blk();
              }
              if (_r$31 && _r$31.$blk !== undefined) {
                break s;
              }
              right = _r$31;
              yyVAL.expr = new $Bool(left && right);
              $s = 119;
              continue;
            /* } else if (_2 === (33)) { */ case 100:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$32 = asBool(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 139;
            case 139:
              if ($c) {
                $c = false;
                _r$32 = _r$32.$blk();
              }
              if (_r$32 && _r$32.$blk !== undefined) {
                break s;
              }
              left$1 = _r$32;
              _r$33 = asBool(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 140;
            case 140:
              if ($c) {
                $c = false;
                _r$33 = _r$33.$blk();
              }
              if (_r$33 && _r$33.$blk !== undefined) {
                break s;
              }
              right$1 = _r$33;
              yyVAL.expr = new $Bool(left$1 || right$1);
              $s = 119;
              continue;
            /* } else if (_2 === (34)) { */ case 101:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$34 = asInteger(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 141;
            case 141:
              if ($c) {
                $c = false;
                _r$34 = _r$34.$blk();
              }
              if (_r$34 && _r$34.$blk !== undefined) {
                break s;
              }
              _r$35 = asInteger(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 142;
            case 142:
              if ($c) {
                $c = false;
                _r$35 = _r$35.$blk();
              }
              if (_r$35 && _r$35.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Int(_r$34 | _r$35);
              $s = 119;
              continue;
            /* } else if (_2 === (35)) { */ case 102:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$36 = asInteger(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 143;
            case 143:
              if ($c) {
                $c = false;
                _r$36 = _r$36.$blk();
              }
              if (_r$36 && _r$36.$blk !== undefined) {
                break s;
              }
              _r$37 = asInteger(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 144;
            case 144:
              if ($c) {
                $c = false;
                _r$37 = _r$37.$blk();
              }
              if (_r$37 && _r$37.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Int(_r$36 & _r$37);
              $s = 119;
              continue;
            /* } else if (_2 === (36)) { */ case 103:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$38 = asInteger(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 145;
            case 145:
              if ($c) {
                $c = false;
                _r$38 = _r$38.$blk();
              }
              if (_r$38 && _r$38.$blk !== undefined) {
                break s;
              }
              _r$39 = asInteger(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 146;
            case 146:
              if ($c) {
                $c = false;
                _r$39 = _r$39.$blk();
              }
              if (_r$39 && _r$39.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Int((_r$38 ^ _r$39) >> 0);
              $s = 119;
              continue;
            /* } else if (_2 === (37)) { */ case 104:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$40 = asInteger(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 147;
            case 147:
              if ($c) {
                $c = false;
                _r$40 = _r$40.$blk();
              }
              if (_r$40 && _r$40.$blk !== undefined) {
                break s;
              }
              l = _r$40;
              _r$41 = asInteger(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 148;
            case 148:
              if ($c) {
                $c = false;
                _r$41 = _r$41.$blk();
              }
              if (_r$41 && _r$41.$blk !== undefined) {
                break s;
              }
              r = _r$41;
              if (r >= 0) {
                yyVAL.expr = new $Int(
                  ((y = r >>> 0), y < 32 ? l << y : 0) >> 0
                );
              } else {
                yyVAL.expr = new $Int((l >> $min(-r >>> 0, 31)) >> 0);
              }
              $s = 119;
              continue;
            /* } else if (_2 === (38)) { */ case 105:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$42 = asInteger(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 149;
            case 149:
              if ($c) {
                $c = false;
                _r$42 = _r$42.$blk();
              }
              if (_r$42 && _r$42.$blk !== undefined) {
                break s;
              }
              l$1 = _r$42;
              _r$43 = asInteger(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 150;
            case 150:
              if ($c) {
                $c = false;
                _r$43 = _r$43.$blk();
              }
              if (_r$43 && _r$43.$blk !== undefined) {
                break s;
              }
              r$1 = _r$43;
              if (r$1 >= 0) {
                yyVAL.expr = new $Int((l$1 >> $min(r$1 >>> 0, 31)) >> 0);
              } else {
                yyVAL.expr = new $Int(
                  ((y$1 = -r$1 >>> 0), y$1 < 32 ? l$1 << y$1 : 0) >> 0
                );
              }
              $s = 119;
              continue;
            /* } else if (_2 === (39)) { */ case 106:
              yyDollar = $subslice(yyS, (yypt - 2) >> 0, (yypt + 1) >> 0);
              _r$44 = asInteger(
                (2 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 2]
                ).expr
              );
              /* */ $s = 151;
            case 151:
              if ($c) {
                $c = false;
                _r$44 = _r$44.$blk();
              }
              if (_r$44 && _r$44.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Int(~_r$44 >> 0);
              $s = 119;
              continue;
            /* } else if (_2 === (40)) { */ case 107:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              _r$45 = accessVar(
                $assertType(yylex, ptrType).variables,
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).token.literal
              );
              /* */ $s = 152;
            case 152:
              if ($c) {
                $c = false;
                _r$45 = _r$45.$blk();
              }
              if (_r$45 && _r$45.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$45;
              $s = 119;
              continue;
            /* } else if (_2 === (41)) { */ case 108:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$46 = accessField(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                new $String(
                  (3 >= yyDollar.$length
                    ? ($throwRuntimeError("index out of range"), undefined)
                    : yyDollar.$array[yyDollar.$offset + 3]
                  ).token.literal
                )
              );
              /* */ $s = 153;
            case 153:
              if ($c) {
                $c = false;
                _r$46 = _r$46.$blk();
              }
              if (_r$46 && _r$46.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$46;
              $s = 119;
              continue;
            /* } else if (_2 === (42)) { */ case 109:
              yyDollar = $subslice(yyS, (yypt - 4) >> 0, (yypt + 1) >> 0);
              _r$47 = accessField(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              /* */ $s = 154;
            case 154:
              if ($c) {
                $c = false;
                _r$47 = _r$47.$blk();
              }
              if (_r$47 && _r$47.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$47;
              $s = 119;
              continue;
            /* } else if (_2 === (43)) { */ case 110:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              _r$48 = arrayContains(
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 155;
            case 155:
              if ($c) {
                $c = false;
                _r$48 = _r$48.$blk();
              }
              if (_r$48 && _r$48.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = new $Bool(_r$48);
              $s = 119;
              continue;
            /* } else if (_2 === (44)) { */ case 111:
              yyDollar = $subslice(yyS, (yypt - 6) >> 0, (yypt + 1) >> 0);
              _r$49 = slice(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                (5 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 5]
                ).expr
              );
              /* */ $s = 156;
            case 156:
              if ($c) {
                $c = false;
                _r$49 = _r$49.$blk();
              }
              if (_r$49 && _r$49.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$49;
              $s = 119;
              continue;
            /* } else if (_2 === (45)) { */ case 112:
              yyDollar = $subslice(yyS, (yypt - 5) >> 0, (yypt + 1) >> 0);
              _r$50 = slice(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                $ifaceNil,
                (4 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 4]
                ).expr
              );
              /* */ $s = 157;
            case 157:
              if ($c) {
                $c = false;
                _r$50 = _r$50.$blk();
              }
              if (_r$50 && _r$50.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$50;
              $s = 119;
              continue;
            /* } else if (_2 === (46)) { */ case 113:
              yyDollar = $subslice(yyS, (yypt - 5) >> 0, (yypt + 1) >> 0);
              _r$51 = slice(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                $ifaceNil
              );
              /* */ $s = 158;
            case 158:
              if ($c) {
                $c = false;
                _r$51 = _r$51.$blk();
              }
              if (_r$51 && _r$51.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$51;
              $s = 119;
              continue;
            /* } else if (_2 === (47)) { */ case 114:
              yyDollar = $subslice(yyS, (yypt - 4) >> 0, (yypt + 1) >> 0);
              _r$52 = slice(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
                $ifaceNil,
                $ifaceNil
              );
              /* */ $s = 159;
            case 159:
              if ($c) {
                $c = false;
                _r$52 = _r$52.$blk();
              }
              if (_r$52 && _r$52.$blk !== undefined) {
                break s;
              }
              yyVAL.expr = _r$52;
              $s = 119;
              continue;
            /* } else if (_2 === (48)) { */ case 115:
              yyDollar = $subslice(yyS, (yypt - 1) >> 0, (yypt + 1) >> 0);
              yyVAL.exprList = new sliceType([
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr,
              ]);
              $s = 119;
              continue;
            /* } else if (_2 === (49)) { */ case 116:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.exprList = $append(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).exprList,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr
              );
              $s = 119;
              continue;
            /* } else if (_2 === (50)) { */ case 117:
              yyDollar = $subslice(yyS, (yypt - 3) >> 0, (yypt + 1) >> 0);
              yyVAL.exprMap = new $global.Map();
              _r$53 = asObjectKey(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).expr
              );
              /* */ $s = 160;
            case 160:
              if ($c) {
                $c = false;
                _r$53 = _r$53.$blk();
              }
              if (_r$53 && _r$53.$blk !== undefined) {
                break s;
              }
              _key = _r$53;
              (
                yyVAL.exprMap ||
                $throwRuntimeError("assignment to entry in nil map")
              ).set($String.keyFor(_key), {
                k: _key,
                v: (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
              });
              $s = 119;
              continue;
            /* } else if (_2 === (51)) { */ case 118:
              yyDollar = $subslice(yyS, (yypt - 5) >> 0, (yypt + 1) >> 0);
              _r$54 = addObjectMember(
                (1 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 1]
                ).exprMap,
                (3 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 3]
                ).expr,
                (5 >= yyDollar.$length
                  ? ($throwRuntimeError("index out of range"), undefined)
                  : yyDollar.$array[yyDollar.$offset + 5]
                ).expr
              );
              /* */ $s = 161;
            case 161:
              if ($c) {
                $c = false;
                _r$54 = _r$54.$blk();
              }
              if (_r$54 && _r$54.$blk !== undefined) {
                break s;
              }
              yyVAL.exprMap = _r$54;
            /* } */ case 119:
            case 72:
              /* goto yystack */ $s = 1;
              continue;
              $s = -1;
              return 0;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
        return 0;
      } finally {
        $callDeferred($deferred, $err);
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: yyParserImpl.ptr.prototype.Parse,
            $c: true,
            $r,
            $24r,
            $24r$1,
            Errflag,
            Nerrs,
            _1,
            _2,
            _arg,
            _arg$1,
            _arg$2,
            _arg$3,
            _arg$4,
            _arg$5,
            _arg$6,
            _key,
            _r,
            _r$1,
            _r$10,
            _r$11,
            _r$12,
            _r$13,
            _r$14,
            _r$15,
            _r$16,
            _r$17,
            _r$18,
            _r$19,
            _r$2,
            _r$20,
            _r$21,
            _r$22,
            _r$23,
            _r$24,
            _r$25,
            _r$26,
            _r$27,
            _r$28,
            _r$29,
            _r$3,
            _r$30,
            _r$31,
            _r$32,
            _r$33,
            _r$34,
            _r$35,
            _r$36,
            _r$37,
            _r$38,
            _r$39,
            _r$4,
            _r$40,
            _r$41,
            _r$42,
            _r$43,
            _r$44,
            _r$45,
            _r$46,
            _r$47,
            _r$48,
            _r$49,
            _r$5,
            _r$50,
            _r$51,
            _r$52,
            _r$53,
            _r$54,
            _r$6,
            _r$7,
            _r$8,
            _r$9,
            _tuple,
            _tuple$1,
            l,
            l$1,
            left,
            left$1,
            nyys,
            nyys$1,
            r,
            r$1,
            right,
            right$1,
            x,
            x$1,
            x$2,
            x$3,
            x$4,
            x$5,
            x$6,
            xi,
            y,
            y$1,
            yyDollar,
            yyS,
            yyVAL,
            yyg,
            yyj,
            yylex,
            yyn,
            yynt,
            yyp,
            yypt,
            yyrcvr,
            yystate,
            yytoken,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    yyParserImpl.prototype.Parse = function (yylex) {
      return this.$val.Parse(yylex);
    };
    NewLexer = function (src, variables, functions) {
      var { _r, file, fset, functions, lexer, src, variables, $s, $r, $c } =
        $restore(this, { src, variables, functions });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            if (variables === false) {
              variables = $makeMap($String.keyFor, []);
            }
            if (functions === false) {
              functions = $makeMap($String.keyFor, []);
            }
            lexer = new Lexer.ptr(
              new scanner.Scanner.ptr(
                ptrType$1.nil,
                "",
                sliceType$3.nil,
                $throwNilPointerError,
                0,
                0,
                0,
                0,
                0,
                false,
                0
              ),
              $ifaceNil,
              0,
              new Token.ptr("", $ifaceNil),
              variables,
              functions
            );
            fset = token.NewFileSet();
            _r = fset.AddFile("", fset.Base(), src.length);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            file = _r;
            $r = lexer.scanner.Init(
              file,
              new sliceType$3($stringToBytes(src)),
              $throwNilPointerError,
              0
            );
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = -1;
            return lexer;
          /* */
        }
        return;
      }
      var $f = {
        $blk: NewLexer,
        $c: true,
        $r,
        _r,
        file,
        fset,
        functions,
        lexer,
        src,
        variables,
        $s,
      };
      return $f;
    };
    $pkg.NewLexer = NewLexer;
    Lexer.ptr.prototype.scan = function () {
      var { _r, _tuple, l, lit, pos, tok, $s, $r, $c } = $restore(this, {});
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            l = this;
          /* while (true) { */ case 1:
            _r = l.scanner.Scan();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            pos = _tuple[0];
            tok = _tuple[1];
            lit = _tuple[2];
            if (tok === 57 && lit === "\n") {
              /* continue; */ $s = 1;
              continue;
            }
            if (new token.Token(tok).IsKeyword()) {
              tok = 4;
            }
            $s = -1;
            return [pos, tok, lit];
          case 2:
            $s = -1;
            return [0, 0, ""];
          /* */
        }
        return;
      }
      var $f = {
        $blk: Lexer.ptr.prototype.scan,
        $c: true,
        $r,
        _r,
        _tuple,
        l,
        lit,
        pos,
        tok,
        $s,
      };
      return $f;
    };
    Lexer.prototype.scan = function () {
      return this.$val.scan();
    };
    Lexer.ptr.prototype.Lex = function (lval) {
      var {
        _1,
        _r,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        err,
        hex,
        hexVal,
        l,
        lit,
        lval,
        pos,
        tok,
        tokenInfo,
        tokenType,
        $s,
        $r,
        $c,
      } = $restore(this, { lval });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            l = this;
            tokenType = 0;
            err = $ifaceNil;
            if (l.nextTokenType > 0) {
              tokenType = l.nextTokenType;
              l.nextTokenType = 0;
              Token.copy(lval.token, l.nextTokenInfo);
              $s = -1;
              return tokenType;
            }
            _r = l.scan();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            pos = _tuple[0];
            tok = _tuple[1];
            lit = _tuple[2];
            tokenInfo = new Token.ptr(lit, $ifaceNil);
            _1 = tok;
            /* */ if (_1 === 1) {
              $s = 3;
              continue;
            }
            /* */ if (_1 === 5) {
              $s = 4;
              continue;
            }
            /* */ if (_1 === 6) {
              $s = 5;
              continue;
            }
            /* */ if (_1 === 9) {
              $s = 6;
              continue;
            }
            /* */ if (
              _1 === 12 ||
              _1 === 13 ||
              _1 === 14 ||
              _1 === 15 ||
              _1 === 16
            ) {
              $s = 7;
              continue;
            }
            /* */ if (_1 === 43) {
              $s = 8;
              continue;
            }
            /* */ if (_1 === 34) {
              $s = 9;
              continue;
            }
            /* */ if (_1 === 35) {
              $s = 10;
              continue;
            }
            /* */ if (_1 === 39) {
              $s = 11;
              continue;
            }
            /* */ if (_1 === 44) {
              $s = 12;
              continue;
            }
            /* */ if (_1 === 40) {
              $s = 13;
              continue;
            }
            /* */ if (_1 === 41) {
              $s = 14;
              continue;
            }
            /* */ if (_1 === 45) {
              $s = 15;
              continue;
            }
            /* */ if (_1 === 46) {
              $s = 16;
              continue;
            }
            /* */ if (_1 === 36) {
              $s = 17;
              continue;
            }
            /* */ if (_1 === 17 || _1 === 18 || _1 === 19) {
              $s = 18;
              continue;
            }
            /* */ if (_1 === 20) {
              $s = 19;
              continue;
            }
            /* */ if (_1 === 21) {
              $s = 20;
              continue;
            }
            /* */ if (_1 === 4) {
              $s = 21;
              continue;
            }
            /* */ if (_1 === 53) {
              $s = 22;
              continue;
            }
            /* */ if (_1 === 52) {
              $s = 23;
              continue;
            }
            /* */ if (_1 === 58) {
              $s = 24;
              continue;
            }
            /* */ if (
              _1 === 50 ||
              _1 === 55 ||
              _1 === 51 ||
              _1 === 56 ||
              _1 === 49 ||
              _1 === 54
            ) {
              $s = 25;
              continue;
            }
            /* */ if (_1 === 88) {
              $s = 26;
              continue;
            }
            /* */ if (_1 === 0) {
              $s = 27;
              continue;
            }
            /* */ $s = 28;
            continue;
          /* if (_1 === (1)) { */ case 3:
            tokenType = 0;
            $s = 29;
            continue;
          /* } else if (_1 === (5)) { */ case 4:
            tokenType = 57348;
            hex = strings.TrimPrefix(lit, "0x");
            if (hex.length < lit.length) {
              hexVal = new $Uint64(0, 0);
              _tuple$1 = strconv.ParseUint(hex, 16, 32);
              hexVal = _tuple$1[0];
              err = _tuple$1[1];
              tokenInfo.value = new $Int(hexVal.$low >> 0);
            } else {
              _tuple$2 = strconv.Atoi(lit);
              tokenInfo.value = new $Int(_tuple$2[0]);
              err = _tuple$2[1];
            }
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 30;
              continue;
            }
            /* */ $s = 31;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 30:
            $r = l.Perrorf(
              pos,
              "parse error: cannot parse integer",
              sliceType.nil
            );
            /* */ $s = 32;
          case 32:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 31:
            $s = 29;
            continue;
          /* } else if (_1 === (6)) { */ case 5:
            tokenType = 57348;
            _tuple$3 = strconv.ParseFloat(lit, 64);
            tokenInfo.value = new $Float64(_tuple$3[0]);
            err = _tuple$3[1];
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 33;
              continue;
            }
            /* */ $s = 34;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 33:
            $r = l.Perrorf(
              pos,
              "parse error: cannot parse float",
              sliceType.nil
            );
            /* */ $s = 35;
          case 35:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 34:
            $s = 29;
            continue;
          /* } else if (_1 === (9)) { */ case 6:
            tokenType = 57349;
            _tuple$4 = strconv.Unquote(lit);
            tokenInfo.value = new $String(_tuple$4[0]);
            err = _tuple$4[1];
            /* */ if (!$interfaceIsEqual(err, $ifaceNil)) {
              $s = 36;
              continue;
            }
            /* */ $s = 37;
            continue;
          /* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 36:
            $r = l.Perrorf(
              pos,
              "parse error: cannot unquote string literal",
              sliceType.nil
            );
            /* */ $s = 38;
          case 38:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 37:
            $s = 29;
            continue;
          /* } else if ((_1 === (12)) || (_1 === (13)) || (_1 === (14)) || (_1 === (15)) || (_1 === (16))) { */ case 7:
            tokenType = new token.Token(tok).String().charCodeAt(0) >> 0;
            $s = 29;
            continue;
          /* } else if (_1 === (43)) { */ case 8:
            tokenType = new token.Token(tok).String().charCodeAt(0) >> 0;
            $s = 29;
            continue;
          /* } else if (_1 === (34)) { */ case 9:
            tokenType = 57351;
            $s = 29;
            continue;
          /* } else if (_1 === (35)) { */ case 10:
            tokenType = 57352;
            $s = 29;
            continue;
          /* } else if (_1 === (39)) { */ case 11:
            tokenType = 57353;
            $s = 29;
            continue;
          /* } else if (_1 === (44)) { */ case 12:
            tokenType = 57354;
            $s = 29;
            continue;
          /* } else if (_1 === (40)) { */ case 13:
            tokenType = 57355;
            $s = 29;
            continue;
          /* } else if (_1 === (41)) { */ case 14:
            tokenType = 57356;
            $s = 29;
            continue;
          /* } else if (_1 === (45)) { */ case 15:
            tokenType = 57357;
            $s = 29;
            continue;
          /* } else if (_1 === (46)) { */ case 16:
            tokenType = 57358;
            $s = 29;
            continue;
          /* } else if (_1 === (36)) { */ case 17:
            tokenType = 57355;
            tokenInfo.literal = "<";
            l.nextTokenType = 45;
            Token.copy(l.nextTokenInfo, new Token.ptr("-", $ifaceNil));
            $s = 29;
            continue;
          /* } else if ((_1 === (17)) || (_1 === (18)) || (_1 === (19))) { */ case 18:
            tokenType = new token.Token(tok).String().charCodeAt(0) >> 0;
            $s = 29;
            continue;
          /* } else if (_1 === (20)) { */ case 19:
            tokenType = 57359;
            $s = 29;
            continue;
          /* } else if (_1 === (21)) { */ case 20:
            tokenType = 57360;
            $s = 29;
            continue;
          /* } else if (_1 === (4)) { */ case 21:
            if (lit === "nil") {
              tokenType = 57346;
            } else if (lit === "true") {
              tokenType = 57347;
              tokenInfo.value = new $Bool(true);
            } else if (lit === "false") {
              tokenType = 57347;
              tokenInfo.value = new $Bool(false);
            } else if (lit === "in" || lit === "IN") {
              tokenType = 57362;
            } else {
              tokenType = 57350;
            }
            $s = 29;
            continue;
          /* } else if (_1 === (53)) { */ case 22:
            tokenType = 46;
            $s = 29;
            continue;
          /* } else if (_1 === (52)) { */ case 23:
            tokenType = 44;
            $s = 29;
            continue;
          /* } else if (_1 === (58)) { */ case 24:
            tokenType = 58;
            $s = 29;
            continue;
          /* } else if ((_1 === (50)) || (_1 === (55)) || (_1 === (51)) || (_1 === (56)) || (_1 === (49)) || (_1 === (54))) { */ case 25:
            tokenType = new token.Token(tok).String().charCodeAt(0) >> 0;
            $s = 29;
            continue;
          /* } else if (_1 === (88)) { */ case 26:
            tokenType = 57361;
            $s = 29;
            continue;
          /* } else if (_1 === (0)) { */ case 27:
            if (lit === "?") {
              tokenType = 63;
              /* break; */ $s = 2;
              continue;
            }
            if (lit === ":") {
              tokenType = 58;
              /* break; */ $s = 2;
              continue;
            }
            if (lit === "~") {
              tokenType = 57361;
              /* break; */ $s = 2;
              continue;
            }
            $r = l.Perrorf(
              pos,
              "unknown token %q (%q)",
              new sliceType([
                new $String(new token.Token(tok).String()),
                new $String(lit),
              ])
            );
            /* */ $s = 39;
          case 39:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $s = 29;
            continue;
          /* } else { */ case 28:
            $r = l.Perrorf(
              pos,
              "unknown token %q (%q)",
              new sliceType([
                new $String(new token.Token(tok).String()),
                new $String(lit),
              ])
            );
            /* */ $s = 40;
          case 40:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* } */ case 29:
          case 2:
            Token.copy(lval.token, tokenInfo);
            $s = -1;
            return tokenType;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Lexer.ptr.prototype.Lex,
        $c: true,
        $r,
        _1,
        _r,
        _tuple,
        _tuple$1,
        _tuple$2,
        _tuple$3,
        _tuple$4,
        err,
        hex,
        hexVal,
        l,
        lit,
        lval,
        pos,
        tok,
        tokenInfo,
        tokenType,
        $s,
      };
      return $f;
    };
    Lexer.prototype.Lex = function (lval) {
      return this.$val.Lex(lval);
    };
    Lexer.ptr.prototype.Error = function (e) {
      var e, l;
      l = this;
      $panic(errors.New(e));
    };
    Lexer.prototype.Error = function (e) {
      return this.$val.Error(e);
    };
    Lexer.ptr.prototype.Perrorf = function (pos, format, a) {
      var { _r, a, format, l, pos, $s, $r, $c } = $restore(this, {
        pos,
        format,
        a,
      });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            l = this;
            if (new token.Pos(pos).IsValid()) {
              format = format + " at position " + strconv.Itoa(pos >> 0);
            }
            _r = fmt.Errorf(format, a);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            $panic(_r);
            $s = -1;
            return;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Lexer.ptr.prototype.Perrorf,
        $c: true,
        $r,
        _r,
        a,
        format,
        l,
        pos,
        $s,
      };
      return $f;
    };
    Lexer.prototype.Perrorf = function (pos, format, a) {
      return this.$val.Perrorf(pos, format, a);
    };
    Lexer.ptr.prototype.Result = function () {
      var l;
      l = this;
      return l.result;
    };
    Lexer.prototype.Result = function () {
      return this.$val.Result();
    };
    Evaluate = function (str, variables, functions) {
      var {
        $24r,
        _r,
        _r$1,
        _tmp,
        _tmp$1,
        err,
        functions,
        lexer,
        result,
        str,
        variables,
        $s,
        $deferred,
        $r,
        $c,
      } = $restore(this, { str, variables, functions });
      /* */ $s = $s || 0;
      var $err = null;
      try {
        s: while (true) {
          switch ($s) {
            case 0:
              $deferred = [];
              $curGoroutine.deferStack.push($deferred);
              err = [err];
              result = $ifaceNil;
              err[0] = $ifaceNil;
              $deferred.push([
                (function (err) {
                  return function () {
                    var _tuple, ok, r;
                    r = $recover();
                    if (!$interfaceIsEqual(r, $ifaceNil)) {
                      _tuple = $assertType(r, runtime.Error, true);
                      ok = _tuple[1];
                      if (ok) {
                        $panic(r);
                      }
                      err[0] = $assertType(r, $error);
                    }
                  };
                })(err),
                [],
              ]);
              _r = NewLexer(str, variables, functions);
              /* */ $s = 1;
            case 1:
              if ($c) {
                $c = false;
                _r = _r.$blk();
              }
              if (_r && _r.$blk !== undefined) {
                break s;
              }
              lexer = _r;
              _r$1 = yyNewParser().Parse(lexer);
              /* */ $s = 2;
            case 2:
              if ($c) {
                $c = false;
                _r$1 = _r$1.$blk();
              }
              if (_r$1 && _r$1.$blk !== undefined) {
                break s;
              }
              _r$1;
              _tmp = lexer.Result();
              _tmp$1 = $ifaceNil;
              result = _tmp;
              err[0] = _tmp$1;
              $24r = [result, err[0]];
              $s = 3;
            case 3:
              return $24r;
            /* */
          }
          return;
        }
      } catch (err) {
        $err = err;
        $s = -1;
      } finally {
        $callDeferred($deferred, $err);
        if (!$curGoroutine.asleep) {
          return [result, err[0]];
        }
        if ($curGoroutine.asleep) {
          var $f = {
            $blk: Evaluate,
            $c: true,
            $r,
            $24r,
            _r,
            _r$1,
            _tmp,
            _tmp$1,
            err,
            functions,
            lexer,
            result,
            str,
            variables,
            $s,
            $deferred,
          };
          return $f;
        }
      }
    };
    $pkg.Evaluate = Evaluate;
    ptrType$3.methods = [
      {
        prop: "Lookahead",
        name: "Lookahead",
        pkg: "",
        typ: $funcType([], [$Int], false),
      },
      {
        prop: "Parse",
        name: "Parse",
        pkg: "",
        typ: $funcType([yyLexer], [$Int], false),
      },
    ];
    ptrType.methods = [
      {
        prop: "scan",
        name: "scan",
        pkg: "github.com/maja42/goval/internal",
        typ: $funcType([], [token.Pos, token.Token, $String], false),
      },
      {
        prop: "Lex",
        name: "Lex",
        pkg: "",
        typ: $funcType([ptrType$2], [$Int], false),
      },
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Perrorf",
        name: "Perrorf",
        pkg: "",
        typ: $funcType([token.Pos, $String, sliceType], [], true),
      },
      {
        prop: "Result",
        name: "Result",
        pkg: "",
        typ: $funcType([], [$emptyInterface], false),
      },
    ];
    yySymType.init("github.com/maja42/goval/internal", [
      {
        prop: "yys",
        name: "yys",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "token",
        name: "token",
        embedded: false,
        exported: false,
        typ: Token,
        tag: "",
      },
      {
        prop: "expr",
        name: "expr",
        embedded: false,
        exported: false,
        typ: $emptyInterface,
        tag: "",
      },
      {
        prop: "exprList",
        name: "exprList",
        embedded: false,
        exported: false,
        typ: sliceType,
        tag: "",
      },
      {
        prop: "exprMap",
        name: "exprMap",
        embedded: false,
        exported: false,
        typ: mapType,
        tag: "",
      },
    ]);
    yyLexer.init([
      {
        prop: "Error",
        name: "Error",
        pkg: "",
        typ: $funcType([$String], [], false),
      },
      {
        prop: "Lex",
        name: "Lex",
        pkg: "",
        typ: $funcType([ptrType$2], [$Int], false),
      },
    ]);
    yyParserImpl.init("github.com/maja42/goval/internal", [
      {
        prop: "lval",
        name: "lval",
        embedded: false,
        exported: false,
        typ: yySymType,
        tag: "",
      },
      {
        prop: "stack",
        name: "stack",
        embedded: false,
        exported: false,
        typ: arrayType$2,
        tag: "",
      },
      {
        prop: "char$2",
        name: "char",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
    ]);
    Token.init("github.com/maja42/goval/internal", [
      {
        prop: "literal",
        name: "literal",
        embedded: false,
        exported: false,
        typ: $String,
        tag: "",
      },
      {
        prop: "value",
        name: "value",
        embedded: false,
        exported: false,
        typ: $emptyInterface,
        tag: "",
      },
    ]);
    Lexer.init("github.com/maja42/goval/internal", [
      {
        prop: "scanner",
        name: "scanner",
        embedded: false,
        exported: false,
        typ: scanner.Scanner,
        tag: "",
      },
      {
        prop: "result",
        name: "result",
        embedded: false,
        exported: false,
        typ: $emptyInterface,
        tag: "",
      },
      {
        prop: "nextTokenType",
        name: "nextTokenType",
        embedded: false,
        exported: false,
        typ: $Int,
        tag: "",
      },
      {
        prop: "nextTokenInfo",
        name: "nextTokenInfo",
        embedded: false,
        exported: false,
        typ: Token,
        tag: "",
      },
      {
        prop: "variables",
        name: "variables",
        embedded: false,
        exported: false,
        typ: mapType,
        tag: "",
      },
      {
        prop: "functions",
        name: "functions",
        embedded: false,
        exported: false,
        typ: mapType$1,
        tag: "",
      },
    ]);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = fmt.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = scanner.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = token.$init();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = math.$init();
            /* */ $s = 5;
          case 5:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = reflect.$init();
            /* */ $s = 6;
          case 6:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = runtime.$init();
            /* */ $s = 7;
          case 7:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strconv.$init();
            /* */ $s = 8;
          case 8:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = strings.$init();
            /* */ $s = 9;
          case 9:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            yyToknames = $toNativeArray($kindString, [
              "$end",
              "error",
              "$unk",
              "LITERAL_NIL",
              "LITERAL_BOOL",
              "LITERAL_NUMBER",
              "LITERAL_STRING",
              "IDENT",
              "AND",
              "OR",
              "EQL",
              "NEQ",
              "LSS",
              "GTR",
              "LEQ",
              "GEQ",
              "SHL",
              "SHR",
              "BIT_NOT",
              "IN",
              "'?'",
              "':'",
              "'|'",
              "'^'",
              "'&'",
              "'+'",
              "'-'",
              "'*'",
              "'/'",
              "'%'",
              "'!'",
              "'.'",
              "'['",
              "']'",
              "'('",
              "')'",
              "'{'",
              "'}'",
              "','",
            ]);
            yyStatenames = arrayType.zero();
            yyExca = $toNativeArray($kindInt, [-1, 1, 1, -1, -2, 0]);
            yyAct = $toNativeArray(
              $kindInt,
              [
                45, 2, 88, 80, 81, 79, 78, 71, 42, 41, 47, 79, 44, 38, 39, 7,
                48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
                64, 65, 66, 67, 68, 69, 70, 6, 72, 74, 31, 32, 25, 26, 27, 28,
                29, 30, 36, 37, 5, 40, 19, 77, 33, 35, 34, 20, 21, 22, 23, 24,
                40, 38, 39, 4, 3, 75, 1, 0, 0, 0, 86, 0, 38, 39, 0, 0, 89, 0,
                90, 91, 92, 0, 93, 31, 32, 25, 26, 27, 28, 29, 30, 36, 37, 98,
                40, 19, 85, 33, 35, 34, 20, 21, 22, 23, 24, 0, 38, 39, 84, 31,
                32, 25, 26, 27, 28, 29, 30, 36, 37, 0, 40, 19, 0, 33, 35, 34,
                20, 21, 22, 23, 24, 0, 38, 39, 97, 31, 32, 25, 26, 27, 28, 29,
                30, 36, 37, 0, 40, 19, 0, 33, 35, 34, 20, 21, 22, 23, 24, 0, 38,
                39, 95, 31, 32, 25, 26, 27, 28, 29, 30, 36, 37, 0, 40, 19, 96,
                33, 35, 34, 20, 21, 22, 23, 24, 0, 38, 39, 31, 32, 25, 26, 27,
                28, 29, 30, 36, 37, 0, 40, 19, 83, 33, 35, 34, 20, 21, 22, 23,
                24, 0, 38, 39, 31, 32, 25, 26, 27, 28, 29, 30, 36, 37, 0, 40,
                19, 82, 33, 35, 34, 20, 21, 22, 23, 24, 0, 38, 39, 31, 32, 25,
                26, 27, 28, 29, 30, 36, 37, 0, 40, 19, 0, 33, 35, 34, 20, 21,
                22, 23, 24, 0, 38, 39, 31, 0, 25, 26, 27, 28, 29, 30, 36, 37, 0,
                40, 0, 0, 33, 35, 34, 20, 21, 22, 23, 24, 0, 38, 39, 25, 26, 27,
                28, 29, 30, 36, 37, 0, 40, 0, 0, 33, 35, 34, 20, 21, 22, 23, 24,
                0, 38, 39, 25, 26, 27, 28, 29, 30, 36, 37, 0, 40, 0, 0, 0, 35,
                34, 20, 21, 22, 23, 24, 0, 38, 39, 25, 26, 27, 28, 29, 30, 36,
                37, 0, 40, 0, 0, 0, 0, 34, 20, 21, 22, 23, 24, 0, 38, 39, 10,
                11, 12, 13, 9, 0, 0, 0, 40, 10, 11, 12, 13, 9, 0, 18, 22, 23,
                24, 0, 38, 39, 0, 16, 18, 0, 0, 17, 0, 14, 0, 8, 16, 15, 46, 0,
                17, 0, 14, 94, 8, 0, 15, 10, 11, 12, 13, 9, 27, 28, 29, 30, 36,
                37, 0, 40, 0, 0, 18, 0, 0, 20, 21, 22, 23, 24, 16, 38, 39, 0,
                17, 0, 14, 87, 8, 0, 15, 25, 26, 27, 28, 29, 30, 36, 37, 0, 40,
                10, 11, 12, 13, 9, 20, 21, 22, 23, 24, 0, 38, 39, 0, 0, 18, 0,
                0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 17, 0, 14, 0, 8, 76, 15, 10, 11,
                12, 13, 9, 10, 11, 12, 13, 9, 0, 0, 0, 0, 0, 18, 0, 0, 73, 0,
                18, 0, 0, 16, 0, 0, 0, 17, 16, 14, 0, 8, 17, 15, 14, 43, 8, 0,
                15, 10, 11, 12, 13, 9, 0, 0, 0, 0, 36, 37, 0, 40, 0, 0, 18, 0,
                0, 20, 21, 22, 23, 24, 16, 38, 39, 0, 17, 40, 14, 0, 8, 0, 15,
                20, 21, 22, 23, 24, 0, 38, 39,
              ]
            );
            yyPact = $toNativeArray(
              $kindInt,
              [
                515, -1000, 231, -1000, -1000, -1000, -1000, -1000, 515, -27,
                -1000, -1000, -1000, -1000, 481, 355, 515, 515, 515, 515, 515,
                515, 515, 515, 515, 515, 515, 515, 515, 515, 515, 515, 515, 515,
                515, 515, 515, 515, -1, 476, 515, 33, 442, -1000, -28, 231,
                -1000, -35, 206, 44, 44, 44, 181, 347, 347, 44, 44, 44, 394,
                394, 511, 511, 511, 511, 279, 256, 302, 425, 325, 527, 527,
                -1000, 78, 398, -19, -1000, -1000, -34, -1000, 515, -1000, 515,
                515, 515, -1000, 364, 130, -1000, -1000, 231, 156, 231, 231,
                104, -1000, -1000, 515, -1000, 231,
              ]
            );
            yyPgo = $toNativeArray(
              $kindInt,
              [0, 70, 0, 68, 67, 52, 39, 15, 12, 10]
            );
            yyR1 = $toNativeArray(
              $kindInt,
              [
                0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
                4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7,
                7, 7, 7, 7, 7, 7, 8, 8, 9, 9,
              ]
            );
            yyR2 = $toNativeArray(
              $kindInt,
              [
                0, 1, 1, 1, 1, 1, 1, 5, 3, 3, 4, 1, 1, 1, 1, 2, 3, 2, 3, 2, 3,
                3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 3,
                4, 3, 6, 5, 5, 4, 1, 3, 3, 5,
              ]
            );
            yyChk = $toNativeArray(
              $kindInt,
              [
                -1000, -1, -2, -3, -4, -5, -6, -7, 35, 8, 4, 5, 6, 7, 33, 37,
                27, 31, 19, 21, 26, 27, 28, 29, 30, 11, 12, 13, 14, 15, 16, 9,
                10, 23, 25, 24, 17, 18, 32, 33, 20, -2, 35, 34, -8, -2, 38, -9,
                -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
                -2, -2, -2, -2, -2, -2, -2, 8, -2, 22, -2, 36, 36, -8, 34, 39,
                38, 39, 22, 22, 34, 22, -2, 34, 36, -2, -2, -2, -2, -2, 34, 34,
                22, 34, -2,
              ]
            );
            yyDef = $toNativeArray(
              $kindInt,
              [
                0, -2, 1, 2, 3, 4, 5, 6, 0, 40, 11, 12, 13, 14, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 15, 0, 48, 17, 0, 0, 19, 25, 39, 0, 20, 21, 22, 23, 24,
                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 41, 0, 0,
                43, 8, 9, 0, 16, 0, 18, 0, 0, 0, 42, 0, 0, 47, 10, 49, 0, 50, 7,
                0, 46, 45, 0, 44, 51,
              ]
            );
            yyTok1 = $toNativeArray(
              $kindInt,
              [
                1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 31, 3, 3, 3, 30, 25, 3, 35,
                36, 28, 26, 39, 27, 32, 29, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 22, 3,
                3, 3, 3, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 33, 3, 34, 24, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 37, 23, 38,
              ]
            );
            yyTok2 = $toNativeArray(
              $kindInt,
              [
                2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                20,
              ]
            );
            yyTok3 = $toNativeArray($kindInt, [0]);
            yyErrorMessages = arrayType$1.zero();
            yyDebug = 0;
            yyErrorVerbose = false;
            init();
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["github.com/maja42/goval"] = (function () {
    var $pkg = {},
      $init,
      internal,
      Evaluator,
      mapType,
      sliceType,
      funcType,
      mapType$1,
      ptrType,
      NewEvaluator;
    internal = $packages["github.com/maja42/goval/internal"];
    Evaluator = $pkg.Evaluator = $newType(
      0,
      $kindStruct,
      "goval.Evaluator",
      true,
      "github.com/maja42/goval",
      true,
      function () {
        this.$val = this;
        if (arguments.length === 0) {
          return;
        }
      }
    );
    mapType = $mapType($String, $emptyInterface);
    sliceType = $sliceType($emptyInterface);
    funcType = $funcType([sliceType], [$emptyInterface, $error], true);
    mapType$1 = $mapType($String, funcType);
    ptrType = $ptrType(Evaluator);
    NewEvaluator = function () {
      return new Evaluator.ptr();
    };
    $pkg.NewEvaluator = NewEvaluator;
    Evaluator.ptr.prototype.Evaluate = function (str, variables, functions) {
      var {
        $24r,
        _r,
        _tuple,
        e,
        err,
        functions,
        result,
        str,
        variables,
        $s,
        $r,
        $c,
      } = $restore(this, { str, variables, functions });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            result = $ifaceNil;
            err = $ifaceNil;
            e = this;
            _r = internal.Evaluate(str, variables, functions);
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            result = _tuple[0];
            err = _tuple[1];
            $24r = [result, err];
            $s = 2;
          case 2:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Evaluator.ptr.prototype.Evaluate,
        $c: true,
        $r,
        $24r,
        _r,
        _tuple,
        e,
        err,
        functions,
        result,
        str,
        variables,
        $s,
      };
      return $f;
    };
    Evaluator.prototype.Evaluate = function (str, variables, functions) {
      return this.$val.Evaluate(str, variables, functions);
    };
    ptrType.methods = [
      {
        prop: "Evaluate",
        name: "Evaluate",
        pkg: "",
        typ: $funcType(
          [$String, mapType, mapType$1],
          [$emptyInterface, $error],
          false
        ),
      },
    ];
    Evaluator.init("", []);
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = internal.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $packages["main"] = (function () {
    var $pkg = {},
      $init,
      errors,
      js,
      goval,
      mapType,
      sliceType,
      ptrType,
      funcType,
      mapType$1,
      funcType$1,
      evaluator,
      Evaluate,
      main;
    errors = $packages["errors"];
    js = $packages["github.com/gopherjs/gopherjs/js"];
    goval = $packages["github.com/maja42/goval"];
    mapType = $mapType($String, $emptyInterface);
    sliceType = $sliceType($emptyInterface);
    ptrType = $ptrType(js.Object);
    funcType = $funcType([sliceType], [ptrType], true);
    mapType$1 = $mapType($String, funcType);
    funcType$1 = $funcType(
      [$String, mapType, mapType$1],
      [$emptyInterface, $String],
      false
    );
    Evaluate = function (expr, vals, funcs) {
      var {
        $24r,
        _entry,
        _i,
        _key,
        _key$1,
        _keys,
        _r,
        _r$1,
        _ref,
        _size,
        _tuple,
        err,
        expr,
        funcs,
        k,
        result,
        v,
        vals,
        wrappedFuncs,
        $s,
        $r,
        $c,
      } = $restore(this, { expr, vals, funcs });
      /* */ $s = $s || 0;
      s: while (true) {
        switch ($s) {
          case 0:
            wrappedFuncs = $makeMap($String.keyFor, []);
            _ref = funcs;
            _i = 0;
            _keys = _ref ? _ref.keys() : undefined;
            _size = _ref ? _ref.size : 0;
          /* while (true) { */ case 1:
            /* if (!(_i < _size)) { break; } */ if (!(_i < _size)) {
              $s = 2;
              continue;
            }
            _key = _keys.next().value;
            _entry = _ref.get(_key);
            if (_entry === undefined) {
              _i++;
              /* continue; */ $s = 1;
              continue;
            }
            k = _entry.k;
            v = _entry.v;
            _key$1 = k;
            (
              wrappedFuncs ||
              $throwRuntimeError("assignment to entry in nil map")
            ).set($String.keyFor(_key$1), {
              k: _key$1,
              v: (function (v$1) {
                var v$1;
                return function $b(args) {
                  var { _r, args, err, object, $s, $r, $c } = $restore(this, {
                    args,
                  });
                  /* */ $s = $s || 0;
                  s: while (true) {
                    switch ($s) {
                      case 0:
                        _r = v$1(args);
                        /* */ $s = 1;
                      case 1:
                        if ($c) {
                          $c = false;
                          _r = _r.$blk();
                        }
                        if (_r && _r.$blk !== undefined) {
                          break s;
                        }
                        object = _r;
                        if (
                          $interfaceIsEqual(
                            $internalize(object[1], $emptyInterface),
                            $ifaceNil
                          )
                        ) {
                          $s = -1;
                          return [
                            $internalize(object[0], $emptyInterface),
                            $ifaceNil,
                          ];
                        }
                        err = $assertType(
                          $internalize(object[1], $emptyInterface),
                          $String
                        );
                        $s = -1;
                        return [
                          $internalize(object[0], $emptyInterface),
                          errors.New(err),
                        ];
                      /* */
                    }
                    return;
                  }
                  var $f = {
                    $blk: $b,
                    $c: true,
                    $r,
                    _r,
                    args,
                    err,
                    object,
                    $s,
                  };
                  return $f;
                };
              })(v),
            });
            _i++;
            $s = 1;
            continue;
          case 2:
            _r = evaluator.Evaluate(expr, vals, wrappedFuncs);
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              _r = _r.$blk();
            }
            if (_r && _r.$blk !== undefined) {
              break s;
            }
            _tuple = _r;
            result = _tuple[0];
            err = _tuple[1];
            if ($interfaceIsEqual(err, $ifaceNil)) {
              $s = -1;
              return [result, ""];
            }
            _r$1 = err.Error();
            /* */ $s = 4;
          case 4:
            if ($c) {
              $c = false;
              _r$1 = _r$1.$blk();
            }
            if (_r$1 && _r$1.$blk !== undefined) {
              break s;
            }
            $24r = [result, _r$1];
            $s = 5;
          case 5:
            return $24r;
          /* */
        }
        return;
      }
      var $f = {
        $blk: Evaluate,
        $c: true,
        $r,
        $24r,
        _entry,
        _i,
        _key,
        _key$1,
        _keys,
        _r,
        _r$1,
        _ref,
        _size,
        _tuple,
        err,
        expr,
        funcs,
        k,
        result,
        v,
        vals,
        wrappedFuncs,
        $s,
      };
      return $f;
    };
    $pkg.Evaluate = Evaluate;
    main = function () {
      $module.exports.Evaluate = $externalize(Evaluate, funcType$1);
      $module.exports.default = $externalize(Evaluate, funcType$1);
    };
    $init = function () {
      $pkg.$init = function () {};
      /* */ var $f,
        $c = false,
        $s = 0,
        $r;
      if (this !== undefined && this.$blk !== undefined) {
        $f = this;
        $c = true;
        $s = $f.$s;
        $r = $f.$r;
      }
      s: while (true) {
        switch ($s) {
          case 0:
            $r = errors.$init();
            /* */ $s = 1;
          case 1:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = js.$init();
            /* */ $s = 2;
          case 2:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            $r = goval.$init();
            /* */ $s = 3;
          case 3:
            if ($c) {
              $c = false;
              $r = $r.$blk();
            }
            if ($r && $r.$blk !== undefined) {
              break s;
            }
            evaluator = goval.NewEvaluator();
            if ($pkg === $mainPkg) {
              main();
              $mainFinished = true;
            }
          /* */
        }
        return;
      }
      if ($f === undefined) {
        $f = { $blk: $init };
      }
      $f.$s = $s;
      $f.$r = $r;
      return $f;
    };
    $pkg.$init = $init;
    return $pkg;
  })();
  $synthesizeMethods();
  $initAllLinknames();
  var $mainPkg = $packages["main"];
  $packages["runtime"].$init();
  $go($mainPkg.$init, []);
  $flushConsole();
}).call(this);
//# sourceMappingURL=index.js.map
